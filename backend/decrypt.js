
const key = `
38a5236d026377c0951d73c72994554b291ce21cb95dc234064ec0722936b4299103c2e4700abfe1fbef689a20a02dcf8a135766a33da37e9f349ba71c5ff4a25cfb9b0b125491b120d61d306856eed2b68def448f31abc8f4ee1cc7492e31b57b8ca3fd4ad3a6289565410aca3c51981379557cdea5e6262c8e7535ed958cd61664ab6de598b487fe8798036fa365dd9aaa172aa591db14c6989a40f6876bb91b056dd849ecfcb4e6506c7a09d8e20de3b2190814a664c25356afa39f101f100b95da0db5c979e19e51b928b2bc59c9ac9a3ac79299adbab131901d845e927f8d3a8417cfae0614532741c8afcd8a0a97bf319abef751b1f4a0b53dd1a35f38da17bd240ce159e48fe6871b3eb764abe76f3d34a86c79b73eda0aad03e73cc1a87422d0429ed187885f122d6e9083cd27d0a00c27dfcfc3265030ab76bdf8958b3fb11c6cae1850061358b4288809d2f60b52e50446971e2cebf23a21e22f61bce64da3f60baa32f2dd115a32f917ceb001e6388b`


const msg = `lzw:{"messagă":[],"replayBaseUrlĉ"https://ďđē.nolimitcįy.com/"čgaĂCĬentConfiguratińĉĀĻmbleGļeRoundľoėIŁervalHŚrsĉ24čshowNetPşįōnĉfŦėčopţŋorĜHOMEPAGE_PUBLICĹ"ĪĬĮtWinnţsEnaœedĉtruečŽstSpƞƣƥŔƨ:ƪƬĺŗřśŝlşeštţťě:90čautoPĒySŵŌngū:ĀǍǏħyAlǁwƧƩƫƭ"ǜƁǒƾŜǙ[1ǋ25,5ǋǰǱǵ,Ƿ0ČǨǎǪēRequiďsSǝLşsLĭįżžǧtŉnOffAǿǞOnBńuǙŽlė}ůűwSĭuĒǅdMaxȫmPēŚtǥƻ"őŘŚŜŞŠŢŤŦTyƂĜDAYSƗhidŘĠȑȤǧőƦǄoȟnȡǠǢǤƹǦȧŲRĠWŋţmarkɓſ"crɆǏCŉďncyRȬĈɠȺboşȮBŵȋckƧȂeȤɭǧŰŲŖĂVơźšGȅʖɏeȹǧɿʁƧʃtɝŲɟƺʍȨȰxƝnProbƥiĬtyɦǅrɩɫʌčbʊŲȉaʇʪȂưricŌŎ:ȣɮjŉisdˆˈnNŗɈEFAULTƗexƪaƲƞʢǣƸʥƀƂŊǏrGʭupĜNOƔMITC˷YƗɖŔFifʳ˿́ǟǡʣ˧ɡāƞȳˣnTĭʚ:ǋāȱšaˇivĲšMƞǎɼ̓feŋŉeBuyƵƦ̈ɾʀưʟŵEˠŊřwǙ˨ɯǁʆǔğƞǘŏ"ʎwʛǌ̆ȩǕ̾ʺ"ȡeǔĄź̏Ă͎͊͂s͐̐UŜţʌȦǨ̘ń̍ʛ͝ȼšfòˑsǞ˕͒:"˿ď š The ŨŔ 2ƗɩxMȬŌđi͛:6ǵ0̓;΀l΂Ŀrʬʮʰʲyĉ17ΉἸvīŋʱĲĜǰ.0 (̲ƪeĂ)"͝cɵŀɸ̀ĵɐĜUSDƗsyŒīĜ$ Ɨʼͦď͢črɒǚ́̾Ŕĉ0.9607Ʈ̣Ȕȇ̀BOOSTED_BE˝ω͖Ǘό̒Ϗϑ9͝FREESPIN_LEVEL_1̀ϥgϧώϐǰϬϮϰϲϴ϶ϸϺͼϤϋ̑Ё634ЄϯϱϳϵϷϹ_3ϽЎύϩ33͝GUARANϝϞ_DWЦFНϦЏϩ42͝LUCKYЬЧWбϿгЂж}ͣƽȾd̲ƳɱšDēǙǊφ̣ΔCͶʆ̀wƞn̾Ǚ0̢̤͝ďʠ͊ʼtLevʊǙĀѥΡΣ0ρʄѨѪĉ["ώ2Ѱčώ4Ѻѷ.ϑƗώ8Ѿ1ѯƗ҆ѹ҈ҀѾ2҇čҎѽƗҎ҄Ɨ3.Ҋčҗҁč4ҏ"5ҟ6ҟ8ҟ΢Ή҈ҞҨč1ҥҫ"ŭҟ3ҎүѽҢώү҄ҦΉ҇ǽaťʱƶ̦ѲѩʋĊѿҙѿҒѻҌ҂.ҕҬҦҘ҅ӍҐҟґҍӏѾҗӉқѾҪѾҡүңҹһҦӠ҈ҮҍӨҚҴӟҸѾϑҤӰ҈ҼҨǽśҿaӁƦʠѧӅǮ]џϕ̥ӾѳӆĀϭЕЇИЊϻѵӈѾѼԒӕѿӐ"҆ү҉ӔҜҰӗ.ӋԞԗӜӛԕӬҠҢҤӦԚԧҭӗԧҳҟҶӣӴčҺԚӶѰǽԊІЗЉКЌѶѸԔԡώԝ҃ӔԚӓҋԝӮғԠәԣՋҚԦҟӢӱԪԸӧҦӪғ԰ՎҝԵ"ӲҹբǷҽčԼЖЈЙϺМӇՃӎՅԕՈҋՊӉ҆ՍԟԡҔԥӝՕү՗ƗӤѾ՝ҬզԭֆҰ՟ԲբդօզԹ"ǽФЦШЪϟЭЯԐձӌճՇӚնӔոԕՠԞռ֡ՔտԝԧւčքƗ֊ҧ҅։ԯҲ֦ԳӱբԷ҅֒ǽикмDо֜ՓӊԔ֠ԗԙ֣ԜәүӘՏՒ֫ӟՖԩӥ՚Ԭ՜ֶүԱҵ֎ֻ֑ӴǽϙϛϝϟϡϣՂ׆ԓӎ׉Չ׌Ռ׎ә֨גԥ֬וӣՙֽ՛Ԛ֊ұלָןӳһע͝ŦɞdFԄďɅƂǮ"ϙNζϠU˻čפϜЫרƗEXTЧ_իƗGAMƓƏFIFTмةثؖ"ؤئ϶_ϳTOϠOؒɌč˳˵˷_WϳNERɌҾ͆Ƨʐe؊ѡɼѶؘצϠϢƗؚّϢ_X_ROWؼ"؝؟AءЇƗժԌԿϺϼؗغؓBؕ٦ЅիԍՀٱԋԾխЛأإا_خجپتجٻسƏضظؑζأХЧЩϯ֙ЮRаč׀лнAпؽ˴I˶Tفكمهͅ؈ٍϖӃt؏ٖקٔթٲ٨ٹ٫ͯڮٸԎͼڭٷլԎМč֕ڍ֘Ьڑړ"ڕׂׄو؈ًMoɐԁƼͭĀκμlVŦƬѫ"Mϼωկ1ǳ"4ĉѽč5ĉ҄֯Ζǵ͝MЌĀۜ̓۠:۝ۣۡ̓6ĉ75зۭۚĉ6ҝۥ۳۱۾գĉ3ўčMկۼǉۿ۱2܁܆ۧ:۩ڔ۬"կ۞۰ϓҠΖŮ܄:ǲ۪۰܋8܍11܁ǲܒѽз܊ܗۡ܍܃ۤ܎ܒ2ж܈ܳ܋ܛ۰ǰܩ۵܅۹ڔܣܯ:ܞ۰ܲΖ܏ܟ21зܹ݄݆۽܁1݊۶ܠўԃَ̧y͑ăʠ۔lƬѵĀƤͭڲڸٴ٪Ɨʳɇͮ٧ϳƗadˑ˓ɄɆُǽp˅c̑ΘȦݤ˖ݮڳڹٵčݬ̑ݧԽNݱݳŹńݶ؎ѵݹݻ̑ѹ܇ހݦݯބծݫݷĜޚތݴźސݸčݺˆ̑ϑޗƘށرڌ֗ڏۀ֛ކޞނڸޡގƤl؍ޥ"ާݼ܅ުݿެݦۄڗڙ"އޟރ޸ݵ޻ݷۍ޾ޔΖ۸߃ݥވڪٓ˝޴ݭؐϚؙګߛǨލߎ޼ߑ޿ޕ.۹ǽˏ˃ˬ͍tɧ͊ďѴĊѶۙƗLڶۃۤؗAٕ߿čθČ߷߽ۘ۠ࠂ߈θࠂƗࠃ,ѶLڱٟLڻؐࠁ"DXࠍ֓ࠏۘࠕMࠆߺࠀࠣࠌࠄۃڱ۫Ɨ߸߾ࠛࠥࠝࠔࠪڱࠑٟ࠭࠘ࠃҾcήmȬɧdǬdʪύčmۋވ˳RMALƗƠˠۊδͮࡇࡉࡋčwĖڥԅ̨Ѥ̮ʂŵ͊fߴͪƞȍéࡂ߉o߱l̍sǑēɟ̓ۑɿ࡫izُǯǺࡹܨࡻࠄࡻࡺࡺࡽࡿࡾ1ࢁࢃࢀࠏࢆࢃࢅࢂǺ]ǽďࡄѩdSλࡳǮ[ɛǡ,࢙l࢛Ȭ࢚࢝࢜࢞࢜ࠄࢡࢦ࢟ࢢࢠࢨࢤࠏࢧࢣࢫࢰࢯǡࢥࢱࢪࢲࢶࢸࢴࢷࢩࢼࢮlࢺࢸࢽࢵࢩࢎࡃ΁i΃΅ܨɯoƞݠۖѵ[ǋ࣓,ࣔǼࠏ࣒ࣖࣕࣚࣗࣛࣞࣜࣙࣖࠄࣣ࣡ࣛࣟࣥӸpgŊɐŃݡmŻĊˋƭࣳ,ࣵࣳ࠸࠺࠼ȮFS࠿ࡁ̒ࡕяWńTࡩŦ࠿ࡧςƅٌࡡƳnsAďa࣑ࢾࣂࢻࢬ࢘ࣃखࢾࣀगࣁझࢭछणࢷञजतࢿढघनࣄǽscŋʶŃśȸँ"ࡠeăए࡭ǒࡰݙڦѫ͝࢐ӻћǗFߴ࡬ऊŦaɷɼĀطTࡊϠࡊШCEΡΚ҇͝ʯĒ्क़Ιҟ̋व"oɬčɏĜ5xlwb8p2xr-Ѿ˟ŶऽrKeΕͮa4f77Žc3f3d193949141С0eΘ89d0927ॿ2Ž7aa8र6d4cf0fd3ƥfb238ࡥ3bѰ}`

const e = '0123456789abcdef'

const HEX_CHARS = '0123456789abcdef'

/**
 * This module provides simple encryption and decryption functionalities
 * using the RC4 stream cipher.
 *
 * WARNING: RC4 is considered cryptographically insecure and should not be
 * used for sensitive data. It is provided here for compatibility or
 * educational purposes only.
 */
'use strict'


/**
 * Converts a hexadecimal string into an array of bytes.
 * @param {string} hexString - The hexadecimal string to convert.
 * @returns {number[]} An array of bytes.
 */
function hexStringToByteArray(hexString) {
    if (typeof hexString !== 'string') {
        return []
    }
    const bytes = []
    for (let i = 0; i < hexString.length; i += 2) {
        const high = HEX_CHARS.indexOf(hexString[i])
        const low = HEX_CHARS.indexOf(hexString[i + 1])
        bytes.push((high << 4) | low)
    }
    return bytes
}

/**
 * Converts an array of bytes into a hexadecimal string.
 * @param {number[]} byteArray - The array of bytes to convert.
 * @returns {string} The resulting hexadecimal string.
 */
function byteArrayToHexString(byteArray) {
    const hexChars = []
    byteArray.forEach(byte => {
        hexChars.push(HEX_CHARS.charAt((byte >> 4) & 0x0F))
        hexChars.push(HEX_CHARS.charAt(byte & 0x0F))
    })
    return hexChars.join('')
}

/**
 * Converts a UTF-8 string into an array of bytes.
 * Handles URI encoding to correctly represent multi-byte characters.
 * @param {string} str - The string to convert.
 * @returns {number[]} An array of bytes.
 */
function stringToByteArray(str) {
    const uriEncoded = encodeURIComponent(str)
    const bytes = []
    for (let i = 0; i < uriEncoded.length; i++) {
        const char = uriEncoded[i]
        if (char === '%') {
            const high = HEX_CHARS.indexOf(uriEncoded[i + 1].toLowerCase())
            const low = HEX_CHARS.indexOf(uriEncoded[i + 2].toLowerCase())
            bytes.push((high << 4) | low)
            i += 2
        } else {
            bytes.push(char.charCodeAt(0))
        }
    }
    return bytes
}

/**
 * Converts an array of bytes into a UTF-8 string.
 * @param {number[]} byteArray - The array of bytes to convert.
 * @returns {string} The resulting UTF-8 string.
 */
function byteArrayToString(byteArray) {
    let uriEncoded = ''
    for (const byte of byteArray) {
        uriEncoded += `%${HEX_CHARS.charAt((byte >> 4) & 0x0F)}${HEX_CHARS.charAt(byte & 0x0F)}`
    }
    // If the byte sequence is not valid UTF-8, this will throw a URIError.
    // This is the desired behavior, as it indicates an issue with the
    // key or the ciphertext.
    return decodeURIComponent(uriEncoded)
}

/**
 * Implements the RC4 stream cipher algorithm.
 * It performs the same operation for both encryption and decryption.
 * @param {number[]} key - The key as an array of bytes.
 * @param {number[]} data - The data to process as an array of bytes.
 * @returns {number[]} The processed (encrypted or decrypted) data as an array of bytes.
 */
function rc4(key, data) {
    // Key-Scheduling Algorithm (KSA)
    const sBox = []
    for (let i = 0; i < 256; i++) {
        sBox[i] = i
    }

    let j = 0
    for (let i = 0; i < 256; i++) {
        j = (j + sBox[i] + key[i % key.length]) % 256;
        // Swap sBox[i] and sBox[j]
        [sBox[i], sBox[j]] = [sBox[j], sBox[i]]
    }

    // Pseudo-Random Generation Algorithm (PRGA)
    let i = 0
    j = 0
    const result = []
    for (const charCode of data) {
        i = (i + 1) % 256
        j = (j + sBox[i]) % 256;
        // Swap sBox[i] and sBox[j]
        [sBox[i], sBox[j]] = [sBox[j], sBox[i]]
        const keyStreamChar = sBox[(sBox[i] + sBox[j]) % 256]
        result.push(charCode ^ keyStreamChar)
    }
    return result
}

const cryptoApi = {
    /**
     * Encrypts a plaintext string using a key.
     * @param {string} key - The encryption key.
     * @param {string} plaintext - The string to encrypt.
     * @returns {string} The encrypted string in hexadecimal format.
     */
    encrypt(key, plaintext) {
        const keyBytes = stringToByteArray(key)
        const plaintextBytes = stringToByteArray(plaintext)
        const encryptedBytes = rc4(keyBytes, plaintextBytes)
        return byteArrayToHexString(encryptedBytes)
    },

    /**
     * Decrypts a hexadecimal ciphertext string using a key.
     * @param {string} key - The decryption key.
     * @param {string} ciphertext - The hexadecimal string to decrypt.
     * @returns {string} The decrypted plaintext string.
     */
    decrypt(key, ciphertext) {
        const keyBytes = stringToByteArray(key)
        const ciphertextBytes = hexStringToByteArray(ciphertext)
        const decryptedBytes = rc4(keyBytes, ciphertextBytes)
        return byteArrayToString(decryptedBytes)
    }
}

const result = cryptoApi.decrypt(key, msg)
function lzwDecode(input) {
    if (!input.startsWith('lzw:')) return input
    input = input.substring('lzw:'.length)
    const dict = {}
    let currChar = input.substring(0, 1)
    let oldPhrase = currChar
    let code = 256
    const out = [currChar]
    for (let i = 1; i < input.length; i++) {
        const currentCode = input.charCodeAt(i)
        let phrase
        if (currentCode < 256) phrase = input.substring(i, 1)
        else if (dict[currentCode]) phrase = dict[currentCode]
        else phrase = oldPhrase + currChar
        out.push(phrase)
        currChar = phrase.substring(0, 1)
        dict[code++] = oldPhrase + currChar
        oldPhrase = phrase
    }
    return out.join('')
}

console.log(result)
console.log(lzwDecode(msg))

console.log(cryptoApi.decrypt(key, lzwDecode(msg)))