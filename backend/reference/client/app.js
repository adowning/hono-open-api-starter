console.log('%c777SuperStrike v0.0.22 master#ad38d70', 'background: #2980b9; color: #ffffff'),
(function (t) {
    const e = {}

    function n(r) {
        if (e[r]) return e[r].exports
        const i = e[r] = {
            i: r,
            l: !1,
            exports: {}
        }
        return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
    }
    n.m = t, n.c = e, n.d = function (t, e, r) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: r
        })
    }, n.r = function (t) {
        typeof Symbol != 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: 'Module'
        }), Object.defineProperty(t, '__esModule', {
            value: !0
        })
    }, n.t = function (t, e) {
        if (1 & e && (t = n(t)), 8 & e) return t
        if (4 & e && typeof t == 'object' && t && t.__esModule) return t
        const r = Object.create(null)
        if (n.r(r), Object.defineProperty(r, 'default', {
            enumerable: !0,
            value: t
        }), 2 & e && typeof t != 'string') {
            for (const i in t) { n.d(r, i, ((e) => {
                return t[e]
            }).bind(null, i))
            }
        }
        return r
    }, n.n = function (t) {
        const e = t && t.__esModule
            ? function () {
                return t.default
            }
            : function () {
                return t
            }
        return n.d(e, 'a', e), e
    }, n.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, n.p = './dist/', n(n.s = './src/core/main.js')
}({
    './node_modules/@games/dope/src/Dopamine.js': function (t, e, n) {
        'use strict'
        n.d(e, 'b', () => {
            return l
        }), n.d(e, 'a', () => {
            return I
        }), n.d(e, 'c', () => {
            return N
        })
        const r = n('./node_modules/eventemitter3/index.js')

        function i(t) {
            return (i = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function o(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function a(t, e, n) {
            return e = u(e),
            (function (t, e) {
                if (e && (i(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], u(t).constructor)
                : e.apply(t, n)))
        }

        function s(t, e, n) {
            return (s = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = u(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function u(t) {
            return (u = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function c(t, e) {
            return (c = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        var l = (function (t) {
            function e() {
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), a(this, e)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && c(t, e)
            }(e, t)), n = e, (r = [{
                key: 'eventNames',
                value() {
                    return s(u(e.prototype), 'eventNames', this).call(this)
                }
            }, {
                key: 'listeners',
                value(t, n) {
                    return s(u(e.prototype), 'listeners', this).call(this, t, n)
                }
            }, {
                key: 'emit',
                value(t, n) {
                    let r = s(u(e.prototype), 'emit', this).apply(this, arguments)
                    if (t !== h) {
                        let i = [h].concat(arguments)
                        s(u(e.prototype), 'emit', this).apply(this, i)
                    }
                    return r
                }
            }, {
                key: 'on',
                value(t, n, r) {
                    return s(u(e.prototype), 'on', this).call(this, t, n, r), n
                }
            }, {
                key: 'onAny',
                value(t, n) {
                    return s(u(e.prototype), 'on', this).call(this, h, t, n), t
                }
            }, {
                key: 'once',
                value(t, n, r) {
                    return s(u(e.prototype), 'once', this).call(this, t, n, r), n
                }
            }, {
                key: 'onceAny',
                value(t, n) {
                    return s(u(e.prototype), 'once', this).call(this, h, t, n), t
                }
            }, {
                key: 'addListener',
                value(t, n, r) {
                    return s(u(e.prototype), 'addListener', this).call(this, t, n, r)
                }
            }, {
                key: 'off',
                value(t, n, r, i) {
                    return s(u(e.prototype), 'off', this).call(this, t, n, r, i)
                }
            }, {
                key: 'offAny',
                value(t, n, r) {
                    return s(u(e.prototype), 'off', this).call(this, h, t, n, r)
                }
            }, {
                key: 'removeListener',
                value(t, n, r, i) {
                    return s(u(e.prototype), 'removeListener', this).call(this, t, n, r, i)
                }
            }, {
                key: 'removeAllListeners',
                value(t) {
                    return s(u(e.prototype), 'removeAllListeners', this).call(this, t)
                }
            }, {
                key: 'setMaxListeners',
                value() {
                    throw new Error('EventEmitter::setMaxListeners is deprecated.')
                }
            }, {
                key: 'getMaxListeners',
                value() {
                    throw new Error('EventEmitter::getMaxListeners is deprecated.')
                }
            }]) && o(n.prototype, r), i && o(n, i), e
        }(n.n(r).a))
        var h = '_____ANY_EVENT_____'

        function f(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function d(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const p = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t))
            }
            let e, n, r
            return e = t, r = [{
                key: 'match',
                value(t, e) {
                    return e.match(t)
                }
            }, {
                key: 'matchAll',
                value(e, n, r) {
                    r = r || t.REGEXP_SET_ORDER
                    var i; let o = []
                    if (e.global) {
                        for (; (i = e.exec(n)) !== null;) o.push(i)
}
                    else { (i = n.match(e)) !== null && o.push(i)
}
                    if (r === t.REGEXP_PATTERN_ORDER) {
                        for (var a = [], s = [], u = 0; u < o.length; u++) s.push(`${o[u][0] }`)
                        for (s.length > 0 && a.push(s), u = 0; u < o.length; u++) {
                            s = []
                            for (let c = 1; c < o[u].length; c++) s.push(o[u][c])
                            s.length > 0 && a.push(s)
                        }
                        o = a
                    }
                    return o
                }
            }], (n = null) && f(e.prototype, n), r && f(e, r), t
        }())
        d(p, 'REGEXP_SET_ORDER', 0), d(p, 'REGEXP_PATTERN_ORDER', 0)
        let m

        function y(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function v(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function _(t, e, n) {
            return e && v(t.prototype, e), n && v(t, n), t
        }

        function g(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const b = (function () {
            function t(e) {
                y(this, t), g(this, '_storage', null), this._storage = e
            }
            return _(t, [{
                key: 'get',
                value (t) {
                    var e = this._storage.getItem(t)
                    return e == null ? null : !1 === e ? e : JSON.parse(e)
                }
            }, {
                key: 'set',
                value (t, e) {
                    this._storage.setItem(t, JSON.stringify(e))
                }
            }, {
                key: 'getKey',
                value (t) {
                    return this._storage.key(t)
                }
            }, {
                key: 'remove',
                value (t) {
                    this._storage.removeItem(t)
                }
            }, {
                key: 'clear',
                value () {
                    this._storage.clear()
                }
            }, {
                key: 'length',
                get () {
                    return this._storage.length
                }
            }]), t
        }())
        let E = _(function t() {
            y(this, t)
        })
        m = E, g(E, 'getLocalStorage', () => {
            let t = null
            try {
                t = window.localStorage
            } catch (t) {
                console.warn(t)
            }
            return t
        }), g(E, 'getSessionStorage', () => {
            let t = null
            try {
                t = window.sessionStorage
            } catch (t) {
                console.warn(t)
            }
            return t
        }), g(E, 'local', new b(m.getLocalStorage())), g(E, 'session', new b(m.getLocalStorage()))

        function x(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const T = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t))
            }
            let e, n, r
            return e = t, r = [{
                key: 'number',
                value(t, e, n, r) {
                    let i; let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]
                            var a = (`${t  }`).replace(/[^0-9+\-E.]/gi, '');
                    var s = isFinite(+a) ? +a : 0
                            var u = isFinite(+e) ? Math.abs(e) : 0
                            var c = void 0 === r ? ' ' : r
                            var l = void 0 === n ? '.' : n
                            var h = function (t, e) {
                        var n = 10 ** e;
                        return `${  (Math.round(t * n) / n).toFixed(e)}`
                    };
                    return (i = (u ? h(s, u) : `${  Math.round(s)}`).split('.'))[0].length > 3 && (i[0] = i[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, c)), (i[1] || '').length < u && (i[1] = i[1] || '', i[1] += Array.from({ length: u - i[1].length + 1 }).join('0')), o ? i[0] : i.join(l)
                }
            }, {
                key: 'currency',
                value(e, n, r, i, o, a) {
                    let s = arguments.length > 6 && void 0 !== arguments[6] && arguments[6]
                    null == a && (a = 2), r == null && (r = '$%s')
                    var u; let c = 10**a;
                    var l = Math.round(e * c) / c
                    if (l < 0) { u = ('-' + r).replace('%s', t.number(Math.abs(l), a, i, o))
}
                    else {
                        let h = e % 1 == 0
                                var f = s && h
                        u = r.replace('%s', t.number(l, a, i, o, f))
                    }
                    return u
                }
            }, {
                key: 'fraction',
                value(t) {
                    return `1/${  t ? (1 / t).toFixed(1) : '0.0'}`
                }
            }, {
                key: 'float',
                value(t) {
                    return t ? Number.parseFloat(t) : '0'
                }
            }, {
                key: 'integer',
                value(t) {
                    return t ? Number.parseInt(t) : '0'
                }
            }, {
                key: 'percent',
                value(t, e) {
                    e || e === 0 || (e = 4)
                    for (var n = '', r = 0; r < e; r++) n += '0'
                    return t ? `${(100 * t).toFixed(e) }%` : `0.${  n  }%`
                }
            }], (n = null) && x(e.prototype, n), r && x(e, r), t
        }())

        function S(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function w(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const O = (function () {
            function t(e) {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), w(this, 'dir', console.dir.bind(console)), w(this, 'count', console.count.bind(console)), w(this, 'group', console.group.bind(console)), w(this, 'groupCollapsed', console.groupCollapsed.bind(console)), w(this, 'groupEnd', console.groupEnd.bind(console)), w(this, 'profile', console.profile.bind(console)), w(this, 'profileEnd', console.profileEnd.bind(console)), w(this, 'table', console.table.bind(console)), w(this, 'time', console.time.bind(console)), w(this, 'timeEnd', console.timeEnd.bind(console)), w(this, 'timeStamp', console.timeStamp.bind(console)), this.group = e || '', this.enabled = !t.DISABLED_GROUPS.includes(this.group)
            }
            let e, n, r
            return e = t, (n = [{
                key: 'output',
                value(t, e) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                    if (this.enabled) {
                        if (this.group) {
                            let r = `[${  this.group  }]`;
                            e.splice(n, 0, r)
                        }
                        return console[t].apply(console, e)
                    }
                }
            }, {
                key: 'disable',
                value() {
                    this.enabled = !1
                }
            }, {
                key: 'enable',
                value() {
                    this.enabled = !0
                }
            }, {
                key: 'log',
                value() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
                    return this.output('log', e)
                }
            }, {
                key: 'info',
                value() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
                    return this.output('info', e)
                }
            }, {
                key: 'warn',
                value() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
                    return this.output('warn', e)
                }
            }, {
                key: 'trace',
                value() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
                    return this.output('trace', e)
                }
            }, {
                key: 'error',
                value() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
                    return this.output('error', e)
                }
            }, {
                key: 'assert',
                value() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
                    return this.output('assert', e, 1)
                }
            }]) && S(e.prototype, n), r && S(e, r), t
        }())
        w(O, 'DISABLED_GROUPS', [])

        function P(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function R(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const A = ['NOK', 'SEK', 'DKK', 'AMD', 'BGN', 'CZK', 'GEL', 'VN2', 'KR2', 'ID2']
        var I = (function () {
            function t(e) {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), R(this, '_code', 'USD'), R(this, '_symbol', '$'), R(this, '_position', 'left'), R(this, '_thousands', ','), R(this, '_decimals', '.'), R(this, '_digits', 2), R(this, '_formatting', '$%s'), this._exists(e) && this.set(e)
            }
            let e, n, r
            return e = t, r = [{
                key: 'set',
                value(t) {
                    return this.singleton.set(t)
                }
            }, {
                key: 'format',
                value(t) {
                    const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                    var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                    return this.singleton.format(t, e, n)
                }
            }], (n = [{
                key: 'set',
                value(t) {
                    this._exists(t.code) && (this._code = t.code), this._exists(t.symbol) && (this._symbol = t.symbol), this._exists(t.position) ? this._position = t.position : A.includes(this._code) && (this._position = 'right'), this._exists(t.thousands) && (this._thousands = t.thousands), this._exists(t.decimals) && (this._decimals = t.decimals), this._exists(t.digits) && (this._digits = t.digits), this._formatting = this._position === 'right' ? `%s${ this._symbol}` : `${this._symbol}%s`
                }
            }, {
                key: 'format',
                value(t, e, n) {
                    const r = n ? this._formatting : '%s'
                    return T.currency(t, this._code, r, this._decimals, this._thousands, this._digits, e)
                }
            }, {
                key: '_exists',
                value(t) {
                    return t != null
                }
            }, {
                key: 'code',
                get() {
                    return this._code
                }
            }, {
                key: 'symbol',
                get() {
                    return this._symbol
                }
            }, {
                key: 'position',
                get() {
                    return this._position
                }
            }, {
                key: 'thousands',
                get() {
                    return this._thousands
                }
            }, {
                key: 'decimals',
                get() {
                    return this._decimals
                }
            }, {
                key: 'digits',
                get() {
                    return this._digits
                }
            }, {
                key: 'formatting',
                get() {
                    return this._formatting
                }
            }]) && P(e.prototype, n), r && P(e, r), t
        }())

        function C(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function k(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        R(I, 'singleton', new I({}))
        var N = (function () {
            function t(e, n) {
                if ((function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), k(this, '_code', ''), k(this, '_texts', null), k(this, '_default', ''), !n) { throw new Error('Missing default language.')
                }
                this._code = this._default = n, this._texts = e
            }
            let e, n, r
            return e = t, r = [{
                key: 'setLanguage',
                value(e, n, r) {
                    return this.singleton || (this.singleton = new t(n, r)), this.singleton.setLanguage(e)
                }
            }, {
                key: 'texts',
                get() {
                    return this.singleton ? this.singleton.texts : console.error('[Language] Static Module is not initiated, use Languge.setLanguage(code, text, defaultLanguage) first')
                }
            }, {
                key: 'code',
                get() {
                    return this.singleton ? this.singleton._code : console.error('[Language] Static Module is not initiated, use Languge.setLanguage(code, text, defaultLanguage) first')
                }
            }], (n = [{
                key: 'setLanguage',
                value(t) {
                    return this._code = this._supported(t), this._code
                }
            }, {
                key: 'texts',
                get() {
                    if (!this._code) throw new Error('No language has been set')
                    return this._texts[this._code]
                }
            }, {
                key: '_supported',
                value(t) {
                    if (void 0 === t) return this._default
                    if (!this._texts.hasOwnProperty(t)) {
                        const e = t.substr(0, 2)
                        return this._texts.hasOwnProperty(e) ? (console.warn(`Language was not found: ${ t }, fallback available: ${ e}`), e) : (console.warn(`Language code was not found: ${ t }, falling back to default: ${ this._default}`), this._default)
                    }
                    return t
                }
            }]) && C(e.prototype, n), r && C(e, r), t
        }())
    },
    './node_modules/@games/gsap/CSSPlugin.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return pt
        }), n.d(e, 'b', () => {
            return pt
        })
        let r; let i; let o; let a; let s; let u; let c; const l = n('./node_modules/@games/gsap/gsap-core.js')
        const h = {}
        const f = 180 / Math.PI
        const d = Math.PI / 180
        const p = Math.atan2
        const m = /([A-Z])/g
        const y = /left|right|width|margin|padding|x/i
        const v = /[\s,(]\S/
        const _ = {
            autoAlpha: 'opacity,visibility',
            scale: 'scaleX,scaleY',
            alpha: 'opacity'
        }
        const g = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }
        const b = function (t, e) {
            return e.set(e.t, e.p, t === 1 ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }
        const E = function (t, e) {
            return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
        }
        const x = function (t, e) {
            const n = e.s + e.c * t
            e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e)
        }
        const T = function (t, e) {
            return e.set(e.t, e.p, t ? e.e : e.b, e)
        }
        const S = function (t, e) {
            return e.set(e.t, e.p, t !== 1 ? e.b : e.e, e)
        }
        const w = function (t, e, n) {
            return t.style[e] = n
        }
        const O = function (t, e, n) {
            return t.style.setProperty(e, n)
        }
        const P = function (t, e, n) {
            return t._gsap[e] = n
        }
        const R = function (t, e, n) {
            return t._gsap.scaleX = t._gsap.scaleY = n
        }
        const A = function (t, e, n, r, i) {
            const o = t._gsap
            o.scaleX = o.scaleY = n, o.renderTransform(i, o)
        }
        const I = function (t, e, n, r, i) {
            const o = t._gsap
            o[e] = n, o.renderTransform(i, o)
        }
        let C = 'transform'
        let k = `${C}Origin`
        const N = function (t, e) {
            const n = i.createElementNS ? i.createElementNS((e || 'http://www.w3.org/1999/xhtml').replace(/^https/, 'http'), t) : i.createElement(t)
            return n.style ? n : i.createElement(t)
        }
        const M = function t(e, n, r) {
            const i = getComputedStyle(e)
            return i[n] || i.getPropertyValue(n.replace(m, '-$1').toLowerCase()) || i.getPropertyValue(n) || !r && t(e, D(n) || n, 1) || ''
        }
        const j = 'O,Moz,ms,Ms,Webkit'.split(',')
        var D = function (t, e, n) {
            const r = (e || s).style
            let i = 5
            if (t in r && !n) return t
            for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(j[i] + t in r););
            return i < 0 ? null : (i === 3 ? 'ms' : i >= 0 ? j[i] : '') + t
        }
        const L = function () {
            typeof window != 'undefined' && window.document && (r = window, i = r.document, o = i.documentElement, s = N('div') || {
                style: {}
            }, N('div'), C = D(C), k = `${C}Origin`, s.style.cssText = 'border-width:0;line-height:0;position:absolute;padding:0', c = !!D('perspective'), a = 1)
        }
        const F = function t(e) {
            let n; const r = N('svg', this.ownerSVGElement && this.ownerSVGElement.getAttribute('xmlns') || 'http://www.w3.org/2000/svg');
            let i = this.parentNode
            var a = this.nextSibling
            var s = this.style.cssText
            if (o.appendChild(r), r.appendChild(this), this.style.display = 'block', e) { try {
                n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
            } catch (t) {}
            } else { this._gsapBBox && (n = this._gsapBBox())
            }
            return i && (a ? i.insertBefore(this, a) : i.appendChild(this)), o.removeChild(r), this.style.cssText = s, n
        }
        const B = function (t, e) {
            for (let n = e.length; n--;) {
                if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
            }
        }
        const U = function (t) {
            let e
            try {
                e = t.getBBox()
            } catch (n) {
                e = F.call(t, !0)
            }
            return e && (e.width || e.height) || t.getBBox === F || (e = F.call(t, !0)), !e || e.width || e.x || e.y
                ? e
                : {
                        x: +B(t, ['x', 'cx', 'x1']) || 0,
                        y: +B(t, ['y', 'cy', 'y1']) || 0,
                        width: 0,
                        height: 0
                    }
        }
        const G = function (t) {
            return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !U(t))
        }
        const X = function (t, e) {
            if (e) {
                const n = t.style
                e in h && e !== k && (e = C), n.removeProperty ? (e.substr(0, 2) !== 'ms' && e.substr(0, 6) !== 'webkit' || (e = `-${ e}`), n.removeProperty(e.replace(m, '-$1').toLowerCase())) : n.removeAttribute(e)
            }
        }
        const H = function (t, e, n, r, i, o) {
            const a = new l.d(t._pt, e, n, 0, 1, o ? S : T)
            return t._pt = a, a.b = r, a.e = i, t._props.push(n), a
        }
        const V = {
            deg: 1,
            rad: 1,
            turn: 1
        }
        const W = function t(e, n, r, o) {
            let a; let u; let c; let f; let d = Number.parseFloat(r) || 0
            var p = (`${r }`).trim().substr((`${d }`).length) || 'px'
            var m = s.style
            var v = y.test(n)
            var _ = e.tagName.toLowerCase() === 'svg'
            var g = (_ ? 'client' : 'offset') + (v ? 'Width' : 'Height')
            var b = o === 'px'
            var E = o === '%'
            return o === p || !d || V[o] || V[p] ? d : (p !== 'px' && !b && (d = t(e, n, r, 'px')), f = e.getCTM && G(e), !E && p !== '%' || !h[n] && !~n.indexOf('adius') ? (m[v ? 'width' : 'height'] = 100 + (b ? p : o), u = ~n.indexOf('adius') || o === 'em' && e.appendChild && !_ ? e : e.parentNode, f && (u = (e.ownerSVGElement || {}).parentNode), u && u !== i && u.appendChild || (u = i.body), (c = u._gsap) && E && c.width && v && c.time === l.x.time ? new Object(l.v)(d / c.width * 100) : ((E || p === '%') && (m.position = M(e, 'position')), u === e && (m.position = 'static'), u.appendChild(s), a = s[g], u.removeChild(s), m.position = 'absolute', v && E && ((c = new Object(l.j)(u)).time = l.x.time, c.width = u[g]), new Object(l.v)(b ? a * d / 100 : a && d ? 100 / a * d : 0))) : (a = f ? e.getBBox()[v ? 'width' : 'height'] : e[g], new Object(l.v)(E ? d / a * 100 : d / 100 * a)))
        }
        const Y = function (t, e, n, r) {
            let i
            return a || L(), e in _ && e !== 'transform' && ~(e = _[e]).indexOf(',') && (e = e.split(',')[0]), h[e] && e !== 'transform' ? (i = rt(t, r), i = e !== 'transformOrigin' ? i[e] : `${it(M(t, k))} ${i.zOrigin}px`) : (!(i = t.style[e]) || i === 'auto' || r || ~(`${i}`).indexOf('calc(')) && (i = Z[e] && Z[e](t, e, n) || M(t, e) || new Object(l.k)(t, e) || (e === 'opacity' ? 1 : 0)), n && !~(`${i}`).trim().indexOf(' ') ? W(t, e, i, n) + n : i
        }
        const z = function (t, e, n, r) {
            if (!n || n === 'none') {
                const i = D(e, t, 1)
                var o = i && M(t, i, 1)
                o && o !== n ? (e = i, n = o) : e === 'borderColor' && (n = M(t, 'borderTopColor'))
            }
            let a; let s; let u; let c; let h; let f; let d; let p; let m; let y; let v; let _; const g = new l.d(this._pt, t.style, e, 0, 1, l.t)
            var b = 0
            var E = 0
            if (g.b = n, g.e = r, n += '', (r += '') === 'auto' && (t.style[e] = r, r = M(t, e) || r, t.style[e] = n), a = [n, r], new Object(l.g)(a), r = a[1], u = (n = a[0]).match(l.q) || [], (r.match(l.q) || []).length) {
                for (; s = l.q.exec(r);) { d = s[0], m = r.substring(b, s.index), h ? h = (h + 1) % 5 : m.substr(-5) !== 'rgba(' && m.substr(-5) !== 'hsla(' || (h = 1), d !== (f = u[E++] || '') && (c = Number.parseFloat(f) || 0, v = f.substr((`${c }`).length), (_ = d.charAt(1) === '=' ? +(`${d.charAt(0) }1`) : 0) && (d = d.substr(2)), p = Number.parseFloat(d), y = d.substr((`${p }`).length), b = l.q.lastIndex - y.length, y || (y = y || l.h.units[e] || v, b === r.length && (r += y, g.e += y)), v !== y && (c = W(t, e, f, y) || 0), g._pt = {
                    _next: g._pt,
                    p: m || E === 1 ? m : ',',
                    s: c,
                    c: _ ? _ * p : p - c,
                    m: h && h < 4 || e === 'zIndex' ? Math.round : 0
                })
                }
                g.c = b < r.length ? r.substring(b, r.length) : ''
            } else { g.r = e === 'display' && r === 'none' ? S : T
            }
            return l.s.test(r) && (g.e = 0), this._pt = g, g
        }
        const q = {
            top: '0%',
            bottom: '100%',
            left: '0%',
            right: '100%',
            center: '50%'
        }
        const K = function (t, e) {
            if (e.tween && e.tween._time === e.tween._dur) {
                let n; let r; let i; const o = e.t
                var a = o.style
                var s = e.u
                var u = o._gsap
                if (s === 'all' || !0 === s) { a.cssText = '', r = 1
                }
                else {
                    for (i = (s = s.split(',')).length; --i > -1;) n = s[i], h[n] && (r = 1, n = n === 'transformOrigin' ? k : C), X(o, n)
                }
                r && (X(o, C), u && (u.svg && o.removeAttribute('transform'), rt(o, 1), u.uncache = 1))
            }
        }
        var Z = {
            clearProps(t, e, n, r, i) {
                if (i.data !== 'isFromStart') {
                    const o = t._pt = new l.d(t._pt, e, n, 0, 0, K)
                    return o.u = r, o.pr = -10, o.tween = i, t._props.push(n), 1
                }
            }
        }
        const $ = [1, 0, 0, 1, 0, 0]
        const J = {}
        const Q = function (t) {
            return t === 'matrix(1, 0, 0, 1, 0, 0)' || t === 'none' || !t
        }
        const tt = function (t) {
            const e = M(t, C)
            return Q(e) ? $ : e.substr(7).match(l.p).map(l.v)
        }
        const et = function (t, e) {
            let n; let r; let i; let a; const s = t._gsap || new Object(l.j)(t)
            var u = t.style
            var c = tt(t)
            return s.svg && t.getAttribute('transform') ? (c = [(i = t.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(',') === '1,0,0,1,0,0' ? $ : c : (c !== $ || t.offsetParent || t === o || s.svg || (i = u.display, u.display = 'block', (n = t.parentNode) && t.offsetParent || (a = 1, r = t.nextSibling, o.appendChild(t)), c = tt(t), i ? u.display = i : X(t, 'display'), a && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : o.removeChild(t))), e && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c)
        }
        const nt = function (t, e, n, r, i, o) {
            let a; let s; let u; const c = t._gsap
            var l = i || et(t, !0)
            var h = c.xOrigin || 0
            var f = c.yOrigin || 0
            var d = c.xOffset || 0
            var p = c.yOffset || 0
            var m = l[0]
            var y = l[1]
            var v = l[2]
            var _ = l[3]
            var g = l[4]
            var b = l[5]
            var E = e.split(' ')
            var x = Number.parseFloat(E[0]) || 0
            var T = Number.parseFloat(E[1]) || 0
            n ? l !== $ && (s = m * _ - y * v) && (u = x * (-y / s) + T * (m / s) - (m * b - y * g) / s, x = x * (_ / s) + T * (-v / s) + (v * b - _ * g) / s, T = u) : (x = (a = U(t)).x + (~E[0].indexOf('%') ? x / 100 * a.width : x), T = a.y + (~(E[1] || E[0]).indexOf('%') ? T / 100 * a.height : T)), r || !1 !== r && c.smooth ? (g = x - h, b = T - f, c.xOffset = d + (g * m + b * v) - g, c.yOffset = p + (g * y + b * _) - b) : c.xOffset = c.yOffset = 0, c.xOrigin = x, c.yOrigin = T, c.smooth = !!r, c.origin = e, c.originIsAbsolute = !!n, t.style[k] = '0px 0px', o && (H(o, c, 'xOrigin', h, x), H(o, c, 'yOrigin', f, T), H(o, c, 'xOffset', d, c.xOffset), H(o, c, 'yOffset', p, c.yOffset)), t.setAttribute('data-svg-origin', `${x} ${T}`)
        }
        var rt = function (t, e) {
            const n = t._gsap || new l.a(t)
            if ('x' in n && !e && !n.uncache) return n
            let r; let i; let o; let a; let s; let u; let h; let m; let y; let v; let _; let g; let b; let E; let x; let T; let S; let w; let O; let P; let R; let A; let I; let N; let j; let D; let L; let F; let B; let U; let X; let H; const V = t.style
            let W = n.scaleX < 0
            let Y = M(t, k) || '0'
            return r = i = o = u = h = m = y = v = _ = 0, a = s = 1, n.svg = !(!t.getCTM || !G(t)), E = et(t, n.svg), n.svg && (N = !n.uncache && !e && t.getAttribute('data-svg-origin'), nt(t, N || Y, !!N || n.originIsAbsolute, !1 !== n.smooth, E)), g = n.xOrigin || 0, b = n.yOrigin || 0, E !== $ && (w = E[0], O = E[1], P = E[2], R = E[3], r = A = E[4], i = I = E[5], E.length === 6 ? (a = Math.sqrt(w * w + O * O), s = Math.sqrt(R * R + P * P), u = w || O ? p(O, w) * f : 0, (y = P || R ? p(P, R) * f + u : 0) && (s *= Math.abs(Math.cos(y * d))), n.svg && (r -= g - (g * w + b * P), i -= b - (g * O + b * R))) : (H = E[6], U = E[7], L = E[8], F = E[9], B = E[10], X = E[11], r = E[12], i = E[13], o = E[14], h = (x = p(H, B)) * f, x && (N = A * (T = Math.cos(-x)) + L * (S = Math.sin(-x)), j = I * T + F * S, D = H * T + B * S, L = A * -S + L * T, F = I * -S + F * T, B = H * -S + B * T, X = U * -S + X * T, A = N, I = j, H = D), m = (x = p(-P, B)) * f, x && (T = Math.cos(-x), X = R * (S = Math.sin(-x)) + X * T, w = N = w * T - L * S, O = j = O * T - F * S, P = D = P * T - B * S), u = (x = p(O, w)) * f, x && (N = w * (T = Math.cos(x)) + O * (S = Math.sin(x)), j = A * T + I * S, O = O * T - w * S, I = I * T - A * S, w = N, A = j), h && Math.abs(h) + Math.abs(u) > 359.9 && (h = u = 0, m = 180 - m), a = new Object(l.v)(Math.sqrt(w * w + O * O + P * P)), s = new Object(l.v)(Math.sqrt(I * I + H * H)), x = p(A, I), y = Math.abs(x) > 2e-4 ? x * f : 0, _ = X ? 1 / (X < 0 ? -X : X) : 0), n.svg && (N = t.getAttribute('transform'), n.forceCSS = t.setAttribute('transform', '') || !Q(M(t, C)), N && t.setAttribute('transform', N))), Math.abs(y) > 90 && Math.abs(y) < 270 && (W ? (a *= -1, y += u <= 0 ? 180 : -180, u += u <= 0 ? 180 : -180) : (s *= -1, y += y <= 0 ? 180 : -180)), n.x = `${r - ((n.xPercent = r && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0)}px`, n.y = `${i - ((n.yPercent = i && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0)}px`, n.z = `${o}px`, n.scaleX = new Object(l.v)(a), n.scaleY = new Object(l.v)(s), n.rotation = `${new Object(l.v)(u)}deg`, n.rotationX = `${new Object(l.v)(h)}deg`, n.rotationY = `${new Object(l.v)(m)}deg`, n.skewX = `${y}deg`, n.skewY = `${v}deg`, n.transformPerspective = `${_}px`, (n.zOrigin = Number.parseFloat(Y.split(' ')[2]) || 0) && (V[k] = it(Y)), n.xOffset = n.yOffset = 0, n.force3D = l.h.force3D, n.renderTransform = n.svg ? ut : c ? st : at, n.uncache = 0, n
        }
        var it = function (t) {
            return `${(t = t.split(' '))[0]} ${t[1]}`
        }
        const ot = function (t, e, n) {
            const r = new Object(l.z)(e)
            return new Object(l.v)(Number.parseFloat(e) + Number.parseFloat(W(t, 'x', `${n}px`, r))) + r
        }
        var at = function (t, e) {
            e.z = '0px', e.rotationY = e.rotationX = '0deg', e.force3D = 0, st(t, e)
        }
        var st = function (t, e) {
            const n = e || this
            let r = n.xPercent
            let i = n.yPercent
            let o = n.x
            let a = n.y
            let s = n.z
            let u = n.rotation
            let c = n.rotationY
            let l = n.rotationX
            let h = n.skewX
            let f = n.skewY
            let p = n.scaleX
            let m = n.scaleY
            let y = n.transformPerspective
            let v = n.force3D
            let _ = n.target
            let g = n.zOrigin
            let b = ''
            let E = v === 'auto' && t && t !== 1 || !0 === v
            if (g && (l !== '0deg' || c !== '0deg')) {
                let x; let T = Number.parseFloat(c) * d
                let S = Math.sin(T)
                let w = Math.cos(T)
                T = Number.parseFloat(l) * d, x = Math.cos(T), o = ot(_, o, S * x * -g), a = ot(_, a, -Math.sin(T) * -g), s = ot(_, s, w * x * -g + g)
            }
            y !== '0px' && (b += `perspective(${y}) `), (r || i) && (b += `translate(${r}%, ${i}%) `), (E || o !== '0px' || a !== '0px' || s !== '0px') && (b += s !== '0px' || E ? `translate3d(${o}, ${a}, ${s}) ` : `translate(${o}, ${a}) `), u !== '0deg' && (b += `rotate(${u}) `), c !== '0deg' && (b += `rotateY(${c}) `), l !== '0deg' && (b += `rotateX(${l}) `), h === '0deg' && f === '0deg' || (b += `skew(${h}, ${f}) `), p === 1 && m === 1 || (b += `scale(${p}, ${m}) `), _.style[C] = b || 'translate(0, 0)'
        }
        var ut = function (t, e) {
            let n; let r; let i; let o; let a; const s = e || this
            let u = s.xPercent
            let c = s.yPercent
            let h = s.x
            let f = s.y
            let p = s.rotation
            let m = s.skewX
            let y = s.skewY
            let v = s.scaleX
            let _ = s.scaleY
            let g = s.target
            let b = s.xOrigin
            let E = s.yOrigin
            let x = s.xOffset
            let T = s.yOffset
            let S = s.forceCSS
            let w = Number.parseFloat(h)
            let O = Number.parseFloat(f)
            p = Number.parseFloat(p), m = Number.parseFloat(m), (y = Number.parseFloat(y)) && (m += y = Number.parseFloat(y), p += y), p || m ? (p *= d, m *= d, n = Math.cos(p) * v, r = Math.sin(p) * v, i = Math.sin(p - m) * -_, o = Math.cos(p - m) * _, m && (y *= d, a = Math.tan(m - y), i *= a = Math.sqrt(1 + a * a), o *= a, y && (a = Math.tan(y), n *= a = Math.sqrt(1 + a * a), r *= a)), n = new Object(l.v)(n), r = new Object(l.v)(r), i = new Object(l.v)(i), o = new Object(l.v)(o)) : (n = v, o = _, r = i = 0), (w && !~(`${h}`).indexOf('px') || O && !~(`${f}`).indexOf('px')) && (w = W(g, 'x', h, 'px'), O = W(g, 'y', f, 'px')), (b || E || x || T) && (w = new Object(l.v)(w + b - (b * n + E * i) + x), O = new Object(l.v)(O + E - (b * r + E * o) + T)), (u || c) && (a = g.getBBox(), w = new Object(l.v)(w + u / 100 * a.width), O = new Object(l.v)(O + c / 100 * a.height)), a = `matrix(${n},${r},${i},${o},${w},${O})`, g.setAttribute('transform', a), S && (g.style[C] = a)
        }
        const ct = function (t, e, n, r, i, o) {
            let a; let s; const u = new Object(l.m)(i)
            var c = Number.parseFloat(i) * (u && ~i.indexOf('rad') ? f : 1)
            var h = o ? c * o : c - r
            var d = `${r + h}deg`;
            return u && ((a = i.split('_')[1]) === 'short' && (h %= 360) !== h % 180 && (h += h < 0 ? 360 : -360), a === 'cw' && h < 0 ? h = (h + 36e9) % 360 - 360 * ~~(h / 360) : a === 'ccw' && h > 0 && (h = (h - 36e9) % 360 - 360 * ~~(h / 360))), t._pt = s = new l.d(t._pt, e, n, r, h, b), s.e = d, s.u = 'deg', t._props.push(n), s
        }
        const lt = function (t, e) {
            for (const n in e) t[n] = e[n]
            return t
        }
        const ht = function (t, e, n) {
            let r; let i; let o; let a; let s; let u; let c; const f = lt({}, n._gsap)
            let d = n.style
            for (i in f.svg ? (o = n.getAttribute('transform'), n.setAttribute('transform', ''), d[C] = e, r = rt(n, 1), X(n, C), n.setAttribute('transform', o)) : (o = getComputedStyle(n)[C], d[C] = e, r = rt(n, 1), d[C] = o), h)(o = f[i]) !== (a = r[i]) && !'perspective,force3D,transformOrigin,svgOrigin'.includes(i) && (s = new Object(l.z)(o) !== (c = new Object(l.z)(a)) ? W(n, i, o, c) : Number.parseFloat(o), u = Number.parseFloat(a), t._pt = new l.d(t._pt, r, i, s, u - s, g), t._pt.u = c || 0, t._props.push(i))
            lt(r, f)
        }
        /*!
             * CSSPlugin 3.6.1
             * https://greensock.com
             *
             * Copyright 2008-2021, GreenSock. All rights reserved.
             * Subject to the terms at https://greensock.com/standard-license or for
             * Club GreenSock members, the agreement issued with that membership.
             * @author: Jack Doyle, jack@greensock.com
             */
        new Object(l.i)('padding,margin,Width,Radius', (t, e) => {
            const n = 'Top'
            var r = 'Right'
            var i = 'Bottom'
            var o = 'Left'
            var a = (e < 3 ? [n, r, i, o] : [n + o, n + r, i + r, i + o]).map((n) => {
                return e < 2 ? t + n : `border${ n }${t}`
            })
            Z[e > 1 ? `border${t}` : t] = function (t, e, n, r, i) {
                let o, s
                if (arguments.length < 4) { return o = a.map((e) => {
                    return Y(t, e, n)
                }), (s = o.join(' ')).split(o[0]).length === 5 ? o[0] : s
                }
                o = (`${r}`).split(' '), s = {}, a.forEach((t, e) => {
                    return s[t] = o[e] = o[e] || o[(e - 1) / 2 | 0]
                }), t.init(e, s, i)
            }
        })
        let ft; let dt; var pt = {
            name: 'css',
            register: L,
            targetTest(t) {
                return t.style && t.nodeType
            },
            init(t, e, n, r, i) {
                let o; let s; let u; let c; let f; let d; let p; let m; let y; let b; let T; let S; let w; let O; let P; let R; let A; let I; let k; const N = this._props
                let M = t.style
                let j = n.vars.startAt
                for (p in a || L(), e) {
                    if (p !== 'autoRound' && (s = e[p], !l.r[p] || !new Object(l.e)(p, e, n, r, t, i))) {
                        if (f = typeof s, d = Z[p], f === 'function' && (f = typeof (s = s.call(n, r, t, i))), f === 'string' && ~s.indexOf('random(') && (s = new Object(l.u)(s)), d) { d(this, t, p, s, n) && (P = 1)
}
                        else if (p.substr(0, 2) === '--') { o = (`${getComputedStyle(t).getPropertyValue(p)  }`).trim(), s += '', l.f.lastIndex = 0, l.f.test(o) || (m = new Object(l.z)(o), y = new Object(l.z)(s)), y ? m !== y && (o = W(t, p, o, y) + y) : m && (s += m), this.add(M, 'setProperty', o, s, r, i, 0, 0, p)
}
                        else if (f !== 'undefined') {
                            if (j && p in j ? (o = typeof j[p] == 'function' ? j[p].call(n, r, t, i) : j[p], p in l.h.units && !new Object(l.z)(o) && (o += l.h.units[p]), (`${o  }`).charAt(1) === '=' && (o = Y(t, p))) : o = Y(t, p), c = Number.parseFloat(o), (b = f === 'string' && s.charAt(1) === '=' ? +(`${s.charAt(0) }1`) : 0) && (s = s.substr(2)), u = Number.parseFloat(s), p in _ && (p === 'autoAlpha' && (c === 1 && Y(t, 'visibility') === 'hidden' && u && (c = 0), H(this, M, 'visibility', c ? 'inherit' : 'hidden', u ? 'inherit' : 'hidden', !u)), p !== 'scale' && p !== 'transform' && ~(p = _[p]).indexOf(',') && (p = p.split(',')[0])), T = p in h) {
                                if (S || ((w = t._gsap).renderTransform && !e.parseTransform || rt(t, e.parseTransform), O = !1 !== e.smoothOrigin && w.smooth, (S = this._pt = new l.d(this._pt, M, C, 0, 1, w.renderTransform, w, 0, -1)).dep = 1), 'scale' === p) { this._pt = new l.d(this._pt, w, "scaleY", w.scaleY, b ? b * u : u - w.scaleY), N.push("scaleY", p), p += "X";
}
                                else {
                                    if ('transformOrigin' === p) {
                                        A = void 0, I = void 0, k = void 0, A = (R = s).split(' '), I = A[0], k = A[1] || '50%', 'top' !== I && 'bottom' !== I && 'left' !== k && 'right' !== k || (R = I, I = k, k = R), A[0] = q[I] || I, A[1] = q[k] || k, s = A.join(' '), w.svg ? nt(t, s, 0, O, 0, this) : ((y = Number.parseFloat(s.split(' ')[2]) || 0) !== w.zOrigin && H(this, w, 'zOrigin', w.zOrigin, y), H(this, M, p, it(o), it(s)))
                                    continue
                                    }
                                    if ('svgOrigin' === p) {
                                        nt(t, s, 1, O, 0, this)
                                    continue
                                    }
                                    if (p in J) {
                                        ct(this, w, p, c, s, b)
                                    continue
                                    }
                                    if ('smoothOrigin' === p) {
                                        H(this, w, 'smooth', w.smooth, s)
                                    continue
                                    }
                                    if ('force3D' === p) {
                                        w[p] = s
                                    continue
                                    }
                                    if ('transform' === p) {
                                        ht(this, s, t)
                                    continue
                                    }
                                }
                            }
                            else { p in M || (p = D(p) || p)
}
                            if (T || (u || u === 0) && (c || c === 0) && !v.test(s) && p in M) { u || (u = 0), (m = (`${o  }`).substr((`${c  }`).length)) !== (y = new Object(l.z)(s) || (p in l.h.units ? l.h.units[p] : m)) && (c = W(t, p, o, y)), this._pt = new l.d(this._pt, T ? w : M, p, c, b ? b * u : u - c, T || 'px' !== y && 'zIndex' !== p || !1 === e.autoRound ? g : x), this._pt.u = y || 0, m !== y && (this._pt.b = o, this._pt.r = E)
}
                            else if (p in M) { z.call(this, t, p, o, s)
}
                            else {
                                if (!(p in t)) {
                                    new Object(l.o)(p, s)
                                    continue
                                }
                                this.add(t, p, t[p], s, r, i)
                            }
                            N.push(p)
                        }
                    }
                }
                P && new Object(l.w)(this)
            },
            get: Y,
            aliases: _,
            getSetter(t, e, n) {
                const r = _[e]
                return r && !r.includes(',') && (e = r), e in h && e !== k && (t._gsap.x || Y(t, 'x')) ? n && u === n ? e === 'scale' ? R : P : (u = n || {}) && (e === 'scale' ? A : I) : t.style && !new Object(l.n)(t.style[e]) ? w : ~e.indexOf('-') ? O : new Object(l.l)(t, e)
            },
            core: {
                _removeProperty: X,
                _getMatrix: et
            }
        }
        l.A.utils.checkPrefix = D, ft = 'rotation,rotationX,rotationY,skewX,skewY', dt = new Object(l.i)(`x,y,z,scale,scaleX,scaleY,xPercent,yPercent,${ft},transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective`, (t) => {
            h[t] = 1
        }), new Object(l.i)(ft, (t) => {
            l.h.units[t] = 'deg', J[t] = 1
        }), _[dt[13]] = `x,y,z,scale,scaleX,scaleY,xPercent,yPercent,${ft}`, new Object(l.i)('0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY', (t) => {
            const e = t.split(':')
            _[e[1]] = dt[e[0]]
        }), new Object(l.i)('x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective', (t) => {
            l.h.units[t] = 'px'
        }), l.A.registerPlugin(pt)
    },
    './node_modules/@games/gsap/EasePack.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return f
        })
        /*!
             * EasePack 3.0.0
             * https://greensock.com
             *
             * @license Copyright 2008-2019, GreenSock. All rights reserved.
             * Subject to the terms at https://greensock.com/standard-license or for
             * Club GreenSock members, the agreement issued with that membership.
             * @author: Jack Doyle, jack@greensock.com
             */
        let r; let i; const o = function () {
            return r || typeof window != 'undefined' && (r = window.gsap) && r.registerPlugin && r
        }
        const a = function (t, e) {
            return !!(void 0 === t ? e : t && !~(`${t}`).indexOf('false'))
        }
        const s = function (t) {
            if (r = t || o()) {
                i = r.registerEase
                let e; const n = r.parseEase()
                var a = function (t) {
                    return function (e) {
                        let n = 0.5 + e / 2
                        t.config = function (e) {
                            return t(2 * (1 - e) * e * n + e * e)
                        }
                    }
                }
                for (e in n) n[e].config || a(n[e])
                for (e in i('slow', f), i('expoScale', d), i('rough', p), m) e !== 'version' && r.core.globals(e, m[e])
                1
            }
        }
        const u = function (t, e, n) {
            const r = (t = Math.min(1, t || 0.7)) < 1 ? e || e === 0 ? e : 0.7 : 0
            var i = (1 - t) / 2
            var o = i + t
            var s = a(n)
            return function (t) {
                const e = t + (0.5 - t) * r
                return t < i ? s ? 1 - (t = 1 - t / i) * t : e - (t = 1 - t / i) * t * t * t * e : t > o ? s ? t === 1 ? 0 : 1 - (t = (t - o) / i) * t : e + (t - e) * (t = (t - o) / i) * t * t * t : s ? 1 : e
            }
        }
        const c = function (t, e, n) {
            const i = Math.log(e / t)
            var o = e - t
            return n && (n = r.parseEase(n)),
            function (e) {
                return (t * Math.exp(i * (n ? n(e) : e)) - t) / o
            }
        }
        const l = function (t, e, n) {
            this.t = t, this.v = e, n && (this.next = n, n.prev = this, this.c = n.v - e, this.gap = n.t - t)
        }
        const h = function (t) {
            typeof t != 'object' && (t = {
                points: +t || 20
            })
            for (var e, n, i, o, s, u, c, h = t.taper || 'none', f = [], d = 0, p = 0 | (+t.points || 20), m = p, y = a(t.randomize, !0), v = a(t.clamp), _ = r ? r.parseEase(t.template) : 0, g = 0.4 * (+t.strength || 1); --m > -1;) { e = y ? Math.random() : 1 / p * m, n = _ ? _(e) : e, i = h === 'none' ? g : h === 'out' ? (o = 1 - e) * o * g : h === 'in' ? e * e * g : e < 0.5 ? (o = 2 * e) * o * 0.5 * g : (o = 2 * (1 - e)) * o * 0.5 * g, y ? n += Math.random() * i - 0.5 * i : m % 2 ? n += 0.5 * i : n -= 0.5 * i, v && (n > 1 ? n = 1 : n < 0 && (n = 0)), f[d++] = {
                x: e,
                y: n
            }
            }
            for (f.sort((t, e) => {
                return t.x - e.x
            }), u = new l(1, 1, null), m = p; m--;) s = f[m], u = new l(s.x, s.y, u)
            return c = new l(0, 0, u.t ? u : u.next),
            function (t) {
                let e = c
                if (t > e.t) {
                    for (; e.next && t >= e.t;) e = e.next
                    e = e.prev
                } else {
                    for (; e.prev && t <= e.t;) e = e.prev
                }
                return c = e, e.v + (t - e.t) / e.gap * e.c
            }
        }
        var f = u(0.7)
        f.ease = f, f.config = u
        var d = c(1, 2)
        d.config = c
        var p = h()
        p.ease = p, p.config = h
        var m = {
            SlowMo: f,
            RoughEase: p,
            ExpoScaleEase: d
        }
        for (const y in m) m[y].register = s, m[y].version = '3.0.0'
        o() && r.registerPlugin(f)
    },
    './node_modules/@games/gsap/InertiaPlugin.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return Z
        })
        /*!
             * VelocityTracker: 3.6.1
             * https://greensock.com
             *
             * Copyright 2008-2021, GreenSock. All rights reserved.
             * Subject to the terms at https://greensock.com/standard-license or for
             * Club GreenSock members, the agreement issued with that membership.
             * @author: Jack Doyle, jack@greensock.com
             */
        let r; let i; let o; let a; let s; let u; let c; let l; const h = function () {
            return r || typeof window != 'undefined' && (r = window.gsap)
        }
        const f = {}
        const d = function (t) {
            return l(t).id
        }
        const p = function (t) {
            return f[d(typeof t == 'string' ? o(t)[0] : t)]
        }
        const m = function (t) {
            let e; let n = s
            if (t - c >= 0.05) {
                for (c, c = t; n;)((e = n.g(n.t, n.p)) !== n.v1 || t - n.t1 > 0.2) && (n.v2 = n.v1, n.v1 = e, n.t2 = n.t1, n.t1 = t), n = n._next
            }
        }
        const y = {
            deg: 360,
            rad: 2 * Math.PI
        }
        const v = function () {
            (r = h()) && (o = r.utils.toArray, a = r.utils.getUnit, l = r.core.getCache, u = r.ticker, i = 1)
        }
        const _ = function (t, e, n, r) {
            this.t = t, this.p = e, this.g = t._gsap.get, this.rCap = y[n || a(this.g(t, e))], this.v1 = this.v2 = 0, this.t1 = this.t2 = u.time, r && (this._next = r, r._prev = this)
        }
        const g = (function () {
            function t(t, e) {
                i || v(), this.target = o(t)[0], f[d(this.target)] = this, this._props = {}, e && this.add(e)
            }
            t.register = function (t) {
                r = t, v()
            }
            let e = t.prototype
            return e.get = function (t, e) {
                let n; let r; let i; const o = this._props[t] || console.warn(`Not tracking ${  t  } velocity.`);
                return n = Number.parseFloat(e ? o.v1 : o.g(o.t, o.p)) - Number.parseFloat(o.v2), (r = o.rCap) && (n %= r) !== n % (r / 2) && (n = n < 0 ? n + r : n - r), i = n / ((e ? o.t1 : u.time) - o.t2), Math.round(1e4 * i) / 1e4
            }, e.getAll = function () {
                let t; const e = {}
                var n = this._props
                for (t in n) e[t] = this.get(t)
                return e
            }, e.isTracking = function (t) {
                return t in this._props
            }, e.add = function (t, e) {
                t in this._props || (s || (u.add(m), c = u.time), s = this._props[t] = new _(this.target, t, e, s))
            }, e.remove = function (t) {
                let e; let n; const r = this._props[t]
                r && (e = r._prev, n = r._next, e && (e._next = n), n ? n._prev = e : s === r && (u.remove(m), s = 0), delete this._props[t])
            }, e.kill = function (t) {
                for (const e in this._props) this.remove(e)
                t || delete f[d(this.target)]
            }, t.track = function (e, n, r) {
                i || v()
                for (var a, s, u = [], c = o(e), l = n.split(','), h = (r || '').split(','), f = c.length; f--;) {
                    for (a = p(c[f]) || new t(c[f]), s = l.length; s--;) a.add(l[s], h[s] || h[0])
                    u.push(a)
                }
                return u
            }, t.untrack = function (t, e) {
                const n = (e || '').split(',')
                o(t).forEach((t) => {
                    let e = p(t)
                    e && (n.length
                        ? n.forEach((t) => {
                                return e.remove(t)
                            })
                        : e.kill(1))
                })
            }, t.isTracking = function (t, e) {
                const n = p(t)
                return n && n.isTracking(e)
            }, t.getVelocity = function (t, e) {
                const n = p(t)
                return n && n.isTracking(e) ? n.get(e) : console.warn(`Not tracking velocity of ${ e}`)
            }, t
        }())
        g.getByTarget = p, h() && r.registerPlugin(g)
        /*!
             * InertiaPlugin 3.6.1
             * https://greensock.com
             *
             * @license Copyright 2008-2021, GreenSock. All rights reserved.
             * Subject to the terms at https://greensock.com/standard-license or for
             * Club GreenSock members, the agreement issued with that membership.
             * @author: Jack Doyle, jack@greensock.com
             */
        let b; let E; let x; let T; let S; let w; let O; let P; let R; let A; let I; let C; const k = g.getByTarget
        const N = function () {
            return b || typeof window != 'undefined' && (b = window.gsap) && b.registerPlugin && b
        }
        const M = function (t) {
            return typeof t == 'number'
        }
        const j = function (t) {
            return typeof t == 'object'
        }
        const D = function (t) {
            return typeof t == 'function'
        }
        const L = Array.isArray
        const F = function (t) {
            return t
        }
        const B = 1e10
        const U = function (t, e, n) {
            for (const r in e) r in t || r === n || (t[r] = e[r])
            return t
        }
        const G = function t(e) {
            let n; let r; const i = {}
            for (n in e) i[n] = j(r = e[n]) ? t(r) : r
            return i
        }
        const X = function (t, e, n, r, i) {
            let o; let a; let s; let u; let c = e.length
            var l = 0
            var h = B
            if (j(t)) {
                for (; c--;) {
                    for (s in o = e[c], a = 0, t) a += (u = o[s] - t[s]) * u
                    a < h && (l = c, h = a)
                }
                if ((i || B) < B && i < Math.sqrt(h)) return t
            } else {
                for (; c--;)(a = (o = e[c]) - t) < 0 && (a = -a), a < h && o >= r && o <= n && (l = c, h = a)
            }
            return e[l]
        }
        const H = function (t, e, n, r, i, o) {
            if (t.end === 'auto') return t
            let a; let s; const u = t.end
            if (n = isNaN(n) ? B : n, r = isNaN(r) ? -B : r, j(e)) {
                if (a = e.calculated ? e : (D(u) ? u(e) : X(e, u, n, r, o)) || e, !e.calculated) {
                    for (s in a) e[s] = a[s]
                    e.calculated = !0
                }
                a = a[i]
            } else { a = D(u) ? u(e) : L(u) ? X(e, u, n, r, o) : Number.parseFloat(u)
            }
            return a > n ? a = n : a < r && (a = r), {
                max: a,
                min: a,
                unitFactor: t.unitFactor
            }
        }
        const V = function (t, e, n) {
            return isNaN(t[e]) ? n : +t[e]
        }
        const W = function (t, e) {
            return 0.05 * e * t / A
        }
        const Y = function (t, e, n) {
            return Math.abs((e - t) * A / n / 0.05)
        }
        const z = {
            resistance: 1,
            checkpoint: 1,
            preventOvershoot: 1,
            linkedProps: 1,
            radius: 1,
            duration: 1
        }
        const q = function (t, e, n, r) {
            if (e.linkedProps) {
                let i; let o; let a; let s; let u; let c; const l = e.linkedProps.split(',');
                let h = {}
                for (i = 0; i < l.length; i++)(a = e[o = l[i]]) && (s = M(a.velocity) ? a.velocity : (u = u || k(t)) && u.isTracking(o) ? u.get(o) : 0, c = Math.abs(s / V(a, 'resistance', r)), h[o] = Number.parseFloat(n(t, o)) + W(s, c))
                return h
            }
        }
        const K = function () {
            (b = N()) && (x = b.parseEase, T = b.utils.toArray, O = b.utils.getUnit, R = b.core.getCache, I = b.utils.clamp, S = x('power3'), A = S(0.05), P = b.core.PropTween, b.config({
                resistance: 100,
                unitFactors: {
                    time: 1e3,
                    totalTime: 1e3,
                    progress: 1e3,
                    totalProgress: 1e3
                }
            }), w = b.config(), b.registerPlugin(g), E = 1)
        }
        var Z = {
            version: '3.6.1',
            name: 'inertia',
            register(t) {
                b = t, K()
            },
            init(t, e, n, r, i) {
                E || K()
                const o = k(t)
                if (e === 'auto') {
                    if (!o) return void console.warn(`No inertia tracking on ${t}. InertiaPlugin.track(target) first.`)
                    e = o.getAll()
                }
                this.target = t, this.tween = n, C = e
                let a; let s; let u; let c; let l; let h; let f; let d; let p; const m = t._gsap
                let y = m.get
                let v = e.duration
                let _ = j(v)
                let g = e.preventOvershoot || _ && v.overshoot === 0
                let b = V(e, 'resistance', w.resistance)
                let x = M(v)
                    ? v
                    : (function (t, e, n, r, i, o) {
                            if (void 0 === n && (n = 10), void 0 === r && (r = 0.2), void 0 === i && (i = 1), void 0 === o && (o = 0), typeof t == 'string' && (t = T(t)[0]), !t) return 0
                            let a; let s; let u; let c; let l; let h; let f; let d; let p; let m; let y = 0
                            var v = B
                            var _ = e.inertia || e
                            var g = R(t).get
                            var b = V(_, 'resistance', w.resistance)
                            for (a in m = q(t, _, g, b), _) { z[a] || (s = _[a], j(s) || ((d = d || k(t)) && d.isTracking(a)
                                ? s = M(s)
                                    ? {
                                            velocity: s
                                        }
                                    : {
                                            velocity: d.get(a)
                                        }
                                : (c = +s || 0, u = Math.abs(c / b))), j(s) && (c = M(s.velocity) ? s.velocity : (d = d || k(t)) && d.isTracking(a) ? d.get(a) : 0, u = I(r, n, Math.abs(c / V(s, 'resistance', b))), h = (l = Number.parseFloat(g(t, a)) || 0) + W(c, u), 'end' in s && (s = H(s, m && a in m ? m : h, s.max, s.min, a, _.radius), o && (C === e && (C = _ = G(e)), _[a] = U(s, _[a], 'end'))), 'max' in s && h > +s.max + 1e-10 ? (p = s.unitFactor || w.unitFactors[a] || 1, (f = l > s.max && s.min !== s.max || c * p > -15 && c * p < 45 ? r + 0.1 * (n - r) : Y(l, s.max, c)) + i < v && (v = f + i)) : 'min' in s && h < +s.min - 1e-10 && (p = s.unitFactor || w.unitFactors[a] || 1, (f = l < s.min && s.min !== s.max || c * p > -45 && c * p < 15 ? r + 0.1 * (n - r) : Y(l, s.min, c)) + i < v && (v = f + i)), f > y && (y = f)), u > y && (y = u))
                            }
                            return y > v && (y = v), y > n ? n : y < r ? r : y
                        }(t, e, _ && v.max || 10, _ && v.min || 0.2, _ && 'overshoot' in v ? +v.overshoot : g ? 0 : 1, !0))
                for (a in e = C, C = 0, p = q(t, e, y, b), e) z[a] || (s = e[a], D(s) && (s = s(r, t, i)), M(s) ? l = s : j(s) && !isNaN(s.velocity) ? l = +s.velocity : o && o.isTracking(a) ? l = o.get(a) : console.warn(`ERROR: No velocity was defined for ${t} property: ${a}`), h = W(l, x), d = 0, u = y(t, a), c = O(u), u = Number.parseFloat(u), j(s) && (f = u + h, 'end' in s && (s = H(s, p && a in p ? p : f, s.max, s.min, a, e.radius)), 'max' in s && +s.max < f ? g || s.preventOvershoot ? h = s.max - u : d = s.max - u - h : 'min' in s && +s.min > f && (g || s.preventOvershoot ? h = s.min - u : d = s.min - u - h)), this._props.push(a), this._pt = new P(this._pt, t, a, u, 0, F, 0, m.set(t, a, this)), this._pt.u = c || 0, this._pt.c1 = h, this._pt.c2 = d)
                return n.duration(x), 1
            },
            render(t, e) {
                let n; let r = e._pt
                for (t = S(e.tween._time / e.tween._dur); r;) r.set(r.t, r.p, (n = r.s + r.c1 * t + r.c2 * t * t, Math.round(1e4 * n) / 1e4 + r.u), r.d, t), r = r._next
            }
        }
        'track,untrack,isTracking,getVelocity,getByTarget'.split(',').forEach((t) => {
            return Z[t] = g[t]
        }), N() && b.registerPlugin(Z)
    },
    './node_modules/@games/gsap/PixiPlugin.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return X
        })
        /*!
             * PixiPlugin 3.6.1
             * https://greensock.com
             *
             * @license Copyright 2008-2021, GreenSock. All rights reserved.
             * Subject to the terms at https://greensock.com/standard-license or for
             * Club GreenSock members, the agreement issued with that membership.
             * @author: Jack Doyle, jack@greensock.com
             */
        let r; let i; let o; let a; let s; let u; let c; let l; const h = function () {
            return typeof window != 'undefined'
        }
        const f = function () {
            return r || h() && (r = window.gsap) && r.registerPlugin && r
        }
        const d = function (t) {
            return typeof t == 'function'
        }
        const p = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
        const m = 0.212671
        const y = 0.71516
        const v = 0.072169
        const _ = function (t, e) {
            let n; let r; const i = []
            var o = 0
            var a = 0
            for (n = 0; n < 4; n++) {
                for (r = 0; r < 5; r++) a = r === 4 ? t[o + 4] : 0, i[o + r] = t[o] * e[r] + t[o + 1] * e[r + 5] + t[o + 2] * e[r + 10] + t[o + 3] * e[r + 15] + a
                o += 5
            }
            return i
        }
        const g = function (t, e) {
            const n = 1 - e
            var r = n * m
            var i = n * y
            var o = n * v
            return _([r + e, i, o, 0, 0, r, i + e, o, 0, 0, r, i, o + e, 0, 0, 0, 0, 0, 1, 0], t)
        }
        const b = function (t, e, n) {
            const r = o(e)
            var i = r[0] / 255
            var a = r[1] / 255
            var s = r[2] / 255
            var u = 1 - n
            return _([u + n * i * m, n * i * y, n * i * v, 0, 0, n * a * m, u + n * a * y, n * a * v, 0, 0, n * s * m, n * s * y, u + n * s * v, 0, 0, 0, 0, 0, 1, 0], t)
        }
        const E = function (t, e) {
            e *= Math.PI / 180
            let n = Math.cos(e)
            var r = Math.sin(e)
            return _([m + n * (1 - m) + r * -m, y + n * -y + r * -y, v + n * -v + r * (1 - v), 0, 0, m + n * -m + 0.143 * r, y + n * (1 - y) + 0.14 * r, v + n * -v + -0.283 * r, 0, 0, m + n * -m + r * -(1 - m), y + n * -y + r * y, v + n * (1 - v) + r * v, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], t)
        }
        const x = function (t, e) {
            return _([e, 0, 0, 0, 0.5 * (1 - e), 0, e, 0, 0, 0.5 * (1 - e), 0, 0, e, 0, 0.5 * (1 - e), 0, 0, 0, 1, 0], t)
        }
        const T = function (t, e) {
            let n; let r; const i = a.filters[e]
            var o = t.filters || []
            var s = o.length
            for (i || (r = `${e} not found. PixiPlugin.registerPIXI(PIXI)`, console.warn(r)); --s > -1;) {
                if (o[s] instanceof i) return o[s]
            }
            return n = new i(), e === 'BlurFilter' && (n.blur = 0), o.push(n), t.filters = o, n
        }
        const S = function (t, e, n, r) {
            e.add(n, t, n[t], r[t]), e._props.push(t)
        }
        const w = function (t, e) {
            const n = new a.filters.ColorMatrixFilter()
            return n.matrix = e, n.brightness(t, !0), n.matrix
        }
        const O = {
            contrast: 1,
            saturation: 1,
            colorizeAmount: 0,
            colorize: 'rgb(255,255,255)',
            hue: 0,
            brightness: 1
        }
        const P = function (t, e, n) {
            let r; let i; let o; const a = T(t, 'ColorMatrixFilter');
            let s = t._gsColorMatrixFilter = t._gsColorMatrixFilter || (function (t) {
                var e; var n = {}
                            for (e in t) n[e] = t[e]
                            return n
            }(O))
            var u = e.combineCMF && !('colorMatrixFilter' in e && !e.colorMatrixFilter)
            o = a.matrix, e.resolution && (a.resolution = e.resolution), e.matrix && e.matrix.length === o.length ? (i = e.matrix, s.contrast !== 1 && S('contrast', n, s, O), s.hue && S('hue', n, s, O), s.brightness !== 1 && S('brightness', n, s, O), s.colorizeAmount && (S('colorize', n, s, O), S('colorizeAmount', n, s, O)), s.saturation !== 1 && S('saturation', n, s, O)) : (i = p.slice(), e.contrast != null ? (i = x(i, +e.contrast), S('contrast', n, s, e)) : s.contrast !== 1 && (u ? i = x(i, s.contrast) : S('contrast', n, s, O)), e.hue != null ? (i = E(i, +e.hue), S('hue', n, s, e)) : s.hue && (u ? i = E(i, s.hue) : S('hue', n, s, O)), e.brightness != null ? (i = w(+e.brightness, i), S('brightness', n, s, e)) : s.brightness !== 1 && (u ? i = w(s.brightness, i) : S('brightness', n, s, O)), e.colorize != null ? (e.colorizeAmount = 'colorizeAmount' in e ? +e.colorizeAmount : 1, i = b(i, e.colorize, e.colorizeAmount), S('colorize', n, s, e), S('colorizeAmount', n, s, e)) : s.colorizeAmount && (u ? i = b(i, s.colorize, s.colorizeAmount) : (S('colorize', n, s, O), S('colorizeAmount', n, s, O))), e.saturation != null ? (i = g(i, +e.saturation), S('saturation', n, s, e)) : s.saturation !== 1 && (u ? i = g(i, s.saturation) : S('saturation', n, s, O))), r = i.length
            for (; --r > -1;) i[r] !== o[r] && n.add(o, r, o[r], i[r], 'colorMatrixFilter')
            n._props.push('colorMatrixFilter')
        }
        const R = function (t, e) {
            const n = e.t
            var r = e.p
            var i = e.color;
            (0, e.set)(n, r, i[0] << 16 | i[1] << 8 | i[2])
        }
        const A = function (t, e) {
            const n = e.g
            n && (n.dirty++, n.clearDirty++)
        }
        const I = function (t, e) {
            e.t.visible = !!e.t.alpha
        }
        const C = function (t, e, n, r) {
            const i = t[e]
            var a = o(d(i) ? t[e.indexOf('set') || !d(t[`get${  e.substr(3)}`]) ? e : `get${  e.substr(3)}`]() : i)
            var c = o(n)
            r._pt = new s(r._pt, t, e, 0, 0, R, {
                t,
                p: e,
                color: a,
                set: u(t, e)
            }), r.add(a, 0, a[0], c[0]), r.add(a, 1, a[1], c[1]), r.add(a, 2, a[2], c[2])
        }
        const k = {
            tint: 1,
            lineColor: 1,
            fillColor: 1
        }
        const N = 'position,scale,skew,pivot,anchor,tilePosition,tileScale'.split(',')
        const M = {
            x: 'position',
            y: 'position',
            tileX: 'tilePosition',
            tileY: 'tilePosition'
        }
        const j = {
            colorMatrixFilter: 1,
            saturation: 1,
            contrast: 1,
            hue: 1,
            colorize: 1,
            colorizeAmount: 1,
            brightness: 1,
            combineCMF: 1
        }
        const D = Math.PI / 180
        const L = function (t) {
            return typeof t == 'string'
        }
        const F = function (t) {
            return L(t) && t.charAt(1) === '=' ? t.substr(0, 2) + Number.parseFloat(t.substr(2)) * D : t * D
        }
        const B = function (t, e) {
            return e.set(e.t, e.p, t === 1 ? e.e : Math.round(1e5 * (e.s + e.c * t)) / 1e5, e)
        }
        const U = function (t, e, n, r, i, o) {
            let a; let u; const c = 360 * (o ? D : 1)
            var l = L(i)
            var h = l && i.charAt(1) === '=' ? +(`${i.charAt(0) }1`) : 0
            var f = Number.parseFloat(h ? i.substr(2) : i) * (o ? D : 1)
            var d = h ? f * h : f - r
            var p = r + d
            return l && ((a = i.split('_')[1]) === 'short' && (d %= c) !== d % (c / 2) && (d += d < 0 ? c : -c), a === 'cw' && d < 0 ? d = (d + 1e10 * c) % c - ~~(d / c) * c : a === 'ccw' && d > 0 && (d = (d - 1e10 * c) % c - ~~(d / c) * c)), t._pt = u = new s(t._pt, e, n, r, d, B), u.e = p, u
        }
        const G = function () {
            h() && (i = window, r = f(), a = a || i.PIXI, o = function (t) {
                return r.utils.splitColor((`${t}`).substr(0, 2) === '0x' ? `#${t.substr(2)}` : t)
            })
        }
        for (c = 0; c < N.length; c++) l = N[c], M[`${l}X`] = l, M[`${l}Y`] = l
        var X = {
            version: '3.6.1',
            name: 'pixi',
            register(t, e, n) {
                r = t, s = n, u = e.getSetter, G()
            },
            registerPIXI(t) {
                a = t
            },
            init(t, e, n, r, i) {
                if (a || G(), !t instanceof a.DisplayObject) return !1
                let o; let u; let c; let l; let h; let f; let d; let p; let m; const y = a.VERSION.charAt(0) === '4'
                for (f in e) {
                    if (o = M[f], c = e[f], o) { u = ~f.charAt(f.length - 1).toLowerCase().indexOf('x') ? 'x' : 'y', this.add(t[o], u, t[o][u], o === 'skew' ? F(c) : c)
                    }
                    else if (f === 'scale' || f === 'anchor' || f === 'pivot' || f === 'tileScale') { this.add(t[f], 'x', t[f].x, c), this.add(t[f], 'y', t[f].y, c)
                    }
                    else if (f === 'rotation' || f === 'angle') { U(this, t, f, t[f], c, f === 'rotation')
                    }
                    else if (j[f]) { l || (P(t, e.colorMatrixFilter || e, this), l = !0)
                    }
                    else if (f === 'blur' || f === 'blurX' || f === 'blurY' || f === 'blurPadding') {
                        if (h = T(t, 'BlurFilter'), this.add(h, f, h[f], c), e.blurPadding !== 0) {
                            for (d = e.blurPadding || 2 * Math.max(h[f], c), p = t.filters.length; --p > -1;) t.filters[p].padding = Math.max(t.filters[p].padding, d)
                        }
                    } else if (k[f]) {
                        if ((f === 'lineColor' || f === 'fillColor') && t instanceof a.Graphics) {
                            for (m = (t.geometry || t).graphicsData, this._pt = new s(this._pt, t, f, 0, 0, A, {
                                g: t.geometry || t
                            }), p = m.length; --p > -1;) C(y ? m[p] : m[p][`${f.substr(0, 4) }Style`], y ? f : 'color', c, this)
                        }
                        else { C(t, f, c, this)
                        }
                    }
                    else { f === 'autoAlpha' ? (this._pt = new s(this._pt, t, 'visible', 0, 0, I), this.add(t, 'alpha', t.alpha, c), this._props.push('alpha', 'visible')) : f !== 'resolution' && this.add(t, f, 'get', c)
                    }
                    this._props.push(f)
                }
            }
        }
        f() && r.registerPlugin(X)
    },
    './node_modules/@games/gsap/all.js': function (t, e, n) {
        'use strict'
        n.d(e, 'b', () => {
            return o
        }), n.d(e, 'a', () => {
            return o
        })
        const r = n('./node_modules/@games/gsap/gsap-core.js')
        const i = n('./node_modules/@games/gsap/CSSPlugin.js')
        var o = r.y.registerPlugin(i.b) || r.y
        o.core.Tween
    },
    './node_modules/@games/gsap/gsap-core.js': function (t, e, n) {
        'use strict'

        function r(t) {
            if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
            return t
        }

        function i(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }
        /*!
             * GSAP 3.6.1
             * https://greensock.com
             *
             * @license Copyright 2008-2021, GreenSock. All rights reserved.
             * Subject to the terms at https://greensock.com/standard-license or for
             * Club GreenSock members, the agreement issued with that membership.
             * @author: Jack Doyle, jack@greensock.com
             */
        n.d(e, 'a', () => {
            return Ue
        }), n.d(e, 'd', () => {
            return fn
        }), n.d(e, 'A', () => {
            return yn
        }), n.d(e, 'c', () => {
            return vn
        }), n.d(e, 'b', () => {
            return _n
        }), n.d(e, 'y', () => {
            return yn
        }), n.d(e, 'z', () => {
            return ne
        }), n.d(e, 'k', () => {
            return xt
        }), n.d(e, 'p', () => {
            return Q
        }), n.d(e, 'q', () => {
            return tt
        }), n.d(e, 'm', () => {
            return X
        }), n.d(e, 'n', () => {
            return W
        }), n.d(e, 't', () => {
            return an
        }), n.d(e, 's', () => {
            return nt
        }), n.d(e, 'i', () => {
            return Tt
        }), n.d(e, 'w', () => {
            return hn
        }), n.d(e, 'g', () => {
            return Oe
        }), n.d(e, 'u', () => {
            return de
        }), n.d(e, 'e', () => {
            return Ye
        }), n.d(e, 'r', () => {
            return mt
        }), n.d(e, 'x', () => {
            return Pe
        }), n.d(e, 'h', () => {
            return N
        }), n.d(e, 'v', () => {
            return St
        }), n.d(e, 'o', () => {
            return ut
        }), n.d(e, 'l', () => {
            return nn
        }), n.d(e, 'j', () => {
            return Et
        }), n.d(e, 'f', () => {
            return Se
        })
        let o; let a; let s; let u; let c; let l; let h; let f; let d; let p; let m; let y; let v; let _; let g; let b; let E; let x; let T; let S; let w; let O; let P; let R; let A; let I; let C; let k; var N = {
            autoSleep: 120,
            force3D: 'auto',
            nullTargetWarn: 1,
            units: {
                lineHeight: ''
            }
        }
        const M = {
            duration: 0.5,
            overwrite: !1,
            delay: 0
        }
        const j = 1e8
        const D = 2 * Math.PI
        const L = D / 4
        let F = 0
        const B = Math.sqrt
        const U = Math.cos
        const G = Math.sin
        var X = function (t) {
            return typeof t == 'string'
        }
        const H = function (t) {
            return typeof t == 'function'
        }
        const V = function (t) {
            return typeof t == 'number'
        }
        var W = function (t) {
            return void 0 === t
        }
        const Y = function (t) {
            return typeof t == 'object'
        }
        const z = function (t) {
            return !1 !== t
        }
        const q = function () {
            return typeof window != 'undefined'
        }
        const K = function (t) {
            return H(t) || X(t)
        }
        const Z = typeof ArrayBuffer == 'function' && ArrayBuffer.isView || function () {}
        const $ = Array.isArray
        const J = /(?:-?\.?\d|\.)+/g
        var Q = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g
        var tt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g
        const et = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi
        var nt = /[+-]=-?[.\d]+/
        const rt = /[#\-+.]*\b[a-z\d-=+%.]+/gi
        const it = /[\d.+\-=]+(?:e[-+]\d*)*/i
        const ot = {}
        let at = {}
        const st = function (t) {
            return (at = Nt(t, ot)) && yn
        }
        var ut = function (t, e) {
            return console.warn('Invalid property', t, 'set to', e, 'Missing plugin? gsap.registerPlugin()')
        }
        const ct = function (t, e) {
            return !e && console.warn(t)
        }
        const lt = function (t, e) {
            return t && (ot[t] = e) && at && (at[t] = e) || ot
        }
        const ht = function () {
            return 0
        }
        const ft = {}
        const dt = []
        let pt = {}
        var mt = {}
        const yt = {}
        let vt = 30
        const _t = []
        let gt = ''
        const bt = function (t) {
            let e; let n; const r = t[0]
            if (Y(r) || H(r) || (t = [t]), !(e = (r._gsap || {}).harness)) {
                for (n = _t.length; n-- && !_t[n].targetTest(r););
                e = _t[n]
            }
            for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new Ue(t[n], e))) || t.splice(n, 1)
            return t
        }
        var Et = function (t) {
            return t._gsap || bt(ae(t))[0]._gsap
        }
        var xt = function (t, e, n) {
            return (n = t[e]) && H(n) ? t[e]() : W(n) && t.getAttribute && t.getAttribute(e) || n
        }
        var Tt = function (t, e) {
            return (t = t.split(',')).forEach(e) || t
        }
        var St = function (t) {
            return Math.round(1e5 * t) / 1e5 || 0
        }
        const wt = function (t, e) {
            for (var n = e.length, r = 0; !t.includes(e[r]) && ++r < n;);
            return r < n
        }
        const Ot = function (t, e, n) {
            let r; const i = V(t[1])
            var o = (i ? 2 : 1) + (e < 2 ? 0 : 1)
            var a = t[o]
            if (i && (a.duration = t[1]), a.parent = n, e) {
                for (r = a; n && !('immediateRender' in r);) r = n.vars.defaults || {}, n = z(n.vars.inherit) && n.parent
                a.immediateRender = z(r.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[o - 1]
            }
            return a
        }
        const Pt = function () {
            let t; let e; const n = dt.length
            var r = dt.slice(0)
            for (pt = {}, dt.length = 0, t = 0; t < n; t++)(e = r[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
        }
        const Rt = function (t, e, n, r) {
            dt.length && Pt(), t.render(e, n, r), dt.length && Pt()
        }
        const At = function (t) {
            const e = Number.parseFloat(t)
            return (e || e === 0) && (`${t}`).match(rt).length < 2 ? e : X(t) ? t.trim() : t
        }
        const It = function (t) {
            return t
        }
        const Ct = function (t, e) {
            for (const n in e) n in t || (t[n] = e[n])
            return t
        }
        const kt = function (t, e) {
            for (const n in e) n in t || n === 'duration' || n === 'ease' || (t[n] = e[n])
        }
        var Nt = function (t, e) {
            for (const n in e) t[n] = e[n]
            return t
        }
        const Mt = function t(e, n) {
            for (const r in n) r !== '__proto__' && r !== 'constructor' && r !== 'prototype' && (e[r] = Y(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r])
            return e
        }
        const jt = function (t, e) {
            let n; const r = {}
            for (n in t) n in e || (r[n] = t[n])
            return r
        }
        const Dt = function (t) {
            let e = t.parent || a
            var n = t.keyframes ? kt : Ct
            if (z(t.inherit)) {
                for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp
            }
            return t
        }
        const Lt = function (t, e, n, r) {
            void 0 === n && (n = '_first'), void 0 === r && (r = '_last')
            let i = e._prev
            var o = e._next
            i ? i._next = o : t[n] === e && (t[n] = o), o ? o._prev = i : t[r] === e && (t[r] = i), e._next = e._prev = e.parent = null
        }
        const Ft = function (t, e) {
            t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
        }
        const Bt = function (t, e) {
            if (t && (!e || e._end > t._dur || e._start < 0)) {
                for (let n = t; n;) n._dirty = 1, n = n.parent
            }
            return t
        }
        const Ut = function (t) {
            for (let e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent
            return t
        }
        const Gt = function (t) {
            return t._repeat ? Xt(t._tTime, t = t.duration() + t._rDelay) * t : 0
        }
        var Xt = function (t, e) {
            const n = Math.floor(t /= e)
            return t && n === t ? n - 1 : n
        }
        const Ht = function (t, e) {
            return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        }
        const Vt = function (t) {
            return t._end = St(t._start + (t._tDur / Math.abs(t._ts || t._rts || 1e-8) || 0))
        }
        const Wt = function (t, e) {
            const n = t._dp
            return n && n.smoothChildTiming && t._ts && (t._start = St(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Vt(t), n._dirty || Bt(n, t)), t
        }
        const Yt = function (t, e) {
            let n
            if ((e._time || e._initted && !e._dur) && (n = Ht(t.rawTime(), e), (!e._dur || ee(0, e.totalDuration(), n) - e._tTime > 1e-8) && e.render(n, !0)), Bt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                if (t._dur < t.duration()) {
                    for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp
                }
                t._zTime = -1e-8
            }
        }
        const zt = function (t, e, n, r) {
            return e.parent && Ft(e), e._start = St(n + e._delay), e._end = St(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
            (function (t, e, n, r, i) {
                void 0 === n && (n = '_first'), void 0 === r && (r = '_last')
                var o; let a = t[r]
                if (i) {
                    for (o = e[i]; a && a[i] > o;) a = a._prev
}
                a ? (e._next = a._next, a._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = a, e.parent = e._dp = t
            }(t, e, '_first', '_last', t._sort ? '_start' : 0)), t._recent = e, r || Yt(t, e), t
        }
        const qt = function (t, e) {
            return (ot.ScrollTrigger || ut('scrollTrigger', e)) && ot.ScrollTrigger.create(e, t)
        }
        const Kt = function (t, e, n, r) {
            return ze(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && h !== Pe.frame ? (dt.push(t), t._lazy = [e, r], 1) : void 0 : 1
        }
        const Zt = function (t, e, n, r) {
            const i = t._repeat
            var o = St(e) || 0
            var a = t._tTime / t._tDur
            return a && !r && (t._time *= o / t._dur), t._dur = o, t._tDur = i ? i < 0 ? 1e10 : St(o * (i + 1) + t._rDelay * i) : o, a && !r ? Wt(t, t._tTime = t._tDur * a) : t.parent && Vt(t), n || Bt(t.parent, t), t
        }
        const $t = function (t) {
            return t instanceof Xe ? Bt(t) : Zt(t, t._dur)
        }
        const Jt = {
            _start: 0,
            endTime: ht
        }
        const Qt = function t(e, n) {
            let r; let i; const o = e.labels
            var a = e._recent || Jt
            var s = e.duration() >= j ? a.endTime(!1) : e._dur
            return X(n) && (isNaN(n) || n in o) ? (r = n.charAt(0)) === '<' || r === '>' ? (r === '<' ? a._start : a.endTime(a._repeat >= 0)) + (Number.parseFloat(n.substr(1)) || 0) : (r = n.indexOf('=')) < 0 ? (n in o || (o[n] = s), o[n]) : (i = +(n.charAt(r - 1) + n.substr(r + 1)), r > 1 ? t(e, n.substr(0, r - 1)) + i : s + i) : n == null ? s : +n
        }
        const te = function (t, e) {
            return t || t === 0 ? e(t) : e
        }
        var ee = function (t, e, n) {
            return n < t ? t : n > e ? e : n
        }
        var ne = function (t) {
            if (typeof t != 'string') return ''
            const e = it.exec(t)
            return e ? t.substr(e.index + e[0].length) : ''
        }
        const re = [].slice
        const ie = function (t, e) {
            return t && Y(t) && 'length' in t && (!e && !t.length || t.length - 1 in t && Y(t[0])) && !t.nodeType && t !== s
        }
        const oe = function (t, e, n) {
            return void 0 === n && (n = []), t.forEach((t) => {
                let r
                return X(t) && !e || ie(t, 1) ? (r = n).push.apply(r, ae(t)) : n.push(t)
            }) || n
        }
        var ae = function (t, e) {
            return !X(t) || e || !u && Re() ? $(t) ? oe(t, e) : ie(t) ? re.call(t, 0) : t ? [t] : [] : re.call(c.querySelectorAll(t), 0)
        }
        const se = function (t) {
            return t.sort(() => {
                return 0.5 - Math.random()
            })
        }
        const ue = function (t) {
            if (H(t)) return t
            let e = Y(t)
                ? t
                : {
                        each: t
                    }
            var n = je(e.ease)
            var r = e.from || 0
            var i = Number.parseFloat(e.base) || 0
            var o = {}
            var a = r > 0 && r < 1
            var s = isNaN(r) || a
            var u = e.axis
            var c = r
            var l = r
            return X(r)
                ? c = l = {
                    center: 0.5,
                    edges: 0.5,
                    end: 1
                }[r] || 0
                : !a && s && (c = r[0], l = r[1]),
            function (t, a, h) {
                let f; let d; let p; let m; let y; let v; let _; let g; let b; let E = (h || e).length
                var x = o[E]
                if (!x) {
                    if (!(b = e.grid === 'auto' ? 0 : (e.grid || [1, j])[1])) {
                        for (_ = -j; _ < (_ = h[b++].getBoundingClientRect().left) && b < E;);
                        b--
                    }
                    for (x = o[E] = [], f = s ? Math.min(b, E) * c - 0.5 : r % b, d = s ? E * l / b - 0.5 : r / b | 0, _ = 0, g = j, v = 0; v < E; v++) p = v % b - f, m = d - (v / b | 0), x[v] = y = u ? Math.abs(u === 'y' ? m : p) : B(p * p + m * m), y > _ && (_ = y), y < g && (g = y)
                    'random' === r && se(x), x.max = _ - g, x.min = g, x.v = E = (Number.parseFloat(e.amount) || Number.parseFloat(e.each) * (b > E ? E - 1 : u ? u === 'y' ? E / b : b : Math.max(b, E / b)) || 0) * (r === 'edges' ? -1 : 1), x.b = E < 0 ? i - E : i, x.u = ne(e.amount || e.each) || 0, n = n && E < 0 ? Ne(n) : n
                }
                return E = (x[t] - x.min) / x.max || 0, St(x.b + (n ? n(E) : E) * x.v) + x.u
            }
        }
        const ce = function (t) {
            const e = t < 1 ? 10 ** ((`${t  }`).length - 2) : 1
            return function (n) {
                const r = Math.round(Number.parseFloat(n) / t) * t * e
                return (r - r % 1) / e + (V(n) ? 0 : ne(n))
            }
        }
        const le = function (t, e) {
            let n; let r; let i = $(t)
            return !i && Y(t) && (n = i = t.radius || j, t.values ? (t = ae(t.values), (r = !V(t[0])) && (n *= n)) : t = ce(t.increment)), te(e, i
                ? H(t)
                    ? (e) => {
                            return r = t(e), Math.abs(r - e) <= n ? r : e
                        }
                    : (e) => {
                            for (var i, o, a = Number.parseFloat(r ? e.x : e), s = Number.parseFloat(r ? e.y : 0), u = j, c = 0, l = t.length; l--;)(i = r ? (i = t[l].x - a) * i + (o = t[l].y - s) * o : Math.abs(t[l] - a)) < u && (u = i, c = l)
                            return c = !n || u <= n ? t[c] : e, r || c === e || V(e) ? c : c + ne(e)
                        }
                : ce(t))
        }
        const he = function (t, e, n, r) {
            return te($(t) ? !e : !0 === n ? !!(n = 0) : !r, () => {
                return $(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? 10 ** ((`${n  }`).length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n) * n * r) / r
            })
        }
        const fe = function (t, e, n) {
            return te(n, (n) => {
                return t[~~e(n)]
            })
        }
        var de = function (t) {
            for (var e, n, r, i, o = 0, a = ''; ~(e = t.indexOf('random(', o));) r = t.indexOf(')', e), i = t.charAt(e + 7) === '[', n = t.substr(e + 7, r - e - 7).match(i ? rt : J), a += t.substr(o, e - o) + he(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5), o = r + 1
            return a + t.substr(o, t.length - o)
        }
        const pe = function (t, e, n, r, i) {
            const o = e - t
            var a = r - n
            return te(i, (e) => {
                return n + ((e - t) / o * a || 0)
            })
        }
        const me = function (t, e, n) {
            let r; let i; let o; const a = t.labels
            var s = j
            for (r in a)(i = a[r] - e) < 0 == !!n && i && s > (i = Math.abs(i)) && (o = r, s = i)
            return o
        }
        const ye = function (t, e, n) {
            let r; let i; const o = t.vars
            var a = o[e]
            if (a) return r = o[`${e}Params`], i = o.callbackScope || t, n && dt.length && Pt(), r ? a.apply(i, r) : a.call(i)
        }
        const ve = function (t) {
            return Ft(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && ye(t, 'onInterrupt'), t
        }
        const _e = function (t) {
            let e = (t = !t.name && t.default || t).name
            var n = H(t)
            var r = e && !n && t.init
                ? function () {
                    this._props = []
                }
                : t
            var i = {
                init: ht,
                render: sn,
                add: We,
                kill: cn,
                modifier: un,
                rawVars: 0
            }
            var o = {
                targetTest: 0,
                get: 0,
                getSetter: nn,
                aliases: {},
                register: 0
            }
            if (Re(), t !== r) {
                if (mt[e]) return
                Ct(r, Ct(jt(t, i), o)), Nt(r.prototype, Nt(i, jt(t, o))), mt[r.prop = e] = r, t.targetTest && (_t.push(r), ft[e] = 1), e = `${e === 'css' ? 'CSS' : e.charAt(0).toUpperCase() + e.substr(1)}Plugin`
            }
            lt(e, r), t.register && t.register(yn, r, fn)
        }
        const ge = {
            aqua: [0, 255, 255],
            lime: [0, 255, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, 255],
            navy: [0, 0, 128],
            white: [255, 255, 255],
            olive: [128, 128, 0],
            yellow: [255, 255, 0],
            orange: [255, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [255, 0, 0],
            pink: [255, 192, 203],
            cyan: [0, 255, 255],
            transparent: [255, 255, 255, 0]
        }
        const be = function (t, e, n) {
            return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < 0.5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + 0.5 | 0
        }
        const Ee = function (t, e, n) {
            let r; let i; let o; let a; let s; let u; let c; let l; let h; let f; let d = t ? V(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : ge.black
            if (!d) {
                if (t.substr(-1) === ',' && (t = t.substr(0, t.length - 1)), ge[t]) { d = ge[t]
                }
                else if (t.charAt(0) === '#') {
                    if (t.length < 6 && (r = t.charAt(1), i = t.charAt(2), o = t.charAt(3), t = `#${ r }${r }${i }${i }${o }${o }${t.length === 5 ? t.charAt(4) + t.charAt(4) : ''}`), t.length === 9) return [(d = Number.parseInt(t.substr(1, 6), 16)) >> 16, d >> 8 & 255, 255 & d, Number.parseInt(t.substr(7), 16) / 255]
                    d = [(t = Number.parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t]
                } else if (t.substr(0, 3) === 'hsl') {
                    if (d = f = t.match(J), e) {
                        if (~t.indexOf('=')) return d = t.match(Q), n && d.length < 4 && (d[3] = 1), d
                    } else { a = +d[0] % 360 / 360, s = +d[1] / 100, r = 2 * (u = +d[2] / 100) - (i = u <= 0.5 ? u * (s + 1) : u + s - u * s), d.length > 3 && (d[3] *= 1), d[0] = be(a + 1 / 3, r, i), d[1] = be(a, r, i), d[2] = be(a - 1 / 3, r, i)
}
                }
                else { d = t.match(J) || ge.transparent
                }
                d = d.map(Number)
            }
            return e && !f && (r = d[0] / 255, i = d[1] / 255, o = d[2] / 255, u = ((c = Math.max(r, i, o)) + (l = Math.min(r, i, o))) / 2, c === l ? a = s = 0 : (h = c - l, s = u > 0.5 ? h / (2 - c - l) : h / (c + l), a = c === r ? (i - o) / h + (i < o ? 6 : 0) : c === i ? (o - r) / h + 2 : (r - i) / h + 4, a *= 60), d[0] = ~~(a + 0.5), d[1] = ~~(100 * s + 0.5), d[2] = ~~(100 * u + 0.5)), n && d.length < 4 && (d[3] = 1), d
        }
        const xe = function (t) {
            const e = []
            var n = []
            var r = -1
            return t.split(Se).forEach((t) => {
                let i = t.match(tt) || []
                e.push.apply(e, i), n.push(r += i.length + 1)
            }), e.c = n, e
        }
        const Te = function (t, e, n) {
            let r; let i; let o; let a; let s = ''
            var u = (t + s).match(Se)
            var c = e ? 'hsla(' : 'rgba('
            var l = 0
            if (!u) return t
            if (u = u.map((t) => {
                return (t = Ee(t, e, 1)) && `${c + (e ? `${t[0]  },${  t[1]  }%,${  t[2]  }%,${  t[3]}` : t.join(',')) })`
            }), n && (o = xe(t), (r = n.c).join(s) !== o.c.join(s))) {
                for (a = (i = t.replace(Se, '1').split(tt)).length - 1; l < a; l++) s += i[l] + (~r.indexOf(l) ? u.shift() || `${c }0,0,0,0)` : (o.length ? o : u.length ? u : n).shift())
            }
            if (!i) {
                for (a = (i = t.split(Se)).length - 1; l < a; l++) s += i[l] + u[l]
            }
            return s + i[a]
        }
        var Se = (function () {
            let t; let e = '(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b'
            for (t in ge) e += `|${ t }\\b`;
            return new RegExp(`${e})`, 'gi')
        }())
        const we = /hsla?\(/
        var Oe = function (t) {
            let e; const n = t.join(' ')
            if (Se.lastIndex = 0, Se.test(n)) return e = we.test(n), t[1] = Te(t[1], e), t[0] = Te(t[0], e, xe(t[1])), !0
        }
        var Pe = (b = Date.now, E = 500, x = 33, T = b(), S = T, O = w = 1e3 / 240, R = function t(e) {
            let n; let r; let i; let o; const a = b() - S
            let s = !0 === e
            if (a > E && (T += a - x), ((n = (i = (S += a) - T) - O) > 0 || s) && (o = ++v.frame, _ = i - 1e3 * v.time, v.time = i /= 1e3, O += n + (n >= w ? 4 : w - n), r = 1), s || (p = m(t)), r) {
                for (g = 0; g < P.length; g++) P[g](i, _, o, e)
            }
        }, v = {
            time: 0,
            frame: 0,
            tick() {
                R(!0)
            },
            deltaRatio(t) {
                return _ / (1e3 / (t || 60))
            },
            wake() {
                l && (!u && q() && (s = u = window, c = s.document || {}, ot.gsap = yn, (s.gsapVersions || (s.gsapVersions = [])).push(yn.version), st(at || s.GreenSockGlobals || !s.gsap && s || {}), y = s.requestAnimationFrame), p && v.sleep(), m = y || function (t) {
                    return setTimeout(t, O - 1e3 * v.time + 1 | 0)
                }, d = 1, R(2))
            },
            sleep() {
                (y ? s.cancelAnimationFrame : clearTimeout)(p), d = 0, m = ht
            },
            lagSmoothing(t, e) {
                E = t || 1 / 1e-8, x = Math.min(e, E, 0)
            },
            fps(t) {
                w = 1e3 / (t || 240), O = 1e3 * v.time + w
            },
            add(t) {
                !P.includes(t) && P.push(t), Re()
            },
            remove(t) {
                let e
                ~(e = P.indexOf(t)) && P.splice(e, 1) && g >= e && g--
            },
            _listeners: P = []
        })
        var Re = function () {
            return !d && Pe.wake()
        }
        const Ae = {}
        const Ie = /^[\d.\-M][\d.\-,\s]/
        const Ce = /["']/g
        const ke = function (t) {
            for (var e, n, r, i = {}, o = t.substr(1, t.length - 3).split(':'), a = o[0], s = 1, u = o.length; s < u; s++) n = o[s], e = s !== u - 1 ? n.lastIndexOf(',') : n.length, r = n.substr(0, e), i[a] = isNaN(r) ? r.replace(Ce, '').trim() : +r, a = n.substr(e + 1).trim()
            return i
        }
        var Ne = function (t) {
            return function (e) {
                return 1 - t(1 - e)
            }
        }
        const Me = function t(e, n) {
            for (var r, i = e._first; i;) i instanceof Xe ? t(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? t(i.timeline, n) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = n)), i = i._next
        }
        var je = function (t, e) {
            return t && (H(t)
                ? t
                : Ae[t] || (function (t) {
                    let e; let n; let r; let i; const o = (`${t  }`).split('(');
                    let a = Ae[o[0]]
                    return a && o.length > 1 && a.config ? a.config.apply(null, ~t.indexOf('{') ? [ke(o[1])] : (e = t, n = e.indexOf('(') + 1, r = e.indexOf(')'), i = e.indexOf('(', n), e.substring(n, ~i && i < r ? e.indexOf(')', r + 1) : r)).split(',').map(At)) : Ae._CE && Ie.test(t) ? Ae._CE('', t) : a
                }(t))) || e
        }
        const De = function (t, e, n, r) {
            void 0 === n && (n = function (t) {
                return 1 - e(1 - t)
            }), void 0 === r && (r = function (t) {
                return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
            })
            let i; const o = {
                easeIn: e,
                easeOut: n,
                easeInOut: r
            }
            return Tt(t, (t) => {
                for (const e in Ae[t] = ot[t] = o, Ae[i = t.toLowerCase()] = n, o) Ae[i + (e === 'easeIn' ? '.in' : e === 'easeOut' ? '.out' : '.inOut')] = Ae[`${t }.${ e}`] = o[e]
            }), o
        }
        const Le = function (t) {
            return function (e) {
                return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2
            }
        }
        const Fe = function t(e, n, r) {
            const i = n >= 1 ? n : 1
            var o = (r || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1)
            var a = o / D * (Math.asin(1 / i) || 0)
            var s = function (t) {
                return t === 1 ? 1 : i * 2 ** (-10 * t) * G((t - a) * o) + 1
            }
            var u = e === 'out'
                ? s
                : e === 'in'
                    ? function (t) {
                        return 1 - s(1 - t)
                    }
                    : Le(s)
            return o = D / o, u.config = function (n, r) {
                return t(e, n, r)
            }, u
        }
        const Be = function t(e, n) {
            void 0 === n && (n = 1.70158)
            const r = function (t) {
                return t ? --t * t * ((n + 1) * t + n) + 1 : 0
            }
            let i = e === 'out'
                ? r
                : e === 'in'
                    ? function (t) {
                        return 1 - r(1 - t)
                    }
                    : Le(r)
            return i.config = function (n) {
                return t(e, n)
            }, i
        }
        Tt('Linear,Quad,Cubic,Quart,Quint,Strong', (t, e) => {
            const n = e < 5 ? e + 1 : e
            De(`${t},Power${n - 1}`, e
                ? (t) => {
                        return t ** n
                    }
                : (t) => {
                        return t
                    }, (t) => {
                return 1 - (1 - t) ** n
            }, (t) => {
                return t < 0.5 ? (2 * t) ** n / 2 : 1 - (2 * (1 - t)) ** n / 2
            })
        }), Ae.Linear.easeNone = Ae.none = Ae.Linear.easeIn, De('Elastic', Fe('in'), Fe('out'), Fe()), A = 7.5625, C = 1 / (I = 2.75), De('Bounce', (t) => {
            return 1 - k(1 - t)
        }, k = function (t) {
            return t < C ? A * t * t : t < 0.7272727272727273 ? A * (t - 1.5 / I) ** 2 + 0.75 : t < 0.9090909090909092 ? A * (t -= 2.25 / I) * t + 0.9375 : A * (t - 2.625 / I) ** 2 + 0.984375
        }), De('Expo', (t) => {
            return t ? 2 ** (10 * (t - 1)) : 0
        }), De('Circ', (t) => {
            return -(B(1 - t * t) - 1)
        }), De('Sine', (t) => {
            return t === 1 ? 1 : 1 - U(t * L)
        }), De('Back', Be('in'), Be('out'), Be()), Ae.SteppedEase = Ae.steps = ot.SteppedEase = {
            config(t, e) {
                void 0 === t && (t = 1)
                const n = 1 / t
                let r = t + (e ? 0 : 1)
                let i = e ? 1 : 0
                return function (t) {
                    return ((r * ee(0, 1 - 1e-8, t) | 0) + i) * n
                }
            }
        }, M.ease = Ae['quad.out'], Tt('onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt', (t) => {
            return gt += `${t},${t}Params,`
        })
        var Ue = function (t, e) {
            this.id = F++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : xt, this.set = e ? e.getSetter : nn
        }
        const Ge = (function () {
            function t(t, e) {
                const n = t.parent || a
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Zt(this, +t.duration, 1, 1), this.data = t.data, d || Pe.wake(), n && zt(n, this, e || e === 0 ? e : n._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
            }
            const e = t.prototype
            return e.delay = function (t) {
                return t || t === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
            }, e.duration = function (t) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }, e.totalDuration = function (t) {
                return arguments.length ? (this._dirty = 0, Zt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, e.totalTime = function (t, e) {
                if (Re(), !arguments.length) return this._tTime
                let n = this._dp
                if (n && n.smoothChildTiming && this._ts) {
                    for (Wt(this, t), !n._dp || n.parent || Yt(n, this); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && zt(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === 1e-8 || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), Rt(this, t, e)), this
            }, e.time = function (t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Gt(this)) % this._dur || (t ? this._dur : 0), e) : this._time
            }, e.totalProgress = function (t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }, e.progress = function (t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Gt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }, e.iteration = function (t, e) {
                const n = this.duration() + this._rDelay
                return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Xt(this._tTime, n) + 1 : 1
            }, e.timeScale = function (t) {
                if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts
                if (this._rts === t) return this
                let e = this.parent && this._ts ? Ht(this.parent._time, this) : this._tTime
                return this._rts = +t || 0, this._ts = this._ps || t === -1e-8 ? 0 : this._rts, Ut(this.totalTime(ee(-this._delay, this._tDur, e), !0))
            }, e.paused = function (t) {
                return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Re(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= 1e-8) && Math.abs(this._zTime) !== 1e-8))), this) : this._ps
            }, e.startTime = function (t) {
                if (arguments.length) {
                    this._start = t
                    let e = this.parent || this._dp
                    return e && (e._sort || !this.parent) && zt(e, this, t - this._delay), this
                }
                return this._start
            }, e.endTime = function (t) {
                return this._start + (z(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
            }, e.rawTime = function (t) {
                const e = this.parent || this._dp
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ht(e.rawTime(t), this) : this._tTime : this._tTime
            }, e.globalTime = function (t) {
                for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp
                return n
            }, e.repeat = function (t) {
                return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, $t(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
            }, e.repeatDelay = function (t) {
                return arguments.length ? (this._rDelay = t, $t(this)) : this._rDelay
            }, e.yoyo = function (t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, e.seek = function (t, e) {
                return this.totalTime(Qt(this, t), z(e))
            }, e.restart = function (t, e) {
                return this.play().totalTime(t ? -this._delay : 0, z(e))
            }, e.play = function (t, e) {
                return t != null && this.seek(t, e), this.reversed(!1).paused(!1)
            }, e.reverse = function (t, e) {
                return t != null && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, e.pause = function (t, e) {
                return t != null && this.seek(t, e), this.paused(!0)
            }, e.resume = function () {
                return this.paused(!1)
            }, e.reversed = function (t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
            }, e.invalidate = function () {
                return this._initted = this._act = 0, this._zTime = -1e-8, this
            }, e.isActive = function () {
                let t; const e = this.parent || this._dp
                var n = this._start
                return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - 1e-8))
            }, e.eventCallback = function (t, e, n) {
                const r = this.vars
                return arguments.length > 1 ? (e ? (r[t] = e, n && (r[`${t}Params`] = n), t === 'onUpdate' && (this._onUpdate = e)) : delete r[t], this) : r[t]
            }, e.then = function (t) {
                const e = this
                return new Promise((n) => {
                    let r = H(t) ? t : It
                                var i = function () {
                        var t = e.then
                        e.then = null, H(r) && (r = r(e)) && (r.then || r === e) && (e.then = t), n(r), e.then = t
                    };
                    e._initted && e.totalProgress() === 1 && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i
                })
            }, e.kill = function () {
                ve(this)
            }, t
        }())
        Ct(Ge.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        })
        var Xe = (function (t) {
            function e(e, n) {
                let i
                return void 0 === e && (e = {}), (i = t.call(this, e, n) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = z(e.sortChildren), i.parent && Yt(i.parent, r(i)), e.scrollTrigger && qt(r(i), e.scrollTrigger), i
            }
            i(e, t)
            const n = e.prototype
            return n.to = function (t, e, n) {
                return new $e(t, Ot(arguments, 0, this), Qt(this, V(e) ? arguments[3] : n)), this
            }, n.from = function (t, e, n) {
                return new $e(t, Ot(arguments, 1, this), Qt(this, V(e) ? arguments[3] : n)), this
            }, n.fromTo = function (t, e, n, r) {
                return new $e(t, Ot(arguments, 2, this), Qt(this, V(e) ? arguments[4] : r)), this
            }, n.set = function (t, e, n) {
                return e.duration = 0, e.parent = this, Dt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new $e(t, e, Qt(this, n), 1), this
            }, n.call = function (t, e, n) {
                return zt(this, $e.delayedCall(0, t, e), Qt(this, n))
            }, n.staggerTo = function (t, e, n, r, i, o, a) {
                return n.duration = e, n.stagger = n.stagger || r, n.onComplete = o, n.onCompleteParams = a, n.parent = this, new $e(t, n, Qt(this, i)), this
            }, n.staggerFrom = function (t, e, n, r, i, o, a) {
                return n.runBackwards = 1, Dt(n).immediateRender = z(n.immediateRender), this.staggerTo(t, e, n, r, i, o, a)
            }, n.staggerFromTo = function (t, e, n, r, i, o, a, s) {
                return r.startAt = n, Dt(r).immediateRender = z(r.immediateRender), this.staggerTo(t, e, r, i, o, a, s)
            }, n.render = function (t, e, n) {
                let r; let i; let o; let s; let u; let c; let l; let h; let f; let d; let p; let m; let y = this._time
                let v = this._dirty ? this.totalDuration() : this._tDur
                let _ = this._dur
                let g = this !== a && t > v - 1e-8 && t >= 0 ? v : t < 1e-8 ? 0 : t
                let b = this._zTime < 0 != t < 0 && (this._initted || !_)
                if (g !== this._tTime || n || b) {
                    if (y !== this._time && _ && (g += this._time - y, t += this._time - y), r = g, f = this._start, c = !(h = this._ts), b && (_ || (y = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                        if (p = this._yoyo, u = _ + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * u + t, e, n)
                        if (r = St(g % u), g === v ? (s = this._repeat, r = _) : ((s = ~~(g / u)) && s === g / u && (r = _, s--), r > _ && (r = _)), d = Xt(this._tTime, u), !y && this._tTime && d !== s && (d = s), p && 1 & s && (r = _ - r, m = 1), s !== d && !this._lock) {
                            let E = p && 1 & d
                            let x = E === (p && 1 & s)
                            if (s < d && (E = !E), y = E ? 0 : _, this._lock = 1, this.render(y || (m ? 0 : St(s * u)), e, !_)._lock = 0, !e && this.parent && ye(this, 'onRepeat'), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), y && y !== this._time || c !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this
                            if (_ = this._dur, v = this._tDur, x && (this._lock = 2, y = E ? _ : -1e-4, this.render(y, !0)), this._lock = 0, !this._ts && !c) return this
                            Me(this, m)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (l = (function (t, e, n) {
                        let r
                        if (n > e) {
                            for (r = t._first; r && r._start <= n;) {
                                if (!r._dur && r.data === 'isPause' && r._start > e) return r
                                r = r._next
                            }
                        } else {
                            for (r = t._last; r && r._start >= n;) {
                                if (!r._dur && r.data === 'isPause' && r._start < e) return r
                                r = r._prev
                            }
                        }
                    }(this, St(y), St(r)))) && (g -= r - (r = l._start)), this._tTime = g, this._time = r, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, y = 0), !y && r && !e && ye(this, 'onStart'), r >= y && t >= 0) {
                        for (i = this._first; i;) {
                            if (o = i._next, (i._act || r >= i._start) && i._ts && l !== i) {
                                if (i.parent !== this) return this.render(t, e, n)
                                if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, e, n), r !== this._time || !this._ts && !c) {
                                    l = 0, o && (g += this._zTime = -1e-8)
                                    break
                                }
                            }
                            i = o
                        }
                    } else {
                        i = this._last
                        for (let T = t < 0 ? t : r; i;) {
                            if (o = i._prev, (i._act || T <= i._end) && i._ts && l !== i) {
                                if (i.parent !== this) return this.render(t, e, n)
                                if (i.render(i._ts > 0 ? (T - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (T - i._start) * i._ts, e, n), r !== this._time || !this._ts && !c) {
                                    l = 0, o && (g += this._zTime = T ? -1e-8 : 1e-8)
                                    break
                                }
                            }
                            i = o
                        }
                    }
                    if (l && !e && (this.pause(), l.render(r >= y ? 0 : -1e-8)._zTime = r >= y ? 1 : -1, this._ts)) return this._start = f, Vt(this), this.render(t, e, n)
                    this._onUpdate && !e && ye(this, 'onUpdate', !0), (g === v && v >= this.totalDuration() || !g && y) && (f !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((t || !_) && (g === v && this._ts > 0 || !g && this._ts < 0) && Ft(this, 1), e || t < 0 && !y || !g && !y || (ye(this, g === v ? 'onComplete' : 'onReverseComplete', !0), this._prom && !(g < v && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function (t, e) {
                const n = this
                if (V(e) || (e = Qt(this, e)), !(t instanceof Ge)) {
                    if ($(t)) { return t.forEach((t) => {
                        return n.add(t, e)
                    }), this
                    }
                    if (X(t)) return this.addLabel(t, e)
                    if (!H(t)) return this
                    t = $e.delayedCall(0, t)
                }
                return this !== t ? zt(this, t, e) : this
            }, n.getChildren = function (t, e, n, r) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -j)
                for (var i = [], o = this._first; o;) o._start >= r && (o instanceof $e ? e && i.push(o) : (n && i.push(o), t && i.push.apply(i, o.getChildren(!0, e, n)))), o = o._next
                return i
            }, n.getById = function (t) {
                for (let e = this.getChildren(1, 1, 1), n = e.length; n--;) {
                    if (e[n].vars.id === t) return e[n]
                }
            }, n.remove = function (t) {
                return X(t) ? this.removeLabel(t) : H(t) ? this.killTweensOf(t) : (Lt(this, t), t === this._recent && (this._recent = this._last), Bt(this))
            }, n.totalTime = function (e, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = St(Pe.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function (t, e) {
                return this.labels[t] = Qt(this, e), this
            }, n.removeLabel = function (t) {
                return delete this.labels[t], this
            }, n.addPause = function (t, e, n) {
                const r = $e.delayedCall(0, e || ht, n)
                return r.data = 'isPause', this._hasPause = 1, zt(this, r, Qt(this, t))
            }, n.removePause = function (t) {
                let e = this._first
                for (t = Qt(this, t); e;) e._start === t && e.data === 'isPause' && Ft(e), e = e._next
            }, n.killTweensOf = function (t, e, n) {
                for (let r = this.getTweensOf(t, n), i = r.length; i--;) He !== r[i] && r[i].kill(t, e)
                return this
            }, n.getTweensOf = function (t, e) {
                for (var n, r = [], i = ae(t), o = this._first, a = V(e); o;) o instanceof $e ? wt(o._targets, i) && (a ? (!He || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && r.push(o) : (n = o.getTweensOf(i, e)).length && r.push.apply(r, n), o = o._next
                return r
            }, n.tweenTo = function (t, e) {
                e = e || {}
                const n = this
                let r = Qt(n, t)
                let i = e
                let o = i.startAt
                let a = i.onStart
                let s = i.onStartParams
                let u = i.immediateRender
                var c = $e.to(n, Ct({
                    ease: e.ease || 'none',
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: 'auto',
                    duration: e.duration || Math.abs((r - (o && 'time' in o ? o.time : n._time)) / n.timeScale()) || 1e-8,
                    onStart() {
                        n.pause()
                        let t = e.duration || Math.abs((r - n._time) / n.timeScale())
                        c._dur !== t && Zt(c, t, 0, 1).render(c._time, !0, !0), a && a.apply(c, s || [])
                    }
                }, e))
                return u ? c.render(0) : c
            }, n.tweenFromTo = function (t, e, n) {
                return this.tweenTo(e, Ct({
                    startAt: {
                        time: Qt(this, t)
                    }
                }, n))
            }, n.recent = function () {
                return this._recent
            }, n.nextLabel = function (t) {
                return void 0 === t && (t = this._time), me(this, Qt(this, t))
            }, n.previousLabel = function (t) {
                return void 0 === t && (t = this._time), me(this, Qt(this, t), 1)
            }, n.currentLabel = function (t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + 1e-8)
            }, n.shiftChildren = function (t, e, n) {
                void 0 === n && (n = 0)
                for (var r, i = this._first, o = this.labels; i;) i._start >= n && (i._start += t, i._end += t), i = i._next
                if (e) {
                    for (r in o) o[r] >= n && (o[r] += t)
                }
                return Bt(this)
            }, n.invalidate = function () {
                let e = this._first
                for (this._lock = 0; e;) e.invalidate(), e = e._next
                return t.prototype.invalidate.call(this)
            }, n.clear = function (t) {
                void 0 === t && (t = !0)
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e
                return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Bt(this)
            }, n.totalDuration = function (t) {
                let e; let n; let r; let i = 0
                let o = this
                let s = o._last
                let u = j
                if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t))
                if (o._dirty) {
                    for (r = o.parent; s;) e = s._prev, s._dirty && s.totalDuration(), (n = s._start) > u && o._sort && s._ts && !o._lock ? (o._lock = 1, zt(o, s, n - s._delay, 1)._lock = 0) : u = n, n < 0 && s._ts && (i -= n, (!r && !o._dp || r && r.smoothChildTiming) && (o._start += n / o._ts, o._time -= n, o._tTime -= n), o.shiftChildren(-n, !1, -Infinity), u = 0), s._end > i && s._ts && (i = s._end), s = e
                    Zt(o, o === a && o._time > i ? o._time : i, 1, 1), o._dirty = 0
                }
                return o._tDur
            }, e.updateRoot = function (t) {
                if (a._ts && (Rt(a, Ht(t, a)), h = Pe.frame), Pe.frame >= vt) {
                    vt += N.autoSleep || 120
                    let e = a._first
                    if ((!e || !e._ts) && N.autoSleep && Pe._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next
                        e || Pe.sleep()
                    }
                }
            }, e
        }(Ge))
        Ct(Xe.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        })
        let He; const Ve = function (t, e, n, r, i, o, a) {
            let s; let u; let c; let l; let h; let f; let d; let p; const m = new fn(this._pt, t, e, 0, 1, an, null, i)
            var y = 0
            var v = 0
            for (m.b = n, m.e = r, n += '', (d = ~(r += '').indexOf('random(')) && (r = de(r)), o && (o(p = [n, r], t, e), n = p[0], r = p[1]), u = n.match(et) || []; s = et.exec(r);) { l = s[0], h = r.substring(y, s.index), c ? c = (c + 1) % 5 : h.substr(-5) === 'rgba(' && (c = 1), l !== u[v++] && (f = Number.parseFloat(u[v - 1]) || 0, m._pt = {
                _next: m._pt,
                p: h || v === 1 ? h : ',',
                s: f,
                c: l.charAt(1) === '=' ? Number.parseFloat(l.substr(2)) * (l.charAt(0) === '-' ? -1 : 1) : Number.parseFloat(l) - f,
                m: c && c < 4 ? Math.round : 0
            }, y = et.lastIndex)
            }
            return m.c = y < r.length ? r.substring(y, r.length) : '', m.fp = a, (nt.test(r) || d) && (m.e = 0), this._pt = m, m
        }
        var We = function (t, e, n, r, i, o, a, s, u) {
            H(r) && (r = r(i || 0, t, o))
            let c; const l = t[e]
            let h = n !== 'get' ? n : H(l) ? u ? t[e.indexOf('set') || !H(t[`get${ e.substr(3)}`]) ? e : `get${ e.substr(3)}`](u) : t[e]() : l
            let f = H(l) ? u ? tn : Qe : Je
            if (X(r) && (~r.indexOf('random(') && (r = de(r)), r.charAt(1) === '=' && (r = Number.parseFloat(h) + Number.parseFloat(r.substr(2)) * (r.charAt(0) === '-' ? -1 : 1) + (ne(h) || 0))), h !== r) return isNaN(h * r) ? (!l && !(e in t) && ut(e, r), Ve.call(this, t, e, h, r, f, s || N.stringFilter, u)) : (c = new fn(this._pt, t, e, +h || 0, r - (h || 0), typeof l == 'boolean' ? on : rn, 0, f), u && (c.fp = u), a && c.modifier(a, this, t), this._pt = c)
        }
        var Ye = function (t, e, n, r, i, o) {
            let a, s, u, c
            if (mt[t] && !1 !== (a = new mt[t]()).init(i, a.rawVars
                ? e[t]
                : (function (t, e, n, r, i) {
                        if (H(t) && (t = qe(t, i, e, n, r)), !Y(t) || t.style && t.nodeType || $(t) || Z(t)) return X(t) ? qe(t, i, e, n, r) : t
                        let o; const a = {}
                        for (o in t) a[o] = qe(t[o], i, e, n, r)
                        return a
                    }(e[t], r, i, o, n)), n, r, o) && (n._pt = s = new fn(n._pt, i, t, 0, 1, a.render, a, 0, a.priority), n !== f)) {
                for (u = n._ptLookup[n._targets.indexOf(i)], c = a._props.length; c--;) u[a._props[c]] = s
            }
            return a
        }
        var ze = function t(e, n) {
            let r; let i; let s; let u; let c; let l; let h; let f; let d; let p; let m; let y; let v; const _ = e.vars
            let g = _.ease
            let b = _.startAt
            let E = _.immediateRender
            let x = _.lazy
            let T = _.onUpdate
            let S = _.onUpdateParams
            let w = _.callbackScope
            let O = _.runBackwards
            let P = _.yoyoEase
            let R = _.keyframes
            let A = _.autoRevert
            let I = e._dur
            let C = e._startAt
            let k = e._targets
            let N = e.parent
            let j = N && N.data === 'nested' ? N.parent._targets : k
            let D = e._overwrite === 'auto' && !o
            let L = e.timeline
            if (L && (!R || !g) && (g = 'none'), e._ease = je(g, M.ease), e._yEase = P ? Ne(je(!0 === P ? g : P, M.ease)) : 0, P && e._yoyo && !e._repeat && (P = e._yEase, e._yEase = e._ease, e._ease = P), !L) {
                if (y = (f = k[0] ? Et(k[0]).harness : 0) && _[f.prop], r = jt(_, ft), C && C.render(-1, !0).kill(), b) {
                    if (Ft(e._startAt = $e.set(k, Ct({
                        data: 'isStart',
                        overwrite: !1,
                        parent: N,
                        immediateRender: !0,
                        lazy: z(x),
                        startAt: null,
                        delay: 0,
                        onUpdate: T,
                        onUpdateParams: S,
                        callbackScope: w,
                        stagger: 0
                    }, b))), E) {
                        if (n > 0) A || (e._startAt = 0)
                        else if (I && !(n < 0 && C)) return void (n && (e._zTime = n))
                    } else { !1 === A && (e._startAt = 0)
                    }
                }
                else if (O && I) {
                    if (C) { !A && (e._startAt = 0)
                    }
                    else if (n && (E = !1), s = Ct({
                        overwrite: !1,
                        data: 'isFromStart',
                        lazy: E && z(x),
                        immediateRender: E,
                        stagger: 0,
                        parent: N
                    }, r), y && (s[f.prop] = y), Ft(e._startAt = $e.set(k, s)), E) {
                        if (!n) return
                    } else { t(e._startAt, 1e-8)
                    }
                }
                for (e._pt = 0, x = I && z(x) || x && !I, i = 0; i < k.length; i++) {
                    if (h = (c = k[i])._gsap || bt(k)[i]._gsap, e._ptLookup[i] = p = {}, pt[h.id] && dt.length && Pt(), m = j === k ? i : j.indexOf(c), f && !1 !== (d = new f()).init(c, y || r, e, m, j) && (e._pt = u = new fn(e._pt, c, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((t) => {
                        p[t] = u
                    }), d.priority && (l = 1)), !f || y) {
                        for (s in r) mt[s] && (d = Ye(s, r, e, m, c, j)) ? d.priority && (l = 1) : p[s] = u = We.call(e, c, s, 'get', r[s], m, j, 0, _.stringFilter)
                    }
                    e._op && e._op[i] && e.kill(c, e._op[i]), D && e._pt && (He = e, a.killTweensOf(c, p, e.globalTime(0)), v = !e.parent, He = 0), e._pt && x && (pt[h.id] = 1)
                }
                l && hn(e), e._onInit && e._onInit(e)
            }
            e._from = !L && !!_.runBackwards, e._onUpdate = T, e._initted = (!e._op || e._pt) && !v
        }
        var qe = function (t, e, n, r, i) {
            return H(t) ? t.call(e, n, r, i) : X(t) && ~t.indexOf('random(') ? de(t) : t
        }
        const Ke = `${gt}repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase`;
        const Ze = (`${Ke},id,stagger,delay,duration,paused,scrollTrigger`).split(',')
        var $e = (function (t) {
            function e(e, n, i, s) {
                let u
                typeof n == 'number' && (i.duration = n, n = i, i = null)
                let c; let l; let h; let f; let d; let p; let m; let y; const v = (u = t.call(this, s ? n : Dt(n), i) || this).vars
                let _ = v.duration
                let g = v.delay
                let b = v.immediateRender
                let E = v.stagger
                let x = v.overwrite
                let T = v.keyframes
                let S = v.defaults
                let w = v.scrollTrigger
                let O = v.yoyoEase
                let P = u.parent
                let R = ($(e) || Z(e) ? V(e[0]) : 'length' in n) ? [e] : ae(e)
                if (u._targets = R.length ? bt(R) : ct(`GSAP target ${e} not found. https://greensock.com`, !N.nullTargetWarn) || [], u._ptLookup = [], u._overwrite = x, T || E || K(_) || K(g)) {
                    if (n = u.vars, (c = u.timeline = new Xe({
                        data: 'nested',
                        defaults: S || {}
                    })).kill(), c.parent = c._dp = r(u), c._start = 0, T) { Ct(c.vars.defaults, {
                        ease: 'none'
                    }), T.forEach((t) => {
                        return c.to(R, t, '>')
                    })
                    }
                    else {
                        if (f = R.length, m = E ? ue(E) : ht, Y(E)) {
                            for (d in E) ~Ke.indexOf(d) && (y || (y = {}), y[d] = E[d])
                        }
                        for (l = 0; l < f; l++) {
                            for (d in h = {}, n) !Ze.includes(d) && (h[d] = n[d])
                            h.stagger = 0, O && (h.yoyoEase = O), y && Nt(h, y), p = R[l], h.duration = +qe(_, r(u), l, p, R), h.delay = (+qe(g, r(u), l, p, R) || 0) - u._delay, !E && f === 1 && h.delay && (u._delay = g = h.delay, u._start += g, h.delay = 0), c.to(p, h, m(l, p, R))
                        }
                        c.duration() ? _ = g = 0 : u.timeline = 0
                    }
                    _ || u.duration(_ = c.duration())
                } else { u.timeline = 0
                }
                return !0 !== x || o || (He = r(u), a.killTweensOf(R), He = 0), P && Yt(P, r(u)), (b || !_ && !T && u._start === St(P._time) && z(b) && (function t(e) {
                    return !e || e._ts && t(e.parent)
                }(r(u))) && P.data !== 'nested') && (u._tTime = -1e-8, u.render(Math.max(0, -g))), w && qt(r(u), w), u
            }
            i(e, t)
            const n = e.prototype
            return n.render = function (t, e, n) {
                let r; let i; let o; let a; let s; let u; let c; let l; let h; const f = this._time
                let d = this._tDur
                let p = this._dur
                let m = t > d - 1e-8 && t >= 0 ? d : t < 1e-8 ? 0 : t
                if (p) {
                    if (m !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                        if (r = m, l = this.timeline, this._repeat) {
                            if (a = p + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * a + t, e, n)
                            if (r = St(m % a), m === d ? (o = this._repeat, r = p) : ((o = ~~(m / a)) && o === m / a && (r = p, o--), r > p && (r = p)), (u = this._yoyo && 1 & o) && (h = this._yEase, r = p - r), s = Xt(this._tTime, a), r === f && !n && this._initted) return this
                            o !== s && (l && this._yEase && Me(l, u), !this.vars.repeatRefresh || u || this._lock || (this._lock = n = 1, this.render(St(a * o), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (Kt(this, t < 0 ? t : r, n, e)) return this._tTime = 0, this
                            if (p !== this._dur) return this.render(t, e, n)
                        }
                        for (this._tTime = m, this._time = r, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(r / p), this._from && (this.ratio = c = 1 - c), r && !f && !e && ye(this, 'onStart'), i = this._pt; i;) i.r(c, i.d), i = i._next
                        l && l.render(t < 0 ? t : !r && u ? -1e-8 : l._dur * c, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), ye(this, 'onUpdate')), this._repeat && o !== s && this.vars.onRepeat && !e && this.parent && ye(this, 'onRepeat'), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !p) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && Ft(this, 1), e || t < 0 && !f || !m && !f || (ye(this, m === d ? 'onComplete' : 'onReverseComplete', !0), this._prom && !(m < d && this.timeScale() > 0) && this._prom()))
                    }
                } else { !(function (t, e, n, r) {
                    let i; let o; let a; let s = t.ratio
                                var u = e < 0 || !e && (!t._start && (function t(e) {
                                    var n = e.parent;
                                    return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
                                }(t)) || (t._ts < 0 || t._dp._ts < 0) && 'isFromStart' !== t.data && 'isStart' !== t.data)
? 0
: 1
                                var c = t._rDelay
                                var l = 0
                    if (c && t._repeat && (l = ee(0, t._tDur, e), o = Xt(l, c), a = Xt(t._tTime, c), t._yoyo && 1 & o && (u = 1 - u), o !== a && (s = 1 - u, t.vars.repeatRefresh && t._initted && t.invalidate())), u !== s || r || t._zTime === 1e-8 || !e && t._zTime) {
                        if (!t._initted && Kt(t, e, r, n)) return
                        for (a = t._zTime, t._zTime = e || (n ? 1e-8 : 0), n || (n = e && !a), t.ratio = u, t._from && (u = 1 - u), t._time = 0, t._tTime = l, i = t._pt; i;) i.r(u, i.d), i = i._next
                        t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && ye(t, 'onUpdate'), l && t._repeat && !n && t.parent && ye(t, 'onRepeat'), (e >= t._tDur || e < 0) && t.ratio === u && (u && Ft(t, 1), n || (ye(t, u ? 'onComplete' : 'onReverseComplete', !0), t._prom && t._prom()))
                    } else { t._zTime || (t._zTime = e)
                    }
                }(this, t, e, n))
                }
                return this
            }, n.targets = function () {
                return this._targets
            }, n.invalidate = function () {
                return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
            }, n.kill = function (t, e) {
                if (void 0 === e && (e = 'all'), !(t || e && e !== 'all')) return this._lazy = this._pt = 0, this.parent ? ve(this) : this
                if (this.timeline) {
                    const n = this.timeline.totalDuration()
                    return this.timeline.killTweensOf(t, e, He && !0 !== He.vars.overwrite)._first || ve(this), this.parent && n !== this.timeline.totalDuration() && Zt(this, this._dur * this.timeline._tDur / n, 0, 1), this
                }
                let r; let i; let o; let a; let s; let u; let c; const l = this._targets
                let h = t ? ae(t) : l
                let f = this._ptLookup
                let d = this._pt
                if ((!e || e === 'all') && (function (t, e) {
                    for (var n = t.length, r = n === e.length; r && n-- && t[n] === e[n];);
                    return n < 0
                }(l, h))) { return e === 'all' && (this._pt = 0), ve(this)
                }
                for (r = this._op = this._op || [], e !== 'all' && (X(e) && (s = {}, Tt(e, (t) => {
                    return s[t] = 1
                }), e = s), e = (function (t, e) {
                    let n; let r; let i; let o; const a = t[0] ? Et(t[0]).harness : 0
                    var s = a && a.aliases
                    if (!s) return e
                    for (r in n = Nt({}, e), s) {
                        if (r in n) {
                            for (i = (o = s[r].split(',')).length; i--;) n[o[i]] = n[r]
}
                    }
                    return n
                }(l, e))), c = l.length; c--;) {
                    if (~h.indexOf(l[c])) {
                        for (s in i = f[c], e === 'all' ? (r[c] = e, a = i, o = {}) : (o = r[c] = r[c] || {}, a = e), a)(u = i && i[s]) && ('kill' in u.d && !0 !== u.d.kill(s) || Lt(this, u, '_pt'), delete i[s]), o !== 'all' && (o[s] = 1)
                    }
                }
                return this._initted && !this._pt && d && ve(this), this
            }, e.to = function (t, n) {
                return new e(t, n, arguments[2])
            }, e.from = function (t, n) {
                return new e(t, Ot(arguments, 1))
            }, e.delayedCall = function (t, n, r, i) {
                return new e(n, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: n,
                    onReverseComplete: n,
                    onCompleteParams: r,
                    onReverseCompleteParams: r,
                    callbackScope: i
                })
            }, e.fromTo = function (t, n, r) {
                return new e(t, Ot(arguments, 2))
            }, e.set = function (t, n) {
                return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
            }, e.killTweensOf = function (t, e, n) {
                return a.killTweensOf(t, e, n)
            }, e
        }(Ge))
        Ct($e.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), Tt('staggerTo,staggerFrom,staggerFromTo', (t) => {
            $e[t] = function () {
                const e = new Xe()
                var n = re.call(arguments, 0)
                return n.splice(t === 'staggerFromTo' ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        })
        var Je = function (t, e, n) {
            return t[e] = n
        }
        var Qe = function (t, e, n) {
            return t[e](n)
        }
        var tn = function (t, e, n, r) {
            return t[e](r.fp, n)
        }
        const en = function (t, e, n) {
            return t.setAttribute(e, n)
        }
        var nn = function (t, e) {
            return H(t[e]) ? Qe : W(t[e]) && t.setAttribute ? en : Je
        }
        var rn = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
        }
        var on = function (t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        }
        var an = function (t, e) {
            let n = e._pt
            let r = ''
            if (!t && e.b) { r = e.b
            }
            else if (t === 1 && e.e) { r = e.e
            }
            else {
                for (; n;) r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + r, n = n._next
                r += e.c
            }
            e.set(e.t, e.p, r, e)
        }
        var sn = function (t, e) {
            for (let n = e._pt; n;) n.r(t, n.d), n = n._next
        }
        var un = function (t, e, n, r) {
            for (var i, o = this._pt; o;) i = o._next, o.p === r && o.modifier(t, e, n), o = i
        }
        var cn = function (t) {
            for (var e, n, r = this._pt; r;) n = r._next, r.p === t && !r.op || r.op === t ? Lt(this, r, '_pt') : r.dep || (e = 1), r = n
            return !e
        }
        const ln = function (t, e, n, r) {
            r.mSet(t, e, r.m.call(r.tween, n, r.mt), r)
        }
        var hn = function (t) {
            for (var e, n, r, i, o = t._pt; o;) {
                for (e = o._next, n = r; n && n.pr > o.pr;) n = n._next;
                (o._prev = n ? n._prev : i) ? o._prev._next = o : r = o, (o._next = n) ? n._prev = o : i = o, o = e
            }
            t._pt = r
        }
        var fn = (function () {
            function t(t, e, n, r, i, o, a, s, u) {
                this.t = e, this.s = r, this.c = i, this.p = n, this.r = o || rn, this.d = a || this, this.set = s || Je, this.pr = u || 0, this._next = t, t && (t._prev = this)
            }
            return t.prototype.modifier = function (t, e, n) {
                this.mSet = this.mSet || this.set, this.set = ln, this.m = t, this.mt = n, this.tween = e
            }, t
        }())
        Tt(`${gt}parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger`, (t) => {
            return ft[t] = 1
        }), ot.TweenMax = ot.TweenLite = $e, ot.TimelineLite = ot.TimelineMax = Xe, a = new Xe({
            sortChildren: !1,
            defaults: M,
            autoRemoveChildren: !0,
            id: 'root',
            smoothChildTiming: !0
        }), N.stringFilter = Oe
        const dn = {
            registerPlugin() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
                e.forEach((t) => {
                    return _e(t)
                })
            },
            timeline(t) {
                return new Xe(t)
            },
            getTweensOf(t, e) {
                return a.getTweensOf(t, e)
            },
            getProperty(t, e, n, r) {
                X(t) && (t = ae(t)[0])
                let i = Et(t || {}).get
                var o = n ? It : At
                return n === 'native' && (n = ''), t
                    ? e
                        ? o((mt[e] && mt[e].get || i)(t, e, n, r))
                        : function (e, n, r) {
                            return o((mt[e] && mt[e].get || i)(t, e, n, r))
                        }
                    : t
            },
            quickSetter(t, e, n) {
                if ((t = ae(t)).length > 1) {
                    const r = t.map((t) => {
                        return yn.quickSetter(t, e, n)
                    })
                    var i = r.length
                    return function (t) {
                        for (let e = i; e--;) r[e](t)
                    }
                }
                t = t[0] || {}
                let o = mt[e]
                var a = Et(t)
                var s = a.harness && (a.harness.aliases || {})[e] || e
                var u = o
                    ? function (e) {
                        const r = new o()
                        f._pt = 0, r.init(t, n ? e + n : e, f, 0, [t]), r.render(1, r), f._pt && sn(1, f)
                    }
                    : a.set(t, s)
                return o
                    ? u
                    : function (e) {
                        return u(t, s, n ? e + n : e, a, 1)
                    }
            },
            isTweening(t) {
                return a.getTweensOf(t, !0).length > 0
            },
            defaults(t) {
                return t && t.ease && (t.ease = je(t.ease, M.ease)), Mt(M, t || {})
            },
            config(t) {
                return Mt(N, t || {})
            },
            registerEffect(t) {
                const e = t.name
                var n = t.effect
                var r = t.plugins
                var i = t.defaults
                var o = t.extendTimeline;
                (r || '').split(',').forEach((t) => {
                    return t && !mt[t] && !ot[t] && ct(`${e } effect requires ${ t } plugin.`)
                }), yt[e] = function (t, e, r) {
                    return n(ae(t), Ct(e || {}, i), r)
                }, o && (Xe.prototype[e] = function (t, n, r) {
                    return this.add(yt[e](t, Y(n) ? n : (r = n) && {}, this), r)
                })
            },
            registerEase(t, e) {
                Ae[t] = je(e)
            },
            parseEase(t, e) {
                return arguments.length ? je(t, e) : Ae
            },
            getById(t) {
                return a.getById(t)
            },
            exportRoot(t, e) {
                void 0 === t && (t = {})
                let n; let r; const i = new Xe(t)
                for (i.smoothChildTiming = z(t.smoothChildTiming), a.remove(i), i._dp = 0, i._time = i._tTime = a._time, n = a._first; n;) r = n._next, !e && !n._dur && n instanceof $e && n.vars.onComplete === n._targets[0] || zt(i, n, n._start - n._delay), n = r
                return zt(a, i, 0), i
            },
            utils: {
                wrap: function t(e, n, r) {
                    const i = n - e
                    return $(e)
                        ? fe(e, t(0, e.length), n)
                        : te(r, (t) => {
                                return (i + (t - e) % i) % i + e
                            })
                },
                wrapYoyo: function t(e, n, r) {
                    const i = n - e
                    let o = 2 * i
                    return $(e)
                        ? fe(e, t(0, e.length - 1), n)
                        : te(r, (t) => {
                                return e + ((t = (o + (t - e) % o) % o || 0) > i ? o - t : t)
                            })
                },
                distribute: ue,
                random: he,
                snap: le,
                normalize(t, e, n) {
                    return pe(t, e, 0, 1, n)
                },
                getUnit: ne,
                clamp(t, e, n) {
                    return te(n, (n) => {
                        return ee(t, e, n)
                    })
                },
                splitColor: Ee,
                toArray: ae,
                mapRange: pe,
                pipe() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
                    return function (t) {
                        return e.reduce((t, e) => {
                            return e(t)
                        }, t)
                    }
                },
                unitize(t, e) {
                    return function (n) {
                        return t(Number.parseFloat(n)) + (e || ne(n))
                    }
                },
                interpolate: function t(e, n, r, i) {
                    let o = isNaN(e + n)
                        ? 0
                        : function (t) {
                            return (1 - t) * e + t * n
                        }
                    if (!o) {
                        let a; let s; let u; let c; let l; const h = X(e)
                        let f = {}
                        if (!0 === r && (i = 1) && (r = null), h) { e = {
                            p: e
                        }, n = {
                            p: n
                        }
                        }
                        else if ($(e) && !$(n)) {
                            for (u = [], c = e.length, l = c - 2, s = 1; s < c; s++) u.push(t(e[s - 1], e[s]))
                            c--, o = function (t) {
                                t *= c
                                const e = Math.min(l, ~~t)
                                return u[e](t - e)
                            }, r = n
                        } else { i || (e = Nt($(e) ? [] : {}, e))
                        }
                        if (!u) {
                            for (a in n) We.call(f, e, a, 'get', n[a])
                            o = function (t) {
                                return sn(t, f) || (h ? e.p : e)
                            }
                        }
                    }
                    return te(r, o)
                },
                shuffle: se
            },
            install: st,
            effects: yt,
            ticker: Pe,
            updateRoot: Xe.updateRoot,
            plugins: mt,
            globalTimeline: a,
            core: {
                PropTween: fn,
                globals: lt,
                Tween: $e,
                Timeline: Xe,
                Animation: Ge,
                getCache: Et,
                _removeLinkedListItem: Lt,
                suppressOverwrites(t) {
                    return o = t
                }
            }
        }
        Tt('to,from,fromTo,delayedCall,set,killTweensOf', (t) => {
            return dn[t] = $e[t]
        }), Pe.add(Xe.updateRoot), f = dn.to({}, {
            duration: 0
        })
        const pn = function (t, e) {
            for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next
            return n
        }
        const mn = function (t, e) {
            return {
                name: t,
                rawVars: 1,
                init(t, n, r) {
                    r._onInit = function (t) {
                        let r, i
                        if (X(n) && (r = {}, Tt(n, (t) => {
                            return r[t] = 1
                        }), n = r), e) {
                            for (i in r = {}, n) r[i] = e(n[i])
                            n = r
                        }!(function (t, e) {
                            var n; var r; var i; var o = t._targets
                                    for (n in e) {
                                        for (r = o.length; r--;)(i = t._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = pn(i, n)), i && i.modifier && i.modifier(e[n], t, o[r], n))
}
                        }(t, n))
                    }
                }
            }
        }
        var yn = dn.registerPlugin({
            name: 'attr',
            init(t, e, n, r, i) {
                let o, a
                for (o in e)(a = this.add(t, 'setAttribute', `${t.getAttribute(o) || 0}`, e[o], r, i, 0, 0, o)) && (a.op = o), this._props.push(o)
            }
        }, {
            name: 'endArray',
            init(t, e) {
                for (let n = e.length; n--;) this.add(t, n, t[n] || 0, e[n])
            }
        }, mn('roundProps', ce), mn('modifiers'), mn('snap', le)) || dn
        $e.version = Xe.version = yn.version = '3.6.1', l = 1, q() && Re()
        Ae.Power0
        var vn = Ae.Power1
        var _n = (Ae.Power2, Ae.Power3, Ae.Power4, Ae.Linear)
        Ae.Quad, Ae.Cubic, Ae.Quart, Ae.Quint, Ae.Strong, Ae.Elastic, Ae.Back, Ae.SteppedEase, Ae.Bounce, Ae.Sine, Ae.Expo, Ae.Circ
    },
    './node_modules/@games/pixi-animate/lib/animate/Animator.js': function (t, e, n) {
        'use strict'
        let r; const i = (r = n('./node_modules/@games/pixi-animate/lib/animate/AnimatorTimeline.js')) && r.__esModule
            ? r
            : {
                    default: r
                }

        function o(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const a = []
        const s = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t))
            }
            let e, n, r
            return e = t, r = [{
                key: 'play',
                value(t, e, n) {
                    let r; let i; let o = !1
                                var a = typeof e == 'function'
                    if (void 0 === e || a) { r = 0, i = t.totalFrames - 1, a && (n = e)
}
                    else {
                        if (r = t.labelsMap[e], void 0 === (i = t.labelsMap[e + this.STOP_LABEL]) && (i = t.labelsMap[e + this.LOOP_LABEL], o = !0), void 0 === r) throw new Error(`No start label matching '${  e  }'`);
                        if (void 0 === i) throw new Error(`No end label matching '${  e  }'`)
                    }
                    return this.fromTo(t, r, i, o, n)
                }
            }, {
                key: 'to',
                value(t, e, n) {
                    return this.fromTo(t, t.currentFrame, e, !1, n)
                }
            }, {
                key: 'fromTo',
                value(t, e, n, r, o) {
                    if (typeof e == 'string') {
                        let a = e
                        if (void 0 === (e = t.labelsMap[a])) throw new Error(`No start label matching '${  a  }'`)
                    }
                    if (typeof n == 'string') {
                        let s = n
                        if (void 0 === (n = t.labelsMap[s])) throw new Error(`No end label matching '${  s  }'`)
                    }
                    if (e < 0) throw new Error('Start frame is out of bounds')
                    if (n >= t.totalFrames) throw new Error('End frame is out of bounds')
                    if (e >= n) throw new Error('End frame is before start frame')
                    this.stop(t), r = !!r
                    var u = i.default.create(t, e, n, r, o)
                    return this._timelines.push(u), t.currentFrame !== e ? t.gotoAndPlay(e) : t.play(), u
                }
            }, {
                key: 'stop',
                value(t) {
                    for (let e = 0, n = this._timelines.length; e < n; e++) {
                        let r = this._timelines[e]
                        if (r.instance === t) {
                            this._internalStop(r)
                            break
                        }
                    }
                }
            }, {
                key: 'stopAll',
                value() {
                    for (let t = this._timelines.length - 1; t >= 0; t--) this._internalStop(this._timelines[t])
                }
            }, {
                key: '_internalStop',
                value(t) {
                    this._timelines.splice(this._timelines.indexOf(t), 1), t.instance.stop(), t.destroy()
                }
            }, {
                key: '_timelines',
                get() {
                    return a
                }
            }, {
                key: 'STOP_LABEL',
                get() {
                    return '_stop'
                }
            }, {
                key: 'LOOP_LABEL',
                get() {
                    return '_loop'
                }
            }], (n = null) && o(e.prototype, n), r && o(e, r), t
        }())
        t.exports = s
    },
    './node_modules/@games/pixi-animate/lib/animate/AnimatorTimeline.js': function (t, e, n) {
        'use strict'

        function r(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const i = []
        const o = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this._update = this.update.bind(this), this.init(null, 0, 0, !1, null)
            }
            let e, n, o
            return e = t, o = [{
                key: 'create',
                value(e, n, r, i, o) {
                    let a
                    return (a = this._pool.length ? this._pool.pop() : new t()).init(e, n, r, i, o), a
                }
            }, {
                key: '_pool',
                get() {
                    return i
                }
            }], (n = [{
                key: 'init',
                value(t, e, n, r, i) {
                    this.instance = t, this.loop = r, this.start = e, this.end = n, this.callback = i, t && (t.loop = !1, t.gotoAndStop(e), t._beforeUpdate = this._update)
                }
            }, {
                key: 'destroy',
                value() {
                    this.instance._beforeUpdate = null, this.init(null, 0, 0, !1, null), t._pool.push(this)
                }
            }, {
                key: 'update',
                value(t) {
                    let e
                    return t.currentFrame >= this.end && (t.currentFrame = this.end, this.loop ? (t._updateTimeline(), t.gotoAndPlay(this.start)) : (t.stop(), this.callback && (e = this.callback), this.stop())), e
                }
            }, {
                key: 'progress',
                get() {
                    let t = (this.instance.currentFrame - this.start) / (this.end - this.start)
                    return Math.max(0, Math.min(1, t))
                }
            }]) && r(e.prototype, n), o && r(e, o), t
        }())
        t.exports = o
    },
    './node_modules/@games/pixi-animate/lib/animate/Ease.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        const r = Math.PI
        const i = 2 * r

        function o(t) {
            return function (e) {
                return e ** t
            }
        }

        function a(t) {
            return function (e) {
                return 1 - (1 - e) ** t
            }
        }

        function s(t) {
            return function (e) {
                return (e *= 2) < 1 ? 0.5 * e ** t : 1 - 0.5 * Math.abs((2 - e) ** t)
            }
        }
        var u = {
            quadIn: o(2),
            quadOut: a(2),
            quadInOut: s(2),
            cubicIn: o(3),
            cubicOut: a(3),
            cubicInOut: s(3),
            quartIn: o(4),
            quartOut: a(4),
            quartInOut: s(4),
            quintIn: o(5),
            quintOut: a(5),
            quintInOut: s(5),
            sineIn(t) {
                return 1 - Math.cos(t * r / 2)
            },
            sineOut(t) {
                return Math.sin(t * r / 2)
            },
            sineInOut(t) {
                return -0.5 * (Math.cos(r * t) - 1)
            },
            backIn(t) {
                return t * t * (2.7 * t - 1.7)
            },
            backOut(t) {
                return --t * t * (2.7 * t + 1.7) + 1
            },
            backInOut(t) {
                return (t *= 2) < 1 ? t * t * (3.5925 * t - 2.5925) * 0.5 : 0.5 * ((t -= 2) * t * (3.5925 * t + 2.5925) + 2)
            },
            circIn(t) {
                return -(Math.sqrt(1 - t * t) - 1)
            },
            circOut(t) {
                return Math.sqrt(1 - --t * t)
            },
            circInOut(t) {
                return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            },
            bounceIn(t) {
                return 1 - u.bounceOut(1 - t)
            },
            bounceOut(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375
            },
            bounceInOut(t) {
                return t < 0.5 ? 0.5 * u.bounceIn(2 * t) : 0.5 * u.bounceOut(2 * t - 1) + 0.5
            },
            elasticIn(t) {
                if (t === 0 || t === 1) return t
                const e = 0.3 / i * Math.asin(1)
                return -1 * 2 ** (10 * (t -= 1)) * Math.sin((t - e) * i / 0.3)
            },
            elasticOut(t) {
                if (t === 0 || t === 1) return t
                const e = 0.3 / i * Math.asin(1)
                return 1 * 2 ** (-10 * t) * Math.sin((t - e) * i / 0.3) + 1
            },
            elasticInOut(t) {
                const e = 0.3 * 1.5 / i * Math.asin(1)
                return (t *= 2) < 1 ? 1 * 2 ** (10 * (t -= 1)) * Math.sin((t - e) * i / (0.3 * 1.5)) * -0.5 : 1 * 2 ** (-10 * (t -= 1)) * Math.sin((t - e) * i / (0.3 * 1.5)) * 0.5 + 1
            }
        }
        const c = u
        e.default = c
    },
    './node_modules/@games/pixi-animate/lib/animate/MovieClip.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        const r = u(n('./node_modules/@games/pixi-animate/lib/animate/Timeline.js'))
        const i = u(n('./node_modules/@games/pixi-animate/lib/animate/utils.js'))
        const o = n('./node_modules/@games/pixi-animate/lib/animate/Tween.js')
        const a = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const s = u(n('./node_modules/@games/pixi-animate/lib/animate/sound.js'))

        function u(t) {
            return t && t.__esModule
                ? t
                : {
                        default: t
                    }
        }

        function c(t) {
            return (c = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function l(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function h(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        l(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        l(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function f(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function d(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function p(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function m(t) {
            if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
            return t
        }

        function y(t, e, n) {
            return (y = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = v(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function v(t) {
            return (v = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function _(t, e) {
            return (_ = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        let g = null
        const b = (function (t) {
            function e(t, n, r, i, o) {
                let a
                if ((function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), a = (function (t, e) {
                    return !e || c(e) !== 'object' && typeof e != 'function' ? m(t) : e
                }(this, v(e).call(this))), t = typeof (t = void 0 === t ? {} : t) == 'number'
                    ? {
                            mode: t || e.INDEPENDENT,
                            duration: n || 0,
                            loop: void 0 === r || r,
                            labels: o || {},
                            framerate: i || 0,
                            startPosition: 0,
                            frameSkip: !1
                        }
                    : Object.assign({
                            mode: e.INDEPENDENT,
                            startPosition: 0,
                            loop: !0,
                            labels: {},
                            duration: 0,
                            framerate: 0,
                            frameSkip: !1
                        }, t), a.mode = t.mode, a.startPosition = t.startPosition, a.loop = !!t.loop, a.currentFrame = 0, a._labels = [], a._labelDict = t.labels, t.labels) {
                    for (const s in t.labels) {
                        const u = {
                            label: s,
                            position: t.labels[s]
                        }
                        a._labels.push(u)
                    }
                    a._labels.sort((t, e) => {
                        return t.position - e.position
                    })
                }
                return a.selfAdvance = !0, a.paused = !1, a.actionsEnabled = !0, a.autoReset = !0, a._synchOffset = 0, a._prevPos = -1, a._t = 0, a._framerate = t.framerate, a._duration = 0, a._totalFrames = t.duration, a._frameSkip = t.frameSkip, a._timelines = [], a._timedChildTimelines = [], a._depthSorted = [], a._actions = [], a._beforeUpdate = null, a.parentStartPosition = 0, a._listenerRemoved = !0, a.mode === e.INDEPENDENT && (a._tickListener = a._tickListener.bind(m(a)), a._onAdded = a._onAdded.bind(m(a)), a._onRemoved = a._onRemoved.bind(m(a)), a.on('added', a._onAdded), a.on('removed', a._onRemoved)), t.framerate && (a.framerate = t.framerate), a.advance = a.advance, a._updateTimeline = a._updateTimeline, a._setTimelinePosition = a._setTimelinePosition, a._goto = a._goto, a
            }
            let n, u, l
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && _(t, e)
            }(e, t)), n = e, l = [{
                key: 'upload',
                value(t, e, n) {
                    g || (g = t.plugins.prepare).register(this.addMovieClips), g.upload(e, n)
                }
            }, {
                key: 'addMovieClips',
                value(t) {
                    return t instanceof e && (t._timedChildTimelines.forEach((e) => {
                        -1 === t.children.indexOf(e.target) && g.add(e.target)
                    }), !0)
                }
            }], (u = [{
                key: 'stopTick',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                    this._onRemoved(), t && (this.children.forEach((t) => {
                        return t.stopTick && t.stopTick(!0)
                    }), this._timedChildTimelines.forEach((t) => {
                        var e = t.target
                                return e.stopTick && e.stopTick(!0)
                    }))
                }
            }, {
                key: 'startTick',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                    this._onAdded(), t && (this.children.forEach((t) => {
                        return t.startTick && t.startTick(!0)
                    }), this._timedChildTimelines.forEach((t) => {
                        var e = t.target
                                return e.startTick && e.startTick(!0)
                    }))
                }
            }, {
                key: '_onAdded',
                value() {
                    this._listenerRemoved && (this._framerate || (this.framerate = this.parentFramerate), e.Ticker.add(this._tickListener), this._listenerRemoved = !1)
                }
            }, {
                key: '_tickListener',
                value(t) {
                    if (!this.paused && this.selfAdvance) {
                        let n = t / e.Ticker.speed / a.settings.TARGET_FPMS / 1e3
                        this.advance(n)
                    } else { this._prevPos < 0 && this._goto(this.currentFrame)
                    }
                }
            }, {
                key: '_onRemoved',
                value() {
                    e.Ticker.remove(this._tickListener), this._listenerRemoved = !0
                }
            }, {
                key: '_autoExtend',
                value(t) {
                    this._totalFrames < t && (this._totalFrames = t)
                }
            }, {
                key: '_parseProperties',
                value(t) {
                    'string' == typeof t.t ? t.t = i.default.hexToUint(t.t) : typeof t.v == 'number' && (t.v = !!t.v)
                }
            }, {
                key: '_getChildTimeline',
                value(t) {
                    for (let e = this._timelines.length - 1; e >= 0; --e) {
                        if (this._timelines[e].target === t) return this._timelines[e]
}
                    let n = new r.default(t)
                    return this._timelines.push(n), n
                }
            }, {
                key: 'addTimedMask',
                value(t, e) {
                    for (const n in e) { this.addKeyframe(t, {
                        m: e[n]
                    }, Number.parseInt(n, 10))
}
                    return this._setTimelinePosition(this.currentFrame, this.currentFrame, !0), this
                }
            }, {
                key: 'am',
                value(t, e) {
                    return this.addTimedMask(t, e)
                }
            }, {
                key: 'addTween',
                value(t, e, n, r, i) {
                    let o = this._getChildTimeline(t)
                    return this._parseProperties(e), o.addTween(e, n, r, i), this._autoExtend(n + r), this
                }
            }, {
                key: 'addKeyframe',
                value(t, e, n) {
                    let r = this._getChildTimeline(t)
                                var i = e.tw
                    return delete e.tw, this._parseProperties(e), r.addKeyframe(e, n), this._autoExtend(n), i && (this.addTween(t, i.p, n, i.d, (0, o.getEaseFromConfig)(i.e)), r.addKeyframe(i.p, n + i.d)), this
                }
            }, {
                key: 'at',
                value(t, e, n, r) {
                    return this.addTimedChild(t, e, n, r)
                }
            }, {
                key: 'addTimedChild',
                value(t, n, r, o) {
                    let a, s
                    for (void 0 === n && (n = 0), (void 0 === r || r < 1) && (r = this._totalFrames || 1), t.mode === e.SYNCHED && (t.parentStartPosition = n), s = this._timedChildTimelines.length - 1; s >= 0; --s) {
                        if (this._timedChildTimelines[s].target === t) {
                            a = this._timedChildTimelines[s]
                                    break
                        }
                    }
                    if (a || ((a = []).target = t, this._timedChildTimelines.push(a)), i.default.fillFrames(a, n, r), this._totalFrames < n + r && (this._totalFrames = n + r), o) {
                        for (const u in typeof o == 'string' && (o = i.default.deserializeKeyframes(o)), o) this.addKeyframe(t, o[u], Number.parseInt(u, 10))
                        this._getChildTimeline(t).extendLastFrame(n + r - 1)
                    }
                    return this._setTimelinePosition(n, this.currentFrame, !0), this
                }
            }, {
                key: 'aa',
                value(t, e) {
                    return this.addAction(t, e)
                }
            }, {
                key: 'addAction',
                value(t, e) {
                    if (typeof e == 'string') {
                        let n = this._labelDict[e]
                        if (void 0 === n) throw 'The label \''.concat(e, '\' does not exist on this timeline')
                        e = n
                    }
                    let r = this._actions
                    return r.length <= e && (r.length = e + 1), this._totalFrames < e && (this._totalFrames = e), r[e] ? r[e].push(t) : r[e] = [t], this
                }
            }, {
                key: 'ps',
                value(t, e) {
                    return this.playSound(t, e)
                }
            }, {
                key: 'playSound',
                value(t, e) {
                    return s.default.emit('play', t, !!e, this), this
                }
            }, {
                key: 'play',
                value() {
                    this.startTick(!0), this.paused = !1
                }
            }, {
                key: 'stop',
                value() {
                    this.stopTick(), this.paused = !0
                }
            }, {
                key: 'gotoAndPlay',
                value(t) {
                    this.startTick(!0), this.paused = !1, this._goto(t)
                }
            }, {
                key: 'gotoAndStop',
                value(t) {
                    this.stopTick(), this.paused = !0, this._goto(t)
                }
            }, {
                key: 'advance',
                value(t) {
                    let n; let r = t ? t * e.TIME_SCALE : null
                                var i = this.currentFrame
                                var o = this._getNextActionFrame()
                                var a = this.loop && (this._frameSkip || i >= this._getNextActionFrame())
                                var s = Math.floor(this._t * this._framerate + 1e-8)
                    this._framerate || (this.framerate = this.parentFramerate), r && (this._t += r), this._t > this._duration && (this._t = a ? this._t % this._duration : this._duration), this._frameSkip ? this.currentFrame = s : this.currentFrame = o >= 0 ? Math.min(s, o) : s, this.currentFrame >= this._totalFrames && (this.currentFrame = this._totalFrames - 1), this.currentFrame < i && !a && (this.currentFrame = i), this._beforeUpdate && (n = this._beforeUpdate(this)), this._updateTimeline(), n && n()
                }
            }, {
                key: '_getNextActionFrame',
                value() {
                    if (!this.currentFrame) return this._actions.length - 1
                    for (let t = this.currentFrame + 1; t < this._actions.length; t++) {
                        if (this._actions[t]) return t
}
                    return this._actions.length - 1
                }
            }, {
                key: '_goto',
                value(t) {
                    let e = typeof t == 'string' ? this._labelDict[t] : t
                    void 0 !== e && (this._prevPos = Number.NaN, this.currentFrame = e, this._framerate || (this.framerate = this.parentFramerate), this._framerate > 0 ? this._t = e / this._framerate : this._t = 0, this._updateTimeline())
                }
            }, {
                key: '_reset',
                value() {
                    this._prevPos = -1, this._t = 0, this.currentFrame = 0
                }
            }, {
                key: '_updateTimeline',
                value() {
                    let t = this.mode !== e.INDEPENDENT
                    t && (this.currentFrame = this.startPosition + (this.mode === e.SINGLE_FRAME ? 0 : this._synchOffset), this.currentFrame >= this._totalFrames && (this.currentFrame %= this._totalFrames)), this._prevPos !== this.currentFrame && (this._setTimelinePosition(this._prevPos, this.currentFrame, !t && this.actionsEnabled), this._prevPos = this.currentFrame)
                }
            }, {
                key: '_setTimelinePosition',
                value(t, n, r) {
                    if (t !== n && r) {
                        let i = isNaN(t) ? n : t >= this._totalFrames - 1 ? 0 : t + 1
                                    var o = []
                        if (n < i) {
                            for (let a = i; a < this._actions.length; ++a) this._actions[a] && o.push(a)
                            for (let s = 0; s <= n; ++s) this._actions[s] && o.push(s)
                        } else {
                            for (let u = i; u <= n; ++u) this._actions[u] && o.push(u)
}
                        if (o.length) {
                            for (let c = this.currentFrame, l = 0; l < o.length; ++l) {
                                var h = o[l]
                                        if (this._setTimelinePosition(h, h, !0), this.currentFrame !== c || h === n) return
                                        if (this.paused) return void (this.currentFrame = h)
                            }
                        }
                    }
                    let f; let d; let p; let m = this._timelines
                    for (f = m.length - 1; f >= 0; --f) {
                        let y = m[f]
                        for (d = 0, p = y.length; d < p; ++d) {
                            let v = y[d]
                            if (n >= v.startFrame && n <= v.endFrame) {
                                v.setPosition(n)
                                break
                            }
                        }
                    }
                    let _ = this._timedChildTimelines
                                var g = this._depthSorted
                    for (f = 0, p = _.length; f < p; ++f) {
                        let b = _[f].target
                                    var E = _[f][n]
                        E ? (g.push(b), b.parent !== this && (this.addChild(b), b.mode === e.INDEPENDENT && b.autoReset && b._reset())) : E || b.parent !== this || this.removeChild(b)
                    }
                    for (f = 0, p = g.length; f < p; f++) {
                        let x = g[f]
                        this.children.indexOf(x) !== f && this.addChildAt(x, f)
                    }
                    g.length = 0
                    var T; let S = this.children
                    for (f = 0, p = S.length; f < p; ++f)(T = S[f]).mode === e.SYNCHED && (T._synchOffset = n - T.parentStartPosition, T._updateTimeline())
                    if (r && this._actions && this._actions[n]) {
                        for (let w = this._actions[n], O = 0; O < w.length; ++O) w[O].call(this)
                    }
                }
            }, {
                key: 'destroy',
                value(t) {
                    this._tickListener && (e.Ticker.remove(this._tickListener), this._tickListener = null)
                    var n = []
                                var r = this._timelines
                    if (r) {
                        for (let i = 0; i < r.length; i++) {
                            var o = r[i]
                                    n.push(o.target), o._currentProps = null, o.length = 0
                        }
                    }
                    if (r = this._timedChildTimelines) {
                        for (let a = 0; a < r.length; a++) {
                            var s = r[a]
                                    n.indexOf(s.target) < 0 && n.push(s.target), s._currentProps = null, s.length = 0
                        }
                    }
                    for (let u = 0; u < n.length; u++) !this.children.includes(n[u]) && n[u].destroy(t)
                    n.length = 0, this._actions = null, this._timelines = null, this._depthSorted = null, this._timedChildTimelines = null, this._beforeUpdate = null, this._labels = null, this._labelDict = null, y(v(e.prototype), 'destroy', this).call(this, t)
                }
            }, {
                key: 'promises',
                get() {
                    let t = this
                    return (function (t) {
                        for (let e = 1; e < arguments.length; e++) {
                            var n = arguments[e] != null ? arguments[e] : {}
                                    e % 2
? f(n, !0).forEach(function(e) {
                                        d(t, e, n[e])
                                    })
: Object.getOwnPropertyDescriptors
? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
: f(n).forEach(function(e) {
                                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                                    })
                        }
                        return t
                    }({}, y(v(e.prototype), 'promises', this), {
                        play: function () {
                            return new Promise(function(e) {
                                        t.promises.stop(), t.play(), t.once("label_end", (function() {
                                            t.stop(), e()
                                        }))
                                    })
                        },
                        gotoAndPlay: function (e) {
                            var n = arguments.length > 1 && void 0 !== arguments[1]
? arguments[1]
: {
                                repeat: 0
                            };
                            return new Promise(function () {
                                var r = h(regeneratorRuntime.mark(function r(i) {
                                            var o;
                                            return regeneratorRuntime.wrap((function(r) {
                                                for (;;) switch (r.prev = r.next) {
                                                    case 0:
                                                        if (t.promises.stop(), t.gotoAndPlay(e), !(n.repeat < 0)) {
                                                            r.next = 8;
                                                            break
                                                        }
                                                        t._repeatCallback = function() {
                                                            return t.gotoAndPlay(e)
                                                        }, t.on("label_end", t._repeatCallback), i(), r.next = 21;
                                                        break;
                                                    case 8:
                                                        if (!(n.repeat > 0)) {
                                                            r.next = 20;
                                                            break
                                                        }
                                                        o = n.repeat;
                                                    case 10:
                                                        if (!(o > 0)) {
                                                            r.next = 16;
                                                            break
                                                        }
                                                        return o--, r.next = 14, t.promises.gotoAndPlay(e);
                                                    case 14:
                                                        r.next = 10;
                                                        break;
                                                    case 16:
                                                        t.stop(), i(), r.next = 21;
                                                        break;
                                                    case 20:
                                                        t.once("label_end", (function() {
                                                            t.stop(), i()
                                                        }));
                                                    case 21:
                                                    case "end":
                                                        return r.stop()
                                                }
                                            }), r)
                                        }))
                                        return function (t) {
                                    return r.apply(this, arguments)
                                }
                            }())
                        },
                        stop: function () {
                            return t.stop(), 'function' == typeof t._repeatCallback && t.off('label_end', t._repeatCallback), Promise.resolve()
                        },
                        gotoAndStop: function (e) {
                            return t.gotoAndStop(e), Promise.resolve()
                        },
                        finish: function () {
                            return new Promise(function(e) {
                                        return t.once("label_end", (function() {
                                            t.stop(), e()
                                        }))
                                    })
                        }
                    }))
                }
            }, {
                key: 'labels',
                get() {
                    return this._labels
                }
            }, {
                key: 'labelsMap',
                get() {
                    return this._labelDict
                }
            }, {
                key: 'currentLabel',
                get() {
                    for (var t = this._labels, e = null, n = 0, r = t.length; n < r && t[n].position <= this.currentFrame; ++n) e = t[n].label
                    return e
                }
            }, {
                key: 'elapsedTime',
                get() {
                    return this._t
                },
                set(t) {
                    this._t = t
                }
            }, {
                key: 'framerate',
                get() {
                    return this._framerate
                },
                set(t) {
                    t > 0 ? (this._framerate ? this._t *= this._framerate / t : this._t = this.currentFrame / t, this._framerate = t, this._duration = t ? this._totalFrames / t : 0) : this._t = this._framerate = this._duration = 0
                }
            }, {
                key: 'totalFrames',
                get() {
                    return this._totalFrames
                }
            }, {
                key: 'parentFramerate',
                get() {
                    for (var t = this, n = t._framerate;
                        (t = t.parent) && !n;) t.mode === e.INDEPENDENT && (n = t._framerate)
                    return n || e.DEFAULT_FRAMERATE
                }
            }]) && p(n.prototype, u), l && p(n, l), e
        }(a.Container))
        b.INDEPENDENT = 0, b.SINGLE_FRAME = 1, b.SYNCHED = 2, b.DEFAULT_FRAMERATE = 60, b.TIME_SCALE = 1, b.extend = b.e = function (t) {
            return t.prototype = Object.create(b.prototype), t.prototype.__parent = b.prototype, t.prototype.constructor = t, t
        }, b.Ticker = null
        const E = b
        e.default = E
    },
    './node_modules/@games/pixi-animate/lib/animate/Scene.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        const r = o(n('./node_modules/@games/pixi-animate/lib/animate/load.js'))
        const i = o(n('./node_modules/@games/pixi-animate/lib/animate/sound.js'))

        function o(t) {
            return t && t.__esModule
                ? t
                : {
                        default: t
                    }
        }

        function a(t) {
            return (a = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function s(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function u(t, e) {
            return !e || a(e) !== 'object' && typeof e != 'function'
                ? (function (t) {
                        if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                        return t
                    }(t))
                : e
        }

        function c(t, e, n) {
            return (c = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = l(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function l(t) {
            return (l = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function h(t, e) {
            return (h = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const f = (function (t) {
            function e(t, n, r, o) {
                let a
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (a = u(this, l(e).call(this, t, n, r, o))).sound = i.default, a.instance = null, a
            }
            let n, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && h(t, e)
            }(e, t)), n = e, (o = [{
                key: 'load',
                value(t, e, n) {
                    let i = this
                    return (0, r.default)(t, this.stage, (t) => {
                        i.instance = t, e && e(t)
                    }, n)
                }
            }, {
                key: 'destroy',
                value(t) {
                    this.instance && (this.instance.destroy(!0), this.instance = null), c(l(e.prototype), 'destroy', this).call(this, t)
                }
            }]) && s(n.prototype, o), a && s(n, a), e
        }(n('./node_modules/pixi.js/dist/esm/pixi.js').Application))
        e.default = f
    },
    './node_modules/@games/pixi-animate/lib/animate/ShapesCache.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        let r; const i = (r = n('./node_modules/@games/pixi-animate/lib/animate/utils.js')) && r.__esModule
            ? r
            : {
                    default: r
                }

        function o(t) {
            return (o = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const a = {}
        Object.defineProperty(a, 'add', {
            enumerable: !1,
            value(t, e) {
                typeof e == 'string' && (e = i.default.deserializeShapes(e))
                for (let n = 0; n < e.length; n++) {
                    for (let r = e[n], o = 0; o < r.length; o++) {
                        const s = r[o]
                        'string' == typeof s && s[0] === '#' && (r[o] = i.default.hexToUint(s))
                    }
                }
                a[t] = e
            }
        }), Object.defineProperty(a, 'fromCache', {
            enumerable: !1,
            value(t) {
                return a[t] || null
            }
        }), Object.defineProperty(a, 'remove', {
            enumerable: !1,
            value(t) {
                if (o(t) !== 'object') { a[t] && (a[t].length = 0, delete a[t])
                }
                else {
                    for (const e in t) a.remove(e)
                }
            }
        }), Object.defineProperty(a, 'removeAll', {
            enumerable: !1,
            value() {
                for (const t in a) a.remove(t)
            }
        })
        const s = a
        e.default = s
    },
    './node_modules/@games/pixi-animate/lib/animate/SymbolLoader.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        let r; const i = (r = n('./node_modules/@games/pixi-animate/lib/animate/ShapesCache.js')) && r.__esModule
            ? r
            : {
                    default: r
                }
        const o = function () {
            return function (t, e) {
                const n = t.url
                let r = t.data
                r ? n.search(/\.shapes\.(json|txt)$/i) > -1 && i.default.add(t.name, r) : e(), e(t.error)
            }
        }
        n('./node_modules/pixi.js/dist/esm/pixi.js').Loader._plugins.push({
            use: o()
        })
        const a = o
        e.default = a
    },
    './node_modules/@games/pixi-animate/lib/animate/Timeline.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        let r; const i = (r = n('./node_modules/@games/pixi-animate/lib/animate/Tween.js')) && r.__esModule
            ? r
            : {
                    default: r
                }
        const o = function (t) {
            Array.call(this), this.target = t, this._currentProps = {}
        }
        const a = o.prototype = Object.create(Array.prototype)
        a.addTween = function (t, e, n, r) {
            this.extendLastFrame(e - 1)
            const o = Object.assign({}, this._currentProps)
            for (const a in t) {
                const s = a
                if (!Object.hasOwnProperty.call(this._currentProps, a)) {
                    for (let u = o[s] = this.getPropFromShorthand(s), c = this.length - 1; c >= 0; --c) this[c].startProps[s] = u, this[c].endProps[s] = u
                }
            }
            const l = new i.default(this.target, o, t, e, n, r)
            e === this[this.length - 1].startFrame ? this[this.length - 1] = l : this.push(l), Object.assign(this._currentProps, l.endProps)
        }, a.addKeyframe = function (t, e) {
            if (this.length && this[this.length - 1].startFrame >= e) {
                for (let n = this.length - 1; n >= 0; --n) {
                    const r = this[n]
                    if (r.startFrame === e) {
                        Object.assign(r.startProps, t), r.endProps = Object.assign({}, r.startProps, r.endProps)
                        for (let o = n + 1; o < this.length; ++o) {
                            const a = this[o]
                            a.startProps = Object.assign({}, t, a.startProps), a.endProps = Object.assign({}, a.startProps, a.endProps)
                        }
                        break
                    }
                    if (r.startFrame < e && r.endFrame > e && r.isTweenlessFrame) {
                        r.endFrame = e - 1
                        const s = Object.assign({}, r.endProps, t)
                        const u = new i.default(this.target, s, null, e, 0)
                        this.splice(n, 0, u)
                        for (let c = n + 1; c < this.length; ++c) {
                            const l = this[c]
                            l.startProps = Object.assign({}, t, l.startProps), l.endProps = Object.assign({}, l.startProps, l.endProps)
                        }
                        break
                    }
                    if (r.endFrame < e) {
                        const h = Object.assign({}, r.endProps, t)
                        const f = new i.default(this.target, h, null, e, 0)
                        this.splice(n, 0, f)
                        for (let d = n + 1; d < this.length; ++d) {
                            const p = this[d]
                            p.startProps = Object.assign({}, t, p.startProps), p.endProps = Object.assign({}, p.startProps, p.endProps)
                        }
                        break
                    }
                    if (e < r.endFrame && r.isTweenlessFrame) {
                        r.endFrame = e - 1
                        const m = Object.assign({}, r.endProps, t)
                        const y = new i.default(this.target, m, null, e, 0)
                        this.splice(n, 0, y)
                        for (let v = n + 1; v < this.length; ++v) {
                            const _ = this[v]
                            _.startProps = Object.assign({}, t, _.startProps), _.endProps = Object.assign({}, _.startProps, _.endProps)
                        }
                        break
                    }
                }
                Object.assign(this._currentProps, t, this._currentProps)
            } else {
                this.extendLastFrame(e - 1)
                const g = Object.assign({}, this._currentProps, t)
                const b = new i.default(this.target, g, null, e, 0)
                this.push(b), Object.assign(this._currentProps, b.endProps)
            }
        }, a.extendLastFrame = function (t) {
            if (this.length) {
                const e = this[this.length - 1]
                e.endFrame < t && (e.isTweenlessFrame ? e.endFrame = t : this.addKeyframe(this._currentProps, e.endFrame + 1))
            }
        }, a.getPropFromShorthand = function (t) {
            const e = this.target
            switch (t) {
                case 'x':
                    return e.position.x
                case 'y':
                    return e.position.y
                case 'sx':
                    return e.scale.x
                case 'sy':
                    return e.scale.y
                case 'kx':
                    return e.skew.x
                case 'ky':
                    return e.skew.y
                case 'r':
                    return e.rotation
                case 'a':
                    return e.alpha
                case 'v':
                    return e.visible
                case 'm':
                    return e.mask
            }
            return null
        }
        const s = o
        e.default = s
    },
    './node_modules/@games/pixi-animate/lib/animate/Tween.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.getEaseFromConfig = p, e.default = void 0
        let r; const i = (r = n('./node_modules/@games/pixi-animate/lib/animate/Ease.js')) && r.__esModule
            ? r
            : {
                    default: r
                }

        function o(t) {
            return (function (t) {
                if (Array.isArray(t)) {
                    for (var e = 0, n = Array.from({ length: t.length }); e < t.length; e++) n[e] = t[e]
                    return n
                }
            }(t)) || (function (t) {
                if (Symbol.iterator in new Object(t) || Object.prototype.toString.call(t) === '[object Arguments]') return Array.from(t)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance')
            }())
        }

        function a(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const s = (function () {
            function t(e, n, r, i, o, a) {
                if ((function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.target = e, this.startProps = n, this.endProps = {}, this.duration = o, this.startFrame = i, this.endFrame = i + o, this.ease = {}, this.isTweenlessFrame = !r, r) {
                    for (const s in r) s !== 'e' && (this.endProps[s] = r[s], r.e && r.e[s] ? this.ease[s] = p(r.e[s]) : this.ease[s] = a)
                }
                for (const u in n) this.endProps.hasOwnProperty(u) || (this.endProps[u] = n[u])
            }
            let e, n, r
            return e = t, (n = [{
                key: 'setPosition',
                value(t) {
                    if (t >= this.endFrame) { this.setToEnd()
}
                    else if (this.isTweenlessFrame) { this.setToEnd()
}
                    else {
                        let e = (t - this.startFrame) / this.duration
                                var n = this.target
                                var r = this.startProps
                                var i = this.endProps
                        for (const o in i) {
                            let a = o
                                    var s = c[a]
                                    var u = e
                            this.ease[o] && (u = this.ease[o](e)), d(n, a, s ? s(r[a], i[a], u) : r[a])
                        }
                    }
                }
            }, {
                key: 'setToEnd',
                value() {
                    let t = this.endProps
                            var e = this.target
                    for (const n in t) d(e, n, t[n])
                }
            }]) && a(e.prototype, n), r && a(e, r), t
        }())

        function u(t, e, n) {
            return t + (e - t) * n
        }
        var c = {
            x: u,
            y: u,
            sx: u,
            sy: u,
            kx: u,
            ky: u,
            r(t, e, n) {
                Math.abs(e - t) > h && (e > t ? t += f : e += h + f)
                return t + (e - t) * n
            },
            a: u,
            t(t, e, n) {
                const r = t >> 16 & 255
                let i = t >> 8 & 255
                let o = 255 & t
                let a = r + ((e >> 16 & 255) - r) * n
                a < 0 ? a = 0 : a > 255 && (a = 255)
                let s = i + ((e >> 8 & 255) - i) * n
                s < 0 ? s = 0 : s > 255 && (s = 255)
                let u = o + ((255 & e) - o) * n
                u < 0 ? u = 0 : u > 255 && (u = 255)
                return a << 16 | s << 8 | u
            },
            v: null,
            c(t, e, n) {
                return l[0] = t[0] + (e[0] - t[0]) * n, l[1] = t[1] + (e[1] - t[1]) * n, l[2] = t[2] + (e[2] - t[2]) * n, l[3] = t[3] + (e[3] - t[3]) * n, l[4] = t[4] + (e[4] - t[4]) * n, l[5] = t[5] + (e[5] - t[5]) * n, l
            },
            m: null,
            g: null
        }
        var l = []
        var h = Math.PI
        var f = 2 * h

        function d(t, e, n) {
            switch (e) {
                case 'x':
                    t.transform.position.x = n
                    break
                case 'y':
                    t.transform.position.y = n
                    break
                case 'sx':
                    t.transform.scale.x = n
                    break
                case 'sy':
                    t.transform.scale.y = n
                    break
                case 'kx':
                    t.transform.skew.x = n
                    break
                case 'ky':
                    t.transform.skew.y = n
                    break
                case 'r':
                    t.transform.rotation = n
                    break
                case 'a':
                    t.alpha = n
                    break
                case 't':
                    t.i(n)
                    break
                case 'c':
                    t.setColorTransform.apply(t, o(n))
                    break
                case 'v':
                    t.visible = n
                    break
                case 'm':
                    t.ma(n)
            }
        }

        function p(t) {
            if (!t) return null
            if (typeof t == 'function') return t
            if (t.n === 'classic') {
                const e = t.s / 100
                return function (t) {
                    return (e + 1) * t + -e * t * t
                }
            }
            return i.default[t.n]
        }
        const m = s
        e.default = m
    },
    './node_modules/@games/pixi-animate/lib/animate/index.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), Object.defineProperty(e, 'load', {
            enumerable: !0,
            get() {
                return r.default
            }
        }), Object.defineProperty(e, 'sound', {
            enumerable: !0,
            get() {
                return i.default
            }
        }), Object.defineProperty(e, 'utils', {
            enumerable: !0,
            get() {
                return o.default
            }
        }), Object.defineProperty(e, 'MovieClip', {
            enumerable: !0,
            get() {
                return a.default
            }
        }), Object.defineProperty(e, 'Scene', {
            enumerable: !0,
            get() {
                return s.default
            }
        }), Object.defineProperty(e, 'ShapesCache', {
            enumerable: !0,
            get() {
                return u.default
            }
        }), Object.defineProperty(e, 'SymbolLoader', {
            enumerable: !0,
            get() {
                return c.default
            }
        }), Object.defineProperty(e, 'Timeline', {
            enumerable: !0,
            get() {
                return l.default
            }
        }), Object.defineProperty(e, 'Tween', {
            enumerable: !0,
            get() {
                return h.default
            }
        }), Object.defineProperty(e, 'Animator', {
            enumerable: !0,
            get() {
                return f.default
            }
        }), Object.defineProperty(e, 'AnimatorTimeline', {
            enumerable: !0,
            get() {
                return d.default
            }
        }), e.Ease = e.VERSION = void 0
        var r = y(n('./node_modules/@games/pixi-animate/lib/animate/load.js'))
        var i = y(n('./node_modules/@games/pixi-animate/lib/animate/sound.js'))
        var o = y(n('./node_modules/@games/pixi-animate/lib/animate/utils.js'))
        var a = y(n('./node_modules/@games/pixi-animate/lib/animate/MovieClip.js'))
        var s = y(n('./node_modules/@games/pixi-animate/lib/animate/Scene.js'))
        var u = y(n('./node_modules/@games/pixi-animate/lib/animate/ShapesCache.js'))
        var c = y(n('./node_modules/@games/pixi-animate/lib/animate/SymbolLoader.js'))
        var l = y(n('./node_modules/@games/pixi-animate/lib/animate/Timeline.js'))
        var h = y(n('./node_modules/@games/pixi-animate/lib/animate/Tween.js'))
        var f = y(n('./node_modules/@games/pixi-animate/lib/animate/Animator.js'))
        var d = y(n('./node_modules/@games/pixi-animate/lib/animate/AnimatorTimeline.js'))
        const p = (function (t) {
            if (t && t.__esModule) return t
            let e = m()
            if (e && e.has(t)) return e.get(t)
            let n = {}
            if (t != null) {
                const r = Object.defineProperty && Object.getOwnPropertyDescriptor
                for (const i in t) {
                    if (Object.prototype.hasOwnProperty.call(t, i)) {
                        let o = r ? Object.getOwnPropertyDescriptor(t, i) : null
                        o && (o.get || o.set) ? Object.defineProperty(n, i, o) : n[i] = t[i]
                    }
                }
            }
            n.default = t, e && e.set(t, n)
            return n
        }(n('./node_modules/@games/pixi-animate/lib/animate/Ease.js')))

        function m() {
            if (typeof WeakMap != 'function') return null
            const t = new WeakMap()
            return m = function () {
                return t
            }, t
        }

        function y(t) {
            return t && t.__esModule
                ? t
                : {
                        default: t
                    }
        }
        e.Ease = p
        e.VERSION = '1.5.0'
    },
    './node_modules/@games/pixi-animate/lib/animate/load.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = function (t, e, n, i, o, a) {
            function s() {
                const e = t.createInstance && typeof t.stage == 'function' ? new t.stage() : null
                t.parent && t.parent.addChild(e), t.complete && t.complete(e, o)
            }
            typeof e == 'function' ? (i = n, n = e, e = null) : typeof n == 'string' && (i = n, n = null), typeof t == 'function' && (t = {
                stage: t,
                parent: e,
                basePath: i || '',
                complete: n
            }), t = Object.assign({
                stage: null,
                parent: null,
                basePath: '',
                complete: null,
                createInstance: !0
            }, t || {}), o = o || new r.Loader()
            const u = t.stage.assets || {}
            if (u && Object.keys(u).length) {
                let c = t.basePath
                for (const l in c && (c += '/'), u) {
                    let h = null
                    a && (a[l] ? h = a[l] : a.default && (h = a.default)), o.add(l, c + u[l], h)
                }
                o.once('complete', s).load()
            } else { s()
            }
            return o
        }
        e.default = i
    },
    './node_modules/@games/pixi-animate/lib/animate/sound.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        const r = new (n('./node_modules/pixi.js/dist/esm/pixi.js').utils.EventEmitter)()
        e.default = r
    },
    './node_modules/@games/pixi-animate/lib/animate/utils.js': function (t, e, n) {
        'use strict'

        function r(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), e.default = void 0
        const i = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t))
            }
            let e, n, i
            return e = t, i = [{
                key: 'hexToUint',
                value(t) {
                    return (t = t.substr(1)).length === 3 && (t = t.replace(/([a-f0-9])/g, '$1$1')), Number.parseInt(t, 16)
                }
            }, {
                key: 'fillFrames',
                value(t, e, n) {
                    let r = t.length
                    if (r < e + n && (t.length = e + n, r < e)) {
                        if (t.fill) { t.fill(!1, r, e);
}
                        else {
                                for (var i = r; i < e; ++i) t[i] = !1;
}
                    }
                    if (t.fill) { t.fill(!0, e, e + n)
}
                    else {
                        for (let o = t.length, a = e; a < o; ++a) t[a] = !0
                    }
                }
            }, {
                key: 'deserializeKeyframes',
                value(t) {
                    for (var e, n, r = {}, i = 0, o = {
                            X: 'x',
                            Y: 'y',
                            A: 'sx',
                            B: 'sy',
                            C: 'kx',
                            D: 'ky',
                            R: 'r',
                            L: 'a',
                            T: 't',
                            F: 'c',
                            V: 'v'
                        }, a = '', s = !1, u = {}; i <= t.length;) o[e = t[i]] ? (s || (s = !0, r[a] = u), n && (u[n] = this.parseValue(n, a)), n = o[e], a = '', i++) : e && e !== ' ' ? (a += e, i++) : (i++, u[n] = this.parseValue(n, a), a = '', n = null, u = {}, s = !1)
                    return r
                }
            }, {
                key: 'deserializeShapes',
                value(t) {
                    for (var e = [], n = t.split('\n'), r = /^[a-z]{1,2}$/, i = 0; i < n.length; i++) {
                        for (var o = n[i].split(' '), a = 0; a < o.length; a++) {
                            let s = o[a]
                            "#" === s[0] || r.test(s) || (o[a] = Number.parseFloat(s))
                        }
                        e.push(o)
                    }
                    return e
                }
            }, {
                key: 'parseValue',
                value(t, e) {
                    switch (t) {
                        case 'c':
                            return (e = e.split(',')).forEach((t, e, n) => {
                                n[e] = Number.parseFloat(t)
                            }), e
                        case 't':
                            return e
                        case 'v':
                            return !!Number.parseInt(e)
                        default:
                            return Number.parseFloat(e)
                    }
                }
            }], (n = null) && r(e.prototype, n), i && r(e, i), t
        }())
        e.default = i
    },
    './node_modules/@games/pixi-animate/lib/index.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        })
        const r = n('./node_modules/@games/pixi-animate/lib/animate/index.js')
        Object.keys(r).forEach((t) => {
            t !== 'default' && t !== '__esModule' && Object.defineProperty(e, t, {
                enumerable: !0,
                get() {
                    return r[t]
                }
            })
        })
        const i = n('./node_modules/@games/pixi-animate/lib/mixins/index.js')
        Object.keys(i).forEach((t) => {
            t !== 'default' && t !== '__esModule' && Object.defineProperty(e, t, {
                enumerable: !0,
                get() {
                    return i[t]
                }
            })
        })
    },
    './node_modules/@games/pixi-animate/lib/mixins/Container.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = r.Container.prototype
        i.ac = i.addChild, i.stopTick = function () {
            this.children.forEach((t) => {
                return t.stopTick && t.stopTick(!0)
            })
        }, i.startTick = function () {
            this.children.forEach((t) => {
                return t.startTick && t.startTick(!0)
            })
        }, r.Container.extend = r.Container.e = function (t) {
            return t.prototype = Object.create(i), t.prototype.__parent = i, t.prototype.constructor = t, t
        }
    },
    './node_modules/@games/pixi-animate/lib/mixins/DisplayObject.js': function (t, e, n) {
        'use strict'
        let r; const i = (r = n('./node_modules/@games/pixi-animate/lib/animate/utils.js')) && r.__esModule
            ? r
            : {
                    default: r
                }
        const o = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const a = o.filters.ColorMatrixFilter
        const s = o.DisplayObject.prototype
        s.setRenderable = s.re = function (t) {
            return this.renderable = !!t, this
        }, s.t = s.setTransform, s.setMask = s.ma = function (t) {
            return t && !(t instanceof o.Graphics || t instanceof o.Sprite) ? (typeof console != 'undefined' && console.warn && console.warn('Warning: Masks can only be PIXI.Graphics or PIXI.Sprite objects.'), this) : (this.mask = t, this)
        }, s.setAlpha = s.a = function (t) {
            return this.alpha = t, this
        }, s.setTint = s.i = function (t) {
            typeof t == 'string' && (t = i.default.hexToUint(t))
            const e = t >> 16 & 255
            const n = t >> 8 & 255
            const r = 255 & t
            return this.c(e / 255, 0, n / 255, 0, r / 255, 0)
        }, s.setColorTransform = s.c = function (t, e, n, r, i, o) {
            const a = this.colorTransformFilter
            return a.matrix[0] = t, a.matrix[4] = e, a.matrix[6] = n, a.matrix[9] = r, a.matrix[12] = i, a.matrix[14] = o, this.filters = [a], this
        }, s.hasOwnProperty('colorTransformFilter') || Object.defineProperty(s, 'colorTransformFilter', {
            set(t) {
                this._colorTransformFilter = t
            },
            get() {
                return this._colorTransformFilter || new a()
            }
        }), o.DisplayObject.extend = o.DisplayObject.e = function (t) {
            return t.prototype = Object.create(s), t.prototype.__parent = s, t.prototype.constructor = t, t
        }
    },
    './node_modules/@games/pixi-animate/lib/mixins/Graphics.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js').Graphics.prototype
        r.drawCommands = r.d = function (t) {
            for (var e, n = [], r = 0; r <= t.length;) {
                const i = t[r++]
                void 0 === i || this[i] ? (e && (this[e].apply(this, n), n.length = 0), e = i) : n.push(i)
            }
            return this.finishPoly(), this
        }, r.c = r.closePath, r.h = r.addHole, r.m = r.moveTo, r.l = r.lineTo, r.q = r.quadraticCurveTo, r.b = r.bezierCurveTo, r.f = r.beginFill, r.s = r.lineStyle, r.dr = r.drawRect, r.rr = r.drawRoundedRect, r.rc = r.drawRoundedRect, r.dc = r.drawCircle, r.ar = r.arc, r.at = r.arcTo, r.de = r.drawEllipse, r.lf = function (t) {
            return console.warn('Linear gradient fills are not supported'), this.f(t[0])
        }, r.rf = function (t) {
            return console.warn('Radial gradient fills are not supported'), this.f(t[0])
        }, r.bf = function () {
            return console.warn('Bitmap fills are not supported'), this.f(0)
        }, r.sd = function () {
            return console.warn('Dashed strokes are not supported'), this
        }, r.bs = function () {
            return console.warn('Bitmap strokes are not supported'), this
        }, r.ls = function () {
            return console.warn('Linear gradient strokes are not supported'), this
        }, r.rs = function () {
            return console.warn('Radial gradient strokes are not supported'), this
        }
    },
    './node_modules/@games/pixi-animate/lib/mixins/Sprite.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = r.Sprite.prototype
        r.Sprite.extend = r.Sprite.e = function (t) {
            return t.prototype = Object.create(i), t.prototype.__parent = i, t.prototype.constructor = t, t
        }
    },
    './node_modules/@games/pixi-animate/lib/mixins/Text.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js').Text.prototype
        const i = ['center', 'right']
        r.setAlign = r.g = function (t) {
            return typeof t == 'string' && (t = i.indexOf(t)), this.style.align = i[t] || 'left', this.anchor.x = (t + 1) / 2, this
        }
        const o = {
            o: 'font',
            z: 'fontSize',
            f: 'fontFamily',
            y: 'fontStyle',
            g: 'fontWeight',
            i: 'fill',
            a: 'align',
            s: 'stroke',
            t: 'strokeThickness',
            w: 'wordWrap',
            d: 'wordWrapWidth',
            l: 'lineHeight',
            h: 'dropShadow',
            c: 'dropShadowColor',
            n: 'dropShadowAngle',
            b: 'dropShadowBlur',
            p: 'padding',
            x: 'textBaseline',
            j: 'lineJoin',
            m: 'miterLimit',
            e: 'letterSpacing'
        }
        r.setStyle = r.ss = function (t) {
            for (const e in o) void 0 !== t[e] && (t[o[e]] = t[e], delete t[e])
            return this.style = t, this
        }, r.setShadow = r.sh = function (t, e, n) {
            const r = this.style
            return r.dropShadow = !0, void 0 !== t && (t = `#${t.toString(16)}`), r.dropShadowColor = a(t, r.dropShadowColor), r.dropShadowAngle = a(e, r.dropShadowAngle), r.dropShadowDistance = a(n, r.dropShadowDistance), this
        }
        var a = function (t, e) {
            return void 0 === t ? e : t
        }
    },
    './node_modules/@games/pixi-animate/lib/mixins/index.js': function (t, e, n) {
        'use strict'
        Object.defineProperty(e, '__esModule', {
            value: !0
        }), Object.defineProperty(e, 'Container', {
            enumerable: !0,
            get() {
                return r.default
            }
        }), Object.defineProperty(e, 'DisplayObject', {
            enumerable: !0,
            get() {
                return i.default
            }
        }), Object.defineProperty(e, 'Sprite', {
            enumerable: !0,
            get() {
                return o.default
            }
        }), Object.defineProperty(e, 'Graphics', {
            enumerable: !0,
            get() {
                return a.default
            }
        }), Object.defineProperty(e, 'Text', {
            enumerable: !0,
            get() {
                return s.default
            }
        })
        var r = u(n('./node_modules/@games/pixi-animate/lib/mixins/Container.js'))
        var i = u(n('./node_modules/@games/pixi-animate/lib/mixins/DisplayObject.js'))
        var o = u(n('./node_modules/@games/pixi-animate/lib/mixins/Sprite.js'))
        var a = u(n('./node_modules/@games/pixi-animate/lib/mixins/Graphics.js'))
        var s = u(n('./node_modules/@games/pixi-animate/lib/mixins/Text.js'))

        function u(t) {
            return t && t.__esModule
                ? t
                : {
                        default: t
                    }
        }
    },
    './node_modules/@games/quark/dist/quark.js': function (t, e) {
        (() => {
            'use strict'
            const e = {
                940: (t, e) => {
                    Object.defineProperty(e, '__esModule', {
                        value: !0
                    })
                    const n = (function () {
                        function t(t, e) {
                            for (let n = 0; n < e.length; n++) {
                                let r = e[n]
                                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
                            }
                        }
                        return function (e, n, r) {
                            return n && t(e.prototype, n), r && t(e, r), e
                        }
                    }())

                    function r(t, e) {
                        if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                    }
                    const i = (function () {
                        function t(e, n, i) {
                            void 0 === n && (n = !1), r(this, t), this._fn = e, this._once = n, this._thisArg = i, this._next = this._prev = this._owner = null
                        }
                        return n(t, [{
                            key: 'detach',
                            value () {
                                return this._owner !== null && (this._owner.detach(this), !0)
                            }
                        }]), t
                    }())

                    function o(t, e) {
                        return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e
                    }
                    const a = (function () {
                        function t() {
                            r(this, t), this._head = this._tail = void 0
                        }
                        return n(t, [{
                            key: 'handlers',
                            value () {
                                var t = !(arguments.length <= 0 || void 0 === arguments[0]) && arguments[0];
                                            var e = this._head
                                        if (t) return !!e
                                        for (var n = []; e;) n.push(e), e = e._next
                                        return n
                            }
                        }, {
                            key: 'has',
                            value (t) {
                                if (!(t instanceof i)) throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');
                                return t._owner === this
                            }
                        }, {
                            key: 'dispatch',
                            value () {
                                var t = this._head
                                        if (!t) return !1
                                        for (; t;) t._once && this.detach(t), t._fn.apply(t._thisArg, arguments), t = t._next
                                        return !0
                            }
                        }, {
                            key: 'add',
                            value (t) {
                                var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1]
                                        if ('function' != typeof t) throw new Error('MiniSignal#add(): First arg must be a Function.');
                                return o(this, new i(t, !1, e))
                            }
                        }, {
                            key: 'once',
                            value (t) {
                                var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1]
                                        if ('function' != typeof t) throw new Error('MiniSignal#once(): First arg must be a Function.');
                                return o(this, new i(t, !0, e))
                            }
                        }, {
                            key: 'detach',
                            value (t) {
                                if (!(t instanceof i)) throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');
                                return t._owner !== this || (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null), this
                            }
                        }, {
                            key: 'detachAll',
                            value () {
                                var t = this._head
                                        if (!t) return this
                                        for (this._head = this._tail = null; t;) t._owner = null, t = t._next
                                        return this
                            }
                        }]), t
                    }())
                    a.MiniSignalBinding = i, e.default = a, t.exports = e.default
                }
            }
            const n = {}

            function r(t) {
                const i = n[t]
                if (void 0 !== i) return i.exports
                const o = n[t] = {
                    exports: {}
                }
                return e[t](o, o.exports, r), o.exports
            }
            r.n = t => {
                const e = t && t.__esModule ? () => t.default : () => t
                return r.d(e, {
                    a: e
                }), e
            }, r.d = (t, e) => {
                for (const n in e) { r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
                    enumerable: !0,
                    get: e[n]
                })
                }
            }, r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), r.r = t => {
                typeof Symbol != 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                    value: 'Module'
                }), Object.defineProperty(t, '__esModule', {
                    value: !0
                })
            }
            const i = {};
            (() => {
                r.r(i), r.d(i, {
                    Alpha: () => G,
                    Attraction: () => X,
                    CircleZone: () => R,
                    Collision: () => H,
                    Color: () => J,
                    CrossZone: () => O,
                    EMITTER_ADDED: () => p,
                    EMITTER_REMOVED: () => m,
                    EULER: () => a,
                    Emitter: () => at,
                    Force: () => V,
                    Gravity: () => W,
                    GravityWell: () => Y,
                    ImageZone: () => A,
                    Life: () => D,
                    LineZone: () => I,
                    MEASURE: () => o,
                    Mass: () => L,
                    PARTICLE_CREATED: () => l,
                    PARTICLE_DEAD: () => d,
                    PARTICLE_SLEEP: () => f,
                    PARTICLE_UPDATE: () => h,
                    POOL_MAX: () => t,
                    PointZone: () => C,
                    Position: () => B,
                    RK2: () => s,
                    RK4: () => u,
                    Radius: () => F,
                    RandomDrift: () => z,
                    Rate: () => et,
                    RectZone: () => k,
                    Repulsion: () => q,
                    Rotate: () => K,
                    Scale: () => Z,
                    Span: () => E,
                    TIME_STEP: () => e,
                    USE_CLOCK: () => n,
                    VERLET: () => c,
                    Vector2D: () => y,
                    Velocity: () => j,
                    addBehaviors: () => ct,
                    addInitializers: () => ut,
                    getSpan: () => st
                })
                const t = 1e3
                const e = 60
                const n = !1
                const o = 100
                const a = 'euler'
                const s = 'runge-kutta2'
                const u = 'runge-kutta4'
                const c = 'verlet'
                const l = 'partilcleCreated'
                const h = 'partilcleUpdate'
                const f = 'particleSleep'
                const d = 'partilcleDead'
                const p = 'emitterAdded'
                const m = 'emitterRemoved'
                class y {
                    constructor(t, e) {
                        this.x = t || 0, this.y = e || 0
                    }

                    set(t, e) {
                        return this.x = t, this.y = e, this
                    }

                    setX(t) {
                        return this.x = t, this
                    }

                    setY(t) {
                        return this.y = t, this
                    }

                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e
                                break
                            case 1:
                                this.y = e
                                break
                            default:
                                throw new Error(`index is out of range: ${t}`)
                        }
                    }

                    getGradient() {
                        return this.x != 0 ? Math.atan2(this.y, this.x) : this.y > 0 ? Math.PI / 2 : this.y < 0 ? -Math.PI / 2 : void 0
                    }

                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x
                            case 1:
                                return this.y
                            default:
                                throw new Error(`index is out of range: ${t}`)
                        }
                    }

                    copy(t) {
                        return this.x = t.x, this.y = t.y, this
                    }

                    add(t, e) {
                        return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this)
                    }

                    addXY(t, e) {
                        return this.x += t, this.y += e, this
                    }

                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this
                    }

                    addScalar(t) {
                        return this.x += t, this.y += t, this
                    }

                    sub(t, e) {
                        return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this)
                    }

                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this
                    }

                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this
                    }

                    divideScalar(t) {
                        return t !== 0 ? (this.x /= t, this.y /= t) : this.set(0, 0), this
                    }

                    min(t) {
                        return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this
                    }

                    max(t) {
                        return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this
                    }

                    clamp(t, e) {
                        return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this
                    }

                    negate() {
                        return this.multiplyScalar(-1)
                    }

                    dot(t) {
                        return this.x * t.x + this.y * t.y
                    }

                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }

                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }

                    normalize() {
                        return this.divideScalar(this.length())
                    }

                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }

                    rotate(t) {
                        const e = this.x
                        const n = this.y
                        return this.x = e * Math.cos(t) + n * Math.sin(t), this.y = -e * Math.sin(t) + n * Math.cos(t), this
                    }

                    distanceToSquared(t) {
                        const e = this.x - t.x
                        const n = this.y - t.y
                        return e * e + n * n
                    }

                    setLength(t) {
                        const e = this.length()
                        return e !== 0 && t !== e && this.multiplyScalar(t / e), this
                    }

                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                    }

                    equals(t) {
                        return t.x === this.x && t.y === this.y
                    }

                    toArray() {
                        return [this.x, this.y]
                    }

                    clear() {
                        return this.x = 0, this.y = 0, this
                    }

                    clone() {
                        return new y(this.x, this.y)
                    }
                }
                class v {
                    constructor(t = 255, e = 255, n = 255) {
                        this.r = t, this.g = e, this.b = n
                    }

                    reset() {
                        this.r = 255, this.g = 255, this.b = 255
                    }
                }
                let _ = 0
                class g {
                    constructor() {
                        this.id = _++, this.reset(!0), this.sprite = null, this.update = this.update, this.destroy = this.destroy
                    }

                    getDirection() {
                        return Math.atan2(this.v.x, -this.v.y) * (180 / Math.PI)
                    }

                    reset(t) {
                        return this.life = 1 / 0, this.age = 0, this.energy = 1, this.dead = !1, this.sleep = !1, this.target = null, this.parent = null, this.mass = 1, this.radius = 10, this.alpha = 1, this.scale = 1, this.rotation = 0, this.color = null, this.easing = t => t, this.transform = {}, this.rgb = new v(), this.data = {}, t
                            ? (this.p = new y(), this.v = new y(), this.a = new y(), this.old = {
                                    p: new y(),
                                    v: new y(),
                                    a: new y()
                                }, this.behaviors = [])
                            : (this.p.set(0, 0), this.v.set(0, 0), this.a.set(0, 0), this.old.p.set(0, 0), this.old.v.set(0, 0), this.old.a.set(0, 0), this.removeAllBehaviors()), this
                    }

                    update(t, e) {
                        const n = this.age + e
                        if (n >= this.life) return this.destroy(), !1
                        this.age = n
                        const r = this.behaviors.length
                        let i
                        for (i = 0; i < r; i++) this.behaviors[i] && this.behaviors[i].applyBehavior(this, e, t)
                        if (this.dead) return this.destroy(), !1
                        const o = this.easing(this.age / this.life)
                        return this.energy = Math.max(1 - o, 0), !0
                    }

                    addBehavior(t) {
                        this.behaviors.push(t), t.hasOwnProperty('parents') && t.parents.push(this), t.initialize(this)
                    }

                    addBehaviors(t) {
                        let e; const n = t.length
                        for (e = 0; e < n; e++) this.addBehavior(t[e])
                    }

                    removeBehavior(t) {
                        const e = this.behaviors.indexOf(t)
                        e > -1 && ((t = this.behaviors.splice(e, 1)).parents = null)
                    }

                    removeAllBehaviors() {
                        this.behaviors.length = 0
                    }

                    destroy() {
                        this.removeAllBehaviors(), this.energy = 0, this.dead = !0, this.parent = null
                    }
                }

                function b(t, e, n) {
                    return n ? Math.floor(Math.random() * (e - t)) + t : t + Math.random() * (e - t)
                }
                class E {
                    constructor(t, e, n = !1) {
                        Array.isArray(t) ? (this.isArray = !0, this.a = t) : (this.a = t, this.b = e || this.a, this.center = n)
                    }

                    getValue(t) {
                        return this.isArray
                            ? this.a[Math.floor(this.a.length * Math.random())]
                            : this.center
                                ? (function (t, e, n) {
                                        return b(t - e, t + e, n)
                                    }(this.a, this.b, t))
                                : b(this.a, this.b, t)
                    }
                }
                const x = {
                    easeLinear: t => t,
                    easeInQuad: t => t ** 2,
                    easeOutQuad: t => -((t - 1) ** 2 - 1),
                    easeInOutQuad: t => (t /= 0.5) < 1 ? 0.5 * t ** 2 : -0.5 * ((t -= 2) * t - 2),
                    easeInCubic: t => t ** 3,
                    easeOutCubic: t => (t - 1) ** 3 + 1,
                    easeInOutCubic: t => (t /= 0.5) < 1 ? 0.5 * t ** 3 : 0.5 * ((t - 2) ** 3 + 2),
                    easeInQuart: t => t ** 4,
                    easeOutQuart: t => -((t - 1) ** 4 - 1),
                    easeInOutQuart: t => (t /= 0.5) < 1 ? 0.5 * t ** 4 : -0.5 * ((t -= 2) * t ** 3 - 2),
                    easeInSine: t => 1 - Math.cos(t * (Math.PI / 2)),
                    easeOutSine: t => Math.sin(t * (Math.PI / 2)),
                    easeInOutSine: t => -0.5 * (Math.cos(Math.PI * t) - 1),
                    easeInExpo: t => t === 0 ? 0 : 2 ** (10 * (t - 1)),
                    easeOutExpo: t => t === 1 ? 1 : 1 - 2 ** (-10 * t),
                    easeInOutExpo: t => t === 0 ? 0 : t === 1 ? 1 : (t /= 0.5) < 1 ? 0.5 * 2 ** (10 * (t - 1)) : 0.5 * (2 - 2 ** (-10 * --t)),
                    easeInCirc: t => -(Math.sqrt(1 - t * t) - 1),
                    easeOutCirc: t => Math.sqrt(1 - (t - 1) ** 2),
                    easeInOutCirc: t => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
                    easeInBack(t) {
                        const e = 1.70158
                        return t * t * ((e + 1) * t - e)
                    },
                    easeOutBack(t) {
                        const e = 1.70158
                        return (t -= 1) * t * ((e + 1) * t + e) + 1
                    },
                    easeInOutBack(t) {
                        let e = 1.70158
                        return (t /= 0.5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
                    }
                }

                function T(t) {
                    return x[t]
                }
                let S = 0
                class w {
                    constructor(t, e = 'easeLinear') {
                        this.id = 1048575 + S++, this.life = t || 1 / 0, this.easing = T(e), this.age = 0, this.energy = 1, this.dead = !1, this.parents = [], this.name = 'Behavior', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e) {
                        this.life = t || 1 / 0, this.easing = e || T('easeLinear')
                    }

                    normalizeForce(t) {
                        return t.multiplyScalar(o)
                    }

                    normalizeValue(t) {
                        return t * o
                    }

                    initialize(t) {}
                    applyBehavior(t, e, n) {
                        if (this.age += e, this.age >= this.life || this.dead) { this.energy = 0, this.dead = !0, this.destroy()
                        }
                        else {
                            const e = this.easing(t.age / t.life)
                            this.energy = Math.max(1 - e, 0)
                        }
                    }

                    destroy() {
                        let t
                        const e = this.parents.length
                        for (t = 0; t < e; t++) this.parents[t].removeBehavior(this)
                        this.parents = []
                    }
                }
                class O extends w {
                    constructor(t, e, n, r) {
                        super(n, r), this.reset(t, e), this.name = 'CrossZone', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r) {
                        this.zone = t, this.zone.crossType = Q.initValue(e, O.CROSS_TYPES.DEAD), n && super.reset(n, r)
                    }

                    applyBehavior(t, e, n) {
                        super.applyBehavior(t, e, n), this.zone.crossing(t)
                    }
                }
                O.CROSS_TYPES = {
                    CROSS: 1,
                    DEAD: 4,
                    BOUND: 8
                }
                class P {
                    constructor() {
                        this.vector = new y(0, 0), this.random = 0, this.crossType = O.CROSS_TYPES.DEAD, this.alert = !0
                    }

                    getPosition() {}
                    crossing(t) {}
                }
                class R extends P {
                    constructor(t, e, n) {
                        super(), this.x = t, this.y = e, this.radius = n, this.angle = 0, this.center = {
                            x: this.x,
                            y: this.y
                        }
                    }

                    getPosition() {
                        return this.random = Math.random(), this.angle = 2 * Math.PI * Math.random(), this.vector.x = this.x + this.random * this.radius * Math.cos(this.angle), this.vector.y = this.y + this.random * this.radius * Math.sin(this.angle), this.vector
                    }

                    setCenter(t, e) {
                        this.center.x = t, this.center.y = e
                    }

                    crossing(t) {
                        const e = t.p.distanceTo(this.center)
                        this.crossType == O.CROSS_TYPES.DEAD ? e - t.radius > this.radius && (t.dead = !0) : this.crossType == O.CROSS_TYPES.BOUND ? e + t.radius >= this.radius && this.getSymmetric(t) : this.crossType == O.CROSS_TYPES.CROSS && this.alert && (console.error('Sorry CircleZone does not support cross method'), this.alert = !1)
                    }

                    getSymmetric(t) {
                        const e = t.v.getGradient()
                        const n = 2 * (this.getGradient(t) - e)
                        const r = t.v.x
                        const i = t.v.y
                        t.v.x = r * Math.cos(n) - i * Math.sin(n), t.v.y = r * Math.sin(n) + i * Math.cos(n)
                    }

                    getGradient(t) {
                        return -Math.PI / 2 + Math.atan2(t.p.y - this.center.y, t.p.x - this.center.x)
                    }
                }
                class A extends P {
                    constructor(t, e, n, r) {
                        super(), this.reset(t, e, n, r)
                    }

                    reset(t, e, n, r) {
                        this.imageData = t, this.x = e, this.y = n, this.d = r || 2, this.vectors = [], this.setVectors()
                    }

                    setVectors() {
                        let t, e
                        const n = this.imageData.width
                        const r = this.imageData.height
                        for (t = 0; t < n; t += this.d) {
                            for (e = 0; e < r; e += this.d) {
                                const r = 4 * ((e >> 0) * n + (t >> 0))
                                this.imageData.data[r + 3] > 0 && this.vectors.push({
                                    x: t + this.x,
                                    y: e + this.y
                                })
                            }
                        }
                        return this.vector
                    }

                    getBound(t, e) {
                        const n = 4 * ((e >> 0) * this.imageData.width + (t >> 0))
                        return this.imageData.data[n + 3] > 0
                    }

                    getPosition() {
                        return this.vector.copy(this.vectors[Math.floor(Math.random() * this.vectors.length)])
                    }

                    getColor(t, e) {
                        t -= this.x
                        const n = 4 * (((e -= this.y) >> 0) * this.imageData.width + (t >> 0))
                        return {
                            r: this.imageData.data[n],
                            g: this.imageData.data[n + 1],
                            b: this.imageData.data[n + 2],
                            a: this.imageData.data[n + 3]
                        }
                    }

                    crossing(t) {
                        this.crossType == 'dead' ? this.getBound(t.p.x - this.x, t.p.y - this.y) ? t.dead = !0 : t.dead = !1 : this.crossType == 'bound' && (this.getBound(t.p.x - this.x, t.p.y - this.y) || t.v.negate())
                    }
                }
                class I extends P {
                    constructor(t, e, n, r, i) {
                        super(), n - t >= 0 ? (this.x1 = t, this.y1 = e, this.x2 = n, this.y2 = r) : (this.x1 = n, this.y1 = r, this.x2 = t, this.y2 = e), this.dx = this.x2 - this.x1, this.dy = this.y2 - this.y1, this.minx = Math.min(this.x1, this.x2), this.miny = Math.min(this.y1, this.y2), this.maxx = Math.max(this.x1, this.x2), this.maxy = Math.max(this.y1, this.y2), this.dot = this.x2 * this.y1 - this.x1 * this.y2, this.xxyy = this.dx * this.dx + this.dy * this.dy, this.gradient = this.getGradient(), this.length = this.getLength(), this.direction = i || 1
                    }

                    getPosition() {
                        return this.random = Math.random(), this.vector.x = this.x1 + this.random * this.length * Math.cos(this.gradient), this.vector.y = this.y1 + this.random * this.length * Math.sin(this.gradient), this.vector
                    }

                    crossing(t) {
                        const e = this
                        this.crossType == O.CROSS_TYPES.DEAD
                            ? this.direction == 1
                                ? this.getRange(t, () => {
                                        e.getDirection(t.p.x, t.p.y) && (t.dead = !0)
                                    })
                                : this.getRange(t, () => {
                                        e.getDirection(t.p.x, t.p.y) || (t.dead = !0)
                                    })
                            : this.crossType == O.CROSS_TYPES.BOUND
                                ? this.getRange(t, () => {
                                        e.getDistance(t.p.x, t.p.y) <= t.radius && (e.dx == 0 ? t.v.x *= -1 : e.dy == 0 ? t.v.y *= -1 : e.getSymmetric(t.v))
                                    })
                                : this.crossType == O.CROSS_TYPES.CROSS && this.alert && (console.error('Sorry lineZone does not support cross method'), this.alert = !1)
                    }

                    getDirection(t, e) {
                        const n = this.dy
                        const r = -this.dx
                        return (n * t + r * e + this.dot) * (r == 0 ? 1 : r) > 0
                    }

                    getDistance(t, e) {
                        return (this.dy * t + -this.dx * e + this.dot) / Math.sqrt(this.xxyy)
                    }

                    getSymmetric(t) {
                        const e = t.getGradient()
                        const n = 2 * (this.getGradient() - e)
                        const r = t.x
                        const i = t.y
                        return t.x = r * Math.cos(n) - i * Math.sin(n), t.y = r * Math.sin(n) + i * Math.cos(n), t
                    }

                    getGradient() {
                        return Math.atan2(this.dy, this.dx)
                    }

                    getRange(t, e) {
                        Math.abs(this.getGradient()) <= Math.PI / 4 ? t.p.x < this.maxx && t.p.x > this.minx && e() : t.p.y < this.maxy && t.p.y > this.miny && e()
                    }

                    getLength() {
                        return Math.sqrt(this.dx * this.dx + this.dy * this.dy)
                    }
                }
                class C extends P {
                    constructor(t, e) {
                        super(), this.x = t, this.y = e
                    }

                    getPosition() {
                        return this.vector.x = this.x, this.vector.y = this.y, this.vector
                    }

                    crossing(t) {
                        this.alert && (console.error('Sorry PointZone does not support crossing method'), this.alert = !1)
                    }
                }
                class k extends P {
                    constructor(t, e, n, r) {
                        super(), this.x = t, this.y = e, this.width = n, this.height = r
                    }

                    getPosition() {
                        return this.vector.x = this.x + Math.random() * this.width, this.vector.y = this.y + Math.random() * this.height, this.vector
                    }

                    crossing(t) {
                        this.crossType == O.CROSS_TYPES.DEAD
                            ? (function (t, e) {
                                    return t.p.x + t.radius >= e.x && t.p.x - t.radius <= e.x + e.width && t.p.y + t.radius >= e.y && t.p.y - t.radius <= e.y + e.height
                                }(t, this)) && (t.dead = !0)
                            : this.crossType == O.CROSS_TYPES.BOUND ? (t.p.x - t.radius < this.x ? (t.p.x = this.x + t.radius, t.v.x *= -1) : t.p.x + t.radius > this.x + this.width && (t.p.x = this.x + this.width - t.radius, t.v.x *= -1), t.p.y - t.radius < this.y ? (t.p.y = this.y + t.radius, t.v.y *= -1) : t.p.y + t.radius > this.y + this.height && (t.p.y = this.y + this.height - t.radius, t.v.y *= -1)) : this.crossType == O.CROSS_TYPES.CROSS && (t.p.x + t.radius < this.x && t.v.x <= 0 ? t.p.x = this.x + this.width + t.radius : t.p.x - t.radius > this.x + this.width && t.v.x >= 0 && (t.p.x = this.x - t.radius), t.p.y + t.radius < this.y && t.v.y <= 0 ? t.p.y = this.y + this.height + t.radius : t.p.y - t.radius > this.y + this.height && t.v.y >= 0 && (t.p.y = this.y - t.radius))
                    }
                }
                class N {
                    constructor() {}
                    reset() {}
                    init(t, e) {
                        e ? this.initialize(e) : this.initialize(t)
                    }

                    initialize() {}
                }
                class M {
                    constructor(t, e) {
                        this.r = Math.abs(t) || 0, this.tha = e || 0
                    }

                    set(t, e) {
                        return this.r = t, this.tha = e, this
                    }

                    setR(t) {
                        return this.r = t, this
                    }

                    setTha(t) {
                        return this.tha = t, this
                    }

                    copy(t) {
                        return this.r = t.r, this.tha = t.tha, this
                    }

                    toVector() {
                        return new y(this.getX(), this.getY())
                    }

                    getX() {
                        return this.r * Math.sin(this.tha)
                    }

                    getY() {
                        return -this.r * Math.cos(this.tha)
                    }

                    normalize() {
                        return this.r = 1, this
                    }

                    equals(t) {
                        return t.r === this.r && t.tha === this.tha
                    }

                    toArray() {
                        return [this.r, this.tha]
                    }

                    clear() {
                        return this.r = 0, this.tha = 0, this
                    }

                    clone() {
                        return new M(this.r, this.tha)
                    }
                }
                class j extends N {
                    constructor(t, e, n) {
                        super(), this.speed = new E(...t), this.angle = new E(...e), this.type = Q.initValue(n, 'vector'), this.POLAR = 'polar', this.P = 'p', this.speedVal = this.speed.getValue(), this.normalizedPI = Math.PI / 180
                    }

                    reset(t, e, n) {
                        this.speed = Q.setSpanValue(t), this.angle = Q.setSpanValue(e), this.type = Q.initValue(n, 'vector')
                    }

                    normalizeVelocity(t) {
                        return t * o
                    }

                    initialize(t) {
                        if (this.type == this.P || this.type == this.P || this.type == this.POLAR) {
                            const e = b(this.angle.a, this.angle.b) * this.normalizedPI
                            const n = new M(this.normalizeVelocity(this.speed.getValue()), e)
                            t.v.x = n.getX(), t.v.y = n.getY()
                        } else { t.v.x = this.normalizeVelocity(this.speed.getValue()), t.v.y = this.normalizeVelocity(this.angle.getValue())
                        }
                    }
                }
                class D extends N {
                    constructor(t, e, n) {
                        super(), this.lifePan = Q.setSpanValue(t, e, n)
                    }

                    initialize(t) {
                        this.lifePan.a == 1 / 0 ? t.life = 1 / 0 : t.life = this.lifePan.getValue()
                    }
                }
                class L extends N {
                    constructor(t, e, n) {
                        super(), this.massPan = Q.setSpanValue(t, e, n)
                    }

                    initialize(t) {
                        t.mass = this.massPan.getValue()
                    }
                }
                class F extends N {
                    constructor(t, e, n) {
                        super(), this.radius = Q.setSpanValue(t, e, n)
                    }

                    reset(t, e, n) {
                        this.radius = Q.setSpanValue(t, e, n)
                    }

                    initialize(t) {
                        t.radius = this.radius.getValue(), t.transform.oldRadius = t.radius
                    }
                }
                class B extends N {
                    constructor(t) {
                        super(), this.zone = t || new C()
                    }

                    reset(t) {
                        this.zone = t || new C()
                    }

                    initialize(t) {
                        this.zone.getPosition(), t.p.x = this.zone.vector.x, t.p.y = this.zone.vector.y
                    }
                }
                class U extends w {
                    constructor(t, e, n, r) {
                        super(n, r), this.skipUpdate = !1, this.reset(t, e, n, r)
                    }

                    reset(t, e, n, r) {
                        e == null && (this.skipUpdate = !0), n && super.reset(n, r)
                    }
                }
                class G extends U {
                    constructor(t, e, n, r) {
                        super(t, e, n, r), this.name = 'Alpha', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r) {
                        super.reset(t, e, n, r), this.a = Q.setSpanValue(t || 1), this.skipUpdate || (this.b = Q.setSpanValue(e))
                    }

                    initialize(t) {
                        t.transform.alphaA = this.a.getValue(), this.skipUpdate ? (t.transform.alphaB = t.transform.alphaA, t.alpha = t.transform.alphaA) : t.transform.alphaB = this.b.getValue()
                    }

                    applyBehavior(t, e, n) {
                        this.skipUpdate || (super.applyBehavior(t, e, n), t.alpha = t.transform.alphaB + (t.transform.alphaA - t.transform.alphaB) * this.energy, t.alpha < 0.001 && (t.alpha = 0))
                    }
                }
                class X extends w {
                    constructor(t, e, n, r, i) {
                        super(r, i), this.targetPosition = t || new y(), this.radius = n || 1e3, this.force = this.normalizeValue(e) || 100, this.radiusSq = this.radius * this.radius, this.attractionForce = new y(), this.lengthSq = 0, this.name = 'Attraction', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r, i) {
                        this.targetPosition = t || new y(), this.radius = n || 1e3, this.force = this.normalizeValue(e) || 100, this.radiusSq = this.radius * this.radius, this.attractionForce = new y(), this.lengthSq = 0, r && super.reset(r, i)
                    }

                    applyBehavior(t, e, n) {
                        super.applyBehavior(t, e, n), this.attractionForce.copy(this.targetPosition), this.attractionForce.sub(t.p), this.lengthSq = this.attractionForce.lengthSq(), this.lengthSq > 4e-6 && this.lengthSq < this.radiusSq && (this.attractionForce.normalize(), this.attractionForce.multiplyScalar(1 - this.lengthSq / this.radiusSq), this.attractionForce.multiplyScalar(this.force), t.a.add(this.attractionForce))
                    }
                }
                class H extends w {
                    constructor(t, e, n, r, i) {
                        super(r, i), this.reset(t, e, n), this.name = 'Collision', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r, i) {
                        this.emitter = t || null, this.mass = e || !0, this.callback = n || null, this.collisionPool = [], this.delta = new y(), r && super.reset(r, i)
                    }

                    applyBehavior(t, e, n) {
                        const r = this.emitter.particles.slice(n)
                        let i, o, a, s, u
                        const c = r.length
                        for (let e = 0; e < c; e++) {
                            if (i = r[e], i && i !== t) {
                                this.delta.copy(i.p), this.delta.sub(t.p), o = this.delta.lengthSq()
                                const e = t.radius + i.radius
                                if (o <= e * e) {
                                    a = e - Math.sqrt(o), a += 0.5
                                    const n = t.mass + i.mass
                                    s = this.mass ? i.mass / n : 0.5, u = this.mass ? t.mass / n : 0.5, t.p.add(this.delta.clone().normalize().multiplyScalar(a * -s)), i.p.add(this.delta.normalize().multiplyScalar(a * u)), this.callback && this.callback(t, i)
                                }
                            }
                        }
                    }
                }
                class V extends w {
                    constructor(t, e, n, r) {
                        super(n, r), this.force = this.normalizeForce(new y(t, e)), this.name = 'Force', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r) {
                        this.force = this.normalizeForce(new y(t, e)), n && super.reset(n, r)
                    }

                    applyBehavior(t, e, n) {
                        super.applyBehavior(t, e, n), t.a.add(this.force)
                    }
                }
                class W extends V {
                    constructor(t, e, n) {
                        super(0, t, e, n), this.name = 'Gravity', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n) {
                        super.reset(0, t, e, n)
                    }
                }
                class Y extends w {
                    constructor(t, e, n, r) {
                        super(n, r), this.distanceVec = new y(), this.centerPoint = Q.initValue(t, new y()), this.force = Q.initValue(this.normalizeValue(e), 100), this.name = 'GravityWell', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r) {
                        this.distanceVec = new y(), this.centerPoint = Q.initValue(t, new y()), this.force = Q.initValue(this.normalizeValue(e), 100), n && super.reset(n, r)
                    }

                    initialize(t) {}
                    applyBehavior(t, e, n) {
                        this.distanceVec.set(this.centerPoint.x - t.p.x, this.centerPoint.y - t.p.y)
                        const r = this.distanceVec.lengthSq()
                        if (r != 0) {
                            const n = this.distanceVec.length()
                            const i = this.force * e / (r * n)
                            t.v.x += i * this.distanceVec.x, t.v.y += i * this.distanceVec.y
                        }
                    }
                }
                class z extends w {
                    constructor(t, e, n, r, i) {
                        super(r, i), this.reset(t, e, n), this.time = 0, this.name = 'RandomDrift', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r, i) {
                        this.panFoce = new y(t, e), this.panFoce = this.normalizeForce(this.panFoce), this.delay = n, r && z._super_.prototype.reset.call(this, r, i)
                    }

                    applyBehavior(t, e, n) {
                        super.applyBehavior(t, e, n), this.time += e, this.time >= this.delay && (t.a.addXY(b(-this.panFoce.x, this.panFoce.x), b(-this.panFoce.y, this.panFoce.y)), this.time = 0)
                    }
                }
                class q extends X {
                    constructor(t, e, n, r, i) {
                        super(t, e, n, r, i), this.force *= -1, this.name = 'Repulsion', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r, i) {
                        super.reset(t, e, n, r, i), this.force *= -1
                    }
                }
                class K extends U {
                    constructor(t, e, n, r, i) {
                        super(t, e, r, i), this.name = 'Rotate', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r, i) {
                        super.reset(t, e, r, i), this.a = Q.setSpanValue(t || K.TYPE.VELOCITY), this.skipUpdate || (this.b = Q.setSpanValue(e || 0)), this.style = n || K.STYLES.TO
                    }

                    initialize(t) {
                        t.rotation = this.a.getValue(), t.transform.rotationA = this.a.getValue(), this.skipUpdate || (t.transform.rotationB = this.b.getValue())
                    }

                    applyBehavior(t, e, n) {
                        this.skipUpdate ? this.a.a == K.TYPE.VELOCITY && (t.rotation = t.getDirection()) : (super.applyBehavior(t, e, n), this.style == K.STYLES.TO ? t.rotation = t.transform.rotationB + (t.transform.rotationA - t.transform.rotationB) * this.energy : t.rotation += t.transform.rotationB)
                    }
                }
                K.STYLES = {
                    TO: 1,
                    FROM: 2
                }, K.TYPE = {
                    VELOCITY: 1
                }
                class Z extends U {
                    constructor(t, e, n, r) {
                        super(t, e, n, r), this.name = 'Scale', this.applyBehavior = this.applyBehavior
                    }

                    reset(t, e, n, r) {
                        super.reset(t, e, n, r), this.a = Q.setSpanValue(Q.initValue(t, 1)), this.skipUpdate || (this.b = Q.setSpanValue(e))
                    }

                    initialize(t) {
                        t.transform.scaleA = this.a.getValue(), t.transform.oldRadius = t.radius, this.skipUpdate ? (t.transform.scaleB = t.transform.scaleA, t.scale = t.transform.scaleA, t.radius = t.transform.oldRadius * t.transform.scaleA) : t.transform.scaleB = this.b.getValue()
                    }

                    applyBehavior(t, e, n) {
                        this.skipUpdate || (super.applyBehavior(t, e, n), t.scale = t.transform.scaleB + (t.transform.scaleA - t.transform.scaleB) * this.energy, t.scale < 1e-4 && (t.scale = 0), t.radius = t.transform.oldRadius * t.scale)
                    }
                }
                const $ = {
                    hexToRgb(t) {
                        const e = t.charAt(0) === '#' ? t.substring(1, 7) : t
                        return {
                            r: Number.parseInt(e.substring(0, 2), 16),
                            g: Number.parseInt(e.substring(2, 4), 16),
                            b: Number.parseInt(e.substring(4, 6), 16)
                        }
                    },
                    rgbToHex: t => `rgb(${t.r}, ${t.g}, ${t.b})`,
                    getHex16FromParticle: t => 65536 * Number(t.rgb.r) + 256 * Number(t.rgb.g) + Number(t.rgb.b)
                }
                class J extends U {
                    constructor(t, e, n, r) {
                        super(t, e, n, r), this.name = 'Color'
                    }

                    reset(t, e, n, r) {
                        super.reset(t, e, n, r), this.a = Q.setSpanValue(t), this.skipUpdate || (this.b = Q.setSpanValue(e))
                    }

                    initialize(t) {
                        t.color = this.a.getValue(), t.data.colorA = $.hexToRgb(t.color), this.skipUpdate || (t.data.colorB = $.hexToRgb(this.b.getValue()))
                    }

                    applyBehavior(t, e, n) {
                        super.applyBehavior(t, e, n), this.skipUpdate ? (t.rgb.r = t.data.colorA.r, t.rgb.g = t.data.colorA.g, t.rgb.b = t.data.colorA.b) : (t.rgb.r = t.data.colorB.r + (t.data.colorA.r - t.data.colorB.r) * this.energy, t.rgb.g = t.data.colorB.g + (t.data.colorA.g - t.data.colorB.g) * this.energy, t.rgb.b = t.data.colorB.b + (t.data.colorA.b - t.data.colorB.b) * this.energy, t.rgb.r = ~~t.rgb.r, t.rgb.g = ~~t.rgb.g, t.rgb.b = ~~t.rgb.b)
                    }
                }
                const Q = {
                    initValue: (t, e) => t != null && t != null ? t : e,
                    getVector2D: (t, e) => typeof t == 'object' ? t : new y(t, e),
                    judgeVector2D(t) {
                        let e = ''
                        return (t.hasOwnProperty('x') || t.hasOwnProperty('y') || t.hasOwnProperty('p') || t.hasOwnProperty('position')) && (e += 'p'), (t.hasOwnProperty('vx') || t.hasOwnProperty('vx') || t.hasOwnProperty('v') || t.hasOwnProperty('velocity')) && (e += 'v'), (t.hasOwnProperty('ax') || t.hasOwnProperty('ax') || t.hasOwnProperty('a') || t.hasOwnProperty('accelerate')) && (e += 'a'), e
                    },
                    setVector2DByObject(t, e) {
                        e.x && (t.p.x = e.x), e.y && (t.p.y = e.y), e.vx && (t.v.x = e.vx), e.vy && (t.v.y = e.vy), e.ax && (t.a.x = e.ax), e.ay && (t.a.y = e.ay)
                    },
                    setSpanValue: (t, e, n) => t.constructor === E ? t : e ? n ? new E(t, e, n) : new E(t, e) : new E(t),
                    getSpanValue: t => t.constructor === E ? t.getValue() : t,
                    addInitializers(t, {
                        initializers: e,
                            emitterGuide: n,
                            emitterGuideType: r
                    }) {
                        if (!e) return
                        const {
                            life: i,
                            mass: o,
                            radius: a,
                            velocity: s
                        } = e
                        if (n) {
                            const {
                                width: e,
                                height: i
                            } = n
                            let o
                            switch (r) {
                                case 'circle':
                                    o = new R(0, 0, e / 2)
                                    break
                                case 'rect':
                                case 'rectangle':
                                    o = new k(0, 0, e, i)
                            }
                            o && t.addInitialize(new B(o))
                        }
                        i && t.addInitialize(new D(...i)), o && t.addInitialize(new L(...o)), a && t.addInitialize(new F(...a)), s && (s.speed = [].concat(s.speed), t.addInitialize(new j(s.speed, s.angle, 'polar')))
                    },
                    addBehaviors(t, {
                        behaviors: e
                    }) {
                        if (!e) return
                        const {
                            zone: n,
                            boundingZone: r,
                            deadZone: i,
                            alpha: o,
                            attraction: a,
                            collision: s,
                            gravity: u,
                            gravityWell: c,
                            randomDrift: l,
                            repulsion: h,
                            rotation: f,
                            scale: d,
                            color: p
                        } = e
                        r && t.addBehavior(tt(['bounding', ...r])), i && t.addBehavior(tt(['dead', ...i])), n && t.addBehavior(tt(n)), o && t.addBehavior(new G(o.from, o.to)), a && t.addBehavior(new X(new y(...a.center), a.force, a.radius)), u && t.addBehavior(new W(...u)), c && t.addBehavior(new Y(new y(...c.center), c.force)), l && t.addBehavior(new z(l.x, l.y, l.delay)), h && t.addBehavior(new q(new y(...h.center), h.force, h.radius)), f && t.addBehavior(new K(f.from, f.to)), d && t.addBehavior(new Z(d.from, d.to)), p && t.addBehavior(new J(p.from, p.to))
                    }
                }

                function tt(t) {
                    let e; let n; let [r, i, o, a, s, u] = t
                    if (t.guide) {
                        const e = t.guide.getBounds()
                        r = t.type, i = 'rect', o = e.x, a = e.y, s = e.width, u = e.height, t.guide.visible = !1
                    }
                    switch (r) {
                        case 'bounding':
                            n = O.CROSS_TYPES.BOUND
                            break
                        case 'dead':
                            n = O.CROSS_TYPES.DEAD
                    }
                    switch (i) {
                        case 'circle':
                            e = new R(o, a, s / 2)
                            break
                        case 'rect':
                            e = new k(o, a, s, u)
                    }
                    return new O(e, n)
                }
                class et {
                    constructor(t, e) {
                        this.amount = new E(...t), this.interval = new E(...e), this.startTime = 0, this.nextTime = 0, this.init()
                    }

                    init() {
                        this.startTime = 0, this.nextTime = this.interval.getValue()
                    }

                    getValue(t, e = !1) {
                        return this.startTime += t, this.startTime >= this.nextTime || e ? (this.startTime = 0, this.nextTime = this.interval.getValue(), this.amount.b == 1 ? this.amount.getValue(!1) > 0.5 ? 1 : 0 : this.amount.getValue(!0)) : 0
                    }
                }
                class nt {
                    constructor(t) {
                        this.type = t || a, this.integrate = this.integrate, this.eulerIntegrate = this.eulerIntegrate
                    }

                    integrate(t, e, n) {
                        this.eulerIntegrate(t, e, n)
                    }

                    eulerIntegrate(t, e, n) {
                        t.sleep || (t.old.p.copy(t.p), t.old.v.copy(t.v), t.a.multiplyScalar(1 / t.mass), t.v.add(t.a.multiplyScalar(e)), t.p.add(t.old.v.multiplyScalar(e)), n && t.v.multiplyScalar(n), t.a.clear())
                    }
                }

                function rt(t, e, n) {
                    Q.setVector2DByObject(e, n)
                }
                const it = r(940)
                const ot = r.n(it)
                class at extends g {
                    constructor(t) {
                        super(), this._isFirstEmit = !0, this.initializes = [], this.behaviors = [], this.emitTime = 0, this.emitTotalTimes = -1, this.isEmitting = !0, this.damping = 0.006, this.bindEmitter = !0, this.rate = null, this.config = t, this.integrator = new nt(), this.maxParticles = t.maxParticles || 5e4, this.particles = [], this.particleCreated = new (ot())(), this.particleUpdate = new (ot())(), this.particleDead = new (ot())(), this.update = this.update, this.emitting = this.emitting, this.createParticle = this.createParticle, this.integrate = this.integrate, this.updateParticle = this.updateParticle
                    }

                    set config(t) {
                        t.rate && (this.rate = new et(t.rate.amount, t.rate.interval)), t.initializers && (this.removeInitializers(), Q.addInitializers(this, t)), t.behaviors && (this.removeAllBehaviors(), Q.addBehaviors(this, t))
                    }

                    createParticle(t) {
                        const e = this.particles.length
                        if (e === this.maxParticles) return
                        const n = new g()
                        this.particles.push(n), n.reset(),
                        (function (t, e, n) {
                            const r = n.length
                            for (let i = 0; i < r; i++) {
                                const r = n[i]
                                r instanceof N ? r.init(t, e) : rt(0, e, r)
                            }!(function (t, e) {
                                t.bindEmitter && (e.p.add(t.p), e.v.add(t.v), e.a.add(t.a), e.v.rotate(t.rotation * Math.PI / 180))
                            }(t, e))
                        }(this, n, this.initializes)), n.addBehaviors(this.behaviors), n.update(e, t), this.particleCreated.dispatch(n)
                    }

                    updateParticle(t, e, n, r) {
                        const i = t.update(e, n)
                        return this.integrator.integrate(t, n, r), i ? this.particleUpdate.dispatch(t) : this.particleDead.dispatch(t), i
                    }

                    integrate(t) {
                        const e = 1 - this.damping
                        this.integrator.integrate(this, t, e)
                        for (let n = this.particles.length - 1; n >= 0; n--) this.updateParticle(this.particles[n], n, t, e) || this.particles.splice(n, 1)
                    }

                    emitting(t) {
                        if (this.emitTime += t, this.emitTime < this.emitTotalTimes) {
                            const e = this.rate.getValue(t, this._isFirstEmit)
                            this._isFirstEmit && (this._isFirstEmit = !1)
                            for (let n = 0; n < e; n++) this.createParticle(t)
                        }
                    }

                    emit(t, e) {
                        this.isEmitting = !0, this.emitTime = 0, this.emitTotalTimes = t || 1 / 0, isNaN(e) || (this.life = e), this.rate.init()
                    }

                    stopEmit() {
                        this.isEmitting = !1, this.emitTotalTimes = -1, this.emitTime = 0
                    }

                    removeAllParticles() {
                        for (let t = this.particles.length - 1; t >= 0; t--) this.particles[t].dead = !0
                    }

                    addSelfInitialize(t) {
                        t.init ? t.init(this) : this.initAll()
                    }

                    addInitialize() {
                        const t = arguments.length
                        for (let e = 0; e < t; e++) this.initializes.push(arguments[e])
                    }

                    removeInitialize(t) {
                        const e = this.initializes.indexOf(t)
                        e > -1 && this.initializes.splice(e, 1)
                    }

                    removeInitializers() {
                        this.initializes.length = 0
                    }

                    addBehavior() {
                        const t = arguments.length
                        for (let e = 0; e < t; e++) this.behaviors.push(arguments[e]), arguments[e].hasOwnProperty('parents') && arguments[e].parents.push(this)
                    }

                    removeBehavior(t) {
                        const e = this.behaviors.indexOf(t)
                        e > -1 && this.behaviors.splice(e, 1)
                    }

                    removeAllBehaviors() {
                        this.behaviors.length = 0
                    }

                    update(t) {
                        this.age += t, (this.dead || this.age >= this.life) && this.destroy(), this.emitting(t), this.integrate(t)
                    }

                    destroy() {
                        this.isEmitting = !1, this.dead = !0, this.emitTotalTimes = -1, this.removeInitializers(), this.removeAllBehaviors(), this.parent && this.parent.removeEmitter(this)
                    }
                }

                function st(t, e, n) {
                    return new E(t, e, n)
                }
                const ut = Q.addInitializers
                const ct = Q.addBehaviors
            })(), t.exports = i
        })()
    },
    './node_modules/@pixi/canvas-mesh/dist/esm/canvas-mesh.js': function (t, e, n) {
        'use strict';
        (function (t) {
            n.d(e, 'a', () => {
                return Dn
            })
            const r = n('./node_modules/@pixi/settings/dist/esm/settings.js')
            const i = n('./node_modules/@pixi/constants/dist/esm/constants.js')
            const o = n('./node_modules/@pixi/canvas-renderer/dist/esm/canvas-renderer.js')
            const a = n('./node_modules/@pixi/mesh/dist/esm/mesh.js')
            const s = n('./node_modules/@pixi/mesh-extras/dist/esm/mesh-extras.js')
            const u = typeof globalThis != 'undefined' ? globalThis : typeof window != 'undefined' ? window : void 0 !== t ? t : typeof self != 'undefined' ? self : {}

            function c(t, e, n) {
                return t(n = {
                    path: e,
                    exports: {},
                    require(t, e) {
                        return (function () {
                            throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs')
                        }(e == null && n.path))
                    }
                }, n.exports), n.exports
            }
            const l = c((t) => {
                const e = Object.prototype.hasOwnProperty
                var n = '~'

                function r() {}

                function i(t, e, n) {
                    this.fn = t, this.context = e, this.once = n || !1
                }

                function o(t, e, r, o, a) {
                    if (typeof r != 'function') throw new TypeError('The listener must be a function')
                    let s = new i(r, o || t, a)
                    var u = n ? n + e : e
                    return t._events[u] ? t._events[u].fn ? t._events[u] = [t._events[u], s] : t._events[u].push(s) : (t._events[u] = s, t._eventsCount++), t
                }

                function a(t, e) {
                    --t._eventsCount == 0 ? t._events = new r() : delete t._events[e]
                }

                function s() {
                    this._events = new r(), this._eventsCount = 0
                }
                Object.create && (r.prototype = Object.create(null), (new r()).__proto__ || (n = !1)), s.prototype.eventNames = function () {
                    let t; let r; const i = []
                    if (this._eventsCount === 0) return i
                    for (r in t = this._events) e.call(t, r) && i.push(n ? r.slice(1) : r)
                    return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
                }, s.prototype.listeners = function (t) {
                    const e = n ? n + t : t
                    var r = this._events[e]
                    if (!r) return []
                    if (r.fn) return [r.fn]
                    for (var i = 0, o = r.length, a = new Array(o); i < o; i++) a[i] = r[i].fn
                    return a
                }, s.prototype.listenerCount = function (t) {
                    const e = n ? n + t : t
                    var r = this._events[e]
                    return r ? r.fn ? 1 : r.length : 0
                }, s.prototype.emit = function (t, e, r, i, o, a) {
                    const s = arguments
                    var u = n ? n + t : t
                    if (!this._events[u]) return !1
                    let c; let l; const h = this._events[u]
                    var f = arguments.length
                    if (h.fn) {
                        switch (h.once && this.removeListener(t, h.fn, void 0, !0), f) {
                            case 1:
                                return h.fn.call(h.context), !0
                            case 2:
                                return h.fn.call(h.context, e), !0
                            case 3:
                                return h.fn.call(h.context, e, r), !0
                            case 4:
                                return h.fn.call(h.context, e, r, i), !0
                            case 5:
                                return h.fn.call(h.context, e, r, i, o), !0
                            case 6:
                                return h.fn.call(h.context, e, r, i, o, a), !0
                        }
                        for (l = 1, c = Array.from({ length: f - 1 }); l < f; l++) c[l - 1] = s[l]
                        h.fn.apply(h.context, c)
                    } else {
                        let d; const p = h.length
                        for (l = 0; l < p; l++) { switch (h[l].once && this.removeListener(t, h[l].fn, void 0, !0), f) {
                            case 1:
                                h[l].fn.call(h[l].context)
                                break;
                            case 2:
                                h[l].fn.call(h[l].context, e)
                                break;
                            case 3:
                                h[l].fn.call(h[l].context, e, r)
                                break;
                            case 4:
                                h[l].fn.call(h[l].context, e, r, i)
                                break;
                            default:
                                if (!c) {
                                    for (d = 1, c = Array.from({length: f - 1}); d < f; d++) c[d - 1] = s[d]
}
                                h[l].fn.apply(h[l].context, c)
                        }
                        }
                    }
                    return !0
                }, s.prototype.on = function (t, e, n) {
                    return o(this, t, e, n, !1)
                }, s.prototype.once = function (t, e, n) {
                    return o(this, t, e, n, !0)
                }, s.prototype.removeListener = function (t, e, r, i) {
                    const o = n ? n + t : t
                    if (!this._events[o]) return this
                    if (!e) return a(this, o), this
                    let s = this._events[o]
                    if (s.fn) { s.fn !== e || i && !s.once || r && s.context !== r || a(this, o)
                    }
                    else {
                        for (var u = 0, c = [], l = s.length; u < l; u++)(s[u].fn !== e || i && !s[u].once || r && s[u].context !== r) && c.push(s[u])
                        c.length ? this._events[o] = c.length === 1 ? c[0] : c : a(this, o)
                    }
                    return this
                }, s.prototype.removeAllListeners = function (t) {
                    let e
                    return t ? (e = n ? n + t : t, this._events[e] && a(this, e)) : (this._events = new r(), this._eventsCount = 0), this
                }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, t.exports = s
            })
            const h = c((t, e) => {
                !(function (n) {
                    var r = e && !e.nodeType && e;
                                var i = t && !t.nodeType && t;
                                var o = 'object' == typeof u && u
                            o.global !== o && o.window !== o && o.self !== o || (n = o)
                            var a; var s; var c = 2147483647;
                                var l = /^xn--/;
                                var h = /[^\x20-\x7E]/;
                                var f = /[\x2E\u3002\uFF0E\uFF61]/g;
                                var d = {
                                    overflow: "Overflow: input needs wider integers to process",
                                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                                    "invalid-input": "Invalid input"
                                };
                                var p = Math.floor;
                                var m = String.fromCharCode

                            function y(t) {
                        throw new RangeError(d[t])
                    }

                    function v(t, e) {
                        for (var n = t.length, r = []; n--;) r[n] = e(t[n])
                                return r
                    }

                    function _(t, e) {
                        var n = t.split('@');
                                    var r = '';
                        return n.length > 1 && (r = `${n[0]  }@`, t = n[1]), r + v((t = t.replace(f, '.')).split('.'), e).join('.')
                    }

                    function g(t) {
                        for (var e, n, r = [], i = 0, o = t.length; i < o;)(e = t.charCodeAt(i++)) >= 55296 && e <= 56319 && i < o ? (64512 & (n = t.charCodeAt(i++))) == 56320 ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), i--) : r.push(e)
                                return r
                    }

                    function b(t) {
                        return v(t, function(t) {
                                    var e = "";
                                    return t > 65535 && (e += m((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e += m(t)
                                }).join('')
                    }

                    function E(t, e) {
                        return t + 22 + 75 * (t < 26) - ((e != 0) << 5)
                    }

                    function x(t, e, n) {
                        var r = 0
                                for (t = n ? p(t / 700) : t >> 1, t += p(t / e); t > 455; r += 36) t = p(t / 35)
                                return p(r + 36 * t / (t + 38))
                    }

                    function T(t) {
                        var e; var n; var r; var i; var o; var a; var s; var u; var l; var h; var f; var d = [];
                                    var m = t.length;
                                    var v = 0;
                                    var _ = 128;
                                    var g = 72
                                for ((n = t.lastIndexOf('-')) < 0 && (n = 0), r = 0; r < n; ++r) t.charCodeAt(r) >= 128 && y('not-basic'), d.push(t.charCodeAt(r))
                                for (i = n > 0 ? n + 1 : 0; i < m;) {
                            for (o = v, a = 1, s = 36; i >= m && y('invalid-input'), ((u = (f = t.charCodeAt(i++)) - 48 < 10 ? f - 22 : f - 65 < 26 ? f - 65 : f - 97 < 26 ? f - 97 : 36) >= 36 || u > p((c - v) / a)) && y('overflow'), v += u * a, !(u < (l = s <= g ? 1 : s >= g + 26 ? 26 : s - g)); s += 36) a > p(c / (h = 36 - l)) && y('overflow'), a *= h
                                    g = x(v - o, e = d.length + 1, o == 0), p(v / e) > c - _ && y('overflow'), _ += p(v / e), v %= e, d.splice(v++, 0, _)
                        }
                        return b(d)
                    }

                    function S(t) {
                        var e; var n; var r; var i; var o; var a; var s; var u; var l; var h; var f; var d; var v; var _; var b; var T = []
                                for (d = (t = g(t)).length, e = 128, n = 0, o = 72, a = 0; a < d; ++a)(f = t[a]) < 128 && T.push(m(f))
                                for (r = i = T.length, i && T.push('-'); r < d;) {
                            for (s = c, a = 0; a < d; ++a)(f = t[a]) >= e && f < s && (s = f)
                                    for (s - e > p((c - n) / (v = r + 1)) && y('overflow'), n += (s - e) * v, e = s, a = 0; a < d; ++a) {
                                        if ((f = t[a]) < e && ++n > c && y("overflow"), f == e) {
                                            for (u = n, l = 36; !(u < (h = l <= o ? 1 : l >= o + 26 ? 26 : l - o)); l += 36) b = u - h, _ = 36 - h, T.push(m(E(h + b % _, 0))), u = p(b / _);
                                            T.push(m(E(u, 0))), o = x(n, v, r == i), n = 0, ++r
                                        }
}++n, ++e
                        }
                        return T.join('')
                    }
                    if (a = {
                        version: '1.3.2',
                        ucs2: {
                            decode: g,
                            encode: b
                        },
                        decode: T,
                        encode: S,
                        toASCII: function (t) {
                            return _(t, function(t) {
                                            return h.test(t) ? "xn--" + S(t) : t
                                        })
                        },
                        toUnicode: function (t) {
                            return _(t, function(t) {
                                            return l.test(t) ? T(t.slice(4).toLowerCase()) : t
                                        })
                        }
                    }, r && i) {
                                if (t.exports == r) i.exports = a;
                                else
                                    for (s in a) a.hasOwnProperty(s) && (r[s] = a[s]);
}
                    else { n.punycode = a
}
                }(u))
            })
            const f = function (t) {
                return typeof t == 'string'
            }
            const d = function (t) {
                return typeof t == 'object' && t !== null
            }
            const p = function (t) {
                return t === null
            }
            const m = function (t) {
                return t == null
            }

            function y(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }
            const v = function (t, e, n, r) {
                e = e || '&', n = n || '='
                let i = {}
                if (typeof t != 'string' || t.length === 0) return i
                const o = /\+/g
                t = t.split(e)
                let a = 1e3
                r && typeof r.maxKeys == 'number' && (a = r.maxKeys)
                let s = t.length
                a > 0 && s > a && (s = a)
                for (let u = 0; u < s; ++u) {
                    var c; var l; var h; var f; const d = t[u].replace(o, '%20')
                    let p = d.indexOf(n)
                    p >= 0 ? (c = d.substr(0, p), l = d.substr(p + 1)) : (c = d, l = ''), h = decodeURIComponent(c), f = decodeURIComponent(l), y(i, h) ? Array.isArray(i[h]) ? i[h].push(f) : i[h] = [i[h], f] : i[h] = f
                }
                return i
            }
            const _ = function (t) {
                switch (typeof t) {
                    case 'string':
                        return t
                    case 'boolean':
                        return t ? 'true' : 'false'
                    case 'number':
                        return isFinite(t) ? t : ''
                    default:
                        return ''
                }
            }
            const g = function (t, e, n, r) {
                return e = e || '&', n = n || '=', t === null && (t = void 0), typeof t == 'object'
                    ? Object.keys(t).map((r) => {
                            const i = encodeURIComponent(_(r)) + n
                            return Array.isArray(t[r])
                                ? t[r].map((t) => {
                                        return i + encodeURIComponent(_(t))
                                    }).join(e)
                                : i + encodeURIComponent(_(t[r]))
                        }).join(e)
                    : r ? encodeURIComponent(_(r)) + n + encodeURIComponent(_(t)) : ''
            }
            const b = c((t, e) => {
                e.decode = e.parse = v, e.encode = e.stringify = g
            })
            const E = L
            const x = function (t, e) {
                return L(t, !1, !0).resolve(e)
            }
            const T = function (t) {
                f(t) && (t = L(t))
                if (!(t instanceof S)) return S.prototype.format.call(t)
                return t.format()
            }

            function S() {
                this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
            }
            const w = /^([a-z0-9.+-]+:)/i
            const O = /:\d*$/
            const P = /^(\/\/?(?!\/)[^?\s]*)(\?\S*)?$/
            const R = ['{', '}', '|', '\\', '^', '`'].concat(['<', '>', '"', '`', ' ', '\r', '\n', '\t'])
            const A = ['\''].concat(R)
            const I = ['%', '/', '?', ';', '#'].concat(A)
            const C = ['/', '?', '#']
            const k = /^[+\w-]{0,63}$/i
            const N = /^([+\w-]{0,63})(.*)$/i
            const M = {
                'javascript': !0,
                'javascript:': !0
            }
            const j = {
                'javascript': !0,
                'javascript:': !0
            }
            const D = {
                'http': !0,
                'https': !0,
                'ftp': !0,
                'gopher': !0,
                'file': !0,
                'http:': !0,
                'https:': !0,
                'ftp:': !0,
                'gopher:': !0,
                'file:': !0
            }

            function L(t, e, n) {
                if (t && d(t) && t instanceof S) return t
                const r = new S()
                return r.parse(t, e, n), r
            }
            S.prototype.parse = function (t, e, n) {
                if (!f(t)) throw new TypeError(`Parameter 'url' must be a string, not ${typeof t}`)
                const r = t.indexOf('?')
                const i = r !== -1 && r < t.indexOf('#') ? '?' : '#'
                const o = t.split(i)
                o[0] = o[0].replace(/\\/g, '/')
                let a = t = o.join(i)
                if (a = a.trim(), !n && t.split('#').length === 1) {
                    const s = P.exec(a)
                    if (s) return this.path = a, this.href = a, this.pathname = s[1], s[2] ? (this.search = s[2], this.query = e ? b.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = '', this.query = {}), this
                }
                let u = w.exec(a)
                if (u) {
                    var c = (u = u[0]).toLowerCase()
                    this.protocol = c, a = a.substr(u.length)
                }
                if (n || u || a.match(/^\/\/[^@/]+@[^@/]+/)) {
                    var l = a.substr(0, 2) === '//'
                    !l || u && j[u] || (a = a.substr(2), this.slashes = !0)
                }
                if (!j[u] && (l || u && !D[u])) {
                    for (var d, p, m = -1, y = 0; y < C.length; y++) {
                        (v = a.indexOf(C[y])) !== -1 && (m === -1 || v < m) && (m = v)
                    } (p = m === -1 ? a.lastIndexOf('@') : a.lastIndexOf('@', m)) !== -1 && (d = a.slice(0, p), a = a.slice(p + 1), this.auth = decodeURIComponent(d)), m = -1
                    for (y = 0; y < I.length; y++) {
                        var v; (v = a.indexOf(I[y])) !== -1 && (m === -1 || v < m) && (m = v)
                    } m === -1 && (m = a.length), this.host = a.slice(0, m), a = a.slice(m), this.parseHost(), this.hostname = this.hostname || ''
                    const _ = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'
                    if (!_) {
                        for (var g = this.hostname.split(/\./), E = (y = 0, g.length); y < E; y++) {
                            const x = g[y]
                            if (x && !x.match(k)) {
                                for (var T = '', S = 0, O = x.length; S < O; S++) x.charCodeAt(S) > 127 ? T += 'x' : T += x[S]
                                if (!T.match(k)) {
                                    const R = g.slice(0, y)
                                    let L = g.slice(y + 1)
                                    let F = x.match(N)
                                    F && (R.push(F[1]), L.unshift(F[2])), L.length && (a = `/${L.join('.')}${a}`), this.hostname = R.join('.')
                                    break
                                }
                            }
                        }
                    }
                    this.hostname.length > 255 ? this.hostname = '' : this.hostname = this.hostname.toLowerCase(), _ || (this.hostname = h.toASCII(this.hostname))
                    var B = this.port ? `:${this.port}` : ''
                    let U = this.hostname || ''
                    this.host = U + B, this.href += this.host, _ && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a[0] !== '/' && (a = `/${a}`))
                }
                if (!M[c]) {
                    for (y = 0, E = A.length; y < E; y++) {
                        const G = A[y]
                        if (a.includes(G)) {
                            let X = encodeURIComponent(G)
                            X === G && (X = escape(G)), a = a.split(G).join(X)
                        }
                    }
                }
                const H = a.indexOf('#'); H !== -1 && (this.hash = a.substr(H), a = a.slice(0, H))
                const V = a.indexOf('?')
                if (V !== -1 ? (this.search = a.substr(V), this.query = a.substr(V + 1), e && (this.query = b.parse(this.query)), a = a.slice(0, V)) : e && (this.search = '', this.query = {}), a && (this.pathname = a), D[c] && this.hostname && !this.pathname && (this.pathname = '/'), this.pathname || this.search) {
                    B = this.pathname || ''
                    const W = this.search || ''
                    this.path = B + W
                }
                return this.href = this.format(), this
            }, S.prototype.format = function () {
                let t = this.auth || ''
                t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ':'), t += '@')
                let e = this.protocol || ''
                let n = this.pathname || ''
                let r = this.hash || ''
                let i = !1
                let o = ''
                this.host ? i = t + this.host : this.hostname && (i = t + (!this.hostname.includes(':') ? this.hostname : `[${this.hostname}]`), this.port && (i += `:${this.port}`)), this.query && d(this.query) && Object.keys(this.query).length && (o = b.stringify(this.query))
                let a = this.search || o && `?${o}` || ''
                return e && e.substr(-1) !== ':' && (e += ':'), this.slashes || (!e || D[e]) && !1 !== i ? (i = `//${i || ''}`, n && n.charAt(0) !== '/' && (n = `/${n}`)) : i || (i = ''), r && r.charAt(0) !== '#' && (r = `#${r}`), a && a.charAt(0) !== '?' && (a = `?${a}`), e + i + (n = n.replace(/[?#]/g, (t) => {
                    return encodeURIComponent(t)
                })) + (a = a.replace('#', '%23')) + r
            }, S.prototype.resolve = function (t) {
                return this.resolveObject(L(t, !1, !0)).format()
            }, S.prototype.resolveObject = function (t) {
                if (f(t)) {
                    const e = new S()
                    e.parse(t, !1, !0), t = e
                }
                for (var n = new S(), r = Object.keys(this), i = 0; i < r.length; i++) {
                    const o = r[i]
                    n[o] = this[o]
                }
                if (n.hash = t.hash, t.href === '') return n.href = n.format(), n
                if (t.slashes && !t.protocol) {
                    for (let a = Object.keys(t), s = 0; s < a.length; s++) {
                        const u = a[s]
                        u !== 'protocol' && (n[u] = t[u])
                    }
                    return D[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = '/'), n.href = n.format(), n
                }
                if (t.protocol && t.protocol !== n.protocol) {
                    if (!D[t.protocol]) {
                        for (let c = Object.keys(t), l = 0; l < c.length; l++) {
                            const h = c[l]
                            n[h] = t[h]
                        }
                        return n.href = n.format(), n
                    }
                    if (n.protocol = t.protocol, t.host || j[t.protocol]) { n.pathname = t.pathname
                    }
                    else {
                        for (var d = (t.pathname || '').split('/'); d.length && !(t.host = d.shift()););
                        t.host || (t.host = ''), t.hostname || (t.hostname = ''), d[0] !== '' && d.unshift(''), d.length < 2 && d.unshift(''), n.pathname = d.join('/')
                    }
                    if (n.search = t.search, n.query = t.query, n.host = t.host || '', n.auth = t.auth, n.hostname = t.hostname || t.host, n.port = t.port, n.pathname || n.search) {
                        const y = n.pathname || ''
                        let v = n.search || ''
                        n.path = y + v
                    }
                    return n.slashes = n.slashes || t.slashes, n.href = n.format(), n
                }
                const _ = n.pathname && n.pathname.charAt(0) === '/'
                const g = t.host || t.pathname && t.pathname.charAt(0) === '/'
                let b = g || _ || n.host && t.pathname
                const E = b
                let x = n.pathname && n.pathname.split('/') || []
                const T = (d = t.pathname && t.pathname.split('/') || [], n.protocol && !D[n.protocol])
                if (T && (n.hostname = '', n.port = null, n.host && (x[0] === '' ? x[0] = n.host : x.unshift(n.host)), n.host = '', t.protocol && (t.hostname = null, t.port = null, t.host && (d[0] === '' ? d[0] = t.host : d.unshift(t.host)), t.host = null), b = b && (d[0] === '' || x[0] === '')), g) { n.host = t.host || t.host === '' ? t.host : n.host, n.hostname = t.hostname || t.hostname === '' ? t.hostname : n.hostname, n.search = t.search, n.query = t.query, x = d
                }
                else if (d.length) { x || (x = []), x.pop(), x = x.concat(d), n.search = t.search, n.query = t.query
                }
                else if (!m(t.search)) {
                    if (T) n.hostname = n.host = x.shift(), (A = !!(n.host && n.host.indexOf('@') > 0) && n.host.split('@')) && (n.auth = A.shift(), n.host = n.hostname = A.shift())
                    return n.search = t.search, n.query = t.query, p(n.pathname) && p(n.search) || (n.path = (n.pathname ? n.pathname : '') + (n.search ? n.search : '')), n.href = n.format(), n
                }
                if (!x.length) return n.pathname = null, n.search ? n.path = `/${n.search}` : n.path = null, n.href = n.format(), n
                for (var w = x.slice(-1)[0], O = (n.host || t.host || x.length > 1) && (w === '.' || w === '..') || w === '', P = 0, R = x.length; R >= 0; R--) (w = x[R]) === '.' ? x.splice(R, 1) : w === '..' ? (x.splice(R, 1), P++) : P && (x.splice(R, 1), P--)
                if (!b && !E) {
                    for (; P--; P) x.unshift('..')
                }
                !b || x[0] === '' || x[0] && x[0].charAt(0) === '/' || x.unshift(''), O && x.join('/').substr(-1) !== '/' && x.push('')
                let A; const I = x[0] === '' || x[0] && x[0].charAt(0) === '/'
                T && (n.hostname = n.host = I ? '' : x.length ? x.shift() : '', (A = !!(n.host && n.host.indexOf('@') > 0) && n.host.split('@')) && (n.auth = A.shift(), n.host = n.hostname = A.shift()))
                return (b = b || n.host && x.length) && !I && x.unshift(''), x.length ? n.pathname = x.join('/') : (n.pathname = null, n.path = null), p(n.pathname) && p(n.search) || (n.path = (n.pathname ? n.pathname : '') + (n.search ? n.search : '')), n.auth = t.auth || n.auth, n.slashes = n.slashes || t.slashes, n.href = n.format(), n
            }, S.prototype.parseHost = function () {
                let t = this.host
                let e = O.exec(t)
                e && ((e = e[0]) !== ':' && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
            }
            /*!
                 * @pixi/utils - v6.2.0
                 * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                 *
                 * @pixi/utils is licensed under the MIT License.
                 * http://www.opensource.org/licenses/mit-license
                 */
            const F = {
                parse: E,
                format: T,
                resolve: x
            }
            r.b.RETINA_PREFIX = /@([0-9.]+)x/, r.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1
            let B; let U = !1
            const G = (function () {
                for (var t = [], e = [], n = 0; n < 32; n++) t[n] = n, e[n] = n
                t[i.b.NORMAL_NPM] = i.b.NORMAL, t[i.b.ADD_NPM] = i.b.ADD, t[i.b.SCREEN_NPM] = i.b.SCREEN, e[i.b.NORMAL] = i.b.NORMAL_NPM, e[i.b.ADD] = i.b.ADD_NPM, e[i.b.SCREEN] = i.b.SCREEN_NPM
                let r = []
                return r.push(e), r.push(t), r
            }())

            function X(t) {
                if (t.BYTES_PER_ELEMENT === 4) return t instanceof Float32Array ? 'Float32Array' : t instanceof Uint32Array ? 'Uint32Array' : 'Int32Array'
                if (t.BYTES_PER_ELEMENT === 2) {
                    if (t instanceof Uint16Array) return 'Uint16Array'
                } else if (t.BYTES_PER_ELEMENT === 1 && t instanceof Uint8Array) { return 'Uint8Array'
                }
                return null
            }

            function H(t) {
                return t += t === 0 ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, (t |= t >>> 16) + 1
            }

            function V(t) {
                return !(t & t - 1 || !t)
            }

            function W(t) {
                let e = (t > 65535 ? 1 : 0) << 4
                let n = ((t >>>= e) > 255 ? 1 : 0) << 3
                return e |= n, e |= n = ((t >>>= n) > 15 ? 1 : 0) << 2, (e |= n = ((t >>>= n) > 3 ? 1 : 0) << 1) | (t >>>= n) >> 1
            }
            let Y = 0

            function z() {
                return ++Y
            }
            const q = {}

            function K(t, e, n) {
                if (void 0 === n && (n = 3), !q[e]) {
                    let r = (new Error()).stack
                    void 0 === r ? console.warn('PixiJS Deprecation Warning: ', `${e}\nDeprecated since v${t}`) : (r = r.split('\n').splice(n).join('\n'), console.groupCollapsed ? (console.groupCollapsed('%cPixiJS Deprecation Warning: %c%s', 'color:#614108;background:#fffbe6', 'font-weight:normal;color:#614108;background:#fffbe6', `${e}\nDeprecated since v${t}`), console.warn(r), console.groupEnd()) : (console.warn('PixiJS Deprecation Warning: ', `${e}\nDeprecated since v${t}`), console.warn(r))), q[e] = !0
                }
            }
            let Z; const $ = {}
            const J = Object.create(null)
            const Q = Object.create(null)
            !(function () {
                function t(t, e, n) {
                    this.canvas = document.createElement('canvas'), this.context = this.canvas.getContext('2d'), this.resolution = n || r.b.RESOLUTION, this.resize(t, e)
                }
                t.prototype.clear = function () {
                    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
                }, t.prototype.resize = function (t, e) {
                    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution)
                }, t.prototype.destroy = function () {
                    this.context = null, this.canvas = null
                }, Object.defineProperty(t.prototype, 'width', {
                    get() {
                        return this.canvas.width
                    },
                    set(t) {
                        this.canvas.width = Math.round(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'height', {
                    get() {
                        return this.canvas.height
                    },
                    set(t) {
                        this.canvas.height = Math.round(t)
                    },
                    enumerable: !1,
                    configurable: !0
                })
            }())

            function tt(t, e) {
                if (void 0 === e && (e = self.location), t.indexOf('data:') === 0) return ''
                e = e || self.location, Z || (Z = document.createElement('a')), Z.href = t
                const n = F.parse(Z.href)
                const r = !n.port && e.port === '' || n.port === e.port
                return n.hostname === e.hostname && r && n.protocol === e.protocol ? '' : 'anonymous'
            }

            function et(t, e) {
                const n = r.b.RETINA_PREFIX.exec(t)
                return n ? Number.parseFloat(n[1]) : void 0 !== e ? e : 1
            }
            /*!
                 * @pixi/runner - v6.2.0
                 * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                 *
                 * @pixi/runner is licensed under the MIT License.
                 * http://www.opensource.org/licenses/mit-license
                 */
            let nt; const rt = (function () {
                function t(t) {
                    this.items = [], this._name = t, this._aliasCount = 0
                }
                return t.prototype.emit = function (t, e, n, r, i, o, a, s) {
                    if (arguments.length > 8) throw new Error('max arguments reached')
                    let u = this
                    var c = u.name
                    var l = u.items
                    this._aliasCount++
                    for (let h = 0, f = l.length; h < f; h++) l[h][c](t, e, n, r, i, o, a, s)
                    return l === this.items && this._aliasCount--, this
                }, t.prototype.ensureNonAliasedItems = function () {
                    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
                }, t.prototype.add = function (t) {
                    return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
                }, t.prototype.remove = function (t) {
                    const e = this.items.indexOf(t)
                    return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this
                }, t.prototype.contains = function (t) {
                    return this.items.includes(t)
                }, t.prototype.removeAll = function () {
                    return this.ensureNonAliasedItems(), this.items.length = 0, this
                }, t.prototype.destroy = function () {
                    this.removeAll(), this.items = null, this._name = null
                }, Object.defineProperty(t.prototype, 'empty', {
                    get() {
                        return this.items.length === 0
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'name', {
                    get() {
                        return this._name
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }())
            Object.defineProperties(rt.prototype, {
                dispatch: {
                    value: rt.prototype.emit
                },
                run: {
                    value: rt.prototype.emit
                }
            }),
            /*!
                     * @pixi/ticker - v6.2.0
                     * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                     *
                     * @pixi/ticker is licensed under the MIT License.
                     * http://www.opensource.org/licenses/mit-license
                     */
            r.b.TARGET_FPMS = 0.06,
            (function (t) {
                t[t.INTERACTION = 50] = 'INTERACTION', t[t.HIGH = 25] = 'HIGH', t[t.NORMAL = 0] = 'NORMAL', t[t.LOW = -25] = 'LOW', t[t.UTILITY = -50] = 'UTILITY'
            }(nt || (nt = {})))
            let it; const ot = (function () {
                function t(t, e, n, r) {
                    void 0 === e && (e = null), void 0 === n && (n = 0), void 0 === r && (r = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = n, this.once = r
                }
                return t.prototype.match = function (t, e) {
                    return void 0 === e && (e = null), this.fn === t && this.context === e
                }, t.prototype.emit = function (t) {
                    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t))
                    var e = this.next
                    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e
                }, t.prototype.connect = function (t) {
                    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
                }, t.prototype.destroy = function (t) {
                    void 0 === t && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous)
                    var e = this.next
                    return this.next = t ? null : e, this.previous = null, e
                }, t
            }())
            const at = (function () {
                function t() {
                    let t = this
                    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new ot(null, null, 1 / 0), this.deltaMS = 1 / r.b.TARGET_FPMS, this.elapsedMS = 1 / r.b.TARGET_FPMS, this._tick = function (e) {
                        t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)))
                    }
                }
                return t.prototype._requestIfNeeded = function () {
                    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
                }, t.prototype._cancelIfNeeded = function () {
                    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null)
                }, t.prototype._startIfPossible = function () {
                    this.started ? this._requestIfNeeded() : this.autoStart && this.start()
                }, t.prototype.add = function (t, e, n) {
                    return void 0 === n && (n = nt.NORMAL), this._addListener(new ot(t, e, n))
                }, t.prototype.addOnce = function (t, e, n) {
                    return void 0 === n && (n = nt.NORMAL), this._addListener(new ot(t, e, n, !0))
                }, t.prototype._addListener = function (t) {
                    let e = this._head.next
                                var n = this._head
                    if (e) {
                        for (; e;) {
                            if (t.priority > e.priority) {
                                t.connect(n)
                                break
                            }
                            n = e, e = e.next
                        }
                        t.previous || t.connect(n)
                    } else { t.connect(n)
}
                    return this._startIfPossible(), this
                }, t.prototype.remove = function (t, e) {
                    for (let n = this._head.next; n;) n = n.match(t, e) ? n.destroy() : n.next
                    return this._head.next || this._cancelIfNeeded(), this
                }, Object.defineProperty(t.prototype, 'count', {
                    get () {
                        if (!this._head) return 0
                                for (var t = 0, e = this._head; e = e.next;) t++
                                return t
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.start = function () {
                    this.started || (this.started = !0, this._requestIfNeeded())
                }, t.prototype.stop = function () {
                    this.started && (this.started = !1, this._cancelIfNeeded())
                }, t.prototype.destroy = function () {
                    if (!this._protected) {
                        this.stop()
                        for (let t = this._head.next; t;) t = t.destroy(!0)
                        this._head.destroy(), this._head = null
                    }
                }, t.prototype.update = function (t) {
                    let e
                    if (void 0 === t && (t = performance.now()), t > this.lastTime) {
                        if ((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
                            let n = t - this._lastFrame | 0
                            if (n < this._minElapsedMS) return
                            this._lastFrame = t - n % this._minElapsedMS
                        }
                        this.deltaMS = e, this.deltaTime = this.deltaMS * r.b.TARGET_FPMS
                        for (var i = this._head, o = i.next; o;) o = o.emit(this.deltaTime)
                        i.next || this._cancelIfNeeded()
                    } else { this.deltaTime = this.deltaMS = this.elapsedMS = 0
}
                    this.lastTime = t
                }, Object.defineProperty(t.prototype, 'FPS', {
                    get () {
                        return 1e3 / this.elapsedMS
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'minFPS', {
                    get () {
                        return 1e3 / this._maxElapsedMS
                    },
                    set (t) {
                        var e = Math.min(this.maxFPS, t);
                                    var n = Math.min(Math.max(0, e) / 1e3, r.b.TARGET_FPMS)
                                this._maxElapsedMS = 1 / n
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'maxFPS', {
                    get () {
                        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
                    },
                    set (t) {
                        if (t === 0) { this._minElapsedMS = 0;
}
                        else {
                            var e = Math.max(this.minFPS, t)
                                    this._minElapsedMS = 1 / (e / 1e3)
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, 'shared', {
                    get () {
                        if (!t._shared) {
                            var e = t._shared = new t
                                    e.autoStart = !0, e._protected = !0
                        }
                        return t._shared
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, 'system', {
                    get () {
                        if (!t._system) {
                            var e = t._system = new t
                                    e.autoStart = !0, e._protected = !0
                        }
                        return t._system
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }())
            const st = 2 * Math.PI
            !(function (t) {
                t[t.POLY = 0] = 'POLY', t[t.RECT = 1] = 'RECT', t[t.CIRC = 2] = 'CIRC', t[t.ELIP = 3] = 'ELIP', t[t.RREC = 4] = 'RREC'
            }(it || (it = {})))
            const ut = (function () {
                function t(t, e, n, r) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), this.x = Number(t), this.y = Number(e), this.width = Number(n), this.height = Number(r), this.type = it.RECT
                }
                return Object.defineProperty(t.prototype, 'left', {
                    get () {
                        return this.x
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'right', {
                    get () {
                        return this.x + this.width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'top', {
                    get () {
                        return this.y
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'bottom', {
                    get () {
                        return this.y + this.height
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, 'EMPTY', {
                    get () {
                        return new t(0, 0, 0, 0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.clone = function () {
                    return new t(this.x, this.y, this.width, this.height)
                }, t.prototype.copyFrom = function (t) {
                    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
                }, t.prototype.copyTo = function (t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                }, t.prototype.contains = function (t, e) {
                    return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height)
                }, t.prototype.pad = function (t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this
                }, t.prototype.fit = function (t) {
                    let e = Math.max(this.x, t.x)
                    var n = Math.min(this.x + this.width, t.x + t.width)
                    var r = Math.max(this.y, t.y)
                    var i = Math.min(this.y + this.height, t.y + t.height)
                    return this.x = e, this.width = Math.max(n - e, 0), this.y = r, this.height = Math.max(i - r, 0), this
                }, t.prototype.ceil = function (t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = 0.001)
                    let n = Math.ceil((this.x + this.width - e) * t) / t
                    var r = Math.ceil((this.y + this.height - e) * t) / t
                    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = n - this.x, this.height = r - this.y, this
                }, t.prototype.enlarge = function (t) {
                    let e = Math.min(this.x, t.x)
                    var n = Math.max(this.x + this.width, t.x + t.width)
                    var r = Math.min(this.y, t.y)
                    var i = Math.max(this.y + this.height, t.y + t.height)
                    return this.x = e, this.width = n - e, this.y = r, this.height = i - r, this
                }, t.prototype.toString = function () {
                    return `[@pixi/math:Rectangle x=${ this.x } y=${ this.y } width=${ this.width } height=${ this.height }]`
                }, t
            }())
            let ct = (function () {
                function t(t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e
                }
                return t.prototype.clone = function () {
                    return new t(this.x, this.y)
                }, t.prototype.copyFrom = function (t) {
                    return this.set(t.x, t.y), this
                }, t.prototype.copyTo = function (t) {
                    return t.set(this.x, this.y), t
                }, t.prototype.equals = function (t) {
                    return t.x === this.x && t.y === this.y
                }, t.prototype.set = function (t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this
                }, t.prototype.toString = function () {
                    return `[@pixi/math:Point x=${ this.x } y=${ this.y }]`
                }, t
            }())
            let lt = (function () {
                function t(t, e, n, r) {
                    void 0 === n && (n = 0), void 0 === r && (r = 0), this._x = n, this._y = r, this.cb = t, this.scope = e
                }
                return t.prototype.clone = function (e, n) {
                    return void 0 === e && (e = this.cb), void 0 === n && (n = this.scope), new t(e, n, this._x, this._y)
                }, t.prototype.set = function (t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = t), this._x === t && this._y === e || (this._x = t, this._y = e, this.cb.call(this.scope)), this
                }, t.prototype.copyFrom = function (t) {
                    return this._x === t.x && this._y === t.y || (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
                }, t.prototype.copyTo = function (t) {
                    return t.set(this._x, this._y), t
                }, t.prototype.equals = function (t) {
                    return t.x === this._x && t.y === this._y
                }, t.prototype.toString = function () {
                    return `[@pixi/math:ObservablePoint x=0 y=0 scope=${ this.scope }]`
                }, Object.defineProperty(t.prototype, 'x', {
                    get() {
                        return this._x
                    },
                    set(t) {
                        this._x !== t && (this._x = t, this.cb.call(this.scope))
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'y', {
                    get() {
                        return this._y
                    },
                    set(t) {
                        this._y !== t && (this._y = t, this.cb.call(this.scope))
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }())
            let ht = (function () {
                function t(t, e, n, r, i, o) {
                    void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), this.array = null, this.a = t, this.b = e, this.c = n, this.d = r, this.tx = i, this.ty = o
                }
                return t.prototype.fromArray = function (t) {
                    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
                }, t.prototype.set = function (t, e, n, r, i, o) {
                    return this.a = t, this.b = e, this.c = n, this.d = r, this.tx = i, this.ty = o, this
                }, t.prototype.toArray = function (t, e) {
                    this.array || (this.array = new Float32Array(9))
                    let n = e || this.array
                    return t ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n
                }, t.prototype.apply = function (t, e) {
                    e = e || new ct()
                    let n = t.x
                    var r = t.y
                    return e.x = this.a * n + this.c * r + this.tx, e.y = this.b * n + this.d * r + this.ty, e
                }, t.prototype.applyInverse = function (t, e) {
                    e = e || new ct()
                    let n = 1 / (this.a * this.d + this.c * -this.b)
                    var r = t.x
                    var i = t.y
                    return e.x = this.d * n * r + -this.c * n * i + (this.ty * this.c - this.tx * this.d) * n, e.y = this.a * n * i + -this.b * n * r + (-this.ty * this.a + this.tx * this.b) * n, e
                }, t.prototype.translate = function (t, e) {
                    return this.tx += t, this.ty += e, this
                }, t.prototype.scale = function (t, e) {
                    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                }, t.prototype.rotate = function (t) {
                    const e = Math.cos(t)
                    var n = Math.sin(t)
                    var r = this.a
                    var i = this.c
                    var o = this.tx
                    return this.a = r * e - this.b * n, this.b = r * n + this.b * e, this.c = i * e - this.d * n, this.d = i * n + this.d * e, this.tx = o * e - this.ty * n, this.ty = o * n + this.ty * e, this
                }, t.prototype.append = function (t) {
                    const e = this.a
                    var n = this.b
                    var r = this.c
                    var i = this.d
                    return this.a = t.a * e + t.b * r, this.b = t.a * n + t.b * i, this.c = t.c * e + t.d * r, this.d = t.c * n + t.d * i, this.tx = t.tx * e + t.ty * r + this.tx, this.ty = t.tx * n + t.ty * i + this.ty, this
                }, t.prototype.setTransform = function (t, e, n, r, i, o, a, s, u) {
                    return this.a = Math.cos(a + u) * i, this.b = Math.sin(a + u) * i, this.c = -Math.sin(a - s) * o, this.d = Math.cos(a - s) * o, this.tx = t - (n * this.a + r * this.c), this.ty = e - (n * this.b + r * this.d), this
                }, t.prototype.prepend = function (t) {
                    const e = this.tx
                    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
                        const n = this.a
                        var r = this.c
                        this.a = n * t.a + this.b * t.c, this.b = n * t.b + this.b * t.d, this.c = r * t.a + this.d * t.c, this.d = r * t.b + this.d * t.d
                    }
                    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this
                }, t.prototype.decompose = function (t) {
                    const e = this.a
                    var n = this.b
                    var r = this.c
                    var i = this.d
                    var o = t.pivot
                    var a = -Math.atan2(-r, i)
                    var s = Math.atan2(n, e)
                    var u = Math.abs(a + s)
                    return u < 1e-5 || Math.abs(st - u) < 1e-5 ? (t.rotation = s, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = s), t.scale.x = Math.sqrt(e * e + n * n), t.scale.y = Math.sqrt(r * r + i * i), t.position.x = this.tx + (o.x * e + o.y * r), t.position.y = this.ty + (o.x * n + o.y * i), t
                }, t.prototype.invert = function () {
                    const t = this.a
                    var e = this.b
                    var n = this.c
                    var r = this.d
                    var i = this.tx
                    var o = t * r - e * n
                    return this.a = r / o, this.b = -e / o, this.c = -n / o, this.d = t / o, this.tx = (n * this.ty - r * i) / o, this.ty = -(t * this.ty - e * i) / o, this
                }, t.prototype.identity = function () {
                    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
                }, t.prototype.clone = function () {
                    const e = new t()
                    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
                }, t.prototype.copyTo = function (t) {
                    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
                }, t.prototype.copyFrom = function (t) {
                    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                }, t.prototype.toString = function () {
                    return `[@pixi/math:Matrix a=${ this.a } b=${ this.b } c=${ this.c } d=${ this.d } tx=${ this.tx } ty=${ this.ty }]`
                }, Object.defineProperty(t, 'IDENTITY', {
                    get() {
                        return new t()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, 'TEMP_MATRIX', {
                    get() {
                        return new t()
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }())
            let ft = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
            let dt = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
            let pt = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
            let mt = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
            let yt = []
            let vt = []
            let _t = Math.sign
            !(function () {
                for (var t = 0; t < 16; t++) {
                    const e = []
                    yt.push(e)
                    for (let n = 0; n < 16; n++) {
                        for (let r = _t(ft[t] * ft[n] + pt[t] * dt[n]), i = _t(dt[t] * ft[n] + mt[t] * dt[n]), o = _t(ft[t] * pt[n] + pt[t] * mt[n]), a = _t(dt[t] * pt[n] + mt[t] * mt[n]), s = 0; s < 16; s++) {
                            if (ft[s] === r && dt[s] === i && pt[s] === o && mt[s] === a) {
                                e.push(s)
                                break
                            }
                        }
                    }
                }
                for (t = 0; t < 16; t++) {
                    const u = new ht()
                    u.set(ft[t], dt[t], pt[t], mt[t], 0, 0), vt.push(u)
                }
            }())
            var gt = {
                E: 0,
                SE: 1,
                S: 2,
                SW: 3,
                W: 4,
                NW: 5,
                N: 6,
                NE: 7,
                MIRROR_VERTICAL: 8,
                MAIN_DIAGONAL: 10,
                MIRROR_HORIZONTAL: 12,
                REVERSE_DIAGONAL: 14,
                uX(t) {
                    return ft[t]
                },
                uY(t) {
                    return dt[t]
                },
                vX(t) {
                    return pt[t]
                },
                vY(t) {
                    return mt[t]
                },
                inv(t) {
                    return 8 & t ? 15 & t : 7 & -t
                },
                add(t, e) {
                    return yt[t][e]
                },
                sub(t, e) {
                    return yt[t][gt.inv(e)]
                },
                rotate180(t) {
                    return 4 ^ t
                },
                isVertical(t) {
                    return (3 & t) == 2
                },
                byDirection(t, e) {
                    return 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? gt.S : gt.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? gt.E : gt.W : e > 0 ? t > 0 ? gt.SE : gt.SW : t > 0 ? gt.NE : gt.NW
                },
                matrixAppendRotationInv(t, e, n, r) {
                    void 0 === n && (n = 0), void 0 === r && (r = 0)
                    const i = vt[gt.inv(e)]
                    i.tx = n, i.ty = r, t.append(i)
                }
            }
            !(function () {
                function t() {
                    this.worldTransform = new ht(), this.localTransform = new ht(), this.position = new lt(this.onChange, this, 0, 0), this.scale = new lt(this.onChange, this, 1, 1), this.pivot = new lt(this.onChange, this, 0, 0), this.skew = new lt(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
                }
                t.prototype.onChange = function () {
                    this._localID++
                }, t.prototype.updateSkew = function () {
                    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
                }, t.prototype.toString = function () {
                    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
                }, t.prototype.updateLocalTransform = function () {
                    const t = this.localTransform
                    this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1)
                }, t.prototype.updateTransform = function (t) {
                    const e = this.localTransform
                    if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
                        const n = t.worldTransform
                        let r = this.worldTransform
                        r.a = e.a * n.a + e.b * n.c, r.b = e.a * n.b + e.b * n.d, r.c = e.c * n.a + e.d * n.c, r.d = e.c * n.b + e.d * n.d, r.tx = e.tx * n.a + e.ty * n.c + n.tx, r.ty = e.tx * n.b + e.ty * n.d + n.ty, this._parentID = t._worldID, this._worldID++
                    }
                }, t.prototype.setFromMatrix = function (t) {
                    t.decompose(this), this._localID++
                }, Object.defineProperty(t.prototype, 'rotation', {
                    get() {
                        return this._rotation
                    },
                    set(t) {
                        this._rotation !== t && (this._rotation = t, this.updateSkew())
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.IDENTITY = new t()
            }())
            /*!
                 * @pixi/core - v6.2.0
                 * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                 *
                 * @pixi/core is licensed under the MIT License.
                 * http://www.opensource.org/licenses/mit-license
                 */
            r.b.PREFER_ENV = r.a.any ? i.g.WEBGL : i.g.WEBGL2, r.b.STRICT_TEXTURE_CACHE = !1
            const bt = []

            function Et(t, e) {
                if (!t) return null
                let n = ''
                if (typeof t == 'string') {
                    const r = /\.(\w{3,4})(?:$|\?|#)/.exec(t)
                    r && (n = r[1].toLowerCase())
                }
                for (let i = bt.length - 1; i >= 0; --i) {
                    const o = bt[i]
                    if (o.test && o.test(t, n)) return new o(t, e)
                }
                throw new Error('Unrecognized source type to auto-detect Resource')
            }
            /*! *****************************************************************************
                Copyright (c) Microsoft Corporation. All rights reserved.
                Licensed under the Apache License, Version 2.0 (the "License"); you may not use
                this file except in compliance with the License. You may obtain a copy of the
                License at http://www.apache.org/licenses/LICENSE-2.0

                THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
                KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
                WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
                MERCHANTABLITY OR NON-INFRINGEMENT.

                See the Apache Version 2.0 License for specific language governing permissions
                and limitations under the License.
                ***************************************************************************** */
            let xt = function (t, e) {
                return (xt = Object.setPrototypeOf || Array.isArray({
                    __proto__: []
                })
                && function (t, e) {
                    t.__proto__ = e
                } || function (t, e) {
                    for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
                })(t, e)
            }

            function Tt(t, e) {
                function n() {
                    this.constructor = t
                }
                xt(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }
            let St = function () {
                return (St = Object.assign || function (t) {
                    for (var e, n = arguments, r = 1, i = arguments.length; r < i; r++) {
                        for (const o in e = n[r]) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o])
                    }
                    return t
                }).apply(this, arguments)
            }
            const wt = (function () {
                function t(t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new rt('setRealSize'), this.onUpdate = new rt('update'), this.onError = new rt('onError')
                }
                return t.prototype.bind = function (t) {
                    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
                }, t.prototype.unbind = function (t) {
                    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
                }, t.prototype.resize = function (t, e) {
                    t === this._width && e === this._height || (this._width = t, this._height = e, this.onResize.emit(t, e))
                }, Object.defineProperty(t.prototype, 'valid', {
                    get () {
                        return !!this._width && !!this._height
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.update = function () {
                    this.destroyed || this.onUpdate.emit()
                }, t.prototype.load = function () {
                    return Promise.resolve(this)
                }, Object.defineProperty(t.prototype, 'width', {
                    get () {
                        return this._width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'height', {
                    get () {
                        return this._height
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.style = function (t, e, n) {
                    return !1
                }, t.prototype.dispose = function () {}, t.prototype.destroy = function () {
                    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
                }, t.test = function (t, e) {
                    return !1
                }, t
            }())
            let Ot = (function (t) {
                function e(e, n) {
                    let r = this
                    var i = n || {}
                    var o = i.width
                    var a = i.height
                    if (!o || !a) throw new Error('BufferResource width or height invalid')
                    return (r = t.call(this, o, a) || this).data = e, r
                }
                return Tt(e, t), e.prototype.upload = function (t, e, n) {
                    const r = t.gl
                    r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === i.a.UNPACK)
                    let o = e.realWidth
                    var a = e.realHeight
                    return n.width === o && n.height === a ? r.texSubImage2D(e.target, 0, 0, 0, o, a, e.format, n.type, this.data) : (n.width = o, n.height = a, r.texImage2D(e.target, 0, n.internalFormat, o, a, 0, e.format, n.type, this.data)), !0
                }, e.prototype.dispose = function () {
                    this.data = null
                }, e.test = function (t) {
                    return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
                }, e
            }(wt))
            let Pt = {
                scaleMode: i.p.NEAREST,
                format: i.h.RGBA,
                alphaMode: i.a.NPM
            }
            let Rt = (function (t) {
                function e(e, n) {
                    void 0 === e && (e = null), void 0 === n && (n = null)
                    let o = t.call(this) || this
                    var a = (n = n || {}).alphaMode
                    var s = n.mipmap
                    var u = n.anisotropicLevel
                    var c = n.scaleMode
                    var l = n.width
                    var h = n.height
                    var f = n.wrapMode
                    var d = n.format
                    var p = n.type
                    var m = n.target
                    var y = n.resolution
                    var v = n.resourceOptions
                    return !e || e instanceof wt || ((e = Et(e, v)).internal = !0), o.resolution = y || r.b.RESOLUTION, o.width = Math.round((l || 0) * o.resolution) / o.resolution, o.height = Math.round((h || 0) * o.resolution) / o.resolution, o._mipmap = void 0 !== s ? s : r.b.MIPMAP_TEXTURES, o.anisotropicLevel = void 0 !== u ? u : r.b.ANISOTROPIC_LEVEL, o._wrapMode = f || r.b.WRAP_MODE, o._scaleMode = void 0 !== c ? c : r.b.SCALE_MODE, o.format = d || i.h.RGBA, o.type = p || i.r.UNSIGNED_BYTE, o.target = m || i.q.TEXTURE_2D, o.alphaMode = void 0 !== a ? a : i.a.UNPACK, o.uid = z(), o.touched = 0, o.isPowerOfTwo = !1, o._refreshPOT(), o._glTextures = {}, o.dirtyId = 0, o.dirtyStyleId = 0, o.cacheId = null, o.valid = l > 0 && h > 0, o.textureCacheIds = [], o.destroyed = !1, o.resource = null, o._batchEnabled = 0, o._batchLocation = 0, o.parentTextureArray = null, o.setResource(e), o
                }
                return Tt(e, t), Object.defineProperty(e.prototype, 'realWidth', {
                    get() {
                        return Math.round(this.width * this.resolution)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'realHeight', {
                    get() {
                        return Math.round(this.height * this.resolution)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'mipmap', {
                    get() {
                        return this._mipmap
                    },
                    set(t) {
                        this._mipmap !== t && (this._mipmap = t, this.dirtyStyleId++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'scaleMode', {
                    get() {
                        return this._scaleMode
                    },
                    set(t) {
                        this._scaleMode !== t && (this._scaleMode = t, this.dirtyStyleId++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'wrapMode', {
                    get() {
                        return this._wrapMode
                    },
                    set(t) {
                        this._wrapMode !== t && (this._wrapMode = t, this.dirtyStyleId++)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.setStyle = function (t, e) {
                    let n
                    return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t, n = !0), void 0 !== e && e !== this.mipmap && (this.mipmap = e, n = !0), n && this.dirtyStyleId++, this
                }, e.prototype.setSize = function (t, e, n) {
                    return n = n || this.resolution, this.setRealSize(t * n, e * n, n)
                }, e.prototype.setRealSize = function (t, e, n) {
                    return this.resolution = n || this.resolution, this.width = Math.round(t) / this.resolution, this.height = Math.round(e) / this.resolution, this._refreshPOT(), this.update(), this
                }, e.prototype._refreshPOT = function () {
                    this.isPowerOfTwo = V(this.realWidth) && V(this.realHeight)
                }, e.prototype.setResolution = function (t) {
                    const e = this.resolution
                    return e === t || (this.resolution = t, this.valid && (this.width = Math.round(this.width * e) / t, this.height = Math.round(this.height * e) / t, this.emit('update', this)), this._refreshPOT()), this
                }, e.prototype.setResource = function (t) {
                    if (this.resource === t) return this
                    if (this.resource) throw new Error('Resource can be set only once')
                    return t.bind(this), this.resource = t, this
                }, e.prototype.update = function () {
                    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit('update', this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit('loaded', this), this.emit('update', this))
                }, e.prototype.onError = function (t) {
                    this.emit('error', this, t)
                }, e.prototype.destroy = function () {
                    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Q[this.cacheId], delete J[this.cacheId], this.cacheId = null), this.dispose(), e.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
                }, e.prototype.dispose = function () {
                    this.emit('dispose', this)
                }, e.prototype.castToBaseTexture = function () {
                    return this
                }, e.from = function (t, n, i) {
                    void 0 === i && (i = r.b.STRICT_TEXTURE_CACHE)
                    let o = typeof t == 'string'
                    var a = null
                    if (o) { a = t
                    }
                    else {
                        if (!t._pixiId) {
                            const s = n && n.pixiIdPrefix || 'pixiid'
                            t._pixiId = `${s}_${z()}`
                        }
                        a = t._pixiId
                    }
                    let u = Q[a]
                    if (o && i && !u) throw new Error(`The cacheId "${a}" does not exist in BaseTextureCache.`)
                    return u || ((u = new e(t, n)).cacheId = a, e.addToCache(u, a)), u
                }, e.fromBuffer = function (t, n, r, o) {
                    t = t || new Float32Array(n * r * 4)
                    let a = new Ot(t, {
                        width: n,
                        height: r
                    })
                    var s = t instanceof Float32Array ? i.r.FLOAT : i.r.UNSIGNED_BYTE
                    return new e(a, Object.assign(Pt, o || {
                        width: n,
                        height: r,
                        type: s
                    }))
                }, e.addToCache = function (t, e) {
                    e && (!t.textureCacheIds.includes(e) && t.textureCacheIds.push(e), Q[e] && console.warn(`BaseTexture added to the cache with an id [${ e }] that already had an entry`), Q[e] = t)
                }, e.removeFromCache = function (t) {
                    if (typeof t == 'string') {
                        const e = Q[t]
                        if (e) {
                            const n = e.textureCacheIds.indexOf(t)
                            return n > -1 && e.textureCacheIds.splice(n, 1), delete Q[t], e
                        }
                    } else if (t && t.textureCacheIds) {
                        for (let r = 0; r < t.textureCacheIds.length; ++r) delete Q[t.textureCacheIds[r]]
                        return t.textureCacheIds.length = 0, t
                    }
                    return null
                }, e._globalBatch = 0, e
            }(l))
            let At = (function (t) {
                function e(e, n) {
                    let r = this
                    var i = n || {}
                    var o = i.width
                    var a = i.height;
                    (r = t.call(this, o, a) || this).items = [], r.itemDirtyIds = []
                    for (let s = 0; s < e; s++) {
                        const u = new Rt()
                        r.items.push(u), r.itemDirtyIds.push(-2)
                    }
                    return r.length = e, r._load = null, r.baseTexture = null, r
                }
                return Tt(e, t), e.prototype.initFromArray = function (t, e) {
                    for (let n = 0; n < this.length; n++) t[n] && (t[n].castToBaseTexture ? this.addBaseTextureAt(t[n].castToBaseTexture(), n) : t[n] instanceof wt ? this.addResourceAt(t[n], n) : this.addResourceAt(Et(t[n], e), n))
                }, e.prototype.dispose = function () {
                    for (let t = 0, e = this.length; t < e; t++) this.items[t].destroy()
                    this.items = null, this.itemDirtyIds = null, this._load = null
                }, e.prototype.addResourceAt = function (t, e) {
                    if (!this.items[e]) throw new Error(`Index ${ e } is out of bounds`)
                    return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this
                }, e.prototype.bind = function (e) {
                    if (this.baseTexture !== null) throw new Error('Only one base texture per TextureArray is allowed')
                    t.prototype.bind.call(this, e)
                    for (let n = 0; n < this.length; n++) this.items[n].parentTextureArray = e, this.items[n].on('update', e.update, e)
                }, e.prototype.unbind = function (e) {
                    t.prototype.unbind.call(this, e)
                    for (let n = 0; n < this.length; n++) this.items[n].parentTextureArray = null, this.items[n].off('update', e.update, e)
                }, e.prototype.load = function () {
                    const t = this
                    if (this._load) return this._load
                    let e = this.items.map((t) => {
                        return t.resource
                    }).filter((t) => {
                        return t
                    }).map((t) => {
                        return t.load()
                    })
                    return this._load = Promise.all(e).then(() => {
                        let e = t.items[0]
                                    var n = e.realWidth
                                    var r = e.realHeight
                        return t.resize(n, r), Promise.resolve(t)
                    }), this._load
                }, e
            }(wt))
            let It = (function (t) {
                function e(e, n) {
                    let r; let i; let o = this
                    var a = n || {}
                    var s = a.width
                    var u = a.height
                    return Array.isArray(e) ? (r = e, i = e.length) : i = e, o = t.call(this, i, {
                        width: s,
                        height: u
                    }) || this, r && o.initFromArray(r, n), o
                }
                return Tt(e, t), e.prototype.addBaseTextureAt = function (t, e) {
                    if (!t.resource) throw new Error('ArrayResource does not support RenderTexture')
                    return this.addResourceAt(t.resource, e), this
                }, e.prototype.bind = function (e) {
                    t.prototype.bind.call(this, e), e.target = i.q.TEXTURE_2D_ARRAY
                }, e.prototype.upload = function (t, e, n) {
                    const r = this.length
                    var i = this.itemDirtyIds
                    var o = this.items
                    var a = t.gl
                    n.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, r, 0, e.format, n.type, null)
                    for (let s = 0; s < r; s++) {
                        const u = o[s]
                        i[s] < u.dirtyId && (i[s] = u.dirtyId, u.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, s, u.resource.width, u.resource.height, 1, e.format, n.type, u.resource.source))
                    }
                    return !0
                }, e
            }(At))
            let Ct = (function (t) {
                function e(e) {
                    let n = this
                    var r = e
                    var i = r.naturalWidth || r.videoWidth || r.width
                    var o = r.naturalHeight || r.videoHeight || r.height
                    return (n = t.call(this, i, o) || this).source = e, n.noSubImage = !1, n
                }
                return Tt(e, t), e.crossOrigin = function (t, e, n) {
                    void 0 === n && e.indexOf('data:') !== 0 ? t.crossOrigin = tt(e) : !1 !== n && (t.crossOrigin = typeof n == 'string' ? n : 'anonymous')
                }, e.prototype.upload = function (t, e, n, r) {
                    const o = t.gl
                    var a = e.realWidth
                    var s = e.realHeight
                    return r = r || this.source, o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === i.a.UNPACK), this.noSubImage || e.target !== o.TEXTURE_2D || n.width !== a || n.height !== s ? (n.width = a, n.height = s, o.texImage2D(e.target, 0, n.internalFormat, e.format, n.type, r)) : o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, e.format, n.type, r), !0
                }, e.prototype.update = function () {
                    if (!this.destroyed) {
                        const e = this.source
                        var n = e.naturalWidth || e.videoWidth || e.width
                        var r = e.naturalHeight || e.videoHeight || e.height
                        this.resize(n, r), t.prototype.update.call(this)
                    }
                }, e.prototype.dispose = function () {
                    this.source = null
                }, e
            }(wt))
            let kt = (function (t) {
                function e(e) {
                    return t.call(this, e) || this
                }
                return Tt(e, t), e.test = function (t) {
                    const e = self.OffscreenCanvas
                    return !!(e && t instanceof e) || self.HTMLCanvasElement && t instanceof HTMLCanvasElement
                }, e
            }(Ct))
            let Nt = (function (t) {
                function e(n, r) {
                    let o = this
                    var a = r || {}
                    var s = a.width
                    var u = a.height
                    var c = a.autoLoad
                    var l = a.linkBaseTexture
                    if (n && n.length !== e.SIDES) throw new Error(`Invalid length. Got ${ n.length }, expected 6`)
                    o = t.call(this, 6, {
                        width: s,
                        height: u
                    }) || this
                    for (let h = 0; h < e.SIDES; h++) o.items[h].target = i.q.TEXTURE_CUBE_MAP_POSITIVE_X + h
                    return o.linkBaseTexture = !1 !== l, n && o.initFromArray(n, r), !1 !== c && o.load(), o
                }
                return Tt(e, t), e.prototype.bind = function (e) {
                    t.prototype.bind.call(this, e), e.target = i.q.TEXTURE_CUBE_MAP
                }, e.prototype.addBaseTextureAt = function (t, e, n) {
                    if (void 0 === n && (n = this.linkBaseTexture), !this.items[e]) throw new Error(`Index ${ e } is out of bounds`)
                    if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0) {
                        if (!t.resource) throw new Error('CubeResource does not support copying of renderTexture.')
                        this.addResourceAt(t.resource, e)
                    } else { t.target = i.q.TEXTURE_CUBE_MAP_POSITIVE_X + e, t.parentTextureArray = this.baseTexture, this.items[e] = t
                    }
                    return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[e] = t, this
                }, e.prototype.upload = function (t, n, r) {
                    for (let i = this.itemDirtyIds, o = 0; o < e.SIDES; o++) {
                        const a = this.items[o]
                        i[o] < a.dirtyId && (a.valid && a.resource ? (a.resource.upload(t, a, r), i[o] = a.dirtyId) : i[o] < -1 && (t.gl.texImage2D(a.target, 0, r.internalFormat, n.realWidth, n.realHeight, 0, n.format, r.type, null), i[o] = -1))
                    }
                    return !0
                }, e.test = function (t) {
                    return Array.isArray(t) && t.length === e.SIDES
                }, e.SIDES = 6, e
            }(At))
            let Mt = (function (t) {
                function e(e, n) {
                    let i = this
                    if (n = n || {}, !(e instanceof HTMLImageElement)) {
                        const o = new Image()
                        Ct.crossOrigin(o, e, n.crossorigin), o.src = e, e = o
                    }
                    return i = t.call(this, e) || this, !e.complete && i._width && i._height && (i._width = 0, i._height = 0), i.url = e.src, i._process = null, i.preserveBitmap = !1, i.createBitmap = (void 0 !== n.createBitmap ? n.createBitmap : r.b.CREATE_IMAGE_BITMAP) && !!self.createImageBitmap, i.alphaMode = typeof n.alphaMode == 'number' ? n.alphaMode : null, i.bitmap = null, i._load = null, !1 !== n.autoLoad && i.load(), i
                }
                return Tt(e, t), e.prototype.load = function (t) {
                    const e = this
                    return this._load || (void 0 !== t && (this.createBitmap = t), this._load = new Promise((t, n) => {
                        let r = e.source
                        e.url = r.src
                        var i = function () {
                            e.destroyed || (r.onload = null, r.onerror = null, e.resize(r.width, r.height), e._load = null, e.createBitmap ? t(e.process()) : t(e))
                        }
                        r.complete && r.src
                            ? i()
                            : (r.onload = i, r.onerror = function (t) {
                                    n(t), e.onError.emit(t)
                                })
                    })), this._load
                }, e.prototype.process = function () {
                    const t = this
                    var e = this.source
                    if (this._process !== null) return this._process
                    if (this.bitmap !== null || !self.createImageBitmap) return Promise.resolve(this)
                    let n = self.createImageBitmap
                    var r = !e.crossOrigin || e.crossOrigin === 'anonymous'
                    return this._process = fetch(e.src, {
                        mode: r ? 'cors' : 'no-cors'
                    }).then((t) => {
                        return t.blob()
                    }).then((r) => {
                        return n(r, 0, 0, e.width, e.height, {
                            premultiplyAlpha: t.alphaMode === i.a.UNPACK ? 'premultiply' : 'none'
                        })
                    }).then((e) => {
                        return t.destroyed ? Promise.reject() : (t.bitmap = e, t.update(), t._process = null, Promise.resolve(t))
                    }), this._process
                }, e.prototype.upload = function (e, n, r) {
                    if (typeof this.alphaMode == 'number' && (n.alphaMode = this.alphaMode), !this.createBitmap) return t.prototype.upload.call(this, e, n, r)
                    if (!this.bitmap && (this.process(), !this.bitmap)) return !1
                    if (t.prototype.upload.call(this, e, n, r, this.bitmap), !this.preserveBitmap) {
                        let i = !0
                        var o = n._glTextures
                        for (const a in o) {
                            const s = o[a]
                            if (s !== r && s.dirtyId !== n.dirtyId) {
                                i = !1
                                break
                            }
                        }
                        i && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
                    }
                    return !0
                }, e.prototype.dispose = function () {
                    this.source.onload = null, this.source.onerror = null, t.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
                }, e.test = function (t) {
                    return typeof t == 'string' || t instanceof HTMLImageElement
                }, e
            }(Ct))
            let jt = (function (t) {
                function e(e, n) {
                    let r = this
                    return n = n || {}, (r = t.call(this, document.createElement('canvas')) || this)._width = 0, r._height = 0, r.svg = e, r.scale = n.scale || 1, r._overrideWidth = n.width, r._overrideHeight = n.height, r._resolve = null, r._crossorigin = n.crossorigin, r._load = null, !1 !== n.autoLoad && r.load(), r
                }
                return Tt(e, t), e.prototype.load = function () {
                    const t = this
                    return this._load || (this._load = new Promise((n) => {
                        if (t._resolve = function () {
                            t.resize(t.source.width, t.source.height), n(t)
                        }, e.SVG_XML.test(t.svg.trim())) {
                            if (!btoa) throw new Error('Your browser doesn\'t support base64 conversions.')
                            t.svg = `data:image/svg+xml;base64,${  btoa(unescape(encodeURIComponent(t.svg)))}`
                        }
                        t._loadSvg()
                    })), this._load
                }, e.prototype._loadSvg = function () {
                    const t = this
                    var e = new Image()
                    Ct.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = function (n) {
                        t._resolve && (e.onerror = null, t.onError.emit(n))
                    }, e.onload = function () {
                        if (t._resolve) {
                            const n = e.width
                            var r = e.height
                            if (!n || !r) throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.')
                            let i = n * t.scale
                            var o = r * t.scale;
                            (t._overrideWidth || t._overrideHeight) && (i = t._overrideWidth || t._overrideHeight / r * n, o = t._overrideHeight || t._overrideWidth / n * r), i = Math.round(i), o = Math.round(o)
                            let a = t.source
                            a.width = i, a.height = o, a._pixiId = `canvas_${ z()}`, a.getContext('2d').drawImage(e, 0, 0, n, r, 0, 0, i, o), t._resolve(), t._resolve = null
                        }
                    }
                }, e.getSize = function (t) {
                    const n = e.SVG_SIZE.exec(t)
                    var r = {}
                    return n && (r[n[1]] = Math.round(Number.parseFloat(n[3])), r[n[5]] = Math.round(Number.parseFloat(n[7]))), r
                }, e.prototype.dispose = function () {
                    t.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null
                }, e.test = function (t, n) {
                    return n === 'svg' || typeof t == 'string' && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t) || typeof t == 'string' && e.SVG_XML.test(t)
                }, e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(?:(<!--[^(-->]*-->)\s*)?<svg/m, e.SVG_SIZE = /<svg[^>]*\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|")[^>]*\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|")[^>]*>/i, e
            }(Ct))
            let Dt = (function (t) {
                function e(n, r) {
                    let i = this
                    if (r = r || {}, !(n instanceof HTMLVideoElement)) {
                        const o = document.createElement('video')
                        o.setAttribute('preload', 'auto'), o.setAttribute('webkit-playsinline', ''), o.setAttribute('playsinline', ''), typeof n == 'string' && (n = [n])
                        let a = n[0].src || n[0]
                        Ct.crossOrigin(o, a, r.crossorigin)
                        for (let s = 0; s < n.length; ++s) {
                            const u = document.createElement('source')
                            var c = n[s]
                            var l = c.src
                            var h = c.mime
                            var f = (l = l || n[s]).split('?').shift().toLowerCase()
                            var d = f.substr(f.lastIndexOf('.') + 1)
                            h = h || e.MIME_TYPES[d] || `video/${ d}`, u.src = l, u.type = h, o.appendChild(u)
                        }
                        n = o
                    }
                    return (i = t.call(this, n) || this).noSubImage = !0, i._autoUpdate = !0, i._isConnectedToTicker = !1, i._updateFPS = r.updateFPS || 0, i._msToNextUpdate = 0, i.autoPlay = !1 !== r.autoPlay, i._load = null, i._resolve = null, i._onCanPlay = i._onCanPlay.bind(i), i._onError = i._onError.bind(i), !1 !== r.autoLoad && i.load(), i
                }
                return Tt(e, t), e.prototype.update = function (e) {
                    if (!this.destroyed) {
                        const n = at.shared.elapsedMS * this.source.playbackRate
                        this._msToNextUpdate = Math.floor(this._msToNextUpdate - n), (!this._updateFPS || this._msToNextUpdate <= 0) && (t.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
                    }
                }, e.prototype.load = function () {
                    const t = this
                    if (this._load) return this._load
                    let e = this.source
                    return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener('play', this._onPlayStart.bind(this)), e.addEventListener('pause', this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener('canplay', this._onCanPlay), e.addEventListener('canplaythrough', this._onCanPlay), e.addEventListener('error', this._onError, !0)), this._load = new Promise((n) => {
                        t.valid ? n(t) : (t._resolve = n, e.load())
                    }), this._load
                }, e.prototype._onError = function (t) {
                    this.source.removeEventListener('error', this._onError, !0), this.onError.emit(t)
                }, e.prototype._isSourcePlaying = function () {
                    const t = this.source
                    return t.currentTime > 0 && !1 === t.paused && !1 === t.ended && t.readyState > 2
                }, e.prototype._isSourceReady = function () {
                    const t = this.source
                    return t.readyState === 3 || t.readyState === 4
                }, e.prototype._onPlayStart = function () {
                    this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (at.shared.add(this.update, this), this._isConnectedToTicker = !0)
                }, e.prototype._onPlayStop = function () {
                    this._isConnectedToTicker && (at.shared.remove(this.update, this), this._isConnectedToTicker = !1)
                }, e.prototype._onCanPlay = function () {
                    const t = this.source
                    t.removeEventListener('canplay', this._onCanPlay), t.removeEventListener('canplaythrough', this._onCanPlay)
                    let e = this.valid
                    this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
                }, e.prototype.dispose = function () {
                    this._isConnectedToTicker && (at.shared.remove(this.update, this), this._isConnectedToTicker = !1)
                    let e = this.source
                    e && (e.removeEventListener('error', this._onError, !0), e.pause(), e.src = '', e.load()), t.prototype.dispose.call(this)
                }, Object.defineProperty(e.prototype, 'autoUpdate', {
                    get() {
                        return this._autoUpdate
                    },
                    set(t) {
                        t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (at.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (at.shared.add(this.update, this), this._isConnectedToTicker = !0))
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'updateFPS', {
                    get() {
                        return this._updateFPS
                    },
                    set(t) {
                        t !== this._updateFPS && (this._updateFPS = t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.test = function (t, n) {
                    return self.HTMLVideoElement && t instanceof HTMLVideoElement || e.TYPES.includes(n)
                }, e.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'], e.MIME_TYPES = {
                    ogv: 'video/ogg',
                    mov: 'video/quicktime',
                    m4v: 'video/mp4'
                }, e
            }(Ct))
            let Lt = (function (t) {
                function e(e) {
                    return t.call(this, e) || this
                }
                return Tt(e, t), e.test = function (t) {
                    return !!self.createImageBitmap && t instanceof ImageBitmap
                }, e
            }(Ct))
            bt.push(Mt, Lt, kt, Dt, jt, Ot, Nt, It)
            const Ft = {
                __proto__: null,
                Resource: wt,
                BaseImageResource: Ct,
                INSTALLED: bt,
                autoDetectResource: Et,
                AbstractMultiResource: At,
                ArrayResource: It,
                BufferResource: Ot,
                CanvasResource: kt,
                CubeResource: Nt,
                ImageResource: Mt,
                SVGResource: jt,
                VideoResource: Dt,
                ImageBitmapResource: Lt
            }
            const Bt = (function (t) {
                function e() {
                    return t !== null && t.apply(this, arguments) || this
                }
                return Tt(e, t), e.prototype.upload = function (t, e, n) {
                    let r = t.gl
                    r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === i.a.UNPACK)
                    var o = e.realWidth
                                var a = e.realHeight
                    return n.width === o && n.height === a ? r.texSubImage2D(e.target, 0, 0, 0, o, a, e.format, n.type, this.data) : (n.width = o, n.height = a, r.texImage2D(e.target, 0, n.internalFormat, o, a, 0, e.format, n.type, this.data)), !0
                }, e
            }(Ot))
            const Ut = (function () {
                function t(t, e) {
                    this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new rt('disposeFramebuffer'), this.multisample = i.l.NONE
                }
                return Object.defineProperty(t.prototype, 'colorTexture', {
                    get () {
                        return this.colorTextures[0]
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.addColorTexture = function (t, e) {
                    return void 0 === t && (t = 0), this.colorTextures[t] = e || new Rt(null, {
                        scaleMode: i.p.NEAREST,
                        resolution: 1,
                        mipmap: i.k.OFF,
                        width: this.width,
                        height: this.height
                    }), this.dirtyId++, this.dirtyFormat++, this
                }, t.prototype.addDepthTexture = function (t) {
                    return this.depthTexture = t || new Rt(new Bt(null, {
                        width: this.width,
                        height: this.height
                    }), {
                        scaleMode: i.p.NEAREST,
                        resolution: 1,
                        width: this.width,
                        height: this.height,
                        mipmap: i.k.OFF,
                        format: i.h.DEPTH_COMPONENT,
                        type: i.r.UNSIGNED_SHORT
                    }), this.dirtyId++, this.dirtyFormat++, this
                }, t.prototype.enableDepth = function () {
                    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
                }, t.prototype.enableStencil = function () {
                    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
                }, t.prototype.resize = function (t, e) {
                    if (t = Math.round(t), e = Math.round(e), t !== this.width || e !== this.height) {
                        this.width = t, this.height = e, this.dirtyId++, this.dirtySize++
                        for (let n = 0; n < this.colorTextures.length; n++) {
                            let r = this.colorTextures[n]
                                        var i = r.resolution
                            r.setSize(t / i, e / i)
                        }
                        if (this.depthTexture) {
                            i = this.depthTexture.resolution
                            this.depthTexture.setSize(t / i, e / i)
                        }
                    }
                }, t.prototype.dispose = function () {
                    this.disposeRunner.emit(this, !1)
                }, t.prototype.destroyDepthTexture = function () {
                    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
                }, t
            }())
            const Gt = (function (t) {
                function e(e) {
                    let n = this
                    if (typeof e == 'number') {
                        let r = arguments[0]
                                    var o = arguments[1]
                                    var a = arguments[2]
                                    var s = arguments[3]
                        e = {
                            width: r,
                            height: o,
                            scaleMode: a,
                            resolution: s
                        }
                    }
                    return e.width = e.width || 100, e.height = e.height || 100, e.multisample = void 0 !== e.multisample ? e.multisample : i.l.NONE, (n = t.call(this, null, e) || this).mipmap = i.k.OFF, n.valid = !0, n.clearColor = [0, 0, 0, 0], n.framebuffer = new Ut(n.realWidth, n.realHeight).addColorTexture(0, n), n.framebuffer.multisample = e.multisample, n.maskStack = [], n.filterStack = [{}], n
                }
                return Tt(e, t), e.prototype.resize = function (t, e) {
                    this.framebuffer.resize(t * this.resolution, e * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height)
                }, e.prototype.dispose = function () {
                    this.framebuffer.dispose(), t.prototype.dispose.call(this)
                }, e.prototype.destroy = function () {
                    t.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
                }, e
            }(Rt))
            const Xt = (function () {
                function t() {
                    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
                }
                return t.prototype.set = function (t, e, n) {
                    let r = e.width
                                var i = e.height
                    if (n) {
                        let o = t.width / 2 / r
                                    var a = t.height / 2 / i
                                    var s = t.x / r + o
                                    var u = t.y / i + a
                        n = gt.add(n, gt.NW), this.x0 = s + o * gt.uX(n), this.y0 = u + a * gt.uY(n), n = gt.add(n, 2), this.x1 = s + o * gt.uX(n), this.y1 = u + a * gt.uY(n), n = gt.add(n, 2), this.x2 = s + o * gt.uX(n), this.y2 = u + a * gt.uY(n), n = gt.add(n, 2), this.x3 = s + o * gt.uX(n), this.y3 = u + a * gt.uY(n)
                    } else { this.x0 = t.x / r, this.y0 = t.y / i, this.x1 = (t.x + t.width) / r, this.y1 = t.y / i, this.x2 = (t.x + t.width) / r, this.y2 = (t.y + t.height) / i, this.x3 = t.x / r, this.y3 = (t.y + t.height) / i
}
                    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
                }, t.prototype.toString = function () {
                    return `[@pixi/core:TextureUvs x0=${  this.x0  } y0=${  this.y0  } x1=${  this.x1  } y1=${  this.y1  } x2=${  this.x2  } y2=${  this.y2  } x3=${  this.x3  } y3=${  this.y3  }]`
                }, t
            }())
            const Ht = new Xt()
            const Vt = (function (t) {
                function e(n, r, i, o, a, s) {
                    const u = t.call(this) || this
                    if (u.noFrame = !1, r || (u.noFrame = !0, r = new ut(0, 0, 1, 1)), n instanceof e && (n = n.baseTexture), u.baseTexture = n, u._frame = r, u.trim = o, u.valid = !1, u._uvs = Ht, u.uvMatrix = null, u.orig = i || r, u._rotate = Number(a || 0), !0 === a) u._rotate = 2
                    else if (u._rotate % 2 != 0) throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually')
                    return u.defaultAnchor = s ? new ct(s.x, s.y) : new ct(0, 0), u._updateID = 0, u.textureCacheIds = [], n.valid ? u.noFrame ? n.valid && u.onBaseTextureUpdated(n) : u.frame = r : n.once('loaded', u.onBaseTextureUpdated, u), u.noFrame && n.on('update', u.onBaseTextureUpdated, u), u
                }
                return Tt(e, t), e.prototype.update = function () {
                    this.baseTexture.resource && this.baseTexture.resource.update()
                }, e.prototype.onBaseTextureUpdated = function (t) {
                    if (this.noFrame) {
                        if (!this.baseTexture.valid) return
                        this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
                    } else { this.frame = this._frame
                    }
                    this.emit('update', this)
                }, e.prototype.destroy = function (t) {
                    if (this.baseTexture) {
                        if (t) {
                            const n = this.baseTexture.resource
                            n && n.url && J[n.url] && e.removeFromCache(n.url), this.baseTexture.destroy()
                        }
                        this.baseTexture.off('loaded', this.onBaseTextureUpdated, this), this.baseTexture.off('update', this.onBaseTextureUpdated, this), this.baseTexture = null
                    }
                    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null
                }, e.prototype.clone = function () {
                    const t = this._frame.clone()
                    var n = this._frame === this.orig ? t : this.orig.clone()
                    var r = new e(this.baseTexture, !this.noFrame && t, n, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor)
                    return this.noFrame && (r._frame = t), r
                }, e.prototype.updateUvs = function () {
                    this._uvs === Ht && (this._uvs = new Xt()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
                }, e.from = function (t, n, i) {
                    void 0 === n && (n = {}), void 0 === i && (i = r.b.STRICT_TEXTURE_CACHE)
                    let o = typeof t == 'string'
                    var a = null
                    if (o) { a = t
                    }
                    else if (t instanceof Rt) {
                        if (!t.cacheId) {
                            var s = n && n.pixiIdPrefix || 'pixiid'
                            t.cacheId = `${s}-${z()}`, Rt.addToCache(t, t.cacheId)
                        }
                        a = t.cacheId
                    } else {
                        if (!t._pixiId) {
                            s = n && n.pixiIdPrefix || 'pixiid'
                            t._pixiId = `${s}_${z()}`
                        }
                        a = t._pixiId
                    }
                    let u = J[a]
                    if (o && i && !u) throw new Error(`The cacheId "${a}" does not exist in TextureCache.`)
                    return u || t instanceof Rt ? !u && t instanceof Rt && (u = new e(t), e.addToCache(u, a)) : (n.resolution || (n.resolution = et(t)), (u = new e(new Rt(t, n))).baseTexture.cacheId = a, Rt.addToCache(u.baseTexture, a), e.addToCache(u, a)), u
                }, e.fromURL = function (t, n) {
                    const r = Object.assign({
                        autoLoad: !1
                    }, n == null ? void 0 : n.resourceOptions)
                    var i = e.from(t, Object.assign({
                        resourceOptions: r
                    }, n), !1)
                    var o = i.baseTexture.resource
                    return i.baseTexture.valid
                        ? Promise.resolve(i)
                        : o.load().then(() => {
                                return Promise.resolve(i)
                            })
                }, e.fromBuffer = function (t, n, r, i) {
                    return new e(Rt.fromBuffer(t, n, r, i))
                }, e.fromLoader = function (t, n, i, o) {
                    const a = new Rt(t, Object.assign({
                        scaleMode: r.b.SCALE_MODE,
                        resolution: et(n)
                    }, o))
                    var s = a.resource
                    s instanceof Mt && (s.url = n)
                    let u = new e(a)
                    return i || (i = n), Rt.addToCache(u.baseTexture, i), e.addToCache(u, i), i !== n && (Rt.addToCache(u.baseTexture, n), e.addToCache(u, n)), u.baseTexture.valid
                        ? Promise.resolve(u)
                        : new Promise((t) => {
                            u.baseTexture.once('loaded', () => {
                                return t(u)
                            })
                        })
                }, e.addToCache = function (t, e) {
                    e && (!t.textureCacheIds.includes(e) && t.textureCacheIds.push(e), J[e] && console.warn(`Texture added to the cache with an id [${ e }] that already had an entry`), J[e] = t)
                }, e.removeFromCache = function (t) {
                    if (typeof t == 'string') {
                        const e = J[t]
                        if (e) {
                            const n = e.textureCacheIds.indexOf(t)
                            return n > -1 && e.textureCacheIds.splice(n, 1), delete J[t], e
                        }
                    } else if (t && t.textureCacheIds) {
                        for (let r = 0; r < t.textureCacheIds.length; ++r) J[t.textureCacheIds[r]] === t && delete J[t.textureCacheIds[r]]
                        return t.textureCacheIds.length = 0, t
                    }
                    return null
                }, Object.defineProperty(e.prototype, 'resolution', {
                    get() {
                        return this.baseTexture.resolution
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'frame', {
                    get() {
                        return this._frame
                    },
                    set(t) {
                        this._frame = t, this.noFrame = !1
                        var e = t.x
                                    var n = t.y
                                    var r = t.width
                                    var i = t.height
                                    var o = e + r > this.baseTexture.width
                                    var a = n + i > this.baseTexture.height
                        if (o || a) {
                            let s = o && a ? 'and' : 'or';
                                var u = 'X: ' + e + ' + ' + r + ' = ' + (e + r) + ' > ' + this.baseTexture.width;
                                var c = `Y: ${  n  } + ${  i  } = ${  n + i  } > ${  this.baseTexture.height}`
                            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${  u  } ${  s  } ${  c}`)
                        }
                        this.valid = r && i && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t), this.valid && this.updateUvs()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'rotate', {
                    get() {
                        return this._rotate
                    },
                    set(t) {
                        this._rotate = t, this.valid && this.updateUvs()
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'width', {
                    get() {
                        return this.orig.width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'height', {
                    get() {
                        return this.orig.height
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.castToBaseTexture = function () {
                    return this.baseTexture
                }, e
            }(l))

            function Wt(t) {
                t.destroy = function () {}, t.on = function () {}, t.once = function () {}, t.emit = function () {}
            }
            Vt.EMPTY = new Vt(new Rt()), Wt(Vt.EMPTY), Wt(Vt.EMPTY.baseTexture), Vt.WHITE = (function () {
                const t = document.createElement('canvas')
                t.width = 16, t.height = 16
                const e = t.getContext('2d')
                return e.fillStyle = 'white', e.fillRect(0, 0, 16, 16), new Vt(new Rt(new kt(t)))
            }()), Wt(Vt.WHITE), Wt(Vt.WHITE.baseTexture)
            const Yt = (function (t) {
                function e(e, n) {
                    let r = t.call(this, e, n) || this
                    return r.valid = !0, r.filterFrame = null, r.filterPoolKey = null, r.updateUvs(), r
                }
                return Tt(e, t), Object.defineProperty(e.prototype, 'framebuffer', {
                    get () {
                        return this.baseTexture.framebuffer
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'multisample', {
                    get () {
                        return this.framebuffer.multisample
                    },
                    set (t) {
                        this.framebuffer.multisample = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.resize = function (t, e, n) {
                    void 0 === n && (n = !0)
                    let r = this.baseTexture.resolution
                    var i = Math.round(t * r) / r
                    var o = Math.round(e * r) / r
                    this.valid = i > 0 && o > 0, this._frame.width = this.orig.width = i, this._frame.height = this.orig.height = o, n && this.baseTexture.resize(i, o), this.updateUvs()
                }, e.prototype.setResolution = function (t) {
                    let e = this.baseTexture
                    e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1))
                }, e.create = function (t) {
                    for (var n = arguments, r = [], i = 1; i < arguments.length; i++) r[i - 1] = n[i]
                    return typeof t == 'number' && (K('6.0.0', 'Arguments (width, height, scaleMode, resolution) have been deprecated.'), t = {
                        width: t,
                        height: r[0],
                        scaleMode: r[1],
                        resolution: r[2]
                    }), new e(new Gt(t))
                }, e
            }(Vt))
            let zt = (function () {
                function t(t) {
                    this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
                }
                return t.prototype.createTexture = function (t, e, n) {
                    void 0 === n && (n = i.l.NONE)
                    let r = new Gt(Object.assign({
                        width: t,
                        height: e,
                        resolution: 1,
                        multisample: n
                    }, this.textureOptions))
                    return new Yt(r)
                }, t.prototype.getOptimalTexture = function (t, e, n, r) {
                    let o
                    void 0 === n && (n = 1), void 0 === r && (r = i.l.NONE), t = Math.ceil(t * n), e = Math.ceil(e * n), this.enableFullScreen && t === this._pixelsWidth && e === this._pixelsHeight ? o = r > 1 ? -r : -1 : (o = ((65535 & (t = H(t))) << 16 | 65535 & (e = H(e))) >>> 0, r > 1 && (o += 4294967296 * r)), this.texturePool[o] || (this.texturePool[o] = [])
                    let a = this.texturePool[o].pop()
                    return a || (a = this.createTexture(t, e, r)), a.filterPoolKey = o, a.setResolution(n), a
                }, t.prototype.getFilterTexture = function (t, e, n) {
                    const r = this.getOptimalTexture(t.width, t.height, e || t.resolution, n || i.l.NONE)
                    return r.filterFrame = t.filterFrame, r
                }, t.prototype.returnTexture = function (t) {
                    const e = t.filterPoolKey
                    t.filterFrame = null, this.texturePool[e].push(t)
                }, t.prototype.returnFilterTexture = function (t) {
                    this.returnTexture(t)
                }, t.prototype.clear = function (t) {
                    if (t = !1 !== t) {
                        for (const e in this.texturePool) {
                            let n = this.texturePool[e]
                            if (n) {
                                for (let r = 0; r < n.length; r++) n[r].destroy(!0)
                            }
                        }
                    }
                    this.texturePool = {}
                }, t.prototype.setScreenSize = function (t) {
                    if (t.width !== this._pixelsWidth || t.height !== this._pixelsHeight) {
                        for (const e in this.enableFullScreen = t.width > 0 && t.height > 0, this.texturePool) {
                            if (Number(e) < 0) {
                                let n = this.texturePool[e]
                                if (n) {
                                    for (let r = 0; r < n.length; r++) n[r].destroy(!0)
}
                                this.texturePool[e] = []
                            }
                        }
                        this._pixelsWidth = t.width, this._pixelsHeight = t.height
                    }
                }, t.SCREEN_KEY = -1, t
            }())
            let qt = (function () {
                function t(t, e, n, r, o, a, s) {
                    void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = i.r.FLOAT), this.buffer = t, this.size = e, this.normalized = n, this.type = r, this.stride = o, this.start = a, this.instance = s
                }
                return t.prototype.destroy = function () {
                    this.buffer = null
                }, t.from = function (e, n, r, i, o) {
                    return new t(e, n, r, i, o)
                }, t
            }())
            let Kt = 0
            let Zt = (function () {
                function t(t, e, n) {
                    void 0 === e && (e = !0), void 0 === n && (n = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = n, this.static = e, this.id = Kt++, this.disposeRunner = new rt('disposeBuffer')
                }
                return t.prototype.update = function (t) {
                    Array.isArray(t) && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++
                }, t.prototype.dispose = function () {
                    this.disposeRunner.emit(this, !1)
                }, t.prototype.destroy = function () {
                    this.dispose(), this.data = null
                }, Object.defineProperty(t.prototype, 'index', {
                    get() {
                        return this.type === i.d.ELEMENT_ARRAY_BUFFER
                    },
                    set(t) {
                        this.type = t ? i.d.ELEMENT_ARRAY_BUFFER : i.d.ARRAY_BUFFER
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.from = function (e) {
                    return Array.isArray(e) && (e = new Float32Array(e)), new t(e)
                }, t
            }())
            let $t = {
                Float32Array,
                Uint32Array,
                Int32Array,
                Uint8Array
            }
            const Jt = {
                5126: 4,
                5123: 2,
                5121: 1
            }
            let Qt = 0
            const te = {
                Float32Array,
                Uint32Array,
                Int32Array,
                Uint8Array,
                Uint16Array
            }
            const ee = (function () {
                function t(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = Qt++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new rt('disposeGeometry'), this.refCount = 0
                }
                return t.prototype.addAttribute = function (t, e, n, r, i, o, a, s) {
                    if (void 0 === n && (n = 0), void 0 === r && (r = !1), void 0 === s && (s = !1), !e) throw new Error('You must pass a buffer when creating an attribute')
                    e instanceof Zt || (Array.isArray(e) && (e = new Float32Array(e)), e = new Zt(e))
                    var u = t.split('|')
                    if (u.length > 1) {
                        for (let c = 0; c < u.length; c++) this.addAttribute(u[c], e, n, r, i)
                        return this
                    }
                    let l = this.buffers.indexOf(e)
                    return l === -1 && (this.buffers.push(e), l = this.buffers.length - 1), this.attributes[t] = new qt(l, n, r, i, o, a, s), this.instanced = this.instanced || s, this
                }, t.prototype.getAttribute = function (t) {
                    return this.attributes[t]
                }, t.prototype.getBuffer = function (t) {
                    return this.buffers[this.getAttribute(t).buffer]
                }, t.prototype.addIndex = function (t) {
                    return t instanceof Zt || (Array.isArray(t) && (t = new Uint16Array(t)), t = new Zt(t)), t.type = i.d.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, !this.buffers.includes(t) && this.buffers.push(t), this
                }, t.prototype.getIndex = function () {
                    return this.indexBuffer
                }, t.prototype.interleave = function () {
                    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this
                    var t; let e = []
                                var n = []
                                var r = new Zt()
                    for (t in this.attributes) {
                        let i = this.attributes[t]
                                    var o = this.buffers[i.buffer]
                        e.push(o.data), n.push(i.size * Jt[i.type] / 4), i.buffer = 0
                    }
                    for (r.data = (function (t, e) {
                        for (var n = 0, r = 0, i = {}, o = 0; o < t.length; o++) r += e[o], n += t[o].length
                                    var a = new ArrayBuffer(4 * n);
                                        var s = null;
                                        var u = 0
                                    for (o = 0; o < t.length; o++) {
                            var c = e[o];
                                            var l = t[o];
                                            var h = X(l)
                                        i[h] || (i[h] = new $t[h](a)), s = i[h]
                                        for (let f = 0; f < l.length; f++) {
                                s[(f / c | 0) * r + u + f % c] = l[f]
                            }
                            u += c
                        }
                        return new Float32Array(a)
                    }(e, n)), t = 0; t < this.buffers.length; t++) this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy()
                    return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this
                }, t.prototype.getSize = function () {
                    for (const t in this.attributes) {
                        let e = this.attributes[t]
                        return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
                    }
                    return 0
                }, t.prototype.dispose = function () {
                    this.disposeRunner.emit(this, !1)
                }, t.prototype.destroy = function () {
                    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
                }, t.prototype.clone = function () {
                    for (var e = new t(), n = 0; n < this.buffers.length; n++) e.buffers[n] = new Zt(this.buffers[n].data.slice(0))
                    for (var n in this.attributes) {
                        let r = this.attributes[n]
                        e.attributes[n] = new qt(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance)
                    }
                    return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.type = i.d.ELEMENT_ARRAY_BUFFER), e
                }, t.merge = function (e) {
                    for (var n, r = new t(), o = [], a = [], s = [], u = 0; u < e.length; u++) {
                        n = e[u]
                        for (var c = 0; c < n.buffers.length; c++) a[c] = a[c] || 0, a[c] += n.buffers[c].data.length, s[c] = 0
                    }
                    for (u = 0; u < n.buffers.length; u++) o[u] = new (te[X(n.buffers[u].data)])(a[u]), r.buffers[u] = new Zt(o[u])
                    for (u = 0; u < e.length; u++) {
                        n = e[u]
                        for (c = 0; c < n.buffers.length; c++) o[c].set(n.buffers[c].data, s[c]), s[c] += n.buffers[c].data.length
                    }
                    if (r.attributes = n.attributes, n.indexBuffer) {
                        r.indexBuffer = r.buffers[n.buffers.indexOf(n.indexBuffer)], r.indexBuffer.type = i.d.ELEMENT_ARRAY_BUFFER
                        var l = 0
                                    var h = 0
                                    var f = 0
                                    var d = 0
                        for (u = 0; u < n.buffers.length; u++) {
                            if (n.buffers[u] !== n.indexBuffer) {
                                d = u
                                        break
                            }
                        }
                        for (var u in n.attributes) {
                            let p = n.attributes[u];
                            (0 | p.buffer) === d && (h += p.size * Jt[p.type] / 4)
                        }
                        for (u = 0; u < e.length; u++) {
                            let m = e[u].indexBuffer.data
                            for (c = 0; c < m.length; c++) r.indexBuffer.data[c + f] += l
                            l += e[u].buffers[d].data.length / h, f += m.length
                        }
                    }
                    return r
                }, t
            }())
            const ne = (function (t) {
                function e() {
                    let e = t.call(this) || this
                    return e.addAttribute('aVertexPosition', new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e
                }
                return Tt(e, t), e
            }(ee))
            const re = (function (t) {
                function e() {
                    let e = t.call(this) || this
                    return e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e.vertexBuffer = new Zt(e.vertices), e.uvBuffer = new Zt(e.uvs), e.addAttribute('aVertexPosition', e.vertexBuffer).addAttribute('aTextureCoord', e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e
                }
                return Tt(e, t), e.prototype.map = function (t, e) {
                    let n = 0
                                var r = 0
                    return this.uvs[0] = n, this.uvs[1] = r, this.uvs[2] = n + e.width / t.width, this.uvs[3] = r, this.uvs[4] = n + e.width / t.width, this.uvs[5] = r + e.height / t.height, this.uvs[6] = n, this.uvs[7] = r + e.height / t.height, n = e.x, r = e.y, this.vertices[0] = n, this.vertices[1] = r, this.vertices[2] = n + e.width, this.vertices[3] = r, this.vertices[4] = n + e.width, this.vertices[5] = r + e.height, this.vertices[6] = n, this.vertices[7] = r + e.height, this.invalidate(), this
                }, e.prototype.invalidate = function () {
                    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
                }, e
            }(ee))
            let ie = 0
            const oe = (function () {
                function t(t, e, n) {
                    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = ie++, this.static = !!e, this.ubo = !!n, t instanceof Zt ? (this.buffer = t, this.buffer.type = i.d.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Zt(new Float32Array(1)), this.buffer.type = i.d.UNIFORM_BUFFER, this.autoManage = !0))
                }
                return t.prototype.update = function () {
                    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update()
                }, t.prototype.add = function (e, n, r) {
                    if (this.ubo) throw new Error('[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them')
                    this.uniforms[e] = new t(n, r)
                }, t.from = function (e, n, r) {
                    return new t(e, n, r)
                }, t.uboFrom = function (e, n) {
                    return new t(e, n == null || n, !0)
                }, t
            }())
            const ae = (function () {
                function t() {
                    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = i.l.NONE, this.sourceFrame = new ut(), this.destinationFrame = new ut(), this.bindingSourceFrame = new ut(), this.bindingDestinationFrame = new ut(), this.filters = [], this.transform = null
                }
                return t.prototype.clear = function () {
                    this.target = null, this.filters = null, this.renderTexture = null
                }, t
            }())
            const se = [new ct(), new ct(), new ct(), new ct()]
            const ue = new ht()
            const ce = (function () {
                function t(t) {
                    this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new zt(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new ne(), this.quadUv = new re(), this.tempRect = new ut(), this.activeState = {}, this.globalUniforms = new oe({
                        outputFrame: new ut(),
                        inputSize: new Float32Array(4),
                        inputPixel: new Float32Array(4),
                        inputClamp: new Float32Array(4),
                        resolution: 1,
                        filterArea: new Float32Array(4),
                        filterClamp: new Float32Array(4)
                    }, !0), this.forceClear = !1, this.useMaxPadding = !1
                }
                return t.prototype.push = function (t, e) {
                    for (var n = this.renderer, r = this.defaultFilterStack, i = this.statePool.pop() || new ae(), o = this.renderer.renderTexture, a = e[0].resolution, s = e[0].multisample, u = e[0].padding, c = e[0].autoFit, l = e[0].legacy, h = 1; h < e.length; h++) {
                        let f = e[h]
                        a = Math.min(a, f.resolution), s = Math.min(s, f.multisample), u = this.useMaxPadding ? Math.max(u, f.padding) : u + f.padding, c = c && f.autoFit, l = l || f.legacy
                    }
                    if (r.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current), r.push(i), i.resolution = a, i.multisample = s, i.legacy = l, i.target = t, i.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), i.sourceFrame.pad(u), c) {
                        let d = this.tempRect.copyFrom(o.sourceFrame)
                        n.projection.transform && this.transformAABB(ue.copyFrom(n.projection.transform).invert(), d), i.sourceFrame.fit(d)
                    }
                    this.roundFrame(i.sourceFrame, o.current ? o.current.resolution : n.resolution, o.sourceFrame, o.destinationFrame, n.projection.transform), i.renderTexture = this.getOptimalFilterTexture(i.sourceFrame.width, i.sourceFrame.height, a, s), i.filters = e, i.destinationFrame.width = i.renderTexture.width, i.destinationFrame.height = i.renderTexture.height
                    var p = this.tempRect
                    p.x = 0, p.y = 0, p.width = i.sourceFrame.width, p.height = i.sourceFrame.height, i.renderTexture.filterFrame = i.sourceFrame, i.bindingSourceFrame.copyFrom(o.sourceFrame), i.bindingDestinationFrame.copyFrom(o.destinationFrame), i.transform = n.projection.transform, n.projection.transform = null, o.bind(i.renderTexture, i.sourceFrame, p), n.framebuffer.clear(0, 0, 0, 0)
                }, t.prototype.pop = function () {
                    let t = this.defaultFilterStack
                                var e = t.pop()
                                var n = e.filters
                    this.activeState = e
                    var r = this.globalUniforms.uniforms
                    r.outputFrame = e.sourceFrame, r.resolution = e.resolution
                    var o = r.inputSize
                                var a = r.inputPixel
                                var s = r.inputClamp
                    if (o[0] = e.destinationFrame.width, o[1] = e.destinationFrame.height, o[2] = 1 / o[0], o[3] = 1 / o[1], a[0] = Math.round(o[0] * e.resolution), a[1] = Math.round(o[1] * e.resolution), a[2] = 1 / a[0], a[3] = 1 / a[1], s[0] = 0.5 * a[2], s[1] = 0.5 * a[3], s[2] = e.sourceFrame.width * o[2] - 0.5 * a[2], s[3] = e.sourceFrame.height * o[3] - 0.5 * a[3], e.legacy) {
                        let u = r.filterArea
                        u[0] = e.destinationFrame.width, u[1] = e.destinationFrame.height, u[2] = e.sourceFrame.x, u[3] = e.sourceFrame.y, r.filterClamp = r.inputClamp
                    }
                    this.globalUniforms.update()
                    var c = t[t.length - 1]
                    if (this.renderer.framebuffer.blit(), n.length === 1) { n[0].apply(this, e.renderTexture, c.renderTexture, i.e.BLEND, e), this.returnFilterTexture(e.renderTexture)
}
                    else {
                        let l = e.renderTexture
                                    var h = this.getOptimalFilterTexture(l.width, l.height, e.resolution)
                        h.filterFrame = l.filterFrame
                        var f = 0
                        for (f = 0; f < n.length - 1; ++f) {
                            f === 1 && e.multisample > 1 && ((h = this.getOptimalFilterTexture(l.width, l.height, e.resolution)).filterFrame = l.filterFrame), n[f].apply(this, l, h, i.e.CLEAR, e)
                            var d = l
                            l = h, h = d
                        }
                        n[f].apply(this, l, c.renderTexture, i.e.BLEND, e), f > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(l), this.returnFilterTexture(h)
                    }
                    e.clear(), this.statePool.push(e)
                }, t.prototype.bindAndClear = function (t, e) {
                    void 0 === e && (e = i.e.CLEAR)
                    var n = this.renderer
                                var r = n.renderTexture
                                var o = n.state
                    if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
                        let a = this.tempRect
                        a.x = 0, a.y = 0, a.width = t.filterFrame.width, a.height = t.filterFrame.height, r.bind(t, t.filterFrame, a)
                    } else { t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? r.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame)
}
                    let s = 1 & o.stateId || this.forceClear;
                    (e === i.e.CLEAR || e === i.e.BLIT && s) && this.renderer.framebuffer.clear(0, 0, 0, 0)
                }, t.prototype.applyFilter = function (t, e, n, r) {
                    let o = this.renderer
                    o.state.set(t.state), this.bindAndClear(n, r), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, o.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), o.geometry.bind(this.quadUv), o.geometry.draw(i.f.TRIANGLES)) : (o.geometry.bind(this.quad), o.geometry.draw(i.f.TRIANGLE_STRIP))
                }, t.prototype.calculateSpriteMatrix = function (t, e) {
                    let n = this.activeState
                                var r = n.sourceFrame
                                var i = n.destinationFrame
                                var o = e._texture.orig
                                var a = t.set(i.width, 0, 0, i.height, r.x, r.y)
                                var s = e.worldTransform.copyTo(ht.TEMP_MATRIX)
                    return s.invert(), a.prepend(s), a.scale(1 / o.width, 1 / o.height), a.translate(e.anchor.x, e.anchor.y), a
                }, t.prototype.destroy = function () {
                    this.renderer = null, this.texturePool.clear(!1)
                }, t.prototype.getOptimalFilterTexture = function (t, e, n, r) {
                    return void 0 === n && (n = 1), void 0 === r && (r = i.l.NONE), this.texturePool.getOptimalTexture(t, e, n, r)
                }, t.prototype.getFilterTexture = function (t, e, n) {
                    if (typeof t == 'number') {
                        let r = t
                        t = e, e = r
                    }
                    t = t || this.activeState.renderTexture
                    var o = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, n || i.l.NONE)
                    return o.filterFrame = t.filterFrame, o
                }, t.prototype.returnFilterTexture = function (t) {
                    this.texturePool.returnTexture(t)
                }, t.prototype.emptyPool = function () {
                    this.texturePool.clear(!0)
                }, t.prototype.resize = function () {
                    this.texturePool.setScreenSize(this.renderer.view)
                }, t.prototype.transformAABB = function (t, e) {
                    let n = se[0]
                                var r = se[1]
                                var i = se[2]
                                var o = se[3]
                    n.set(e.left, e.top), r.set(e.left, e.bottom), i.set(e.right, e.top), o.set(e.right, e.bottom), t.apply(n, n), t.apply(r, r), t.apply(i, i), t.apply(o, o)
                    var a = Math.min(n.x, r.x, i.x, o.x)
                                var s = Math.min(n.y, r.y, i.y, o.y)
                                var u = Math.max(n.x, r.x, i.x, o.x)
                                var c = Math.max(n.y, r.y, i.y, o.y)
                    e.x = a, e.y = s, e.width = u - a, e.height = c - s
                }, t.prototype.roundFrame = function (t, e, n, r, i) {
                    if (i) {
                        let o = i.a
                                    var a = i.b
                                    var s = i.c
                                    var u = i.d
                        if ((Math.abs(a) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(u) > 1e-4)) return
                    }(i = i ? ue.copyFrom(i) : ue.identity()).translate(-n.x, -n.y).scale(r.width / n.width, r.height / n.height).translate(r.x, r.y), this.transformAABB(i, t), t.ceil(e), this.transformAABB(i.invert(), t)
                }, t
            }())
            const le = (function () {
                function t(t) {
                    this.renderer = t
                }
                return t.prototype.flush = function () {}, t.prototype.destroy = function () {
                    this.renderer = null
                }, t.prototype.start = function () {}, t.prototype.stop = function () {
                    this.flush()
                }, t.prototype.render = function (t) {}, t
            }())
            const he = (function () {
                function t(t) {
                    this.renderer = t, this.emptyRenderer = new le(t), this.currentRenderer = this.emptyRenderer
                }
                return t.prototype.setObjectRenderer = function (t) {
                    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
                }, t.prototype.flush = function () {
                    this.setObjectRenderer(this.emptyRenderer)
                }, t.prototype.reset = function () {
                    this.setObjectRenderer(this.emptyRenderer)
                }, t.prototype.copyBoundTextures = function (t, e) {
                    for (let n = this.renderer.texture.boundTextures, r = e - 1; r >= 0; --r) t[r] = n[r] || null, t[r] && (t[r]._batchLocation = r)
                }, t.prototype.boundArray = function (t, e, n, r) {
                    for (let i = t.elements, o = t.ids, a = t.count, s = 0, u = 0; u < a; u++) {
                        let c = i[u]
                                    var l = c._batchLocation
                        if (l >= 0 && l < r && e[l] === c) { o[u] = l
}
                        else {
                            for (; s < r;) {
                                var h = e[s]
                                        if (!h || h._batchEnabled !== n || h._batchLocation !== s) {
                                    o[u] = s, c._batchLocation = s, e[s] = c
                                            break
                                }
                                s++
                            }
                        }
                    }
                }, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())
            let fe = 0
            const de = (function () {
                function t(t) {
                    this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
                        uint32Indices: !1
                    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener('webglcontextlost', this.handleContextLost, !1), t.view.addEventListener('webglcontextrestored', this.handleContextRestored, !1)
                }
                return Object.defineProperty(t.prototype, 'isLost', {
                    get () {
                        return !this.gl || this.gl.isContextLost()
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.contextChange = function (t) {
                    this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = fe++, t.isContextLost() && t.getExtension('WEBGL_lose_context') && t.getExtension('WEBGL_lose_context').restoreContext()
                }, t.prototype.initFromContext = function (t) {
                    this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = fe++, this.renderer.runners.contextChange.emit(t)
                }, t.prototype.initFromOptions = function (t) {
                    let e = this.createContext(this.renderer.view, t)
                    this.initFromContext(e)
                }, t.prototype.createContext = function (t, e) {
                    let n
                    if (r.b.PREFER_ENV >= i.g.WEBGL2 && (n = t.getContext('webgl2', e)), n) this.webGLVersion = 2
                    else if (this.webGLVersion = 1, !(n = t.getContext('webgl', e) || t.getContext('experimental-webgl', e))) throw new Error('This browser does not support WebGL. Try using the canvas renderer')
                    return this.gl = n, this.getExtensions(), this.gl
                }, t.prototype.getExtensions = function () {
                    let t = this.gl
                                var e = {
                        anisotropicFiltering: t.getExtension('EXT_texture_filter_anisotropic'),
                        floatTextureLinear: t.getExtension('OES_texture_float_linear'),
                        s3tc: t.getExtension('WEBGL_compressed_texture_s3tc'),
                        s3tc_sRGB: t.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
                        etc: t.getExtension('WEBGL_compressed_texture_etc'),
                        etc1: t.getExtension('WEBGL_compressed_texture_etc1'),
                        pvrtc: t.getExtension('WEBGL_compressed_texture_pvrtc') || t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
                        atc: t.getExtension('WEBGL_compressed_texture_atc'),
                        astc: t.getExtension('WEBGL_compressed_texture_astc')
                    };
                    this.webGLVersion === 1
                        ? Object.assign(this.extensions, e, {
                                drawBuffers: t.getExtension('WEBGL_draw_buffers'),
                                depthTexture: t.getExtension('WEBGL_depth_texture'),
                                loseContext: t.getExtension('WEBGL_lose_context'),
                                vertexArrayObject: t.getExtension('OES_vertex_array_object') || t.getExtension('MOZ_OES_vertex_array_object') || t.getExtension('WEBKIT_OES_vertex_array_object'),
                                uint32ElementIndex: t.getExtension('OES_element_index_uint'),
                                floatTexture: t.getExtension('OES_texture_float'),
                                floatTextureLinear: t.getExtension('OES_texture_float_linear'),
                                textureHalfFloat: t.getExtension('OES_texture_half_float'),
                                textureHalfFloatLinear: t.getExtension('OES_texture_half_float_linear')
                            })
                        : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
                            colorBufferFloat: t.getExtension('EXT_color_buffer_float')
                        })
                }, t.prototype.handleContextLost = function (t) {
                    t.preventDefault()
                }, t.prototype.handleContextRestored = function () {
                    this.renderer.runners.contextChange.emit(this.gl)
                }, t.prototype.destroy = function () {
                    let t = this.renderer.view
                    this.renderer = null, t.removeEventListener('webglcontextlost', this.handleContextLost), t.removeEventListener('webglcontextrestored', this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
                }, t.prototype.postrender = function () {
                    this.renderer.renderingToScreen && this.gl.flush()
                }, t.prototype.validateContext = function (t) {
                    let e = t.getContextAttributes()
                                var n = 'WebGL2RenderingContext' in self && t instanceof self.WebGL2RenderingContext
                    n && (this.webGLVersion = 2), e.stencil || console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly')
                    var r = n || !!t.getExtension('OES_element_index_uint')
                    this.supports.uint32Indices = r, r || console.warn('Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly')
                }, t
            }())
            const pe = function (t) {
                this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = i.l.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0
            }
            const me = new ut()
            const ye = (function () {
                function t(t) {
                    this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Ut(10, 10), this.msaaSamples = null
                }
                return t.prototype.contextChange = function () {
                    let t = this.gl = this.renderer.gl
                    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new ut(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) {
                        let e = this.renderer.context.extensions.drawBuffers
                                    var n = this.renderer.context.extensions.depthTexture
                        r.b.PREFER_ENV === i.g.WEBGL_LEGACY && (e = null, n = null), e
                            ? t.drawBuffers = function (t) {
                                return e.drawBuffersWEBGL(t)
                            }
                            : (this.hasMRT = !1, t.drawBuffers = function () {}), n || (this.writeDepthTexture = !1)
                    } else { this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
                    }
                }, t.prototype.bind = function (t, e, n) {
                    void 0 === n && (n = 0)
                    var r = this.gl
                    if (t) {
                        let i = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t)
                        this.current !== t && (this.current = t, r.bindFramebuffer(r.FRAMEBUFFER, i.framebuffer)), i.mipLevel !== n && (t.dirtyId++, t.dirtyFormat++, i.mipLevel = n), i.dirtyId !== t.dirtyId && (i.dirtyId = t.dirtyId, i.dirtyFormat !== t.dirtyFormat ? (i.dirtyFormat = t.dirtyFormat, i.dirtySize = t.dirtySize, this.updateFramebuffer(t, n)) : i.dirtySize !== t.dirtySize && (i.dirtySize = t.dirtySize, this.resizeFramebuffer(t)))
                        for (let o = 0; o < t.colorTextures.length; o++) {
                            let a = t.colorTextures[o]
                            this.renderer.texture.unbind(a.parentTextureArray || a)
                        }
                        if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
                            var s = e.width >> n
                                        var u = e.height >> n
                                        var c = s / e.width
                            this.setViewport(e.x * c, e.y * c, s, u)
                        } else {
                            s = t.width >> n, u = t.height >> n
                            this.setViewport(0, 0, s, u)
                        }
                    } else { this.current && (this.current = null, r.bindFramebuffer(r.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
                    }
                }, t.prototype.setViewport = function (t, e, n, r) {
                    let i = this.viewport
                    t = Math.round(t), e = Math.round(e), n = Math.round(n), r = Math.round(r), i.width === n && i.height === r && i.x === t && i.y === e || (i.x = t, i.y = e, i.width = n, i.height = r, this.gl.viewport(t, e, n, r))
                }, Object.defineProperty(t.prototype, 'size', {
                    get () {
                        return this.current
? {
                            x: 0,
                            y: 0,
                            width: this.current.width,
                            height: this.current.height
                        }
: {
                            x: 0,
                            y: 0,
                            width: this.renderer.width,
                            height: this.renderer.height
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.clear = function (t, e, n, r, o) {
                    void 0 === o && (o = i.c.COLOR | i.c.DEPTH)
                    var a = this.gl
                    a.clearColor(t, e, n, r), a.clear(o)
                }, t.prototype.initFramebuffer = function (t) {
                    let e = this.gl
                                var n = new pe(e.createFramebuffer())
                    return n.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = n, this.managedFramebuffers.push(t), t.disposeRunner.add(this), n
                }, t.prototype.resizeFramebuffer = function (t) {
                    let e = this.gl
                                var n = t.glFramebuffers[this.CONTEXT_UID]
                    n.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, n.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, n.multisample, e.RGBA8, t.width, t.height)), n.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, n.stencil), n.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, n.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height))
                    var r = t.colorTextures
                                var i = r.length
                    e.drawBuffers || (i = Math.min(i, 1))
                    for (let o = 0; o < i; o++) {
                        let a = r[o]
                                    var s = a.parentTextureArray || a
                        this.renderer.texture.bind(s, 0)
                    }
                    t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
                }, t.prototype.updateFramebuffer = function (t, e) {
                    let n = this.gl
                                var r = t.glFramebuffers[this.CONTEXT_UID]
                                var i = t.colorTextures
                                var o = i.length
                    n.drawBuffers || (o = Math.min(o, 1)), r.multisample > 1 && this.canMultisampleFramebuffer(t) ? (r.msaaBuffer = r.msaaBuffer || n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, r.msaaBuffer), n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, n.RGBA8, t.width, t.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, r.msaaBuffer)) : r.msaaBuffer && (n.deleteRenderbuffer(r.msaaBuffer), r.msaaBuffer = null, r.blitFramebuffer && (r.blitFramebuffer.dispose(), r.blitFramebuffer = null))
                    for (var a = [], s = 0; s < o; s++) {
                        let u = i[s]
                                    var c = u.parentTextureArray || u
                        this.renderer.texture.bind(c, 0), s === 0 && r.msaaBuffer || (n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + s, u.target, c._glTextures[this.CONTEXT_UID].texture, e), a.push(n.COLOR_ATTACHMENT0 + s))
                    }
                    if ((a.length > 1 && n.drawBuffers(a), t.depthTexture) && this.writeDepthTexture) {
                        let l = t.depthTexture
                        this.renderer.texture.bind(l, 0), n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, l._glTextures[this.CONTEXT_UID].texture, e)
                    }!t.stencil && !t.depth || t.depthTexture && this.writeDepthTexture ? r.stencil && (n.deleteRenderbuffer(r.stencil), r.stencil = null) : (r.stencil = r.stencil || n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, r.stencil), r.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, n.DEPTH24_STENCIL8, t.width, t.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, t.width, t.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r.stencil))
                }, t.prototype.canMultisampleFramebuffer = function (t) {
                    return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
                }, t.prototype.detectSamples = function (t) {
                    let e = this.msaaSamples
                                var n = i.l.NONE
                    if (t <= 1 || e === null) return n
                    for (let r = 0; r < e.length; r++) {
                        if (e[r] <= t) {
                            n = e[r]
                                    break
                        }
                    }
                    return n === 1 && (n = i.l.NONE), n
                }, t.prototype.blit = function (t, e, n) {
                    let r = this.current
                                var i = this.renderer
                                var o = this.gl
                                var a = this.CONTEXT_UID
                    if (i.context.webGLVersion === 2 && r) {
                        let s = r.glFramebuffers[a]
                        if (s) {
                            if (!t) {
                                if (!s.msaaBuffer) return
                                var u = r.colorTextures[0]
                                if (!u) return
                                s.blitFramebuffer || (s.blitFramebuffer = new Ut(r.width, r.height), s.blitFramebuffer.addColorTexture(0, u)), (t = s.blitFramebuffer).colorTextures[0] !== u && (t.colorTextures[0] = u, t.dirtyId++, t.dirtyFormat++), t.width === r.width && t.height === r.height || (t.width = r.width, t.height = r.height, t.dirtyId++, t.dirtySize++)
                            }
                            e || ((e = me).width = r.width, e.height = r.height), n || (n = e)
                            var c = e.width === n.width && e.height === n.height
                            this.bind(t), o.bindFramebuffer(o.READ_FRAMEBUFFER, s.framebuffer), o.blitFramebuffer(e.x, e.y, e.width, e.height, n.x, n.y, n.width, n.height, o.COLOR_BUFFER_BIT, c ? o.NEAREST : o.LINEAR)
                        }
                    }
                }, t.prototype.disposeFramebuffer = function (t, e) {
                    let n = t.glFramebuffers[this.CONTEXT_UID]
                                var r = this.gl
                    if (n) {
                        delete t.glFramebuffers[this.CONTEXT_UID]
                        var i = this.managedFramebuffers.indexOf(t)
                        i >= 0 && this.managedFramebuffers.splice(i, 1), t.disposeRunner.remove(this), e || (r.deleteFramebuffer(n.framebuffer), n.msaaBuffer && r.deleteRenderbuffer(n.msaaBuffer), n.stencil && r.deleteRenderbuffer(n.stencil)), n.blitFramebuffer && n.blitFramebuffer.dispose()
                    }
                }, t.prototype.disposeAll = function (t) {
                    let e = this.managedFramebuffers
                    this.managedFramebuffers = []
                    for (let n = 0; n < e.length; n++) this.disposeFramebuffer(e[n], t)
                }, t.prototype.forceStencil = function () {
                    let t = this.current
                    if (t) {
                        let e = t.glFramebuffers[this.CONTEXT_UID]
                        if (e && !e.stencil) {
                            t.stencil = !0
                            var n = t.width
                                        var r = t.height
                                        var i = this.gl
                                        var o = i.createRenderbuffer()
                            i.bindRenderbuffer(i.RENDERBUFFER, o), e.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, e.multisample, i.DEPTH24_STENCIL8, n, r) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, n, r), e.stencil = o, i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, o)
                        }
                    }
                }, t.prototype.reset = function () {
                    this.current = this.unknownFramebuffer, this.viewport = new ut()
                }, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())
            const ve = {
                5126: 4,
                5123: 2,
                5121: 1
            }
            const _e = (function () {
                function t(t) {
                    this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {}
                }
                return t.prototype.contextChange = function () {
                    this.disposeAll(!0)
                    var t = this.gl = this.renderer.gl
                                var e = this.renderer.context
                    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
                        let n = this.renderer.context.extensions.vertexArrayObject
                        r.b.PREFER_ENV === i.g.WEBGL_LEGACY && (n = null), n
                            ? (t.createVertexArray = function () {
                                    return n.createVertexArrayOES()
                                }, t.bindVertexArray = function (t) {
                                    return n.bindVertexArrayOES(t)
                                }, t.deleteVertexArray = function (t) {
                                    return n.deleteVertexArrayOES(t)
                                })
                            : (this.hasVao = !1, t.createVertexArray = function () {
                                    return null
                                }, t.bindVertexArray = function () {
                                    return null
                                }, t.deleteVertexArray = function () {
                                    return null
                                })
                    }
                    if (e.webGLVersion !== 2) {
                        let o = t.getExtension('ANGLE_instanced_arrays')
                        o
                            ? (t.vertexAttribDivisor = function (t, e) {
                                    return o.vertexAttribDivisorANGLE(t, e)
                                }, t.drawElementsInstanced = function (t, e, n, r, i) {
                                    return o.drawElementsInstancedANGLE(t, e, n, r, i)
                                }, t.drawArraysInstanced = function (t, e, n, r) {
                                    return o.drawArraysInstancedANGLE(t, e, n, r)
                                })
                            : this.hasInstance = !1
                    }
                    this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex
                }, t.prototype.bind = function (t, e) {
                    e = e || this.renderer.shader.shader
                    var n = this.gl
                                var r = t.glVertexArrayObjects[this.CONTEXT_UID]
                                var i = !1
                    r || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}, i = !0)
                    var o = r[e.program.id] || this.initGeometryVao(t, e, i)
                    this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? n.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers()
                }, t.prototype.reset = function () {
                    this.unbind()
                }, t.prototype.updateBuffers = function () {
                    for (let t = this._activeGeometry, e = this.renderer.buffer, n = 0; n < t.buffers.length; n++) {
                        let r = t.buffers[n]
                        e.update(r)
                    }
                }, t.prototype.checkCompatibility = function (t, e) {
                    let n = t.attributes
                                var r = e.attributeData
                    for (const i in r) {
                        if (!n[i]) throw new Error(`shader and geometry incompatible, geometry missing the "${  i  }" attribute`)
                    }
                }, t.prototype.getSignature = function (t, e) {
                    let n = t.attributes
                                var r = e.attributeData
                                var i = ['g', t.id]
                    for (const o in n) r[o] && i.push(o)
                    return i.join('-')
                }, t.prototype.initGeometryVao = function (t, e, n) {
                    void 0 === n && (n = !0)
                    var r = this.gl
                                var i = this.CONTEXT_UID
                                var o = this.renderer.buffer
                                var a = e.program
                    a.glPrograms[i] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, a)
                    var s = this.getSignature(t, a)
                                var u = t.glVertexArrayObjects[this.CONTEXT_UID]
                                var c = u[s]
                    if (c) return u[a.id] = c, c
                    var l = t.buffers
                                var h = t.attributes
                                var f = {}
                                var d = {}
                    for (var p in l) f[p] = 0, d[p] = 0
                    for (var p in h) !h[p].size && a.attributeData[p] ? h[p].size = a.attributeData[p].size : h[p].size || console.warn(`PIXI Geometry attribute '${  p  }' size cannot be determined (likely the bound shader does not have the attribute)`), f[h[p].buffer] += h[p].size * ve[h[p].type]
                    for (var p in h) {
                        let m = h[p]
                                    var y = m.size
                        void 0 === m.stride && (f[m.buffer] === y * ve[m.type] ? m.stride = 0 : m.stride = f[m.buffer]), void 0 === m.start && (m.start = d[m.buffer], d[m.buffer] += y * ve[m.type])
                    }
                    c = r.createVertexArray(), r.bindVertexArray(c)
                    for (let v = 0; v < l.length; v++) {
                        let _ = l[v]
                        o.bind(_), n && _._glBuffers[i].refCount++
                    }
                    return this.activateVao(t, a), this._activeVao = c, u[a.id] = c, u[s] = c, c
                }, t.prototype.disposeGeometry = function (t, e) {
                    let n
                    if (this.managedGeometries[t.id]) {
                        delete this.managedGeometries[t.id]
                        var r = t.glVertexArrayObjects[this.CONTEXT_UID]
                                    var i = this.gl
                                    var o = t.buffers
                                    var a = (n = this.renderer) === null || void 0 === n ? void 0 : n.buffer
                        if (t.disposeRunner.remove(this), r) {
                            if (a) {
                                for (let s = 0; s < o.length; s++) {
                                    var u = o[s]._glBuffers[this.CONTEXT_UID]
                                            u && (u.refCount--, u.refCount !== 0 || e || a.dispose(o[s], e))
                                }
                            }
                            if (!e) {
                                for (let c in r) {
                                            if ("g" === c[0]) {
                                                var l = r[c];
                                                this._activeVao === l && this.unbind(), i.deleteVertexArray(l)
                                            }
}
                            }
                            delete t.glVertexArrayObjects[this.CONTEXT_UID]
                        }
                    }
                }, t.prototype.disposeAll = function (t) {
                    for (let e = Object.keys(this.managedGeometries), n = 0; n < e.length; n++) this.disposeGeometry(this.managedGeometries[e[n]], t)
                }, t.prototype.activateVao = function (t, e) {
                    let n = this.gl
                                var r = this.CONTEXT_UID
                                var i = this.renderer.buffer
                                var o = t.buffers
                                var a = t.attributes
                    t.indexBuffer && i.bind(t.indexBuffer)
                    var s = null
                    for (const u in a) {
                        let c = a[u]
                                    var l = o[c.buffer]
                                    var h = l._glBuffers[r]
                        if (e.attributeData[u]) {
                            s !== h && (i.bind(l), s = h)
                            var f = e.attributeData[u].location
                            if (n.enableVertexAttribArray(f), n.vertexAttribPointer(f, c.size, c.type || n.FLOAT, c.normalized, c.stride, c.start), c.instance) {
                                if (!this.hasInstance) throw new Error('geometry error, GPU Instancing is not supported on this device')
                                n.vertexAttribDivisor(f, 1)
                            }
                        }
                    }
                }, t.prototype.draw = function (t, e, n, r) {
                    let i = this.gl
                                var o = this._activeGeometry
                    if (o.indexBuffer) {
                        let a = o.indexBuffer.data.BYTES_PER_ELEMENT
                                    var s = a === 2 ? i.UNSIGNED_SHORT : i.UNSIGNED_INT
                        2 === a || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? i.drawElementsInstanced(t, e || o.indexBuffer.data.length, s, (n || 0) * a, r || 1) : i.drawElements(t, e || o.indexBuffer.data.length, s, (n || 0) * a) : console.warn('unsupported index buffer type: uint32')
                    } else { o.instanced ? i.drawArraysInstanced(t, n, e || o.getSize(), r || 1) : i.drawArrays(t, n, e || o.getSize())
}
                    return this
                }, t.prototype.unbind = function () {
                    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
                }, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())
            const ge = (function () {
                function t(t) {
                    void 0 === t && (t = null), this.type = i.j.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = r.b.FILTER_MULTISAMPLE, this.enabled = !0, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._target = null
                }
                return Object.defineProperty(t.prototype, 'filter', {
                    get() {
                        return this._filters ? this._filters[0] : null
                    },
                    set(t) {
                        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.reset = function () {
                    this.pooled && (this.maskObject = null, this.type = i.j.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null
                }, t.prototype.copyCountersOrReset = function (t) {
                    t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
                }, t
            }())

            function be(t, e, n) {
                const r = t.createShader(e)
                return t.shaderSource(r, n), t.compileShader(r), r
            }

            function Ee(t, e) {
                const n = t.getShaderSource(e).split('\n').map((t, e) => {
                    return `${e}: ${t}`
                })
                const r = t.getShaderInfoLog(e)
                const i = r.split('\n')
                const o = {}
                const a = i.map((t) => {
                    return Number.parseFloat(t.replace(/^ERROR: 0:(\d+):.*$/, '$1'))
                }).filter((t) => {
                    return !(!t || o[t]) && (o[t] = !0, !0)
                })
                const s = ['']
                a.forEach((t) => {
                    n[t - 1] = `%c${n[t - 1]}%c`, s.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px')
                })
                const u = n.join('\n')
                s[0] = u, console.error(r), console.groupCollapsed('click to view full shader code'), console.warn.apply(console, s), console.groupEnd()
            }

            function xe(t) {
                for (var e = new Array(t), n = 0; n < e.length; n++) e[n] = !1
                return e
            }

            function Te(t, e) {
                switch (t) {
                    case 'float':
                        return 0
                    case 'vec2':
                        return new Float32Array(2 * e)
                    case 'vec3':
                        return new Float32Array(3 * e)
                    case 'vec4':
                        return new Float32Array(4 * e)
                    case 'int':
                    case 'uint':
                    case 'sampler2D':
                    case 'sampler2DArray':
                        return 0
                    case 'ivec2':
                        return new Int32Array(2 * e)
                    case 'ivec3':
                        return new Int32Array(3 * e)
                    case 'ivec4':
                        return new Int32Array(4 * e)
                    case 'uvec2':
                        return new Uint32Array(2 * e)
                    case 'uvec3':
                        return new Uint32Array(3 * e)
                    case 'uvec4':
                        return new Uint32Array(4 * e)
                    case 'bool':
                        return !1
                    case 'bvec2':
                        return xe(2 * e)
                    case 'bvec3':
                        return xe(3 * e)
                    case 'bvec4':
                        return xe(4 * e)
                    case 'mat2':
                        return new Float32Array([1, 0, 0, 1])
                    case 'mat3':
                        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
                    case 'mat4':
                        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
                }
                return null
            }
            let Se; const we = {}
            let Oe = we

            function Pe() {
                if (!Se) {
                    Se = i.m.MEDIUM
                    const t = (function () {
                        if (Oe === we || Oe && Oe.isContextLost()) {
                            const t = document.createElement('canvas')
                            var e = void 0
                            r.b.PREFER_ENV >= i.g.WEBGL2 && (e = t.getContext('webgl2', {})), e || ((e = t.getContext('webgl', {}) || t.getContext('experimental-webgl', {})) ? e.getExtension('WEBGL_draw_buffers') : e = null), Oe = e
                        }
                        return Oe
                    }())
                    if (t && t.getShaderPrecisionFormat) {
                        const e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                        Se = e.precision ? i.m.HIGH : i.m.MEDIUM
                    }
                }
                return Se
            }

            function Re(t, e, n) {
                if (t.substring(0, 9) !== 'precision') {
                    let r = e
                    return e === i.m.HIGH && n !== i.m.HIGH && (r = i.m.MEDIUM), `precision ${r} float;\n${t}`
                }
                return n !== i.m.HIGH && t.substring(0, 15) === 'precision highp' ? t.replace('precision highp', 'precision mediump') : t
            }
            const Ae = {
                float: 1,
                vec2: 2,
                vec3: 3,
                vec4: 4,
                int: 1,
                ivec2: 2,
                ivec3: 3,
                ivec4: 4,
                uint: 1,
                uvec2: 2,
                uvec3: 3,
                uvec4: 4,
                bool: 1,
                bvec2: 2,
                bvec3: 3,
                bvec4: 4,
                mat2: 4,
                mat3: 9,
                mat4: 16,
                sampler2D: 1
            }

            function Ie(t) {
                return Ae[t]
            }
            let Ce = null
            const ke = {
                FLOAT: 'float',
                FLOAT_VEC2: 'vec2',
                FLOAT_VEC3: 'vec3',
                FLOAT_VEC4: 'vec4',
                INT: 'int',
                INT_VEC2: 'ivec2',
                INT_VEC3: 'ivec3',
                INT_VEC4: 'ivec4',
                UNSIGNED_INT: 'uint',
                UNSIGNED_INT_VEC2: 'uvec2',
                UNSIGNED_INT_VEC3: 'uvec3',
                UNSIGNED_INT_VEC4: 'uvec4',
                BOOL: 'bool',
                BOOL_VEC2: 'bvec2',
                BOOL_VEC3: 'bvec3',
                BOOL_VEC4: 'bvec4',
                FLOAT_MAT2: 'mat2',
                FLOAT_MAT3: 'mat3',
                FLOAT_MAT4: 'mat4',
                SAMPLER_2D: 'sampler2D',
                INT_SAMPLER_2D: 'sampler2D',
                UNSIGNED_INT_SAMPLER_2D: 'sampler2D',
                SAMPLER_CUBE: 'samplerCube',
                INT_SAMPLER_CUBE: 'samplerCube',
                UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',
                SAMPLER_2D_ARRAY: 'sampler2DArray',
                INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
                UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray'
            }

            function Ne(t, e) {
                if (!Ce) {
                    const n = Object.keys(ke)
                    Ce = {}
                    for (let r = 0; r < n.length; ++r) {
                        const i = n[r]
                        Ce[t[i]] = ke[i]
                    }
                }
                return Ce[e]
            }
            const Me = [{
                test(t) {
                    return t.type === 'float' && t.size === 1
                },
                code(t) {
                    return `\n            if(uv["${t}"] !== ud["${t}"].value)\n            {\n                ud["${t}"].value = uv["${t}"]\n                gl.uniform1f(ud["${t}"].location, uv["${t}"])\n            }\n            `
                }
            }, {
                test(t) {
                    return (t.type === 'sampler2D' || t.type === 'samplerCube' || t.type === 'sampler2DArray') && t.size === 1 && !t.isArray
                },
                code(t) {
                    return `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${t}"], t);\n\n            if(ud["${t}"].value !== t)\n            {\n                ud["${t}"].value = t;\n                gl.uniform1i(ud["${t}"].location, t);\n; // eslint-disable-line max-len\n            }`
                }
            }, {
                test(t, e) {
                    return t.type === 'mat3' && t.size === 1 && void 0 !== e.a
                },
                code(t) {
                    return `\n            gl.uniformMatrix3fv(ud["${t}"].location, false, uv["${t}"].toArray(true));\n            `
                },
                codeUbo(t) {
                    return `\n                var ${ t }_matrix = uv.${ t }.toArray(true);\n\n                data[offset] = ${ t }_matrix[0];\n                data[offset+1] = ${ t }_matrix[1];\n                data[offset+2] = ${ t }_matrix[2];\n        \n                data[offset + 4] = ${ t }_matrix[3];\n                data[offset + 5] = ${ t }_matrix[4];\n                data[offset + 6] = ${ t }_matrix[5];\n        \n                data[offset + 8] = ${ t }_matrix[6];\n                data[offset + 9] = ${ t }_matrix[7];\n                data[offset + 10] = ${ t }_matrix[8];\n            `
                }
            }, {
                test(t, e) {
                    return t.type === 'vec2' && t.size === 1 && void 0 !== e.x
                },
                code(t) {
                    return `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${t}"].location, v.x, v.y);\n                }`
                },
                codeUbo(t) {
                    return `\n                v = uv.${ t };\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `
                }
            }, {
                test(t) {
                    return t.type === 'vec2' && t.size === 1
                },
                code(t) {
                    return `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${t}"].location, v[0], v[1]);\n                }\n            `
                }
            }, {
                test(t, e) {
                    return t.type === 'vec4' && t.size === 1 && void 0 !== e.width
                },
                code(t) {
                    return `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${t}"].location, v.x, v.y, v.width, v.height)\n                }`
                },
                codeUbo(t) {
                    return `\n                    v = uv.${ t };\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `
                }
            }, {
                test(t) {
                    return t.type === 'vec4' && t.size === 1
                },
                code(t) {
                    return `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${t}"].location, v[0], v[1], v[2], v[3])\n                }`
                }
            }]
            const je = {
                float: '\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }',
                vec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }',
                vec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }',
                vec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }',
                int: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }',
                ivec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
                ivec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
                ivec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
                uint: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }',
                uvec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }',
                uvec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }',
                uvec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }',
                bool: '\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }',
                bvec2: '\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
                bvec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
                bvec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
                mat2: 'gl.uniformMatrix2fv(location, false, v)',
                mat3: 'gl.uniformMatrix3fv(location, false, v)',
                mat4: 'gl.uniformMatrix4fv(location, false, v)',
                sampler2D: 'gl.uniform1i(location, v)',
                samplerCube: 'gl.uniform1i(location, v)',
                sampler2DArray: 'gl.uniform1i(location, v)'
            }
            const De = {
                float: 'gl.uniform1fv(location, v)',
                vec2: 'gl.uniform2fv(location, v)',
                vec3: 'gl.uniform3fv(location, v)',
                vec4: 'gl.uniform4fv(location, v)',
                mat4: 'gl.uniformMatrix4fv(location, false, v)',
                mat3: 'gl.uniformMatrix3fv(location, false, v)',
                mat2: 'gl.uniformMatrix2fv(location, false, v)',
                int: 'gl.uniform1iv(location, v)',
                ivec2: 'gl.uniform2iv(location, v)',
                ivec3: 'gl.uniform3iv(location, v)',
                ivec4: 'gl.uniform4iv(location, v)',
                uint: 'gl.uniform1uiv(location, v)',
                uvec2: 'gl.uniform2uiv(location, v)',
                uvec3: 'gl.uniform3uiv(location, v)',
                uvec4: 'gl.uniform4uiv(location, v)',
                bool: 'gl.uniform1iv(location, v)',
                bvec2: 'gl.uniform2iv(location, v)',
                bvec3: 'gl.uniform3iv(location, v)',
                bvec4: 'gl.uniform4iv(location, v)',
                sampler2D: 'gl.uniform1iv(location, v)',
                samplerCube: 'gl.uniform1iv(location, v)',
                sampler2DArray: 'gl.uniform1iv(location, v)'
            }
            let Le; const Fe = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join('\n')

            function Be(t) {
                for (var e = '', n = 0; n < t; ++n) n > 0 && (e += '\nelse '), n < t - 1 && (e += `if(test == ${n}.0){}`)
                return e
            }
            let Ue = 0
            const Ge = {}
            const Xe = (function () {
                function t(e, n, o) {
                    void 0 === o && (o = 'pixi-shader'), this.id = Ue++, this.vertexSrc = e || t.defaultVertexSrc, this.fragmentSrc = n || t.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== '#version' && (o = o.replace(/\s+/g, '-'), Ge[o] ? (Ge[o]++, o += `-${  Ge[o]}`) : Ge[o] = 1, this.vertexSrc = `#define SHADER_NAME ${  o  }\n${  this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${  o  }\n${  this.fragmentSrc}`, this.vertexSrc = Re(this.vertexSrc, r.b.PRECISION_VERTEX, i.m.HIGH), this.fragmentSrc = Re(this.fragmentSrc, r.b.PRECISION_FRAGMENT, Pe())), this.glPrograms = {}, this.syncUniforms = null
                }
                return Object.defineProperty(t, 'defaultVertexSrc', {
                    get () {
                        return 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n'
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, 'defaultFragmentSrc', {
                    get () {
                        return 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}'
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.from = function (e, n, r) {
                    let i = e + n
                                var o = $[i]
                    return o || ($[i] = o = new t(e, n, r)), o
                }, t
            }())
            const He = (function () {
                function t(t, e) {
                    this.uniformBindCount = 0, this.program = t, this.uniformGroup = e ? e instanceof oe ? e : new oe(e) : new oe({})
                }
                return t.prototype.checkUniformExists = function (t, e) {
                    if (e.uniforms[t]) return !0
                    for (const n in e.uniforms) {
                        let r = e.uniforms[n]
                        if (r.group && this.checkUniformExists(t, r)) return !0
                    }
                    return !1
                }, t.prototype.destroy = function () {
                    this.uniformGroup = null
                }, Object.defineProperty(t.prototype, 'uniforms', {
                    get () {
                        return this.uniformGroup.uniforms
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.from = function (e, n, r) {
                    return new t(Xe.from(e, n), r)
                }, t
            }())
            const Ve = (function () {
                function t() {
                    this.data = 0, this.blendMode = i.b.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
                }
                return Object.defineProperty(t.prototype, 'blend', {
                    get () {
                        return !!(1 & this.data)
                    },
                    set (t) {
                        !!(1 & this.data) !== t && (this.data ^= 1)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'offsets', {
                    get () {
                        return !!(2 & this.data)
                    },
                    set (t) {
                        !!(2 & this.data) !== t && (this.data ^= 2)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'culling', {
                    get () {
                        return !!(4 & this.data)
                    },
                    set (t) {
                        !!(4 & this.data) !== t && (this.data ^= 4)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'depthTest', {
                    get () {
                        return !!(8 & this.data)
                    },
                    set (t) {
                        !!(8 & this.data) !== t && (this.data ^= 8)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'depthMask', {
                    get () {
                        return !!(32 & this.data)
                    },
                    set (t) {
                        !!(32 & this.data) !== t && (this.data ^= 32)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'clockwiseFrontFace', {
                    get () {
                        return !!(16 & this.data)
                    },
                    set (t) {
                        !!(16 & this.data) !== t && (this.data ^= 16)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'blendMode', {
                    get () {
                        return this._blendMode
                    },
                    set (t) {
                        this.blend = t !== i.b.NONE, this._blendMode = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'polygonOffset', {
                    get () {
                        return this._polygonOffset
                    },
                    set (t) {
                        this.offsets = !!t, this._polygonOffset = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.toString = function () {
                    return `[@pixi/core:State blendMode=${  this.blendMode  } clockwiseFrontFace=${  this.clockwiseFrontFace  } culling=${  this.culling  } depthMask=${  this.depthMask  } polygonOffset=${  this.polygonOffset  }]`
                }, t.for2d = function () {
                    let e = new t()
                    return e.depthTest = !1, e.blend = !0, e
                }, t
            }())
            const We = (function (t) {
                function e(n, i, o) {
                    let a = this
                                var s = Xe.from(n || e.defaultVertexSrc, i || e.defaultFragmentSrc)
                    return (a = t.call(this, s, o) || this).padding = 0, a.resolution = r.b.FILTER_RESOLUTION, a.multisample = r.b.FILTER_MULTISAMPLE, a.enabled = !0, a.autoFit = !0, a.state = new Ve(), a
                }
                return Tt(e, t), e.prototype.apply = function (t, e, n, r, i) {
                    t.applyFilter(this, e, n, r)
                }, Object.defineProperty(e.prototype, 'blendMode', {
                    get () {
                        return this.state.blendMode
                    },
                    set (t) {
                        this.state.blendMode = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'resolution', {
                    get () {
                        return this._resolution
                    },
                    set (t) {
                        this._resolution = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, 'defaultVertexSrc', {
                    get () {
                        return 'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n'
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e, 'defaultFragmentSrc', {
                    get () {
                        return 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n'
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(He))
            const Ye = new ht()
            const ze = (function () {
                function t(t, e) {
                    this._texture = t, this.mapCoord = new ht(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === e ? 0.5 : e, this.isSimple = !1
                }
                return Object.defineProperty(t.prototype, 'texture', {
                    get () {
                        return this._texture
                    },
                    set (t) {
                        this._texture = t, this._textureID = -1
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.multiplyUvs = function (t, e) {
                    void 0 === e && (e = t)
                    for (let n = this.mapCoord, r = 0; r < t.length; r += 2) {
                        let i = t[r]
                                    var o = t[r + 1]
                        e[r] = i * n.a + o * n.c + n.tx, e[r + 1] = i * n.b + o * n.d + n.ty
                    }
                    return e
                }, t.prototype.update = function (t) {
                    let e = this._texture
                    if (!e || !e.valid) return !1
                    if (!t && this._textureID === e._updateID) return !1
                    this._textureID = e._updateID, this._updateID++
                    var n = e._uvs
                    this.mapCoord.set(n.x1 - n.x0, n.y1 - n.y0, n.x3 - n.x0, n.y3 - n.y0, n.x0, n.y0)
                    var r = e.orig
                                var i = e.trim
                    i && (Ye.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(Ye))
                    var o = e.baseTexture
                                var a = this.uClampFrame
                                var s = this.clampMargin / o.resolution
                                var u = this.clampOffset
                    return a[0] = (e._frame.x + s + u) / o.width, a[1] = (e._frame.y + s + u) / o.height, a[2] = (e._frame.x + e._frame.width - s + u) / o.width, a[3] = (e._frame.y + e._frame.height - s + u) / o.height, this.uClampOffset[0] = u / o.realWidth, this.uClampOffset[1] = u / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && e.rotate === 0, !0
                }, t
            }())
            const qe = (function (t) {
                function e(e, n, r) {
                    let i = this
                                var o = null
                    return typeof e != 'string' && void 0 === n && void 0 === r && (o = e, e = void 0, n = void 0, r = void 0), (i = t.call(this, e || 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n', n || 'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n', r) || this).maskSprite = o, i.maskMatrix = new ht(), i
                }
                return Tt(e, t), Object.defineProperty(e.prototype, 'maskSprite', {
                    get () {
                        return this._maskSprite
                    },
                    set (t) {
                        this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.apply = function (t, e, n, r) {
                    let i = this._maskSprite
                                var o = i._texture
                    o.valid && (o.uvMatrix || (o.uvMatrix = new ze(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, i).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = i.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, e, n, r))
                }, e
            }(We))
            const Ke = (function () {
                function t(t) {
                    this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
                }
                return t.prototype.setMaskStack = function (t) {
                    this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
                }, t.prototype.push = function (t, e) {
                    let n = e
                    if (!n.isMaskData) {
                        let r = this.maskDataPool.pop() || new ge()
                        r.pooled = !0, r.maskObject = e, n = r
                    }
                    let o = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null
                    if (n.copyCountersOrReset(o), n.autoDetect && this.detect(n), n._target = t, n.type !== i.j.SPRITE && this.maskStack.push(n), n.enabled) { switch (n.type) {
                        case i.j.SCISSOR:
                            this.renderer.scissor.push(n)
                                    break;
                        case i.j.STENCIL:
                            this.renderer.stencil.push(n)
                                    break;
                        case i.j.SPRITE:
                            n.copyCountersOrReset(null), this.pushSpriteMask(n)
                    }
                    }
                    n.type === i.j.SPRITE && this.maskStack.push(n)
                }, t.prototype.pop = function (t) {
                    let e = this.maskStack.pop()
                    if (e && e._target === t) {
                        if (e.enabled) { switch (e.type) {
                            case i.j.SCISSOR:
                                this.renderer.scissor.pop()
                                        break;
                            case i.j.STENCIL:
                                this.renderer.stencil.pop(e.maskObject)
                                        break;
                            case i.j.SPRITE:
                                this.popSpriteMask(e)
                        }
                        }
                        if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
                            let n = this.maskStack[this.maskStack.length - 1]
                            n.type === i.j.SPRITE && n._filters && (n._filters[0].maskSprite = n.maskObject)
                        }
                    }
                }, t.prototype.detect = function (t) {
                    t.maskObject.isSprite ? t.type = i.j.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = i.j.SCISSOR : t.type = i.j.STENCIL
                }, t.prototype.pushSpriteMask = function (t) {
                    let e; let n; let r = t.maskObject
                                var i = t._target
                                var o = t._filters
                    o || (o = this.alphaMaskPool[this.alphaMaskIndex]) || (o = this.alphaMaskPool[this.alphaMaskIndex] = [new qe()])
                    var a; let s; let u = this.renderer
                                var c = u.renderTexture
                    if (c.current) {
                        let l = c.current
                        a = t.resolution || l.resolution, s = (e = t.multisample) !== null && void 0 !== e ? e : l.multisample
                    } else { a = t.resolution || u.resolution, s = (n = t.multisample) !== null && void 0 !== n ? n : u.multisample
}
                    o[0].resolution = a, o[0].multisample = s, o[0].maskSprite = r
                    var h = i.filterArea
                    i.filterArea = r.getBounds(!0), u.filter.push(i, o), i.filterArea = h, t._filters || this.alphaMaskIndex++
                }, t.prototype.popSpriteMask = function (t) {
                    this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
                }, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())
            const Ze = (function () {
                function t(t) {
                    this.renderer = t, this.maskStack = [], this.glConst = 0
                }
                return t.prototype.getStackLength = function () {
                    return this.maskStack.length
                }, t.prototype.setMaskStack = function (t) {
                    let e = this.renderer.gl
                                var n = this.getStackLength()
                    this.maskStack = t
                    var r = this.getStackLength()
                    r !== n && (r === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()))
                }, t.prototype._useCurrent = function () {}, t.prototype.destroy = function () {
                    this.renderer = null, this.maskStack = null
                }, t
            }())
            const $e = new ht()
            const Je = (function (t) {
                function e(e) {
                    let n = t.call(this, e) || this
                    return n.glConst = WebGLRenderingContext.SCISSOR_TEST, n
                }
                return Tt(e, t), e.prototype.getStackLength = function () {
                    let t = this.maskStack[this.maskStack.length - 1]
                    return t ? t._scissorCounter : 0
                }, e.prototype.calcScissorRect = function (t) {
                    if (!t._scissorRectLocal) {
                        let e = t._scissorRect
                                    var n = t.maskObject
                                    var r = this.renderer
                                    var i = r.renderTexture
                        n.renderable = !0
                        var o = n.getBounds()
                        this.roundFrameToPixels(o, i.current ? i.current.resolution : r.resolution, i.sourceFrame, i.destinationFrame, r.projection.transform), n.renderable = !1, e && o.fit(e), t._scissorRectLocal = o
                    }
                }, e.isMatrixRotated = function (t) {
                    if (!t) return !1
                    var e = t.a
                                var n = t.b
                                var r = t.c
                                var i = t.d
                    return (Math.abs(n) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(i) > 1e-4)
                }, e.prototype.testScissor = function (t) {
                    let n = t.maskObject
                    if (!n.isFastRect || !n.isFastRect()) return !1
                    if (e.isMatrixRotated(n.worldTransform)) return !1
                    if (e.isMatrixRotated(this.renderer.projection.transform)) return !1
                    this.calcScissorRect(t)
                    var r = t._scissorRectLocal
                    return r.width > 0 && r.height > 0
                }, e.prototype.roundFrameToPixels = function (t, n, r, i, o) {
                    e.isMatrixRotated(o) || ((o = o ? $e.copyFrom(o) : $e.identity()).translate(-r.x, -r.y).scale(i.width / r.width, i.height / r.height).translate(i.x, i.y), this.renderer.filter.transformAABB(o, t), t.fit(i), t.x = Math.round(t.x * n), t.y = Math.round(t.y * n), t.width = Math.round(t.width * n), t.height = Math.round(t.height * n))
                }, e.prototype.push = function (t) {
                    t._scissorRectLocal || this.calcScissorRect(t)
                    var e = this.renderer.gl
                    t._scissorRect || e.enable(e.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = t._scissorRectLocal, this._useCurrent()
                }, e.prototype.pop = function () {
                    let t = this.renderer.gl
                    this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
                }, e.prototype._useCurrent = function () {
                    let t; let e = this.maskStack[this.maskStack.length - 1]._scissorRect
                    t = this.renderer.renderTexture.current ? e.y : this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, t, e.width, e.height)
                }, e
            }(Ze))
            const Qe = (function (t) {
                function e(e) {
                    let n = t.call(this, e) || this
                    return n.glConst = WebGLRenderingContext.STENCIL_TEST, n
                }
                return Tt(e, t), e.prototype.getStackLength = function () {
                    let t = this.maskStack[this.maskStack.length - 1]
                    return t ? t._stencilCounter : 0
                }, e.prototype.push = function (t) {
                    let e = t.maskObject
                                var n = this.renderer.gl
                                var r = t._stencilCounter
                    0 === r && (this.renderer.framebuffer.forceStencil(), n.enable(n.STENCIL_TEST)), t._stencilCounter++, n.colorMask(!1, !1, !1, !1), n.stencilFunc(n.EQUAL, r, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, this._useCurrent()
                }, e.prototype.pop = function (t) {
                    let e = this.renderer.gl
                    0 === this.getStackLength() ? (e.disable(e.STENCIL_TEST), e.clearStencil(0), e.clear(e.STENCIL_BUFFER_BIT)) : (e.colorMask(!1, !1, !1, !1), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, this._useCurrent())
                }, e.prototype._useCurrent = function () {
                    let t = this.renderer.gl
                    t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
                }, e
            }(Ze))
            const tn = (function () {
                function t(t) {
                    this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new ht(), this.transform = null
                }
                return t.prototype.update = function (t, e, n, r) {
                    this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, n, r), this.transform && this.projectionMatrix.append(this.transform)
                    var i = this.renderer
                    i.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, i.globalUniforms.update(), i.shader.shader && i.shader.syncUniformGroup(i.shader.shader.uniforms.globals)
                }, t.prototype.calculateProjection = function (t, e, n, r) {
                    let i = this.projectionMatrix
                                var o = r ? -1 : 1
                    i.identity(), i.a = 1 / e.width * 2, i.d = o * (1 / e.height * 2), i.tx = -1 - e.x * i.a, i.ty = -o - e.y * i.d
                }, t.prototype.setTransform = function (t) {}, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())
            const en = new ut()
            const nn = new ut()
            const rn = (function () {
                function t(t) {
                    this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new ut(), this.destinationFrame = new ut(), this.viewportFrame = new ut()
                }
                return t.prototype.bind = function (t, e, n) {
                    void 0 === t && (t = null)
                    let r; let i; let o; const a = this.renderer
                    this.current = t, t ? (o = (r = t.baseTexture).resolution, e || (en.width = t.frame.width, en.height = t.frame.height, e = en), n || (nn.x = t.frame.x, nn.y = t.frame.y, nn.width = e.width, nn.height = e.height, n = nn), i = r.framebuffer) : (o = a.resolution, e || (en.width = a.screen.width, en.height = a.screen.height, e = en), n || ((n = en).width = e.width, n.height = e.height))
                    let s = this.viewportFrame
                    s.x = n.x * o, s.y = n.y * o, s.width = n.width * o, s.height = n.height * o, t || (s.y = a.view.height - (s.y + s.height)), s.ceil(), this.renderer.framebuffer.bind(i, s), this.renderer.projection.update(n, e, o, !i), t ? this.renderer.mask.setMaskStack(r.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(n)
                }, t.prototype.clear = function (t, e) {
                    t = this.current ? t || this.current.baseTexture.clearColor : t || this.clearColor
                    let n = this.destinationFrame
                    var r = this.current ? this.current.baseTexture : this.renderer.screen
                    var i = n.width !== r.width || n.height !== r.height
                    if (i) {
                        const o = this.viewportFrame
                        var a = o.x
                        var s = o.y
                        var u = o.width
                        var c = o.height
                        a = Math.round(a), s = Math.round(s), u = Math.round(u), c = Math.round(c), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(a, s, u, c)
                    }
                    this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), i && this.renderer.scissor.pop()
                }, t.prototype.resize = function () {
                    this.bind(null)
                }, t.prototype.reset = function () {
                    this.bind(null)
                }, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())

            function on(t, e, n, r, i) {
                n.buffer.update(i)
            }
            const an = {
                float: '\n        data[offset] = v;\n    ',
                vec2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ',
                vec3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ',
                vec4: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ',
                mat2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ',
                mat3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ',
                mat4: '\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    '
            }
            const sn = {
                float: 4,
                vec2: 8,
                vec3: 12,
                vec4: 16,
                int: 4,
                ivec2: 8,
                ivec3: 12,
                ivec4: 16,
                uint: 4,
                uvec2: 8,
                uvec3: 12,
                uvec4: 16,
                bool: 4,
                bvec2: 8,
                bvec3: 12,
                bvec4: 16,
                mat2: 32,
                mat3: 48,
                mat4: 64
            }

            function un(t, e) {
                if (!t.autoManage) { return {
                    size: 0,
                    syncFunc: on
                }
                }
                for (var n = (function (t) {
                        for (var e = t.map((t) => {
                                return {
                                    data: t,
                                    offset: 0,
                                    dataLen: 0,
                                    dirty: 0
                                }
                            }), n = 0, r = 0, i = 0, o = 0; o < e.length; o++) {
                            const a = e[o]
                            if (n = sn[a.data.type], a.data.size > 1 && (n = Math.max(n, 16) * a.data.size), a.dataLen = n, r % n != 0 && r < 16) {
                                const s = r % n % 16
                                r += s, i += s
                            }
                            r + n > 16 ? (i = 16 * Math.ceil(i / 16), a.offset = i, i += n, r = n) : (a.offset = i, r += n, i += n)
                        }
                        return {
                            uboElements: e,
                            size: i = 16 * Math.ceil(i / 16)
                        }
                    }(function (t, e) {
                        const n = []
                        for (const r in t) e[r] && n.push(e[r])
                        return n.sort((t, e) => {
                            return t.index - e.index
                        }), n
                    }(t.uniforms, e))), r = n.uboElements, i = n.size, o = ['\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    '], a = 0; a < r.length; a++) {
                    for (var s = r[a], u = t.uniforms[s.data.name], c = s.data.name, l = !1, h = 0; h < Me.length; h++) {
                        const f = Me[h]
                        if (f.codeUbo && f.test(s.data, u)) {
                            o.push(`offset = ${s.offset / 4};`, Me[h].codeUbo(s.data.name, u)), l = !0
                            break
                        }
                    }
                    if (!l) {
                        if (s.data.size > 1) {
                            const d = Ie(s.data.type)
                            let p = Math.max(sn[s.data.type] / 16, 1)
                            let m = d / p
                            let y = (4 - m % 4) % 4
                            o.push(`\n                cv = ud.${c}.value;\n                v = uv.${c};\n                offset = ${s.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${s.data.size * p}; i++)\n                {\n                    for(var j = 0; j < ${m}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${y};\n                }\n\n                `)
                        } else {
                            const v = an[s.data.type]
                            o.push(`\n                cv = ud.${c}.value;\n                v = uv.${c};\n                offset = ${s.offset / 4};\n                ${v};\n                `)
                        }
                    }
                }
                return o.push('\n       renderer.buffer.update(buffer);\n    '), {
                    size: i,
                    syncFunc: new Function('ud', 'uv', 'renderer', 'syncData', 'buffer', o.join('\n'))
                }
            }
            const cn = (function () {
                function t(t, e) {
                    this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {}
                }
                return t.prototype.destroy = function () {
                    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null
                }, t
            }())

            function ln(t, e) {
                const n = be(t, t.VERTEX_SHADER, e.vertexSrc)
                const r = be(t, t.FRAGMENT_SHADER, e.fragmentSrc)
                const i = t.createProgram()
                if (t.attachShader(i, n), t.attachShader(i, r), t.linkProgram(i), t.getProgramParameter(i, t.LINK_STATUS) || (function (t, e, n, r) {
                    t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || Ee(t, n), t.getShaderParameter(r, t.COMPILE_STATUS) || Ee(t, r), console.error('PixiJS Error: Could not initialize shader.'), t.getProgramInfoLog(e) !== '' && console.warn('PixiJS Warning: gl.getProgramInfoLog()', t.getProgramInfoLog(e)))
                }(t, i, n, r)), e.attributeData = (function (t, e) {
                    for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
                        const o = e.getActiveAttrib(t, i)
                        if (o.name.indexOf('gl_') !== 0) {
                            const a = Ne(e, o.type)
                            let s = {
                                type: a,
                                name: o.name,
                                size: Ie(a),
                                location: e.getAttribLocation(t, o.name)
                            }
                            n[o.name] = s
                        }
                    }
                    return n
                }(i, t)), e.uniformData = (function (t, e) {
                    for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), i = 0; i < r; i++) {
                        const o = e.getActiveUniform(t, i)
                        let a = o.name.replace(/\[.*?\]$/, '')
                        let s = !!o.name.match(/\[.*?\]$/)
                        let u = Ne(e, o.type)
                        n[a] = {
                            name: a,
                            index: i,
                            type: u,
                            size: o.size,
                            isArray: s,
                            value: Te(u, o.size)
                        }
                    }
                    return n
                }(i, t)), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
                    const o = Object.keys(e.attributeData)
                    o.sort((t, e) => {
                        return t > e ? 1 : -1
                    })
                    for (var a = 0; a < o.length; a++) e.attributeData[o[a]].location = a, t.bindAttribLocation(i, a, o[a])
                    t.linkProgram(i)
                }
                t.deleteShader(n), t.deleteShader(r)
                const s = {}
                for (var a in e.uniformData) {
                    const u = e.uniformData[a]
                    s[a] = {
                        location: t.getUniformLocation(i, a),
                        value: Te(u.type, u.size)
                    }
                }
                return new cn(i, s)
            }
            let hn = 0
            const fn = {
                textureCount: 0,
                uboCount: 0
            }
            const dn = (function () {
                function t(t) {
                    this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = hn++
                }
                return t.prototype.systemCheck = function () {
                    if (!(function () {
                        if (typeof Le == 'boolean') return Le
                        try {
                            let t = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;')
                            Le = !0 === t({
                                a: 'b'
                            }, 'a', 'b')
                        } catch (t) {
                            Le = !1
                        }
                        return Le
                    }())) { throw new Error('Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.')
                    }
                }, t.prototype.contextChange = function (t) {
                    this.gl = t, this.reset()
                }, t.prototype.bind = function (t, e) {
                    t.uniforms.globals = this.renderer.globalUniforms
                    let n = t.program
                    var r = n.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t)
                    return this.shader = t, this.program !== n && (this.program = n, this.gl.useProgram(r.program)), e || (fn.textureCount = 0, fn.uboCount = 0, this.syncUniformGroup(t.uniformGroup, fn)), r
                }, t.prototype.setUniforms = function (t) {
                    const e = this.shader.program
                    var n = e.glPrograms[this.renderer.CONTEXT_UID]
                    e.syncUniforms(n.uniformData, t, this.renderer)
                }, t.prototype.syncUniformGroup = function (t, e) {
                    const n = this.getGlProgram()
                    t.static && t.dirtyId === n.uniformDirtyGroups[t.id] || (n.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, n, e))
                }, t.prototype.syncUniforms = function (t, e, n) {
                    (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, n)
                }, t.prototype.createSyncGroups = function (t) {
                    const e = this.getSignature(t, this.shader.program.uniformData, 'u')
                    return this.cache[e] || (this.cache[e] = (function (t, e) {
                        let n; let r = ['\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    ']
                        for (const i in t.uniforms) {
                            let o = e[i]
                            if (o) {
                                for (var a = t.uniforms[i], s = !1, u = 0; u < Me.length; u++) {
                                    if (Me[u].test(o, a)) {
                                        r.push(Me[u].code(i, a)), s = !0
                                                break
                                    }
                                }
                                if (!s) {
                                    let c = (o.size === 1 ? je : De)[o.type].replace('location', `ud["${ i }"].location`)
                                    r.push(`\n            cu = ud["${ i }"];\n            cv = cu.value;\n            v = uv["${ i }"];\n            ${ c };`)
                                }
                            } else { ((n = t.uniforms[i]) === null || void 0 === n ? void 0 : n.group) && (t.uniforms[i].ubo ? r.push('\n                        renderer.shader.syncUniformBufferGroup(uv.' + i + ', \'' + i + '\');\n                    ') : r.push('\n                        renderer.shader.syncUniformGroup(uv.' + i + ', syncData);\n                    '))
}
                        }
                        return new Function('ud', 'uv', 'renderer', 'syncData', r.join('\n'))
                    }(t, this.shader.program.uniformData))), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id]
                }, t.prototype.syncUniformBufferGroup = function (t, e) {
                    const n = this.getGlProgram()
                    if (!t.static || t.dirtyId !== 0 || !n.uniformGroups[t.id]) {
                        t.dirtyId = 0
                        let r = n.uniformGroups[t.id] || this.createSyncBufferGroup(t, n, e)
                        t.buffer.update(), r(n.uniformData, t.uniforms, this.renderer, fn, t.buffer)
                    }
                    this.renderer.buffer.bindBufferBase(t.buffer, n.uniformBufferBindings[e])
                }, t.prototype.createSyncBufferGroup = function (t, e, n) {
                    const r = this.renderer.gl
                    this.renderer.buffer.bind(t.buffer)
                    let i = this.gl.getUniformBlockIndex(e.program, n)
                    e.uniformBufferBindings[n] = this.shader.uniformBindCount, r.uniformBlockBinding(e.program, i, this.shader.uniformBindCount), this.shader.uniformBindCount++
                    let o = this.getSignature(t, this.shader.program.uniformData, 'ubo')
                    var a = this._uboCache[o]
                    if (a || (a = this._uboCache[o] = un(t, this.shader.program.uniformData)), t.autoManage) {
                        const s = new Float32Array(a.size / 4)
                        t.buffer.update(s)
                    }
                    return e.uniformGroups[t.id] = a.syncFunc, e.uniformGroups[t.id]
                }, t.prototype.getSignature = function (t, e, n) {
                    const r = t.uniforms
                    var i = [`${n}-`]
                    for (const o in r) i.push(o), e[o] && i.push(e[o].type)
                    return i.join('-')
                }, t.prototype.getGlProgram = function () {
                    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
                }, t.prototype.generateProgram = function (t) {
                    const e = this.gl
                    var n = t.program
                    var r = ln(e, n)
                    return n.glPrograms[this.renderer.CONTEXT_UID] = r, r
                }, t.prototype.reset = function () {
                    this.program = null, this.shader = null
                }, t.prototype.destroy = function () {
                    this.renderer = null, this.destroyed = !0
                }, t
            }())
            const pn = (function () {
                function t() {
                    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = i.b.NONE, this._blendEq = !1, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new Ve(), this.defaultState.blend = !0
                }
                return t.prototype.contextChange = function (t) {
                    this.gl = t, this.blendModes = (function (t, e) {
                        return void 0 === e && (e = []), e[i.b.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.ADD] = [t.ONE, t.ONE], e[i.b.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.NONE] = [0, 0], e[i.b.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e[i.b.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.SRC_IN] = [t.DST_ALPHA, t.ZERO], e[i.b.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO], e[i.b.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[i.b.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE], e[i.b.DST_IN] = [t.ZERO, t.SRC_ALPHA], e[i.b.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], e[i.b.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA], e[i.b.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[i.b.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD], e
                    }(t)), this.set(this.defaultState), this.reset()
                }, t.prototype.set = function (t) {
                    if (t = t || this.defaultState, this.stateId !== t.data) {
                        for (var e = this.stateId ^ t.data, n = 0; e;) 1 & e && this.map[n].call(this, !!(t.data & 1 << n)), e >>= 1, n++
                        this.stateId = t.data
                    }
                    for (n = 0; n < this.checks.length; n++) this.checks[n](this, t)
                }, t.prototype.forceState = function (t) {
                    t = t || this.defaultState
                    for (var e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e))
                    for (e = 0; e < this.checks.length; e++) this.checks[e](this, t)
                    this.stateId = t.data
                }, t.prototype.setBlend = function (e) {
                    this.updateCheck(t.checkBlendMode, e), this.gl[e ? 'enable' : 'disable'](this.gl.BLEND)
                }, t.prototype.setOffset = function (e) {
                    this.updateCheck(t.checkPolygonOffset, e), this.gl[e ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL)
                }, t.prototype.setDepthTest = function (t) {
                    this.gl[t ? 'enable' : 'disable'](this.gl.DEPTH_TEST)
                }, t.prototype.setDepthMask = function (t) {
                    this.gl.depthMask(t)
                }, t.prototype.setCullFace = function (t) {
                    this.gl[t ? 'enable' : 'disable'](this.gl.CULL_FACE)
                }, t.prototype.setFrontFace = function (t) {
                    this.gl.frontFace(this.gl[t ? 'CW' : 'CCW'])
                }, t.prototype.setBlendMode = function (t) {
                    if (t !== this.blendMode) {
                        this.blendMode = t
                        let e = this.blendModes[t]
                        var n = this.gl
                        e.length === 2 ? n.blendFunc(e[0], e[1]) : n.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, n.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD))
                    }
                }, t.prototype.setPolygonOffset = function (t, e) {
                    this.gl.polygonOffset(t, e)
                }, t.prototype.reset = function () {
                    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
                }, t.prototype.updateCheck = function (t, e) {
                    let n = this.checks.indexOf(t)
                    e && n === -1 ? this.checks.push(t) : e || n === -1 || this.checks.splice(n, 1)
                }, t.checkBlendMode = function (t, e) {
                    t.setBlendMode(e.blendMode)
                }, t.checkPolygonOffset = function (t, e) {
                    t.setPolygonOffset(1, e.polygonOffset)
                }, t.prototype.destroy = function () {
                    this.gl = null
                }, t
            }())
            let mn = (function () {
                function t(t) {
                    this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = r.b.GC_MAX_IDLE, this.checkCountMax = r.b.GC_MAX_CHECK_COUNT, this.mode = r.b.GC_MODE
                }
                return t.prototype.postrender = function () {
                    this.renderer.renderingToScreen && (this.count++, this.mode !== i.i.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
                }, t.prototype.run = function () {
                    for (var t = this.renderer.texture, e = t.managedTextures, n = !1, r = 0; r < e.length; r++) {
                        const i = e[r]
                        !i.framebuffer && this.count - i.touched > this.maxIdle && (t.destroyTexture(i, !0), e[r] = null, n = !0)
                    }
                    if (n) {
                        let o = 0
                        for (r = 0; r < e.length; r++) e[r] !== null && (e[o++] = e[r])
                        e.length = o
                    }
                }, t.prototype.unload = function (t) {
                    const e = this.renderer.texture
                    let n = t._texture
                    n && !n.framebuffer && e.destroyTexture(n)
                    for (let r = t.children.length - 1; r >= 0; r--) this.unload(t.children[r])
                }, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())
            const yn = function (t) {
                this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = i.r.UNSIGNED_BYTE, this.internalFormat = i.h.RGBA, this.samplerType = 0
            }
            const vn = (function () {
                function t(t) {
                    this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new Rt(), this.hasIntegerTextures = !1
                }
                return t.prototype.contextChange = function () {
                    let t = this.gl = this.renderer.gl
                    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = (function (t) {
                        var e, n, r, o, a, s, u, c, l, h, f, d, p, m, y, v, _, g, b, E, x, T, S
                                return 'WebGL2RenderingContext' in self && t instanceof self.WebGL2RenderingContext ? ((e = {})[i.r.UNSIGNED_BYTE] = ((n = {})[i.h.RGBA] = t.RGBA8, n[i.h.RGB] = t.RGB8, n[i.h.RG] = t.RG8, n[i.h.RED] = t.R8, n[i.h.RGBA_INTEGER] = t.RGBA8UI, n[i.h.RGB_INTEGER] = t.RGB8UI, n[i.h.RG_INTEGER] = t.RG8UI, n[i.h.RED_INTEGER] = t.R8UI, n[i.h.ALPHA] = t.ALPHA, n[i.h.LUMINANCE] = t.LUMINANCE, n[i.h.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA, n), e[i.r.BYTE] = ((r = {})[i.h.RGBA] = t.RGBA8_SNORM, r[i.h.RGB] = t.RGB8_SNORM, r[i.h.RG] = t.RG8_SNORM, r[i.h.RED] = t.R8_SNORM, r[i.h.RGBA_INTEGER] = t.RGBA8I, r[i.h.RGB_INTEGER] = t.RGB8I, r[i.h.RG_INTEGER] = t.RG8I, r[i.h.RED_INTEGER] = t.R8I, r), e[i.r.UNSIGNED_SHORT] = ((o = {})[i.h.RGBA_INTEGER] = t.RGBA16UI, o[i.h.RGB_INTEGER] = t.RGB16UI, o[i.h.RG_INTEGER] = t.RG16UI, o[i.h.RED_INTEGER] = t.R16UI, o[i.h.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16, o), e[i.r.SHORT] = ((a = {})[i.h.RGBA_INTEGER] = t.RGBA16I, a[i.h.RGB_INTEGER] = t.RGB16I, a[i.h.RG_INTEGER] = t.RG16I, a[i.h.RED_INTEGER] = t.R16I, a), e[i.r.UNSIGNED_INT] = ((s = {})[i.h.RGBA_INTEGER] = t.RGBA32UI, s[i.h.RGB_INTEGER] = t.RGB32UI, s[i.h.RG_INTEGER] = t.RG32UI, s[i.h.RED_INTEGER] = t.R32UI, s[i.h.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24, s), e[i.r.INT] = ((u = {})[i.h.RGBA_INTEGER] = t.RGBA32I, u[i.h.RGB_INTEGER] = t.RGB32I, u[i.h.RG_INTEGER] = t.RG32I, u[i.h.RED_INTEGER] = t.R32I, u), e[i.r.FLOAT] = ((c = {})[i.h.RGBA] = t.RGBA32F, c[i.h.RGB] = t.RGB32F, c[i.h.RG] = t.RG32F, c[i.h.RED] = t.R32F, c[i.h.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F, c), e[i.r.HALF_FLOAT] = ((l = {})[i.h.RGBA] = t.RGBA16F, l[i.h.RGB] = t.RGB16F, l[i.h.RG] = t.RG16F, l[i.h.RED] = t.R16F, l), e[i.r.UNSIGNED_SHORT_5_6_5] = ((h = {})[i.h.RGB] = t.RGB565, h), e[i.r.UNSIGNED_SHORT_4_4_4_4] = ((f = {})[i.h.RGBA] = t.RGBA4, f), e[i.r.UNSIGNED_SHORT_5_5_5_1] = ((d = {})[i.h.RGBA] = t.RGB5_A1, d), e[i.r.UNSIGNED_INT_2_10_10_10_REV] = ((p = {})[i.h.RGBA] = t.RGB10_A2, p[i.h.RGBA_INTEGER] = t.RGB10_A2UI, p), e[i.r.UNSIGNED_INT_10F_11F_11F_REV] = ((m = {})[i.h.RGB] = t.R11F_G11F_B10F, m), e[i.r.UNSIGNED_INT_5_9_9_9_REV] = ((y = {})[i.h.RGB] = t.RGB9_E5, y), e[i.r.UNSIGNED_INT_24_8] = ((v = {})[i.h.DEPTH_STENCIL] = t.DEPTH24_STENCIL8, v), e[i.r.FLOAT_32_UNSIGNED_INT_24_8_REV] = ((_ = {})[i.h.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8, _), S = e) : ((g = {})[i.r.UNSIGNED_BYTE] = ((b = {})[i.h.RGBA] = t.RGBA, b[i.h.RGB] = t.RGB, b[i.h.ALPHA] = t.ALPHA, b[i.h.LUMINANCE] = t.LUMINANCE, b[i.h.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA, b), g[i.r.UNSIGNED_SHORT_5_6_5] = ((E = {})[i.h.RGB] = t.RGB, E), g[i.r.UNSIGNED_SHORT_4_4_4_4] = ((x = {})[i.h.RGBA] = t.RGBA, x), g[i.r.UNSIGNED_SHORT_5_5_5_1] = ((T = {})[i.h.RGBA] = t.RGBA, T), S = g), S
                    }(t))
                    var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
                    this.boundTextures.length = e
                    for (var n = 0; n < e; n++) this.boundTextures[n] = null
                    this.emptyTextures = {}
                    var r = new yn(t.createTexture())
                    t.bindTexture(t.TEXTURE_2D, r.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = r, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new yn(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture)
                    for (n = 0; n < 6; n++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null)
                    t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR)
                    for (n = 0; n < this.boundTextures.length; n++) this.bind(null, n)
                }, t.prototype.bind = function (t, e) {
                    void 0 === e && (e = 0)
                    var n = this.gl
                    if ((t = t == null ? void 0 : t.castToBaseTexture()) && t.valid && !t.parentTextureArray) {
                        t.touched = this.renderer.textureGC.count
                        var r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t)
                        this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), n.bindTexture(t.target, r.texture)), r.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t
                    } else { this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), n.bindTexture(n.TEXTURE_2D, this.emptyTextures[n.TEXTURE_2D].texture), this.boundTextures[e] = null
                    }
                }, t.prototype.reset = function () {
                    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1
                    for (let t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
                }, t.prototype.unbind = function (t) {
                    let e = this.gl
                                var n = this.boundTextures
                    if (this._unknownBoundTextures) {
                        this._unknownBoundTextures = !1
                        for (var r = 0; r < n.length; r++) n[r] === this.unknownTexture && this.bind(null, r)
                    }
                    for (r = 0; r < n.length; r++) n[r] === t && (this.currentLocation !== r && (e.activeTexture(e.TEXTURE0 + r), this.currentLocation = r), e.bindTexture(t.target, this.emptyTextures[t.target].texture), n[r] = null)
                }, t.prototype.ensureSamplerType = function (t) {
                    let e = this.boundTextures
                                var n = this.hasIntegerTextures
                                var r = this.CONTEXT_UID
                    if (n) {
                        for (let o = t - 1; o >= 0; --o) {
                            var a = e[o]
                                    if (a) a._glTextures[r].samplerType !== i.o.FLOAT && this.renderer.texture.unbind(a)
                        }
                    }
                }, t.prototype.initTexture = function (t) {
                    let e = new yn(this.gl.createTexture())
                    return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on('dispose', this.destroyTexture, this), e
                }, t.prototype.initTextureType = function (t, e) {
                    let n, r
                    e.internalFormat = (r = (n = this.internalFormats[t.type]) === null || void 0 === n ? void 0 : n[t.format]) !== null && void 0 !== r ? r : t.format, this.webGLVersion === 2 && t.type === i.r.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type
                }, t.prototype.updateTexture = function (t) {
                    let e = t._glTextures[this.CONTEXT_UID]
                    if (e) {
                        let n = this.renderer
                        if (this.initTextureType(t, e), t.resource && t.resource.upload(n, t, e)) { e.samplerType !== i.o.FLOAT && (this.hasIntegerTextures = !0)
}
                        else {
                            let r = t.realWidth
                                        var o = t.realHeight
                                        var a = n.gl;
                            (e.width !== r || e.height !== o || e.dirtyId < 0) && (e.width = r, e.height = o, a.texImage2D(t.target, 0, e.internalFormat, r, o, 0, t.format, e.type, null))
                        }
                        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId
                    }
                }, t.prototype.destroyTexture = function (t, e) {
                    let n = this.gl
                    if ((t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t), n.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off('dispose', this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
                        let r = this.managedTextures.indexOf(t); r !== -1 && (function (t, e, n) {
                            var r; var i = t.length
                                    if (!(e >= i || n === 0)) {
                                var o = i - (n = e + n > i ? i - e : n)
                                        for (r = e; r < o; ++r) t[r] = t[r + n]
                                        t.length = o
                            }
                        }(this.managedTextures, r, 1))
                    }
                }, t.prototype.updateTextureStyle = function (t) {
                    let e = t._glTextures[this.CONTEXT_UID]
                    e && (t.mipmap !== i.k.POW2 && this.webGLVersion === 2 || t.isPowerOfTwo ? e.mipmap = t.mipmap >= 1 : e.mipmap = !1, this.webGLVersion === 2 || t.isPowerOfTwo ? e.wrapMode = t.wrapMode : e.wrapMode = i.s.CLAMP, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId)
                }, t.prototype.setStyle = function (t, e) {
                    let n = this.gl
                    if (e.mipmap && t.mipmap !== i.k.ON_MANUAL && n.generateMipmap(t.target), n.texParameteri(t.target, n.TEXTURE_WRAP_S, e.wrapMode), n.texParameteri(t.target, n.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
                        n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === i.p.LINEAR ? n.LINEAR_MIPMAP_LINEAR : n.NEAREST_MIPMAP_NEAREST)
                        var r = this.renderer.context.extensions.anisotropicFiltering
                        if (r && t.anisotropicLevel > 0 && t.scaleMode === i.p.LINEAR) {
                            let o = Math.min(t.anisotropicLevel, n.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT))
                            n.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, o)
                        }
                    } else { n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === i.p.LINEAR ? n.LINEAR : n.NEAREST)
}
                    n.texParameteri(t.target, n.TEXTURE_MAG_FILTER, t.scaleMode === i.p.LINEAR ? n.LINEAR : n.NEAREST)
                }, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())
            const _n = {
                __proto__: null,
                FilterSystem: ce,
                BatchSystem: he,
                ContextSystem: de,
                FramebufferSystem: ye,
                GeometrySystem: _e,
                MaskSystem: Ke,
                ScissorSystem: Je,
                StencilSystem: Qe,
                ProjectionSystem: tn,
                RenderTextureSystem: rn,
                ShaderSystem: dn,
                StateSystem: pn,
                TextureGCSystem: mn,
                TextureSystem: vn
            }
            const gn = new ht()
            const bn = (function (t) {
                function e(e, n) {
                    void 0 === e && (e = i.n.UNKNOWN)
                    var o = t.call(this) || this
                    return n = Object.assign({}, r.b.RENDER_OPTIONS, n), o.options = n, o.type = e, o.screen = new ut(0, 0, n.width, n.height), o.view = n.view || document.createElement('canvas'), o.resolution = n.resolution || r.b.RESOLUTION, o.useContextAlpha = n.useContextAlpha, o.autoDensity = !!n.autoDensity, o.preserveDrawingBuffer = n.preserveDrawingBuffer, o.clearBeforeRender = n.clearBeforeRender, o._backgroundColor = 0, o._backgroundColorRgba = [0, 0, 0, 1], o._backgroundColorString = '#000000', o.backgroundColor = n.backgroundColor || o._backgroundColor, o.backgroundAlpha = n.backgroundAlpha, void 0 !== n.transparent && (K('6.0.0', 'Option transparent is deprecated, please use backgroundAlpha instead.'), o.useContextAlpha = n.transparent, o.backgroundAlpha = n.transparent ? 0 : 1), o._lastObjectRendered = null, o.plugins = {}, o
                }
                return Tt(e, t), e.prototype.initPlugins = function (t) {
                    for (const e in t) this.plugins[e] = new t[e](this)
                }, Object.defineProperty(e.prototype, 'width', {
                    get () {
                        return this.view.width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'height', {
                    get () {
                        return this.view.height
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.resize = function (t, e) {
                    this.view.width = Math.round(t * this.resolution), this.view.height = Math.round(e * this.resolution)
                    var n = this.view.width / this.resolution
                                var r = this.view.height / this.resolution
                    this.screen.width = n, this.screen.height = r, this.autoDensity && (this.view.style.width = `${n }px`, this.view.style.height = `${r }px`), this.emit('resize', n, r)
                }, e.prototype.generateTexture = function (t, e, n, r) {
                    void 0 === e && (e = {}), typeof e == 'number' && (K('6.1.0', 'generateTexture options (scaleMode, resolution, region) are now object options.'), e = {
                        scaleMode: e,
                        resolution: n,
                        region: r
                    })
                    var i = e.region
                                var o = (function (t, e) {
                        var n = {}
                                    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && !e.includes(r) && (n[r] = t[r])
                                    if (t != null && 'function' == typeof Object.getOwnPropertySymbols) {
                            var i = 0
                                        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) !e.includes(r[i]) && (n[r[i]] = t[r[i]])
                        }
                        return n
                    }(e, ['region']))
                    0 === (r = i || t.getLocalBounds(null, !0)).width && (r.width = 1), r.height === 0 && (r.height = 1)
                    var a = Yt.create(St({
                        width: r.width,
                        height: r.height
                    }, o))
                    return gn.tx = -r.x, gn.ty = -r.y, this.render(t, {
                        renderTexture: a,
                        clear: !1,
                        transform: gn,
                        skipUpdateTransform: !!t.parent
                    }), a
                }, e.prototype.destroy = function (t) {
                    for (const e in this.plugins) this.plugins[e].destroy(), this.plugins[e] = null
                    t && this.view.parentNode && this.view.parentNode.removeChild(this.view)
                    this.plugins = null, this.type = i.n.UNKNOWN, this.view = null, this.screen = null, this._tempDisplayObjectParent = null, this.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null
                }, Object.defineProperty(e.prototype, 'backgroundColor', {
                    get () {
                        return this._backgroundColor
                    },
                    set (t) {
                        var e
                                this._backgroundColor = t, this._backgroundColorString = (e = t.toString(16), '#' + (e = '000000'.substr(0, 6 - e.length) + e)),
                        function (t, e) {
                            void 0 === e && (e = []), e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255
                        }(t, this._backgroundColorRgba)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, 'backgroundAlpha', {
                    get () {
                        return this._backgroundColorRgba[3]
                    },
                    set (t) {
                        this._backgroundColorRgba[3] = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(l))
            const En = function (t) {
                this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
            }
            const xn = (function () {
                function t(t) {
                    this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {}
                }
                return t.prototype.destroy = function () {
                    this.renderer = null
                }, t.prototype.contextChange = function () {
                    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
                }, t.prototype.bind = function (t) {
                    let e = this.gl
                                var n = this.CONTEXT_UID
                                var r = t._glBuffers[n] || this.createGLBuffer(t)
                    e.bindBuffer(t.type, r.buffer)
                }, t.prototype.bindBufferBase = function (t, e) {
                    let n = this.gl
                                var r = this.CONTEXT_UID
                    if (this.boundBufferBases[e] !== t) {
                        let i = t._glBuffers[r] || this.createGLBuffer(t)
                        this.boundBufferBases[e] = t, n.bindBufferBase(n.UNIFORM_BUFFER, e, i.buffer)
                    }
                }, t.prototype.bindBufferRange = function (t, e, n) {
                    let r = this.gl
                                var i = this.CONTEXT_UID
                    n = n || 0
                    var o = t._glBuffers[i] || this.createGLBuffer(t)
                    r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, o.buffer, 256 * n, 256)
                }, t.prototype.update = function (t) {
                    let e = this.gl
                                var n = this.CONTEXT_UID
                                var r = t._glBuffers[n]
                    if (t._updateID !== r.updateID) {
                        if (r.updateID = t._updateID, e.bindBuffer(t.type, r.buffer), r.byteLength >= t.data.byteLength) { e.bufferSubData(t.type, 0, t.data);
}
                        else {
                            var i = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW
                                    r.byteLength = t.data.byteLength, e.bufferData(t.type, t.data, i)
                        }
                    }
                }, t.prototype.dispose = function (t, e) {
                    if (this.managedBuffers[t.id]) {
                        delete this.managedBuffers[t.id]
                        var n = t._glBuffers[this.CONTEXT_UID]
                                    var r = this.gl
                        t.disposeRunner.remove(this), n && (e || r.deleteBuffer(n.buffer), delete t._glBuffers[this.CONTEXT_UID])
                    }
                }, t.prototype.disposeAll = function (t) {
                    for (let e = Object.keys(this.managedBuffers), n = 0; n < e.length; n++) this.dispose(this.managedBuffers[e[n]], t)
                }, t.prototype.createGLBuffer = function (t) {
                    let e = this.CONTEXT_UID
                                var n = this.gl
                    return t._glBuffers[e] = new En(n.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[e]
                }, t
            }())
            const Tn = ((function (t) {
                function e(n) {
                    let r = t.call(this, i.n.WEBGL, n) || this
                    return n = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {
                        destroy: new rt('destroy'),
                        contextChange: new rt('contextChange'),
                        reset: new rt('reset'),
                        update: new rt('update'),
                        postrender: new rt('postrender'),
                        prerender: new rt('prerender'),
                        resize: new rt('resize')
                    }, r.runners.contextChange.add(r), r.globalUniforms = new oe({
                        projectionMatrix: new ht()
                    }, !0), r.addSystem(Ke, 'mask').addSystem(de, 'context').addSystem(pn, 'state').addSystem(dn, 'shader').addSystem(vn, 'texture').addSystem(xn, 'buffer').addSystem(_e, 'geometry').addSystem(ye, 'framebuffer').addSystem(Je, 'scissor').addSystem(Qe, 'stencil').addSystem(tn, 'projection').addSystem(mn, 'textureGC').addSystem(ce, 'filter').addSystem(rn, 'renderTexture').addSystem(he, 'batch'), r.initPlugins(e.__plugins), r.multisample = void 0, n.context
                        ? r.context.initFromContext(n.context)
                        : r.context.initFromOptions({
                                alpha: !!r.useContextAlpha,
                                antialias: n.antialias,
                                premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== 'notMultiplied',
                                stencil: !0,
                                preserveDrawingBuffer: n.preserveDrawingBuffer,
                                powerPreference: r.options.powerPreference
                            }), r.renderingToScreen = !0,
                    (function (t) {
                        var e
                                    if (!U) {
                            if (navigator.userAgent.toLowerCase().includes("chrome")) {
                                var n = ['\n %c %c %c PixiJS 6.2.0 - ✰ ' + t + ' ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n', 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;'];
                                (e = self.console).log.apply(e, n)
                            } else { self.console && self.console.log("PixiJS 6.2.0 - " + t + " - http://www.pixijs.com/");
}
                            U = !0
                        }
                    }(r.context.webGLVersion === 2 ? 'WebGL 2' : 'WebGL 1')), r.resize(r.options.width, r.options.height), r
                }
                Tt(e, t), e.create = function (t) {
                    if (void 0 === B && (B = (function () {
                        var t = {
                            stencil: !0,
                            failIfMajorPerformanceCaveat: r.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
                        };
                        try {
                            if (!self.WebGLRenderingContext) return !1
                                        var e = document.createElement('canvas');
                                            var n = e.getContext("webgl", t) || e.getContext("experimental-webgl", t);
                                            var i = !(!n || !n.getContextAttributes().stencil)
                                        if (n) {
                                var o = n.getExtension('WEBGL_lose_context');
                                o && o.loseContext()
                            }
                            return n = null, i
                        } catch (t) {
                            return !1
                        }
                    }())), B) { return new e(t)
}
                    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.')
                }, e.prototype.contextChange = function () {
                    let t; let e = this.gl
                    if (this.context.webGLVersion === 1) {
                        var n = e.getParameter(e.FRAMEBUFFER_BINDING)
                        e.bindFramebuffer(e.FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, n)
                    } else {
                        n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING)
                        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n)
                    }
                    t >= i.l.HIGH ? this.multisample = i.l.HIGH : t >= i.l.MEDIUM ? this.multisample = i.l.MEDIUM : t >= i.l.LOW ? this.multisample = i.l.LOW : this.multisample = i.l.NONE
                }, e.prototype.addSystem = function (t, e) {
                    let n = new t(this)
                    if (this[e]) throw new Error(`Whoops! The name "${ e }" is already in use`)
                    for (const r in this[e] = n, this.runners) this.runners[r].add(n)
                    return this
                }, e.prototype.render = function (t, e) {
                    let n, r, i, o
                    if (e && (e instanceof Yt ? (K('6.0.0', 'Renderer#render arguments changed, use options instead.'), n = e, r = arguments[2], i = arguments[3], o = arguments[4]) : (n = e.renderTexture, r = e.clear, i = e.transform, o = e.skipUpdateTransform)), this.renderingToScreen = !n, this.runners.prerender.emit(), this.emit('prerender'), this.projection.transform = i, !this.context.isLost) {
                        if (n || (this._lastObjectRendered = t), !o) {
                            let a = t.enableTempParent()
                            t.updateTransform(), t.disableTempParent(a)
                        }
                        this.renderTexture.bind(n), this.batch.currentRenderer.start(), (void 0 !== r ? r : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), n && n.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit('postrender')
                    }
                }, e.prototype.generateTexture = function (e, n, r, i) {
                    void 0 === n && (n = {})
                    var o = t.prototype.generateTexture.call(this, e, n, r, i)
                    return this.framebuffer.blit(), o
                }, e.prototype.resize = function (e, n) {
                    t.prototype.resize.call(this, e, n), this.runners.resize.emit(this.screen.height, this.screen.width)
                }, e.prototype.reset = function () {
                    return this.runners.reset.emit(), this
                }, e.prototype.clear = function () {
                    this.renderTexture.bind(), this.renderTexture.clear()
                }, e.prototype.destroy = function (e) {
                    for (const n in this.runners.destroy.emit(), this.runners) this.runners[n].destroy()
                    t.prototype.destroy.call(this, e), this.gl = null
                }, Object.defineProperty(e.prototype, 'extract', {
                    get () {
                        return K('6.0.0', 'Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.'), this.plugins.extract
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.registerPlugin = function (t, n) {
                    e.__plugins = e.__plugins || {}, e.__plugins[t] = n
                }
            }(bn)), function () {
                this.texArray = null, this.blend = 0, this.type = i.f.TRIANGLES, this.start = 0, this.size = 0, this.data = null
            })
            const Sn = (function () {
                function t() {
                    this.elements = [], this.ids = [], this.count = 0
                }
                return t.prototype.clear = function () {
                    for (let t = 0; t < this.count; t++) this.elements[t] = null
                    this.count = 0
                }, t
            }())
            const wn = (function () {
                function t(t) {
                    'number' == typeof t ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
                }
                return Object.defineProperty(t.prototype, 'int8View', {
                    get () {
                        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'uint8View', {
                    get () {
                        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'int16View', {
                    get () {
                        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'uint16View', {
                    get () {
                        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, 'int32View', {
                    get () {
                        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.view = function (t) {
                    return this[`${t }View`]
                }, t.prototype.destroy = function () {
                    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
                }, t.sizeOf = function (t) {
                    switch (t) {
                        case 'int8':
                        case 'uint8':
                            return 1
                        case 'int16':
                        case 'uint16':
                            return 2
                        case 'int32':
                        case 'uint32':
                        case 'float32':
                            return 4
                        default:
                            throw new Error(`${t } isn't a valid view type`)
                    }
                }, t
            }())
            const On = (function (t) {
                function e(e) {
                    let n = t.call(this, e) || this
                    return n.shaderGenerator = null, n.geometryClass = null, n.vertexSize = null, n.state = Ve.for2d(), n.size = 4 * r.b.SPRITE_BATCH_SIZE, n._vertexCount = 0, n._indexCount = 0, n._bufferedElements = [], n._bufferedTextures = [], n._bufferSize = 0, n._shader = null, n._packedGeometries = [], n._packedGeometryPoolSize = 2, n._flushId = 0, n._aBuffers = {}, n._iBuffers = {}, n.MAX_TEXTURES = 1, n.renderer.on('prerender', n.onPrerender, n), e.runners.contextChange.add(n), n._dcIndex = 0, n._aIndex = 0, n._iIndex = 0, n._attributeBuffer = null, n._indexBuffer = null, n._tempBoundTextures = [], n
                }
                return Tt(e, t), e.prototype.contextChange = function () {
                    let t = this.renderer.gl
                    r.b.PREFER_ENV === i.g.WEBGL_LEGACY
                        ? this.MAX_TEXTURES = 1
                        : (this.MAX_TEXTURES = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), r.b.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = (function (t, e) {
                                if (t === 0) throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
                                for (let n = e.createShader(e.FRAGMENT_SHADER); ;) {
                                    let r = Fe.replace(/%forloop%/gi, Be(t))
                                    if (e.shaderSource(n, r), e.compileShader(n), e.getShaderParameter(n, e.COMPILE_STATUS)) break
                                    t = t / 2 | 0
                                }
                                return t
                            }(this.MAX_TEXTURES, t))), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES)
                    for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] = new this.geometryClass()
                    this.initFlushBuffers()
                }, e.prototype.initFlushBuffers = function () {
                    for (var t = e._drawCallPool, n = e._textureArrayPool, r = this.size / 4, i = Math.floor(r / this.MAX_TEXTURES) + 1; t.length < r;) t.push(new Tn())
                    for (; n.length < i;) n.push(new Sn())
                    for (let o = 0; o < this.MAX_TEXTURES; o++) this._tempBoundTextures[o] = null
                }, e.prototype.onPrerender = function () {
                    this._flushId = 0
                }, e.prototype.render = function (t) {
                    t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t)
                }, e.prototype.buildTexturesAndDrawCalls = function () {
                    let t = this._bufferedTextures
                                var n = this.MAX_TEXTURES
                                var r = e._textureArrayPool
                                var i = this.renderer.batch
                                var o = this._tempBoundTextures
                                var a = this.renderer.textureGC.count
                                var s = ++Rt._globalBatch
                                var u = 0
                                var c = r[0]
                                var l = 0
                    i.copyBoundTextures(o, n)
                    for (var h = 0; h < this._bufferSize; ++h) {
                        let f = t[h]
                        t[h] = null, f._batchEnabled !== s && (c.count >= n && (i.boundArray(c, o, s, n), this.buildDrawCalls(c, l, h), l = h, c = r[++u], ++s), f._batchEnabled = s, f.touched = a, c.elements[c.count++] = f)
                    }
                    c.count > 0 && (i.boundArray(c, o, s, n), this.buildDrawCalls(c, l, this._bufferSize), ++u, ++s)
                    for (h = 0; h < o.length; h++) o[h] = null
                    Rt._globalBatch = s
                }, e.prototype.buildDrawCalls = function (t, n, r) {
                    let i = this._bufferedElements
                                var o = this._attributeBuffer
                                var a = this._indexBuffer
                                var s = this.vertexSize
                                var u = e._drawCallPool
                                var c = this._dcIndex
                                var l = this._aIndex
                                var h = this._iIndex
                                var f = u[c]
                    f.start = this._iIndex, f.texArray = t
                    for (let d = n; d < r; ++d) {
                        let p = i[d]
                                    var m = p._texture.baseTexture
                                    var y = G[m.alphaMode ? 1 : 0][p.blendMode]
                        i[d] = null, n < d && f.blend !== y && (f.size = h - f.start, n = d, (f = u[++c]).texArray = t, f.start = h), this.packInterleavedGeometry(p, o, a, l, h), l += p.vertexData.length / 2 * s, h += p.indices.length, f.blend = y
                    }
                    n < r && (f.size = h - f.start, ++c), this._dcIndex = c, this._aIndex = l, this._iIndex = h
                }, e.prototype.bindAndClearTexArray = function (t) {
                    for (let e = this.renderer.texture, n = 0; n < t.count; n++) e.bind(t.elements[n], t.ids[n]), t.elements[n] = null
                    t.count = 0
                }, e.prototype.updateGeometry = function () {
                    let t = this._packedGeometries
                                var e = this._attributeBuffer
                                var n = this._indexBuffer
                    r.b.CAN_UPLOAD_SAME_BUFFER ? (t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(n), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t[this._flushId] = new this.geometryClass()), t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(n), this.renderer.geometry.bind(t[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
                }, e.prototype.drawBatches = function () {
                    for (let t = this._dcIndex, n = this.renderer, r = n.gl, i = n.state, o = e._drawCallPool, a = null, s = 0; s < t; s++) {
                        let u = o[s]
                                    var c = u.texArray
                                    var l = u.type
                                    var h = u.size
                                    var f = u.start
                                    var d = u.blend
                        a !== c && (a = c, this.bindAndClearTexArray(c)), this.state.blendMode = d, i.set(this.state), r.drawElements(l, h, r.UNSIGNED_SHORT, 2 * f)
                    }
                }, e.prototype.flush = function () {
                    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
                }, e.prototype.start = function () {
                    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), r.b.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
                }, e.prototype.stop = function () {
                    this.flush()
                }, e.prototype.destroy = function () {
                    for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy()
                    this.renderer.off('prerender', this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t.prototype.destroy.call(this)
                }, e.prototype.getAttributeBuffer = function (t) {
                    let e = H(Math.ceil(t / 8))
                                var n = W(e)
                                var r = 8 * e
                    this._aBuffers.length <= n && (this._iBuffers.length = n + 1)
                    var i = this._aBuffers[r]
                    return i || (this._aBuffers[r] = i = new wn(r * this.vertexSize * 4)), i
                }, e.prototype.getIndexBuffer = function (t) {
                    let e = H(Math.ceil(t / 12))
                                var n = W(e)
                                var r = 12 * e
                    this._iBuffers.length <= n && (this._iBuffers.length = n + 1)
                    var i = this._iBuffers[n]
                    return i || (this._iBuffers[n] = i = new Uint16Array(r)), i
                }, e.prototype.packInterleavedGeometry = function (t, e, n, r, i) {
                    for (var o = e.uint32View, a = e.float32View, s = r / this.vertexSize, u = t.uvs, c = t.indices, l = t.vertexData, h = t._texture.baseTexture._batchLocation, f = Math.min(t.worldAlpha, 1), d = f < 1 && t._texture.baseTexture.alphaMode
                            ? (function (t, e) {
                                    if (e === 1) return (255 * e << 24) + t
                                    if (e === 0) return 0
                                    var n = t >> 16 & 255;
                                        var r = t >> 8 & 255;
                                        var i = 255 & t
                                    return (255 * e << 24) + ((n = n * e + 0.5 | 0) << 16) + ((r = r * e + 0.5 | 0) << 8) + (i = i * e + 0.5 | 0)
                                }(t._tintRGB, f))
: t._tintRGB + (255 * f << 24), p = 0; p < l.length; p += 2) a[r++] = l[p], a[r++] = l[p + 1], a[r++] = u[p], a[r++] = u[p + 1], o[r++] = d, a[r++] = h
                    for (p = 0; p < c.length; p++) n[i++] = s + c[p]
                }, e._drawCallPool = [], e._textureArrayPool = [], e
            }(le))
            const Pn = (function () {
                function t(t, e) {
                    if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, !e.includes('%count%')) throw new Error('Fragment template must contain "%count%".')
                    if (!e.includes('%forloop%')) throw new Error('Fragment template must contain "%forloop%".')
                }
                return t.prototype.generateShader = function (t) {
                    if (!this.programCache[t]) {
                        for (var e = new Int32Array(t), n = 0; n < t; n++) e[n] = n
                        this.defaultGroupCache[t] = oe.from({
                            uSamplers: e
                        }, !0)
                        var r = this.fragTemplate
                        r = (r = r.replace(/%count%/gi, `${  t}`)).replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Xe(this.vertexSrc, r)
                    }
                    let i = {
                        tint: new Float32Array([1, 1, 1, 1]),
                        translationMatrix: new ht(),
                        default: this.defaultGroupCache[t]
                    }
                    return new He(this.programCache[t], i)
                }, t.prototype.generateSampleSrc = function (t) {
                    let e = ''
                    e += '\n', e += '\n'
                    for (let n = 0; n < t; n++) n > 0 && (e += '\nelse '), n < t - 1 && (e += `if(vTextureId < ${  n  }.5)`), e += '\n{', e += `\n\tcolor = texture2D(uSamplers[${  n  }], vTextureCoord);`, e += '\n}'
                    return e += '\n', e += '\n'
                }, t
            }())
            const Rn = (function (t) {
                function e(e) {
                    void 0 === e && (e = !1)
                    var n = t.call(this) || this
                    return n._buffer = new Zt(null, e, !1), n._indexBuffer = new Zt(null, e, !0), n.addAttribute('aVertexPosition', n._buffer, 2, !1, i.r.FLOAT).addAttribute('aTextureCoord', n._buffer, 2, !1, i.r.FLOAT).addAttribute('aColor', n._buffer, 4, !0, i.r.UNSIGNED_BYTE).addAttribute('aTextureId', n._buffer, 1, !0, i.r.FLOAT).addIndex(n._indexBuffer), n
                }
                return Tt(e, t), e
            }(ee))
            const An = 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n'
            const In = 'varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n'
            const Cn = ((function () {
                function t() {}
                return t.create = function (t) {
                    let e = Object.assign({
                        vertex: An,
                        fragment: In,
                        geometryClass: Rn,
                        vertexSize: 6
                    }, t)
                                var n = e.vertex
                                var r = e.fragment
                                var i = e.vertexSize
                                var o = e.geometryClass
                    return (function (t) {
                        function e(e) {
                            var a = t.call(this, e) || this
                                    return a.shaderGenerator = new Pn(n, r), a.geometryClass = o, a.vertexSize = i, a
                        }
                        return Tt(e, t), e
                    }(On))
                }, Object.defineProperty(t, 'defaultVertexSrc', {
                    get () {
                        return An
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, 'defaultFragmentTemplate', {
                    get () {
                        return In
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }()).create(), {})
            const kn = function (t) {
                Object.defineProperty(Cn, t, {
                    get() {
                        return K('6.0.0', `PIXI.systems.${ t } has moved to PIXI.${ t}`), Ft[t]
                    }
                })
            }
            for (var Nn in Ft) kn(Nn)
            const Mn = {}
            const jn = function (t) {
                Object.defineProperty(Mn, t, {
                    get() {
                        return K('6.0.0', `PIXI.resources.${ t } has moved to PIXI.${ t}`), _n[t]
                    }
                })
            }
            for (var Nn in _n) jn(Nn)
            var Dn = (function () {
                function t(t) {
                    this.renderer = t
                }
                return t.prototype.render = function (t) {
                    const e = this.renderer
                    let n = t.worldTransform
                    e.context.globalAlpha = t.worldAlpha, e.setBlendMode(t.blendMode), e.setContextTransform(n, t.roundPixels), t.drawMode !== i.f.TRIANGLES ? this._renderTriangleMesh(t) : this._renderTriangles(t)
                }, t.prototype._renderTriangleMesh = function (t) {
                    for (let e = t.geometry.buffers[0].data.length, n = 0; n < e - 2; n++) {
                        const r = 2 * n
                        this._renderDrawTriangle(t, r, r + 2, r + 4)
                    }
                }, t.prototype._renderTriangles = function (t) {
                    for (let e = t.geometry.getIndex().data, n = e.length, r = 0; r < n; r += 3) {
                        const i = 2 * e[r]
                        let o = 2 * e[r + 1]
                        let a = 2 * e[r + 2]
                        this._renderDrawTriangle(t, i, o, a)
                    }
                }, t.prototype._renderDrawTriangle = function (t, e, n, r) {
                    const i = this.renderer.context
                    let a = t.geometry.buffers[0].data
                    let s = t.uvs
                    let u = t.texture
                    if (u.valid) {
                        const c = t.tint !== 16777215
                        var l = u.baseTexture
                        var h = l.width
                        var f = l.height
                        c && t._cachedTint !== t.tint && (t._cachedTint = t.tint, t._cachedTexture = t._cachedTexture || new Vt(l), t._tintedCanvas = o.b.getTintedCanvas({
                            texture: t._cachedTexture
                        }, t.tint))
                        const d = c ? t._tintedCanvas : l.getDrawableSource()
                        let p = s[e] * l.width
                        let m = s[n] * l.width
                        let y = s[r] * l.width
                        let v = s[e + 1] * l.height
                        let _ = s[n + 1] * l.height
                        let g = s[r + 1] * l.height
                        let b = a[e]
                        let E = a[n]
                        let x = a[r]
                        let T = a[e + 1]
                        let S = a[n + 1]
                        let w = a[r + 1]
                        let O = t.canvasPadding / this.renderer.resolution
                        if (O > 0) {
                            const P = t.worldTransform
                            let R = P.a
                            let A = P.b
                            let I = P.c
                            let C = P.d
                            let k = (b + E + x) / 3
                            let N = (T + S + w) / 3
                            let M = b - k
                            let j = T - N
                            let D = R * M + I * j
                            let L = A * M + C * j
                            let F = Math.sqrt(D * D + L * L)
                            let B = 1 + O / F
                            b = k + M * B, T = N + j * B, D = R * (M = E - k) + I * (j = S - N), L = A * M + C * j, E = k + M * (B = 1 + O / (F = Math.sqrt(D * D + L * L))), S = N + j * B, D = R * (M = x - k) + I * (j = w - N), L = A * M + C * j, x = k + M * (B = 1 + O / (F = Math.sqrt(D * D + L * L))), w = N + j * B
                        }
                        i.save(), i.beginPath(), i.moveTo(b, T), i.lineTo(E, S), i.lineTo(x, w), i.closePath(), i.clip()
                        const U = p * _ + v * y + m * g - _ * y - v * m - p * g
                        let G = b * _ + v * x + E * g - _ * x - v * E - b * g
                        let X = p * E + b * y + m * x - E * y - b * m - p * x
                        let H = p * _ * x + v * E * y + b * m * g - b * _ * y - v * m * x - p * E * g
                        let V = T * _ + v * w + S * g - _ * w - v * S - T * g
                        let W = p * S + T * y + m * w - S * y - T * m - p * w
                        let Y = p * _ * w + v * S * y + T * m * g - T * _ * y - v * m * w - p * S * g
                        i.transform(G / U, V / U, X / U, W / U, H / U, Y / U), i.drawImage(d, 0, 0, h * l.resolution, f * l.resolution, 0, 0, h, f), i.restore(), this.renderer.invalidateBlendMode()
                    }
                }, t.prototype.renderMeshFlat = function (t) {
                    const e = this.renderer.context
                    let n = t.geometry.getBuffer('aVertexPosition').data
                    let r = n.length / 2
                    e.beginPath()
                    for (let i = 1; i < r - 2; ++i) {
                        const o = 2 * i
                        let a = n[o]
                        let s = n[o + 1]
                        let u = n[o + 2]
                        let c = n[o + 3]
                        let l = n[o + 4]
                        let h = n[o + 5]
                        e.moveTo(a, s), e.lineTo(u, c), e.lineTo(l, h)
                    }
                    e.fillStyle = '#FF0000', e.fill(), e.closePath()
                }, t.prototype.destroy = function () {
                    this.renderer = null
                }, t
            }())
            r.b.MESH_CANVAS_PADDING = 0, a.d.prototype._renderCanvas = function (t, e) {
                t.plugins.mesh.render(e)
            }, s.a.prototype._cachedTint = 16777215, s.a.prototype._tintedCanvas = null, s.a.prototype._canvasUvs = null, s.a.prototype._renderCanvas = function (t) {
                const e = t.context
                const n = this.worldTransform
                const r = this.tint !== 16777215
                const i = this.texture
                if (i.valid) {
                    r && this._cachedTint !== this.tint && (this._cachedTint = this.tint, this._tintedCanvas = o.b.getTintedCanvas(this, this.tint))
                    const a = r ? this._tintedCanvas : i.baseTexture.getDrawableSource()
                    this._canvasUvs || (this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0])
                    const s = this.vertices
                    const u = this._canvasUvs
                    const c = r ? 0 : i.frame.x
                    const l = r ? 0 : i.frame.y
                    const h = c + i.frame.width
                    const f = l + i.frame.height
                    u[0] = c, u[1] = c + this._leftWidth, u[2] = h - this._rightWidth, u[3] = h, u[4] = l, u[5] = l + this._topHeight, u[6] = f - this._bottomHeight, u[7] = f
                    for (let d = 0; d < 8; d++) u[d] *= i.baseTexture.resolution
                    e.globalAlpha = this.worldAlpha, t.setBlendMode(this.blendMode), t.setContextTransform(n, this.roundPixels)
                    for (let p = 0; p < 3; p++) {
                        for (let m = 0; m < 3; m++) {
                            const y = 2 * m + 8 * p
                            let v = Math.max(1, u[m + 1] - u[m])
                            let _ = Math.max(1, u[p + 5] - u[p + 4])
                            let g = Math.max(1, s[y + 10] - s[y])
                            let b = Math.max(1, s[y + 11] - s[y + 1])
                            e.drawImage(a, u[m], u[p + 4], v, _, s[y], s[y + 1], g, b)
                        }
                    }
                }
            }
            let Ln = !1
            a.a.prototype._cachedTint = 16777215, a.a.prototype._tintedCanvas = null, a.a.prototype._cachedTexture = null, a.a.prototype._renderCanvas = function (t) {
                this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.material._renderCanvas ? this.material._renderCanvas(t, this) : Ln || (Ln = !0, self.console && console.warn('Mesh with custom shaders are not supported in CanvasRenderer.'))
            }, a.a.prototype._canvasPadding = null, Object.defineProperty(a.a.prototype, 'canvasPadding', {
                get() {
                    return this._canvasPadding !== null ? this._canvasPadding : r.b.MESH_CANVAS_PADDING
                },
                set(t) {
                    this._canvasPadding = t
                }
            }), s.d.prototype._renderCanvas = function (t) {
                this.autoUpdate && this.geometry.getBuffer('aVertexPosition').update(), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t, this)
            }, s.f.prototype._renderCanvas = function (t) {
                (this.autoUpdate || this.geometry._width !== this.shader.texture.height) && (this.geometry._width = this.shader.texture.height, this.geometry.update()), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t, this)
            }
        }).call(this, n('./node_modules/webpack/buildin/global.js'))
    },
    './node_modules/@pixi/canvas-renderer/dist/esm/canvas-renderer.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return d
        }), n.d(e, 'b', () => {
            return p
        })
        const r = n('./node_modules/@pixi/core/dist/esm/core.js')
        const i = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        const o = n('./node_modules/@pixi/math/dist/esm/math.js')
        const a = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const s = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        let u = function (t, e) {
            return (u = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        const c = (function () {
            function t(t) {
                this._foundShapes = [], this.renderer = t
            }
            return t.prototype.pushMask = function (t) {
                const e = this.renderer
                var n = t.maskObject || t
                e.context.save()
                let r = this._foundShapes
                if (this.recursiveFindShapes(n, r), r.length > 0) {
                    const i = e.context
                    i.beginPath()
                    for (let o = 0; o < r.length; o++) {
                        const a = r[o]
                        var s = a.transform.worldTransform
                        this.renderer.setContextTransform(s), this.renderGraphicsShape(a)
                    }
                    r.length = 0, i.clip()
                }
            }, t.prototype.recursiveFindShapes = function (t, e) {
                t.geometry && t.geometry.graphicsData && e.push(t)
                let n = t.children
                if (n) {
                    for (let r = 0; r < n.length; r++) this.recursiveFindShapes(n[r], e)
                }
            }, t.prototype.renderGraphicsShape = function (t) {
                t.finishPoly()
                let e = this.renderer.context
                var n = t.geometry.graphicsData
                var r = n.length
                if (r !== 0) {
                    for (let i = 0; i < r; i++) {
                        let a = n[i]
                                var s = a.shape
                        if (s.type === o.l.POLY) {
                            let u = s.points
                                    var c = a.holes
                                    var l = void 0
                                    var h = void 0
                                    var f = void 0
                                    var d = void 0
                            e.moveTo(u[0], u[1])
                            for (var p = 1; p < u.length / 2; p++) e.lineTo(u[2 * p], u[2 * p + 1])
                            if (c.length > 0) {
                                l = 0, f = u[0], d = u[1]
                                for (p = 2; p + 2 < u.length; p += 2) l += (u[p] - f) * (u[p + 3] - d) - (u[p + 2] - f) * (u[p + 1] - d)
                                for (let m = 0; m < c.length; m++) {
                                    if (u = c[m].shape.points) {
                                        h = 0, f = u[0], d = u[1]
                                            for (p = 2; p + 2 < u.length; p += 2) h += (u[p] - f) * (u[p + 3] - d) - (u[p + 2] - f) * (u[p + 1] - d)
                                            if (h * l < 0) {
                                            e.moveTo(u[0], u[1])
                                                for (p = 2; p < u.length; p += 2) e.lineTo(u[p], u[p + 1])
                                        } else {
                                            e.moveTo(u[u.length - 2], u[u.length - 1])
                                                for (p = u.length - 4; p >= 0; p -= 2) e.lineTo(u[p], u[p + 1])
                                        }
                                        c[m].shape.closeStroke && e.closePath()
                                    }
                                }
                            }
                            u[0] === u[u.length - 2] && u[1] === u[u.length - 1] && e.closePath()
                        } else if (s.type === o.l.RECT) { e.rect(s.x, s.y, s.width, s.height), e.closePath()
}
                        else if (s.type === o.l.CIRC) { e.arc(s.x, s.y, s.radius, 0, 2 * Math.PI), e.closePath()
}
                        else if (s.type === o.l.ELIP) {
                            let y = 2 * s.width
                                    var v = 2 * s.height
                                    var _ = s.x - y / 2
                                    var g = s.y - v / 2
                                    var b = y / 2 * 0.5522848;
                            var E = v / 2 * 0.5522848;
                            var x = _ + y
                                    var T = g + v
                                    var S = _ + y / 2
                                    var w = g + v / 2
                            e.moveTo(_, w), e.bezierCurveTo(_, w - E, S - b, g, S, g), e.bezierCurveTo(S + b, g, x, w - E, x, w), e.bezierCurveTo(x, w + E, S + b, T, S, T), e.bezierCurveTo(S - b, T, _, w + E, _, w), e.closePath()
                        } else if (s.type === o.l.RREC) {
                            let O = s.x
                                    var P = s.y
                                    var R = s.width
                                    var A = s.height
                                    var I = s.radius
                                    var C = Math.min(R, A) / 2
                            I = I > C ? C : I, e.moveTo(O, P + I), e.lineTo(O, P + A - I), e.quadraticCurveTo(O, P + A, O + I, P + A), e.lineTo(O + R - I, P + A), e.quadraticCurveTo(O + R, P + A, O + R, P + A - I), e.lineTo(O + R, P + I), e.quadraticCurveTo(O + R, P, O + R - I, P), e.lineTo(O + I, P), e.quadraticCurveTo(O, P, O, P + I), e.closePath()
                        }
                    }
                }
            }, t.prototype.popMask = function (t) {
                t.context.restore(), t.invalidateBlendMode()
            }, t.prototype.destroy = function () {}, t
        }())

        function l(t) {
            const e = document.createElement('canvas')
            e.width = 6, e.height = 1
            const n = e.getContext('2d')
            return n.fillStyle = t, n.fillRect(0, 0, 6, 1), e
        }

        function h() {
            if (typeof document == 'undefined') return !1
            const t = l('#ff00ff')
            const e = l('#ffff00')
            const n = document.createElement('canvas')
            n.width = 6, n.height = 1
            const r = n.getContext('2d')
            r.globalCompositeOperation = 'multiply', r.drawImage(t, 0, 0), r.drawImage(e, 2, 0)
            const i = r.getImageData(2, 0, 1, 1)
            if (!i) return !1
            const o = i.data
            return o[0] === 255 && o[1] === 0 && o[2] === 0
        }
        const f = new o.d()
        var d = (function (t) {
            function e(n) {
                let r; const o = t.call(this, a.n.CANVAS, n) || this
                if (o.refresh = !0, o.maskManager = new c(o), o.smoothProperty = 'imageSmoothingEnabled', o.blendModes = (void 0 === r && (r = []), h() ? (r[a.b.NORMAL] = 'source-over', r[a.b.ADD] = 'lighter', r[a.b.MULTIPLY] = 'multiply', r[a.b.SCREEN] = 'screen', r[a.b.OVERLAY] = 'overlay', r[a.b.DARKEN] = 'darken', r[a.b.LIGHTEN] = 'lighten', r[a.b.COLOR_DODGE] = 'color-dodge', r[a.b.COLOR_BURN] = 'color-burn', r[a.b.HARD_LIGHT] = 'hard-light', r[a.b.SOFT_LIGHT] = 'soft-light', r[a.b.DIFFERENCE] = 'difference', r[a.b.EXCLUSION] = 'exclusion', r[a.b.HUE] = 'hue', r[a.b.SATURATION] = 'saturate', r[a.b.COLOR] = 'color', r[a.b.LUMINOSITY] = 'luminosity') : (r[a.b.NORMAL] = 'source-over', r[a.b.ADD] = 'lighter', r[a.b.MULTIPLY] = 'source-over', r[a.b.SCREEN] = 'source-over', r[a.b.OVERLAY] = 'source-over', r[a.b.DARKEN] = 'source-over', r[a.b.LIGHTEN] = 'source-over', r[a.b.COLOR_DODGE] = 'source-over', r[a.b.COLOR_BURN] = 'source-over', r[a.b.HARD_LIGHT] = 'source-over', r[a.b.SOFT_LIGHT] = 'source-over', r[a.b.DIFFERENCE] = 'source-over', r[a.b.EXCLUSION] = 'source-over', r[a.b.HUE] = 'source-over', r[a.b.SATURATION] = 'source-over', r[a.b.COLOR] = 'source-over', r[a.b.LUMINOSITY] = 'source-over'), r[a.b.NORMAL_NPM] = r[a.b.NORMAL], r[a.b.ADD_NPM] = r[a.b.ADD], r[a.b.SCREEN_NPM] = r[a.b.SCREEN], r[a.b.SRC_IN] = 'source-in', r[a.b.SRC_OUT] = 'source-out', r[a.b.SRC_ATOP] = 'source-atop', r[a.b.DST_OVER] = 'destination-over', r[a.b.DST_IN] = 'destination-in', r[a.b.DST_OUT] = 'destination-out', r[a.b.DST_ATOP] = 'destination-atop', r[a.b.XOR] = 'xor', r[a.b.SUBTRACT] = 'source-over', r), o.renderingToScreen = !1, o._activeBlendMode = null, o._projTransform = null, o._outerBlend = !1, o.rootContext = o.view.getContext('2d', {
                    alpha: o.useContextAlpha
                }), o.context = o.rootContext, !o.rootContext.imageSmoothingEnabled) {
                    const s = o.rootContext
                    s.webkitImageSmoothingEnabled ? o.smoothProperty = 'webkitImageSmoothingEnabled' : s.mozImageSmoothingEnabled ? o.smoothProperty = 'mozImageSmoothingEnabled' : s.oImageSmoothingEnabled ? o.smoothProperty = 'oImageSmoothingEnabled' : s.msImageSmoothingEnabled && (o.smoothProperty = 'msImageSmoothingEnabled')
                }
                return o.initPlugins(e.__plugins), new Object(i.sayHello)('Canvas'), o.resize(o.options.width, o.options.height), o
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                u(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype.render = function (t, e) {
                if (this.view) {
                    let n, o, s, u
                    e && (e instanceof r.P || e instanceof r.g ? (new Object(i.deprecation)('6.0.0', 'CanvasRenderer#render arguments changed, use options instead.'), n = e, o = arguments[2], s = arguments[3], u = arguments[4]) : (n = e.renderTexture, o = e.clear, s = e.transform, u = e.skipUpdateTransform)), this.renderingToScreen = !n, this.emit('prerender')
                    let c = this.resolution
                    n ? ((n = n.castToBaseTexture())._canvasRenderTarget || (n._canvasRenderTarget = new i.CanvasRenderTarget(n.width, n.height, n.resolution), n.resource = new r.r(n._canvasRenderTarget.canvas), n.valid = !0), this.context = n._canvasRenderTarget.context, this.resolution = n._canvasRenderTarget.resolution) : this.context = this.rootContext
                    let l = this.context
                    if (this._projTransform = s || null, n || (this._lastObjectRendered = t), !u) {
                        const h = t.enableTempParent()
                        t.updateTransform(), t.disableTempParent(h)
                    }
                    if (l.save(), l.setTransform(1, 0, 0, 1, 0, 0), l.globalAlpha = 1, this._activeBlendMode = a.b.NORMAL, this._outerBlend = !1, l.globalCompositeOperation = this.blendModes[a.b.NORMAL], void 0 !== o ? o : this.clearBeforeRender) {
                        if (this.renderingToScreen) { l.clearRect(0, 0, this.width, this.height), this.backgroundAlpha > 0 && (l.globalAlpha = this.useContextAlpha ? this.backgroundAlpha : 1, l.fillStyle = this._backgroundColorString, l.fillRect(0, 0, this.width, this.height), l.globalAlpha = 1)
}
                        else {
                            (n = n)._canvasRenderTarget.clear()
                            var f = n.clearColor
                            f[3] > 0 && (l.globalAlpha = this.useContextAlpha ? f[3] : 1, l.fillStyle = new Object(i.hex2string)(new Object(i.rgb2hex)(f)), l.fillRect(0, 0, n.realWidth, n.realHeight), l.globalAlpha = 1)
                        }
                    }
                    const d = this.context
                    this.context = l, t.renderCanvas(this), this.context = d, l.restore(), this.resolution = c, this._projTransform = null, this.emit('postrender')
                }
            }, e.prototype.setContextTransform = function (t, e, n) {
                let r = t
                var i = this._projTransform
                var o = this.resolution
                n = n || o, i && ((r = f).copyFrom(t), r.prepend(i)), e ? this.context.setTransform(r.a * n, r.b * n, r.c * n, r.d * n, r.tx * o | 0, r.ty * o | 0) : this.context.setTransform(r.a * n, r.b * n, r.c * n, r.d * n, r.tx * o, r.ty * o)
            }, e.prototype.clear = function (t, e) {
                void 0 === t && (t = this._backgroundColorString), void 0 === e && (e = this.backgroundAlpha)
                let n = this.context
                n.clearRect(0, 0, this.width, this.height), t && (n.globalAlpha = this.useContextAlpha ? e : 1, n.fillStyle = t, n.fillRect(0, 0, this.width, this.height), n.globalAlpha = 1)
            }, e.prototype.setBlendMode = function (t, e) {
                const n = t === a.b.SRC_IN || t === a.b.SRC_OUT || t === a.b.DST_IN || t === a.b.DST_ATOP
                !e && n && (t = a.b.NORMAL), this._activeBlendMode !== t && (this._activeBlendMode = t, this._outerBlend = n, this.context.globalCompositeOperation = this.blendModes[t])
            }, e.prototype.destroy = function (e) {
                t.prototype.destroy.call(this, e), this.context = null, this.refresh = !0, this.maskManager.destroy(), this.maskManager = null, this.smoothProperty = null
            }, e.prototype.resize = function (e, n) {
                t.prototype.resize.call(this, e, n), this.smoothProperty && (this.rootContext[this.smoothProperty] = s.b.SCALE_MODE === a.p.LINEAR)
            }, e.prototype.invalidateBlendMode = function () {
                this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation)
            }, e.registerPlugin = function (t, n) {
                e.__plugins = e.__plugins || {}, e.__plugins[t] = n
            }, e
        }(r.c))
        var p = {
            canvas: null,
            getTintedCanvas(t, e) {
                const n = t.texture
                let r = `#${(`00000${ (0 | (e = p.roundColor(e))).toString(16)}`).substr(-6)}`
                n.tintCache = n.tintCache || {}
                let i; const o = n.tintCache[r]
                if (o) {
                    if (o.tintId === n._updateID) return n.tintCache[r]
                    i = n.tintCache[r]
                } else { i = document.createElement('canvas')
                }
                if (p.tintMethod(n, e, i), i.tintId = n._updateID, p.convertTintToImage) {
                    const a = new Image()
                    a.src = i.toDataURL(), n.tintCache[r] = a
                } else { n.tintCache[r] = i
                }
                return i
            },
            getTintedPattern(t, e) {
                const n = `#${ (`00000${  (0 | (e = p.roundColor(e))).toString(16)}`).substr(-6)}`
                t.patternCache = t.patternCache || {}
                let r = t.patternCache[n]
                return r && r.tintId === t._updateID || (p.canvas || (p.canvas = document.createElement('canvas')), p.tintMethod(t, e, p.canvas), (r = p.canvas.getContext('2d').createPattern(p.canvas, 'repeat')).tintId = t._updateID, t.patternCache[n] = r), r
            },
            tintWithMultiply(t, e, n) {
                const r = n.getContext('2d')
                let i = t._frame.clone()
                let o = t.baseTexture.resolution
                i.x *= o, i.y *= o, i.width *= o, i.height *= o, n.width = Math.ceil(i.width), n.height = Math.ceil(i.height), r.save(), r.fillStyle = `#${(`00000${ (0 | e).toString(16)}`).substr(-6)}`, r.fillRect(0, 0, i.width, i.height), r.globalCompositeOperation = 'multiply'
                let a = t.baseTexture.getDrawableSource()
                r.drawImage(a, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height), r.globalCompositeOperation = 'destination-atop', r.drawImage(a, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height), r.restore()
            },
            tintWithOverlay(t, e, n) {
                const r = n.getContext('2d')
                let i = t._frame.clone()
                let o = t.baseTexture.resolution
                i.x *= o, i.y *= o, i.width *= o, i.height *= o, n.width = Math.ceil(i.width), n.height = Math.ceil(i.height), r.save(), r.globalCompositeOperation = 'copy', r.fillStyle = `#${(`00000${ (0 | e).toString(16)}`).substr(-6)}`, r.fillRect(0, 0, i.width, i.height), r.globalCompositeOperation = 'destination-atop', r.drawImage(t.baseTexture.getDrawableSource(), i.x, i.y, i.width, i.height, 0, 0, i.width, i.height), r.restore()
            },
            tintWithPerPixel(t, e, n) {
                const r = n.getContext('2d')
                let o = t._frame.clone()
                let a = t.baseTexture.resolution
                o.x *= a, o.y *= a, o.width *= a, o.height *= a, n.width = Math.ceil(o.width), n.height = Math.ceil(o.height), r.save(), r.globalCompositeOperation = 'copy', r.drawImage(t.baseTexture.getDrawableSource(), o.x, o.y, o.width, o.height, 0, 0, o.width, o.height), r.restore()
                for (var s = new Object(i.hex2rgb)(e), u = s[0], c = s[1], l = s[2], h = r.getImageData(0, 0, o.width, o.height), f = h.data, d = 0; d < f.length; d += 4) f[d + 0] *= u, f[d + 1] *= c, f[d + 2] *= l
                r.putImageData(h, 0, 0)
            },
            roundColor(t) {
                const e = p.cacheStepsPerColorChannel
                let n = new Object(i.hex2rgb)(t)
                return n[0] = Math.min(255, n[0] / e * e), n[1] = Math.min(255, n[1] / e * e), n[2] = Math.min(255, n[2] / e * e), new Object(i.rgb2hex)(n)
            },
            cacheStepsPerColorChannel: 8,
            convertTintToImage: !1,
            canUseMultiply: h(),
            tintMethod: null
        }
        p.tintMethod = p.canUseMultiply ? p.tintWithMultiply : p.tintWithPerPixel
        const m = r.S.create
        r.S.create = function (t) {
            if (!(t && t.forceCanvas)) { try {
                return m(t)
            } catch (t) {}
            }
            return new d(t)
        }, r.h.prototype.getDrawableSource = function () {
            const t = this.resource
            return t ? t.bitmap || t.source : null
        }, r.g.prototype._canvasRenderTarget = null, r.db.prototype.patternCache = null, r.db.prototype.tintCache = null
    },
    './node_modules/@pixi/constants/dist/esm/constants.js': function (t, e, n) {
        'use strict'
        /*!
             * @pixi/constants - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/constants is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        let r, i, o, a, s, u, c, l, h, f, d, p, m, y, v, _, g, b, E
        n.d(e, 'a', () => {
            return m
        }), n.d(e, 'b', () => {
            return a
        }), n.d(e, 'c', () => {
            return o
        }), n.d(e, 'd', () => {
            return E
        }), n.d(e, 'e', () => {
            return y
        }), n.d(e, 'f', () => {
            return s
        }), n.d(e, 'g', () => {
            return r
        }), n.d(e, 'h', () => {
            return u
        }), n.d(e, 'i', () => {
            return v
        }), n.d(e, 'j', () => {
            return g
        }), n.d(e, 'k', () => {
            return p
        }), n.d(e, 'l', () => {
            return b
        }), n.d(e, 'm', () => {
            return _
        }), n.d(e, 'n', () => {
            return i
        }), n.d(e, 'o', () => {
            return h
        }), n.d(e, 'p', () => {
            return f
        }), n.d(e, 'q', () => {
            return c
        }), n.d(e, 'r', () => {
            return l
        }), n.d(e, 's', () => {
            return d
        }),
        (function (t) {
            t[t.WEBGL_LEGACY = 0] = 'WEBGL_LEGACY', t[t.WEBGL = 1] = 'WEBGL', t[t.WEBGL2 = 2] = 'WEBGL2'
        }(r || (r = {}))),
        (function (t) {
            t[t.UNKNOWN = 0] = 'UNKNOWN', t[t.WEBGL = 1] = 'WEBGL', t[t.CANVAS = 2] = 'CANVAS'
        }(i || (i = {}))),
        (function (t) {
            t[t.COLOR = 16384] = 'COLOR', t[t.DEPTH = 256] = 'DEPTH', t[t.STENCIL = 1024] = 'STENCIL'
        }(o || (o = {}))),
        (function (t) {
            t[t.NORMAL = 0] = 'NORMAL', t[t.ADD = 1] = 'ADD', t[t.MULTIPLY = 2] = 'MULTIPLY', t[t.SCREEN = 3] = 'SCREEN', t[t.OVERLAY = 4] = 'OVERLAY', t[t.DARKEN = 5] = 'DARKEN', t[t.LIGHTEN = 6] = 'LIGHTEN', t[t.COLOR_DODGE = 7] = 'COLOR_DODGE', t[t.COLOR_BURN = 8] = 'COLOR_BURN', t[t.HARD_LIGHT = 9] = 'HARD_LIGHT', t[t.SOFT_LIGHT = 10] = 'SOFT_LIGHT', t[t.DIFFERENCE = 11] = 'DIFFERENCE', t[t.EXCLUSION = 12] = 'EXCLUSION', t[t.HUE = 13] = 'HUE', t[t.SATURATION = 14] = 'SATURATION', t[t.COLOR = 15] = 'COLOR', t[t.LUMINOSITY = 16] = 'LUMINOSITY', t[t.NORMAL_NPM = 17] = 'NORMAL_NPM', t[t.ADD_NPM = 18] = 'ADD_NPM', t[t.SCREEN_NPM = 19] = 'SCREEN_NPM', t[t.NONE = 20] = 'NONE', t[t.SRC_OVER = 0] = 'SRC_OVER', t[t.SRC_IN = 21] = 'SRC_IN', t[t.SRC_OUT = 22] = 'SRC_OUT', t[t.SRC_ATOP = 23] = 'SRC_ATOP', t[t.DST_OVER = 24] = 'DST_OVER', t[t.DST_IN = 25] = 'DST_IN', t[t.DST_OUT = 26] = 'DST_OUT', t[t.DST_ATOP = 27] = 'DST_ATOP', t[t.ERASE = 26] = 'ERASE', t[t.SUBTRACT = 28] = 'SUBTRACT', t[t.XOR = 29] = 'XOR'
        }(a || (a = {}))),
        (function (t) {
            t[t.POINTS = 0] = 'POINTS', t[t.LINES = 1] = 'LINES', t[t.LINE_LOOP = 2] = 'LINE_LOOP', t[t.LINE_STRIP = 3] = 'LINE_STRIP', t[t.TRIANGLES = 4] = 'TRIANGLES', t[t.TRIANGLE_STRIP = 5] = 'TRIANGLE_STRIP', t[t.TRIANGLE_FAN = 6] = 'TRIANGLE_FAN'
        }(s || (s = {}))),
        (function (t) {
            t[t.RGBA = 6408] = 'RGBA', t[t.RGB = 6407] = 'RGB', t[t.RG = 33319] = 'RG', t[t.RED = 6403] = 'RED', t[t.RGBA_INTEGER = 36249] = 'RGBA_INTEGER', t[t.RGB_INTEGER = 36248] = 'RGB_INTEGER', t[t.RG_INTEGER = 33320] = 'RG_INTEGER', t[t.RED_INTEGER = 36244] = 'RED_INTEGER', t[t.ALPHA = 6406] = 'ALPHA', t[t.LUMINANCE = 6409] = 'LUMINANCE', t[t.LUMINANCE_ALPHA = 6410] = 'LUMINANCE_ALPHA', t[t.DEPTH_COMPONENT = 6402] = 'DEPTH_COMPONENT', t[t.DEPTH_STENCIL = 34041] = 'DEPTH_STENCIL'
        }(u || (u = {}))),
        (function (t) {
            t[t.TEXTURE_2D = 3553] = 'TEXTURE_2D', t[t.TEXTURE_CUBE_MAP = 34067] = 'TEXTURE_CUBE_MAP', t[t.TEXTURE_2D_ARRAY = 35866] = 'TEXTURE_2D_ARRAY', t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = 'TEXTURE_CUBE_MAP_POSITIVE_X', t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = 'TEXTURE_CUBE_MAP_NEGATIVE_X', t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = 'TEXTURE_CUBE_MAP_POSITIVE_Y', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = 'TEXTURE_CUBE_MAP_NEGATIVE_Y', t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = 'TEXTURE_CUBE_MAP_POSITIVE_Z', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = 'TEXTURE_CUBE_MAP_NEGATIVE_Z'
        }(c || (c = {}))),
        (function (t) {
            t[t.UNSIGNED_BYTE = 5121] = 'UNSIGNED_BYTE', t[t.UNSIGNED_SHORT = 5123] = 'UNSIGNED_SHORT', t[t.UNSIGNED_SHORT_5_6_5 = 33635] = 'UNSIGNED_SHORT_5_6_5', t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = 'UNSIGNED_SHORT_4_4_4_4', t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = 'UNSIGNED_SHORT_5_5_5_1', t[t.UNSIGNED_INT = 5125] = 'UNSIGNED_INT', t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = 'UNSIGNED_INT_10F_11F_11F_REV', t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = 'UNSIGNED_INT_2_10_10_10_REV', t[t.UNSIGNED_INT_24_8 = 34042] = 'UNSIGNED_INT_24_8', t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = 'UNSIGNED_INT_5_9_9_9_REV', t[t.BYTE = 5120] = 'BYTE', t[t.SHORT = 5122] = 'SHORT', t[t.INT = 5124] = 'INT', t[t.FLOAT = 5126] = 'FLOAT', t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = 'FLOAT_32_UNSIGNED_INT_24_8_REV', t[t.HALF_FLOAT = 36193] = 'HALF_FLOAT'
        }(l || (l = {}))),
        (function (t) {
            t[t.FLOAT = 0] = 'FLOAT', t[t.INT = 1] = 'INT', t[t.UINT = 2] = 'UINT'
        }(h || (h = {}))),
        (function (t) {
            t[t.NEAREST = 0] = 'NEAREST', t[t.LINEAR = 1] = 'LINEAR'
        }(f || (f = {}))),
        (function (t) {
            t[t.CLAMP = 33071] = 'CLAMP', t[t.REPEAT = 10497] = 'REPEAT', t[t.MIRRORED_REPEAT = 33648] = 'MIRRORED_REPEAT'
        }(d || (d = {}))),
        (function (t) {
            t[t.OFF = 0] = 'OFF', t[t.POW2 = 1] = 'POW2', t[t.ON = 2] = 'ON', t[t.ON_MANUAL = 3] = 'ON_MANUAL'
        }(p || (p = {}))),
        (function (t) {
            t[t.NPM = 0] = 'NPM', t[t.UNPACK = 1] = 'UNPACK', t[t.PMA = 2] = 'PMA', t[t.NO_PREMULTIPLIED_ALPHA = 0] = 'NO_PREMULTIPLIED_ALPHA', t[t.PREMULTIPLY_ON_UPLOAD = 1] = 'PREMULTIPLY_ON_UPLOAD', t[t.PREMULTIPLY_ALPHA = 2] = 'PREMULTIPLY_ALPHA', t[t.PREMULTIPLIED_ALPHA = 2] = 'PREMULTIPLIED_ALPHA'
        }(m || (m = {}))),
        (function (t) {
            t[t.NO = 0] = 'NO', t[t.YES = 1] = 'YES', t[t.AUTO = 2] = 'AUTO', t[t.BLEND = 0] = 'BLEND', t[t.CLEAR = 1] = 'CLEAR', t[t.BLIT = 2] = 'BLIT'
        }(y || (y = {}))),
        (function (t) {
            t[t.AUTO = 0] = 'AUTO', t[t.MANUAL = 1] = 'MANUAL'
        }(v || (v = {}))),
        (function (t) {
            t.LOW = 'lowp', t.MEDIUM = 'mediump', t.HIGH = 'highp'
        }(_ || (_ = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.SCISSOR = 1] = 'SCISSOR', t[t.STENCIL = 2] = 'STENCIL', t[t.SPRITE = 3] = 'SPRITE'
        }(g || (g = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.LOW = 2] = 'LOW', t[t.MEDIUM = 4] = 'MEDIUM', t[t.HIGH = 8] = 'HIGH'
        }(b || (b = {}))),
        (function (t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = 'ELEMENT_ARRAY_BUFFER', t[t.ARRAY_BUFFER = 34962] = 'ARRAY_BUFFER', t[t.UNIFORM_BUFFER = 35345] = 'UNIFORM_BUFFER'
        }(E || (E = {})))
    },
    './node_modules/@pixi/core/dist/esm/core.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return Te
        }), n.d(e, 'b', () => {
            return _
        }), n.d(e, 'c', () => {
            return fe
        }), n.d(e, 'd', () => {
            return g
        }), n.d(e, 'e', () => {
            return L
        }), n.d(e, 'f', () => {
            return b
        }), n.d(e, 'g', () => {
            return I
        }), n.d(e, 'h', () => {
            return v
        }), n.d(e, 'i', () => {
            return be
        }), n.d(e, 'j', () => {
            return we
        }), n.d(e, 'k', () => {
            return Re
        }), n.d(e, 'l', () => {
            return Ae
        }), n.d(e, 'm', () => {
            return Se
        }), n.d(e, 'n', () => {
            return tt
        }), n.d(e, 'o', () => {
            return Ee
        }), n.d(e, 'p', () => {
            return B
        }), n.d(e, 'q', () => {
            return m
        }), n.d(e, 'r', () => {
            return E
        }), n.d(e, 's', () => {
            return nt
        }), n.d(e, 't', () => {
            return x
        }), n.d(e, 'u', () => {
            return jt
        }), n.d(e, 'v', () => {
            return K
        }), n.d(e, 'w', () => {
            return J
        }), n.d(e, 'x', () => {
            return A
        }), n.d(e, 'y', () => {
            return ot
        }), n.d(e, 'z', () => {
            return rt
        }), n.d(e, 'A', () => {
            return ee
        }), n.d(e, 'B', () => {
            return ue
        }), n.d(e, 'C', () => {
            return V
        }), n.d(e, 'D', () => {
            return st
        }), n.d(e, 'E', () => {
            return te
        }), n.d(e, 'F', () => {
            return c
        }), n.d(e, 'G', () => {
            return O
        }), n.d(e, 'H', () => {
            return T
        }), n.d(e, 'I', () => {
            return ut
        }), n.d(e, 'J', () => {
            return Bt
        }), n.d(e, 'K', () => {
            return Q
        }), n.d(e, 'L', () => {
            return kt
        }), n.d(e, 'M', () => {
            return Vt
        }), n.d(e, 'N', () => {
            return W
        }), n.d(e, 'O', () => {
            return Y
        }), n.d(e, 'P', () => {
            return j
        }), n.d(e, 'Q', () => {
            return D
        }), n.d(e, 'R', () => {
            return zt
        }), n.d(e, 'S', () => {
            return me
        }), n.d(e, 'T', () => {
            return p
        }), n.d(e, 'U', () => {
            return S
        }), n.d(e, 'V', () => {
            return Xt
        }), n.d(e, 'W', () => {
            return Nt
        }), n.d(e, 'X', () => {
            return oe
        }), n.d(e, 'Y', () => {
            return Ft
        }), n.d(e, 'Z', () => {
            return Mt
        }), n.d(e, 'ab', () => {
            return ae
        }), n.d(e, 'bb', () => {
            return Ht
        }), n.d(e, 'cb', () => {
            return ge
        }), n.d(e, 'db', () => {
            return N
        }), n.d(e, 'eb', () => {
            return se
        }), n.d(e, 'fb', () => {
            return Lt
        }), n.d(e, 'gb', () => {
            return ce
        }), n.d(e, 'hb', () => {
            return C
        }), n.d(e, 'ib', () => {
            return q
        }), n.d(e, 'jb', () => {
            return w
        }), n.d(e, 'kb', () => {
            return xe
        }), n.d(e, 'lb', () => {
            return ye
        }), n.d(e, 'mb', () => {
            return l
        }), n.d(e, 'nb', () => {
            return At
        }), n.d(e, 'ob', () => {
            return $t
        }), n.d(e, 'pb', () => {
            return _e
        }), n.d(e, 'qb', () => {
            return ve
        }), n.d(e, 'rb', () => {
            return ne
        }), n.d(e, 'sb', () => {
            return Qt
        }), n.d(e, 'tb', () => {
            return yt
        }), n.d(e, 'ub', () => {
            return Jt
        }), n.d(e, 'vb', () => {
            return Ie
        }), n.d(e, 'wb', () => {
            return Ne
        }), n.d(e, 'xb', () => {
            return Tt
        })
        const r = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        const i = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const o = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        const a = n('./node_modules/@pixi/runner/dist/esm/runner.js')
        const s = n('./node_modules/@pixi/ticker/dist/esm/ticker.js')
        const u = n('./node_modules/@pixi/math/dist/esm/math.js')
        /*!
             * @pixi/core - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/core is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        r.b.PREFER_ENV = o.isMobile.any ? i.g.WEBGL : i.g.WEBGL2, r.b.STRICT_TEXTURE_CACHE = !1
        var c = []

        function l(t, e) {
            if (!t) return null
            let n = ''
            if (typeof t == 'string') {
                const r = /\.(\w{3,4})(?:$|\?|#)/.exec(t)
                r && (n = r[1].toLowerCase())
            }
            for (let i = c.length - 1; i >= 0; --i) {
                const o = c[i]
                if (o.test && o.test(t, n)) return new o(t, e)
            }
            throw new Error('Unrecognized source type to auto-detect Resource')
        }
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0

            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.

            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
            ***************************************************************************** */
        let h = function (t, e) {
            return (h = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }

        function f(t, e) {
            function n() {
                this.constructor = t
            }
            h(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        let d = function () {
            return (d = Object.assign || function (t) {
                for (var e, n = arguments, r = 1, i = arguments.length; r < i; r++) {
                    for (const o in e = n[r]) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o])
                }
                return t
            }).apply(this, arguments)
        }
        var p = (function () {
            function t(t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new a.a('setRealSize'), this.onUpdate = new a.a('update'), this.onError = new a.a('onError')
            }
            return t.prototype.bind = function (t) {
                this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
            }, t.prototype.unbind = function (t) {
                this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
            }, t.prototype.resize = function (t, e) {
                t === this._width && e === this._height || (this._width = t, this._height = e, this.onResize.emit(t, e))
            }, Object.defineProperty(t.prototype, 'valid', {
                get() {
                    return !!this._width && !!this._height
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.update = function () {
                this.destroyed || this.onUpdate.emit()
            }, t.prototype.load = function () {
                return Promise.resolve(this)
            }, Object.defineProperty(t.prototype, 'width', {
                get() {
                    return this._width
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'height', {
                get() {
                    return this._height
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.style = function (t, e, n) {
                return !1
            }, t.prototype.dispose = function () {}, t.prototype.destroy = function () {
                this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
            }, t.test = function (t, e) {
                return !1
            }, t
        }())
        var m = (function (t) {
            function e(e, n) {
                let r = this
                var i = n || {}
                var o = i.width
                var a = i.height
                if (!o || !a) throw new Error('BufferResource width or height invalid')
                return (r = t.call(this, o, a) || this).data = e, r
            }
            return f(e, t), e.prototype.upload = function (t, e, n) {
                const r = t.gl
                r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === i.a.UNPACK)
                let o = e.realWidth
                var a = e.realHeight
                return n.width === o && n.height === a ? r.texSubImage2D(e.target, 0, 0, 0, o, a, e.format, n.type, this.data) : (n.width = o, n.height = a, r.texImage2D(e.target, 0, n.internalFormat, o, a, 0, e.format, n.type, this.data)), !0
            }, e.prototype.dispose = function () {
                this.data = null
            }, e.test = function (t) {
                return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
            }, e
        }(p))
        let y = {
            scaleMode: i.p.NEAREST,
            format: i.h.RGBA,
            alphaMode: i.a.NPM
        }
        var v = (function (t) {
            function e(e, n) {
                void 0 === e && (e = null), void 0 === n && (n = null)
                let a = t.call(this) || this
                var s = (n = n || {}).alphaMode
                var u = n.mipmap
                var c = n.anisotropicLevel
                var h = n.scaleMode
                var f = n.width
                var d = n.height
                var m = n.wrapMode
                var y = n.format
                var v = n.type
                var _ = n.target
                var g = n.resolution
                var b = n.resourceOptions
                return !e || e instanceof p || ((e = l(e, b)).internal = !0), a.resolution = g || r.b.RESOLUTION, a.width = Math.round((f || 0) * a.resolution) / a.resolution, a.height = Math.round((d || 0) * a.resolution) / a.resolution, a._mipmap = void 0 !== u ? u : r.b.MIPMAP_TEXTURES, a.anisotropicLevel = void 0 !== c ? c : r.b.ANISOTROPIC_LEVEL, a._wrapMode = m || r.b.WRAP_MODE, a._scaleMode = void 0 !== h ? h : r.b.SCALE_MODE, a.format = y || i.h.RGBA, a.type = v || i.r.UNSIGNED_BYTE, a.target = _ || i.q.TEXTURE_2D, a.alphaMode = void 0 !== s ? s : i.a.UNPACK, a.uid = new Object(o.uid)(), a.touched = 0, a.isPowerOfTwo = !1, a._refreshPOT(), a._glTextures = {}, a.dirtyId = 0, a.dirtyStyleId = 0, a.cacheId = null, a.valid = f > 0 && d > 0, a.textureCacheIds = [], a.destroyed = !1, a.resource = null, a._batchEnabled = 0, a._batchLocation = 0, a.parentTextureArray = null, a.setResource(e), a
            }
            return f(e, t), Object.defineProperty(e.prototype, 'realWidth', {
                get() {
                    return Math.round(this.width * this.resolution)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'realHeight', {
                get() {
                    return Math.round(this.height * this.resolution)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'mipmap', {
                get() {
                    return this._mipmap
                },
                set(t) {
                    this._mipmap !== t && (this._mipmap = t, this.dirtyStyleId++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'scaleMode', {
                get() {
                    return this._scaleMode
                },
                set(t) {
                    this._scaleMode !== t && (this._scaleMode = t, this.dirtyStyleId++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'wrapMode', {
                get() {
                    return this._wrapMode
                },
                set(t) {
                    this._wrapMode !== t && (this._wrapMode = t, this.dirtyStyleId++)
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.setStyle = function (t, e) {
                let n
                return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t, n = !0), void 0 !== e && e !== this.mipmap && (this.mipmap = e, n = !0), n && this.dirtyStyleId++, this
            }, e.prototype.setSize = function (t, e, n) {
                return n = n || this.resolution, this.setRealSize(t * n, e * n, n)
            }, e.prototype.setRealSize = function (t, e, n) {
                return this.resolution = n || this.resolution, this.width = Math.round(t) / this.resolution, this.height = Math.round(e) / this.resolution, this._refreshPOT(), this.update(), this
            }, e.prototype._refreshPOT = function () {
                this.isPowerOfTwo = new Object(o.isPow2)(this.realWidth) && new Object(o.isPow2)(this.realHeight)
            }, e.prototype.setResolution = function (t) {
                const e = this.resolution
                return e === t || (this.resolution = t, this.valid && (this.width = Math.round(this.width * e) / t, this.height = Math.round(this.height * e) / t, this.emit('update', this)), this._refreshPOT()), this
            }, e.prototype.setResource = function (t) {
                if (this.resource === t) return this
                if (this.resource) throw new Error('Resource can be set only once')
                return t.bind(this), this.resource = t, this
            }, e.prototype.update = function () {
                this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit('update', this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit('loaded', this), this.emit('update', this))
            }, e.prototype.onError = function (t) {
                this.emit('error', this, t)
            }, e.prototype.destroy = function () {
                this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete o.BaseTextureCache[this.cacheId], delete o.TextureCache[this.cacheId], this.cacheId = null), this.dispose(), e.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
            }, e.prototype.dispose = function () {
                this.emit('dispose', this)
            }, e.prototype.castToBaseTexture = function () {
                return this
            }, e.from = function (t, n, i) {
                void 0 === i && (i = r.b.STRICT_TEXTURE_CACHE)
                let a = typeof t == 'string'
                var s = null
                if (a) { s = t
                }
                else {
                    if (!t._pixiId) {
                        const u = n && n.pixiIdPrefix || 'pixiid'
                        t._pixiId = `${u}_${Object(o.uid)()}`
                    }
                    s = t._pixiId
                }
                let c = o.BaseTextureCache[s]
                if (a && i && !c) throw new Error(`The cacheId "${s}" does not exist in BaseTextureCache.`)
                return c || ((c = new e(t, n)).cacheId = s, e.addToCache(c, s)), c
            }, e.fromBuffer = function (t, n, r, o) {
                t = t || new Float32Array(n * r * 4)
                let a = new m(t, {
                    width: n,
                    height: r
                })
                var s = t instanceof Float32Array ? i.r.FLOAT : i.r.UNSIGNED_BYTE
                return new e(a, Object.assign(y, o || {
                    width: n,
                    height: r,
                    type: s
                }))
            }, e.addToCache = function (t, e) {
                e && (!t.textureCacheIds.includes(e) && t.textureCacheIds.push(e), o.BaseTextureCache[e] && console.warn(`BaseTexture added to the cache with an id [${ e }] that already had an entry`), o.BaseTextureCache[e] = t)
            }, e.removeFromCache = function (t) {
                if (typeof t == 'string') {
                    const e = o.BaseTextureCache[t]
                    if (e) {
                        const n = e.textureCacheIds.indexOf(t)
                        return n > -1 && e.textureCacheIds.splice(n, 1), delete o.BaseTextureCache[t], e
                    }
                } else if (t && t.textureCacheIds) {
                    for (let r = 0; r < t.textureCacheIds.length; ++r) delete o.BaseTextureCache[t.textureCacheIds[r]]
                    return t.textureCacheIds.length = 0, t
                }
                return null
            }, e._globalBatch = 0, e
        }(o.EventEmitter))
        var _ = (function (t) {
            function e(e, n) {
                let r = this
                var i = n || {}
                var o = i.width
                var a = i.height;
                (r = t.call(this, o, a) || this).items = [], r.itemDirtyIds = []
                for (let s = 0; s < e; s++) {
                    const u = new v()
                    r.items.push(u), r.itemDirtyIds.push(-2)
                }
                return r.length = e, r._load = null, r.baseTexture = null, r
            }
            return f(e, t), e.prototype.initFromArray = function (t, e) {
                for (let n = 0; n < this.length; n++) t[n] && (t[n].castToBaseTexture ? this.addBaseTextureAt(t[n].castToBaseTexture(), n) : t[n] instanceof p ? this.addResourceAt(t[n], n) : this.addResourceAt(l(t[n], e), n))
            }, e.prototype.dispose = function () {
                for (let t = 0, e = this.length; t < e; t++) this.items[t].destroy()
                this.items = null, this.itemDirtyIds = null, this._load = null
            }, e.prototype.addResourceAt = function (t, e) {
                if (!this.items[e]) throw new Error(`Index ${ e } is out of bounds`)
                return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this
            }, e.prototype.bind = function (e) {
                if (this.baseTexture !== null) throw new Error('Only one base texture per TextureArray is allowed')
                t.prototype.bind.call(this, e)
                for (let n = 0; n < this.length; n++) this.items[n].parentTextureArray = e, this.items[n].on('update', e.update, e)
            }, e.prototype.unbind = function (e) {
                t.prototype.unbind.call(this, e)
                for (let n = 0; n < this.length; n++) this.items[n].parentTextureArray = null, this.items[n].off('update', e.update, e)
            }, e.prototype.load = function () {
                const t = this
                if (this._load) return this._load
                let e = this.items.map((t) => {
                    return t.resource
                }).filter((t) => {
                    return t
                }).map((t) => {
                    return t.load()
                })
                return this._load = Promise.all(e).then(() => {
                    let e = t.items[0]
                                var n = e.realWidth
                                var r = e.realHeight
                    return t.resize(n, r), Promise.resolve(t)
                }), this._load
            }, e
        }(p))
        var g = (function (t) {
            function e(e, n) {
                let r; let i; let o = this
                var a = n || {}
                var s = a.width
                var u = a.height
                return Array.isArray(e) ? (r = e, i = e.length) : i = e, o = t.call(this, i, {
                    width: s,
                    height: u
                }) || this, r && o.initFromArray(r, n), o
            }
            return f(e, t), e.prototype.addBaseTextureAt = function (t, e) {
                if (!t.resource) throw new Error('ArrayResource does not support RenderTexture')
                return this.addResourceAt(t.resource, e), this
            }, e.prototype.bind = function (e) {
                t.prototype.bind.call(this, e), e.target = i.q.TEXTURE_2D_ARRAY
            }, e.prototype.upload = function (t, e, n) {
                const r = this.length
                var i = this.itemDirtyIds
                var o = this.items
                var a = t.gl
                n.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, r, 0, e.format, n.type, null)
                for (let s = 0; s < r; s++) {
                    const u = o[s]
                    i[s] < u.dirtyId && (i[s] = u.dirtyId, u.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, s, u.resource.width, u.resource.height, 1, e.format, n.type, u.resource.source))
                }
                return !0
            }, e
        }(_))
        var b = (function (t) {
            function e(e) {
                let n = this
                var r = e
                var i = r.naturalWidth || r.videoWidth || r.width
                var o = r.naturalHeight || r.videoHeight || r.height
                return (n = t.call(this, i, o) || this).source = e, n.noSubImage = !1, n
            }
            return f(e, t), e.crossOrigin = function (t, e, n) {
                void 0 === n && e.indexOf('data:') !== 0 ? t.crossOrigin = new Object(o.determineCrossOrigin)(e) : !1 !== n && (t.crossOrigin = typeof n == 'string' ? n : 'anonymous')
            }, e.prototype.upload = function (t, e, n, r) {
                const o = t.gl
                var a = e.realWidth
                var s = e.realHeight
                return r = r || this.source, o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === i.a.UNPACK), this.noSubImage || e.target !== o.TEXTURE_2D || n.width !== a || n.height !== s ? (n.width = a, n.height = s, o.texImage2D(e.target, 0, n.internalFormat, e.format, n.type, r)) : o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, e.format, n.type, r), !0
            }, e.prototype.update = function () {
                if (!this.destroyed) {
                    const e = this.source
                    var n = e.naturalWidth || e.videoWidth || e.width
                    var r = e.naturalHeight || e.videoHeight || e.height
                    this.resize(n, r), t.prototype.update.call(this)
                }
            }, e.prototype.dispose = function () {
                this.source = null
            }, e
        }(p))
        var E = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return f(e, t), e.test = function (t) {
                const e = self.OffscreenCanvas
                return !!(e && t instanceof e) || self.HTMLCanvasElement && t instanceof HTMLCanvasElement
            }, e
        }(b))
        var x = (function (t) {
            function e(n, r) {
                let o = this
                var a = r || {}
                var s = a.width
                var u = a.height
                var c = a.autoLoad
                var l = a.linkBaseTexture
                if (n && n.length !== e.SIDES) throw new Error(`Invalid length. Got ${ n.length }, expected 6`)
                o = t.call(this, 6, {
                    width: s,
                    height: u
                }) || this
                for (let h = 0; h < e.SIDES; h++) o.items[h].target = i.q.TEXTURE_CUBE_MAP_POSITIVE_X + h
                return o.linkBaseTexture = !1 !== l, n && o.initFromArray(n, r), !1 !== c && o.load(), o
            }
            return f(e, t), e.prototype.bind = function (e) {
                t.prototype.bind.call(this, e), e.target = i.q.TEXTURE_CUBE_MAP
            }, e.prototype.addBaseTextureAt = function (t, e, n) {
                if (void 0 === n && (n = this.linkBaseTexture), !this.items[e]) throw new Error(`Index ${ e } is out of bounds`)
                if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0) {
                    if (!t.resource) throw new Error('CubeResource does not support copying of renderTexture.')
                    this.addResourceAt(t.resource, e)
                } else { t.target = i.q.TEXTURE_CUBE_MAP_POSITIVE_X + e, t.parentTextureArray = this.baseTexture, this.items[e] = t
                }
                return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[e] = t, this
            }, e.prototype.upload = function (t, n, r) {
                for (let i = this.itemDirtyIds, o = 0; o < e.SIDES; o++) {
                    const a = this.items[o]
                    i[o] < a.dirtyId && (a.valid && a.resource ? (a.resource.upload(t, a, r), i[o] = a.dirtyId) : i[o] < -1 && (t.gl.texImage2D(a.target, 0, r.internalFormat, n.realWidth, n.realHeight, 0, n.format, r.type, null), i[o] = -1))
                }
                return !0
            }, e.test = function (t) {
                return Array.isArray(t) && t.length === e.SIDES
            }, e.SIDES = 6, e
        }(_))
        var T = (function (t) {
            function e(e, n) {
                let i = this
                if (n = n || {}, !(e instanceof HTMLImageElement)) {
                    const o = new Image()
                    b.crossOrigin(o, e, n.crossorigin), o.src = e, e = o
                }
                return i = t.call(this, e) || this, !e.complete && i._width && i._height && (i._width = 0, i._height = 0), i.url = e.src, i._process = null, i.preserveBitmap = !1, i.createBitmap = (void 0 !== n.createBitmap ? n.createBitmap : r.b.CREATE_IMAGE_BITMAP) && !!self.createImageBitmap, i.alphaMode = typeof n.alphaMode == 'number' ? n.alphaMode : null, i.bitmap = null, i._load = null, !1 !== n.autoLoad && i.load(), i
            }
            return f(e, t), e.prototype.load = function (t) {
                const e = this
                return this._load || (void 0 !== t && (this.createBitmap = t), this._load = new Promise((t, n) => {
                    let r = e.source
                    e.url = r.src
                    var i = function () {
                        e.destroyed || (r.onload = null, r.onerror = null, e.resize(r.width, r.height), e._load = null, e.createBitmap ? t(e.process()) : t(e))
                    }
                    r.complete && r.src
                        ? i()
                        : (r.onload = i, r.onerror = function (t) {
                                n(t), e.onError.emit(t)
                            })
                })), this._load
            }, e.prototype.process = function () {
                const t = this
                var e = this.source
                if (this._process !== null) return this._process
                if (this.bitmap !== null || !self.createImageBitmap) return Promise.resolve(this)
                let n = self.createImageBitmap
                var r = !e.crossOrigin || e.crossOrigin === 'anonymous'
                return this._process = fetch(e.src, {
                    mode: r ? 'cors' : 'no-cors'
                }).then((t) => {
                    return t.blob()
                }).then((r) => {
                    return n(r, 0, 0, e.width, e.height, {
                        premultiplyAlpha: t.alphaMode === i.a.UNPACK ? 'premultiply' : 'none'
                    })
                }).then((e) => {
                    return t.destroyed ? Promise.reject() : (t.bitmap = e, t.update(), t._process = null, Promise.resolve(t))
                }), this._process
            }, e.prototype.upload = function (e, n, r) {
                if (typeof this.alphaMode == 'number' && (n.alphaMode = this.alphaMode), !this.createBitmap) return t.prototype.upload.call(this, e, n, r)
                if (!this.bitmap && (this.process(), !this.bitmap)) return !1
                if (t.prototype.upload.call(this, e, n, r, this.bitmap), !this.preserveBitmap) {
                    let i = !0
                    var o = n._glTextures
                    for (const a in o) {
                        const s = o[a]
                        if (s !== r && s.dirtyId !== n.dirtyId) {
                            i = !1
                            break
                        }
                    }
                    i && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
                }
                return !0
            }, e.prototype.dispose = function () {
                this.source.onload = null, this.source.onerror = null, t.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
            }, e.test = function (t) {
                return typeof t == 'string' || t instanceof HTMLImageElement
            }, e
        }(b))
        var S = (function (t) {
            function e(e, n) {
                let r = this
                return n = n || {}, (r = t.call(this, document.createElement('canvas')) || this)._width = 0, r._height = 0, r.svg = e, r.scale = n.scale || 1, r._overrideWidth = n.width, r._overrideHeight = n.height, r._resolve = null, r._crossorigin = n.crossorigin, r._load = null, !1 !== n.autoLoad && r.load(), r
            }
            return f(e, t), e.prototype.load = function () {
                const t = this
                return this._load || (this._load = new Promise((n) => {
                    if (t._resolve = function () {
                        t.resize(t.source.width, t.source.height), n(t)
                    }, e.SVG_XML.test(t.svg.trim())) {
                        if (!btoa) throw new Error('Your browser doesn\'t support base64 conversions.')
                        t.svg = `data:image/svg+xml;base64,${  btoa(unescape(encodeURIComponent(t.svg)))}`
                    }
                    t._loadSvg()
                })), this._load
            }, e.prototype._loadSvg = function () {
                const t = this
                var e = new Image()
                b.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = function (n) {
                    t._resolve && (e.onerror = null, t.onError.emit(n))
                }, e.onload = function () {
                    if (t._resolve) {
                        const n = e.width
                        var r = e.height
                        if (!n || !r) throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.')
                        let i = n * t.scale
                        var a = r * t.scale;
                        (t._overrideWidth || t._overrideHeight) && (i = t._overrideWidth || t._overrideHeight / r * n, a = t._overrideHeight || t._overrideWidth / n * r), i = Math.round(i), a = Math.round(a)
                        let s = t.source
                        s.width = i, s.height = a, s._pixiId = `canvas_${ new Object(o.uid)()}`, s.getContext('2d').drawImage(e, 0, 0, n, r, 0, 0, i, a), t._resolve(), t._resolve = null
                    }
                }
            }, e.getSize = function (t) {
                const n = e.SVG_SIZE.exec(t)
                var r = {}
                return n && (r[n[1]] = Math.round(Number.parseFloat(n[3])), r[n[5]] = Math.round(Number.parseFloat(n[7]))), r
            }, e.prototype.dispose = function () {
                t.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null
            }, e.test = function (t, n) {
                return n === 'svg' || typeof t == 'string' && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t) || typeof t == 'string' && e.SVG_XML.test(t)
            }, e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(?:(<!--[^(-->]*-->)\s*)?<svg/m, e.SVG_SIZE = /<svg[^>]*\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|")[^>]*\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|")[^>]*>/i, e
        }(b))
        var w = (function (t) {
            function e(n, r) {
                let i = this
                if (r = r || {}, !(n instanceof HTMLVideoElement)) {
                    const o = document.createElement('video')
                    o.setAttribute('preload', 'auto'), o.setAttribute('webkit-playsinline', ''), o.setAttribute('playsinline', ''), typeof n == 'string' && (n = [n])
                    let a = n[0].src || n[0]
                    b.crossOrigin(o, a, r.crossorigin)
                    for (let s = 0; s < n.length; ++s) {
                        const u = document.createElement('source')
                        var c = n[s]
                        var l = c.src
                        var h = c.mime
                        var f = (l = l || n[s]).split('?').shift().toLowerCase()
                        var d = f.substr(f.lastIndexOf('.') + 1)
                        h = h || e.MIME_TYPES[d] || `video/${ d}`, u.src = l, u.type = h, o.appendChild(u)
                    }
                    n = o
                }
                return (i = t.call(this, n) || this).noSubImage = !0, i._autoUpdate = !0, i._isConnectedToTicker = !1, i._updateFPS = r.updateFPS || 0, i._msToNextUpdate = 0, i.autoPlay = !1 !== r.autoPlay, i._load = null, i._resolve = null, i._onCanPlay = i._onCanPlay.bind(i), i._onError = i._onError.bind(i), !1 !== r.autoLoad && i.load(), i
            }
            return f(e, t), e.prototype.update = function (e) {
                if (!this.destroyed) {
                    const n = s.a.shared.elapsedMS * this.source.playbackRate
                    this._msToNextUpdate = Math.floor(this._msToNextUpdate - n), (!this._updateFPS || this._msToNextUpdate <= 0) && (t.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
                }
            }, e.prototype.load = function () {
                const t = this
                if (this._load) return this._load
                let e = this.source
                return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener('play', this._onPlayStart.bind(this)), e.addEventListener('pause', this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener('canplay', this._onCanPlay), e.addEventListener('canplaythrough', this._onCanPlay), e.addEventListener('error', this._onError, !0)), this._load = new Promise((n) => {
                    t.valid ? n(t) : (t._resolve = n, e.load())
                }), this._load
            }, e.prototype._onError = function (t) {
                this.source.removeEventListener('error', this._onError, !0), this.onError.emit(t)
            }, e.prototype._isSourcePlaying = function () {
                const t = this.source
                return t.currentTime > 0 && !1 === t.paused && !1 === t.ended && t.readyState > 2
            }, e.prototype._isSourceReady = function () {
                const t = this.source
                return t.readyState === 3 || t.readyState === 4
            }, e.prototype._onPlayStart = function () {
                this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (s.a.shared.add(this.update, this), this._isConnectedToTicker = !0)
            }, e.prototype._onPlayStop = function () {
                this._isConnectedToTicker && (s.a.shared.remove(this.update, this), this._isConnectedToTicker = !1)
            }, e.prototype._onCanPlay = function () {
                const t = this.source
                t.removeEventListener('canplay', this._onCanPlay), t.removeEventListener('canplaythrough', this._onCanPlay)
                let e = this.valid
                this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
            }, e.prototype.dispose = function () {
                this._isConnectedToTicker && (s.a.shared.remove(this.update, this), this._isConnectedToTicker = !1)
                let e = this.source
                e && (e.removeEventListener('error', this._onError, !0), e.pause(), e.src = '', e.load()), t.prototype.dispose.call(this)
            }, Object.defineProperty(e.prototype, 'autoUpdate', {
                get() {
                    return this._autoUpdate
                },
                set(t) {
                    t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (s.a.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (s.a.shared.add(this.update, this), this._isConnectedToTicker = !0))
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'updateFPS', {
                get() {
                    return this._updateFPS
                },
                set(t) {
                    t !== this._updateFPS && (this._updateFPS = t)
                },
                enumerable: !1,
                configurable: !0
            }), e.test = function (t, n) {
                return self.HTMLVideoElement && t instanceof HTMLVideoElement || e.TYPES.includes(n)
            }, e.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'], e.MIME_TYPES = {
                ogv: 'video/ogg',
                mov: 'video/quicktime',
                m4v: 'video/mp4'
            }, e
        }(b))
        var O = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return f(e, t), e.test = function (t) {
                return !!self.createImageBitmap && t instanceof ImageBitmap
            }, e
        }(b))
        c.push(T, O, E, w, S, m, x, g)
        const P = {
            __proto__: null,
            Resource: p,
            BaseImageResource: b,
            INSTALLED: c,
            autoDetectResource: l,
            AbstractMultiResource: _,
            ArrayResource: g,
            BufferResource: m,
            CanvasResource: E,
            CubeResource: x,
            ImageResource: T,
            SVGResource: S,
            VideoResource: w,
            ImageBitmapResource: O
        }
        const R = (function (t) {
            function e() {
                return t !== null && t.apply(this, arguments) || this
            }
            return f(e, t), e.prototype.upload = function (t, e, n) {
                let r = t.gl
                r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === i.a.UNPACK)
                var o = e.realWidth
                            var a = e.realHeight
                return n.width === o && n.height === a ? r.texSubImage2D(e.target, 0, 0, 0, o, a, e.format, n.type, this.data) : (n.width = o, n.height = a, r.texImage2D(e.target, 0, n.internalFormat, o, a, 0, e.format, n.type, this.data)), !0
            }, e
        }(m))
        var A = (function () {
            function t(t, e) {
                this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new a.a('disposeFramebuffer'), this.multisample = i.l.NONE
            }
            return Object.defineProperty(t.prototype, 'colorTexture', {
                get() {
                    return this.colorTextures[0]
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.addColorTexture = function (t, e) {
                return void 0 === t && (t = 0), this.colorTextures[t] = e || new v(null, {
                    scaleMode: i.p.NEAREST,
                    resolution: 1,
                    mipmap: i.k.OFF,
                    width: this.width,
                    height: this.height
                }), this.dirtyId++, this.dirtyFormat++, this
            }, t.prototype.addDepthTexture = function (t) {
                return this.depthTexture = t || new v(new R(null, {
                    width: this.width,
                    height: this.height
                }), {
                    scaleMode: i.p.NEAREST,
                    resolution: 1,
                    width: this.width,
                    height: this.height,
                    mipmap: i.k.OFF,
                    format: i.h.DEPTH_COMPONENT,
                    type: i.r.UNSIGNED_SHORT
                }), this.dirtyId++, this.dirtyFormat++, this
            }, t.prototype.enableDepth = function () {
                return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
            }, t.prototype.enableStencil = function () {
                return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
            }, t.prototype.resize = function (t, e) {
                if (t = Math.round(t), e = Math.round(e), t !== this.width || e !== this.height) {
                    this.width = t, this.height = e, this.dirtyId++, this.dirtySize++
                    for (let n = 0; n < this.colorTextures.length; n++) {
                        const r = this.colorTextures[n]
                        var i = r.resolution
                        r.setSize(t / i, e / i)
                    }
                    if (this.depthTexture) {
                        i = this.depthTexture.resolution
                        this.depthTexture.setSize(t / i, e / i)
                    }
                }
            }, t.prototype.dispose = function () {
                this.disposeRunner.emit(this, !1)
            }, t.prototype.destroyDepthTexture = function () {
                this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
            }, t
        }())
        var I = (function (t) {
            function e(e) {
                let n = this
                if (typeof e == 'number') {
                    const r = arguments[0]
                    var o = arguments[1]
                    var a = arguments[2]
                    var s = arguments[3]
                    e = {
                        width: r,
                        height: o,
                        scaleMode: a,
                        resolution: s
                    }
                }
                return e.width = e.width || 100, e.height = e.height || 100, e.multisample = void 0 !== e.multisample ? e.multisample : i.l.NONE, (n = t.call(this, null, e) || this).mipmap = i.k.OFF, n.valid = !0, n.clearColor = [0, 0, 0, 0], n.framebuffer = new A(n.realWidth, n.realHeight).addColorTexture(0, n), n.framebuffer.multisample = e.multisample, n.maskStack = [], n.filterStack = [{}], n
            }
            return f(e, t), e.prototype.resize = function (t, e) {
                this.framebuffer.resize(t * this.resolution, e * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height)
            }, e.prototype.dispose = function () {
                this.framebuffer.dispose(), t.prototype.dispose.call(this)
            }, e.prototype.destroy = function () {
                t.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
            }, e
        }(v))
        var C = (function () {
            function t() {
                this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
            }
            return t.prototype.set = function (t, e, n) {
                const r = e.width
                var i = e.height
                if (n) {
                    const o = t.width / 2 / r
                    var a = t.height / 2 / i
                    var s = t.x / r + o
                    var c = t.y / i + a
                    n = u.n.add(n, u.n.NW), this.x0 = s + o * u.n.uX(n), this.y0 = c + a * u.n.uY(n), n = u.n.add(n, 2), this.x1 = s + o * u.n.uX(n), this.y1 = c + a * u.n.uY(n), n = u.n.add(n, 2), this.x2 = s + o * u.n.uX(n), this.y2 = c + a * u.n.uY(n), n = u.n.add(n, 2), this.x3 = s + o * u.n.uX(n), this.y3 = c + a * u.n.uY(n)
                } else { this.x0 = t.x / r, this.y0 = t.y / i, this.x1 = (t.x + t.width) / r, this.y1 = t.y / i, this.x2 = (t.x + t.width) / r, this.y2 = (t.y + t.height) / i, this.x3 = t.x / r, this.y3 = (t.y + t.height) / i
                }
                this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
            }, t.prototype.toString = function () {
                return `[@pixi/core:TextureUvs x0=${ this.x0 } y0=${ this.y0 } x1=${ this.x1 } y1=${ this.y1 } x2=${ this.x2 } y2=${ this.y2 } x3=${ this.x3 } y3=${ this.y3 }]`
            }, t
        }())
        const k = new C()
        var N = (function (t) {
            function e(n, r, i, o, a, s) {
                const c = t.call(this) || this
                if (c.noFrame = !1, r || (c.noFrame = !0, r = new u.j(0, 0, 1, 1)), n instanceof e && (n = n.baseTexture), c.baseTexture = n, c._frame = r, c.trim = o, c.valid = !1, c._uvs = k, c.uvMatrix = null, c.orig = i || r, c._rotate = Number(a || 0), !0 === a) c._rotate = 2
                else if (c._rotate % 2 != 0) throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually')
                return c.defaultAnchor = s ? new u.g(s.x, s.y) : new u.g(0, 0), c._updateID = 0, c.textureCacheIds = [], n.valid ? c.noFrame ? n.valid && c.onBaseTextureUpdated(n) : c.frame = r : n.once('loaded', c.onBaseTextureUpdated, c), c.noFrame && n.on('update', c.onBaseTextureUpdated, c), c
            }
            return f(e, t), e.prototype.update = function () {
                this.baseTexture.resource && this.baseTexture.resource.update()
            }, e.prototype.onBaseTextureUpdated = function (t) {
                if (this.noFrame) {
                    if (!this.baseTexture.valid) return
                    this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
                } else { this.frame = this._frame
                }
                this.emit('update', this)
            }, e.prototype.destroy = function (t) {
                if (this.baseTexture) {
                    if (t) {
                        const n = this.baseTexture.resource
                        n && n.url && o.TextureCache[n.url] && e.removeFromCache(n.url), this.baseTexture.destroy()
                    }
                    this.baseTexture.off('loaded', this.onBaseTextureUpdated, this), this.baseTexture.off('update', this.onBaseTextureUpdated, this), this.baseTexture = null
                }
                this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null
            }, e.prototype.clone = function () {
                const t = this._frame.clone()
                let n = this._frame === this.orig ? t : this.orig.clone()
                let r = new e(this.baseTexture, !this.noFrame && t, n, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor)
                return this.noFrame && (r._frame = t), r
            }, e.prototype.updateUvs = function () {
                this._uvs === k && (this._uvs = new C()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
            }, e.from = function (t, n, i) {
                void 0 === n && (n = {}), void 0 === i && (i = r.b.STRICT_TEXTURE_CACHE)
                const a = typeof t == 'string'
                let s = null
                if (a) { s = t
                }
                else if (t instanceof v) {
                    if (!t.cacheId) {
                        var u = n && n.pixiIdPrefix || 'pixiid'
                        t.cacheId = `${u}-${new Object(o.uid)()}`, v.addToCache(t, t.cacheId)
                    }
                    s = t.cacheId
                } else {
                    if (!t._pixiId) {
                        u = n && n.pixiIdPrefix || 'pixiid'
                        t._pixiId = `${u}_${new Object(o.uid)()}`
                    }
                    s = t._pixiId
                }
                let c = o.TextureCache[s]
                if (a && i && !c) throw new Error(`The cacheId "${s}" does not exist in TextureCache.`)
                return c || t instanceof v ? !c && t instanceof v && (c = new e(t), e.addToCache(c, s)) : (n.resolution || (n.resolution = new Object(o.getResolutionOfUrl)(t)), (c = new e(new v(t, n))).baseTexture.cacheId = s, v.addToCache(c.baseTexture, s), e.addToCache(c, s)), c
            }, e.fromURL = function (t, n) {
                const r = Object.assign({
                    autoLoad: !1
                }, n == null ? void 0 : n.resourceOptions)
                let i = e.from(t, Object.assign({
                    resourceOptions: r
                }, n), !1)
                let o = i.baseTexture.resource
                return i.baseTexture.valid
                    ? Promise.resolve(i)
                    : o.load().then(() => {
                            return Promise.resolve(i)
                        })
            }, e.fromBuffer = function (t, n, r, i) {
                return new e(v.fromBuffer(t, n, r, i))
            }, e.fromLoader = function (t, n, i, a) {
                const s = new v(t, Object.assign({
                    scaleMode: r.b.SCALE_MODE,
                    resolution: new Object(o.getResolutionOfUrl)(n)
                }, a))
                let u = s.resource
                u instanceof T && (u.url = n)
                const c = new e(s)
                return i || (i = n), v.addToCache(c.baseTexture, i), e.addToCache(c, i), i !== n && (v.addToCache(c.baseTexture, n), e.addToCache(c, n)), c.baseTexture.valid
                    ? Promise.resolve(c)
                    : new Promise((t) => {
                        c.baseTexture.once('loaded', () => {
                            return t(c)
                        })
                    })
            }, e.addToCache = function (t, e) {
                e && (!t.textureCacheIds.includes(e) && t.textureCacheIds.push(e), o.TextureCache[e] && console.warn(`Texture added to the cache with an id [${e}] that already had an entry`), o.TextureCache[e] = t)
            }, e.removeFromCache = function (t) {
                if (typeof t == 'string') {
                    const e = o.TextureCache[t]
                    if (e) {
                        const n = e.textureCacheIds.indexOf(t)
                        return n > -1 && e.textureCacheIds.splice(n, 1), delete o.TextureCache[t], e
                    }
                } else if (t && t.textureCacheIds) {
                    for (let r = 0; r < t.textureCacheIds.length; ++r) o.TextureCache[t.textureCacheIds[r]] === t && delete o.TextureCache[t.textureCacheIds[r]]
                    return t.textureCacheIds.length = 0, t
                }
                return null
            }, Object.defineProperty(e.prototype, 'resolution', {
                get() {
                    return this.baseTexture.resolution
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'frame', {
                get() {
                    return this._frame
                },
                set(t) {
                    this._frame = t, this.noFrame = !1
                    let e = t.x
                    var n = t.y
                    var r = t.width
                    var i = t.height
                    var o = e + r > this.baseTexture.width
                    var a = n + i > this.baseTexture.height
                    if (o || a) {
                        const s = o && a ? 'and' : 'or';
                        var u = `X: ${  e  } + ${  r  } = ${  e + r  } > ${  this.baseTexture.width}`;
                        var c = `Y: ${ n } + ${ i } = ${ n + i } > ${ this.baseTexture.height}`
                        throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${ u } ${ s } ${ c}`)
                    }
                    this.valid = r && i && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t), this.valid && this.updateUvs()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'rotate', {
                get() {
                    return this._rotate
                },
                set(t) {
                    this._rotate = t, this.valid && this.updateUvs()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'width', {
                get() {
                    return this.orig.width
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'height', {
                get() {
                    return this.orig.height
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.castToBaseTexture = function () {
                return this.baseTexture
            }, e
        }(o.EventEmitter))

        function M(t) {
            t.destroy = function () {}, t.on = function () {}, t.once = function () {}, t.emit = function () {}
        }
        N.EMPTY = new N(new v()), M(N.EMPTY), M(N.EMPTY.baseTexture), N.WHITE = (function () {
            const t = document.createElement('canvas')
            t.width = 16, t.height = 16
            const e = t.getContext('2d')
            return e.fillStyle = 'white', e.fillRect(0, 0, 16, 16), new N(new v(new E(t)))
        }()), M(N.WHITE), M(N.WHITE.baseTexture)
        var j = (function (t) {
            function e(e, n) {
                const r = t.call(this, e, n) || this
                return r.valid = !0, r.filterFrame = null, r.filterPoolKey = null, r.updateUvs(), r
            }
            return f(e, t), Object.defineProperty(e.prototype, 'framebuffer', {
                get() {
                    return this.baseTexture.framebuffer
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'multisample', {
                get() {
                    return this.framebuffer.multisample
                },
                set(t) {
                    this.framebuffer.multisample = t
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.resize = function (t, e, n) {
                void 0 === n && (n = !0)
                const r = this.baseTexture.resolution
                let i = Math.round(t * r) / r
                let o = Math.round(e * r) / r
                this.valid = i > 0 && o > 0, this._frame.width = this.orig.width = i, this._frame.height = this.orig.height = o, n && this.baseTexture.resize(i, o), this.updateUvs()
            }, e.prototype.setResolution = function (t) {
                const e = this.baseTexture
                e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1))
            }, e.create = function (t) {
                for (var n = arguments, r = [], i = 1; i < arguments.length; i++) r[i - 1] = n[i]
                return typeof t == 'number' && (new Object(o.deprecation)('6.0.0', 'Arguments (width, height, scaleMode, resolution) have been deprecated.'), t = {
                    width: t,
                    height: r[0],
                    scaleMode: r[1],
                    resolution: r[2]
                }), new e(new I(t))
            }, e
        }(N))
        var D = (function () {
            function t(t) {
                this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
            }
            return t.prototype.createTexture = function (t, e, n) {
                void 0 === n && (n = i.l.NONE)
                let r = new I(Object.assign({
                    width: t,
                    height: e,
                    resolution: 1,
                    multisample: n
                }, this.textureOptions))
                return new j(r)
            }, t.prototype.getOptimalTexture = function (t, e, n, r) {
                let a
                void 0 === n && (n = 1), void 0 === r && (r = i.l.NONE), t = Math.ceil(t * n), e = Math.ceil(e * n), this.enableFullScreen && t === this._pixelsWidth && e === this._pixelsHeight ? a = r > 1 ? -r : -1 : (a = ((65535 & (t = new Object(o.nextPow2)(t))) << 16 | 65535 & (e = new Object(o.nextPow2)(e))) >>> 0, r > 1 && (a += 4294967296 * r)), this.texturePool[a] || (this.texturePool[a] = [])
                let s = this.texturePool[a].pop()
                return s || (s = this.createTexture(t, e, r)), s.filterPoolKey = a, s.setResolution(n), s
            }, t.prototype.getFilterTexture = function (t, e, n) {
                const r = this.getOptimalTexture(t.width, t.height, e || t.resolution, n || i.l.NONE)
                return r.filterFrame = t.filterFrame, r
            }, t.prototype.returnTexture = function (t) {
                const e = t.filterPoolKey
                t.filterFrame = null, this.texturePool[e].push(t)
            }, t.prototype.returnFilterTexture = function (t) {
                this.returnTexture(t)
            }, t.prototype.clear = function (t) {
                if (t = !1 !== t) {
                    for (const e in this.texturePool) {
                        let n = this.texturePool[e]
                        if (n) {
                            for (let r = 0; r < n.length; r++) n[r].destroy(!0)
                        }
                    }
                }
                this.texturePool = {}
            }, t.prototype.setScreenSize = function (t) {
                if (t.width !== this._pixelsWidth || t.height !== this._pixelsHeight) {
                    for (const e in this.enableFullScreen = t.width > 0 && t.height > 0, this.texturePool) {
                        if (Number(e) < 0) {
                            let n = this.texturePool[e]
                            if (n) {
                                for (let r = 0; r < n.length; r++) n[r].destroy(!0)
}
                            this.texturePool[e] = []
                        }
                    }
                    this._pixelsWidth = t.width, this._pixelsHeight = t.height
                }
            }, t.SCREEN_KEY = -1, t
        }())
        var L = (function () {
            function t(t, e, n, r, o, a, s) {
                void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = i.r.FLOAT), this.buffer = t, this.size = e, this.normalized = n, this.type = r, this.stride = o, this.start = a, this.instance = s
            }
            return t.prototype.destroy = function () {
                this.buffer = null
            }, t.from = function (e, n, r, i, o) {
                return new t(e, n, r, i, o)
            }, t
        }())
        let F = 0
        var B = (function () {
            function t(t, e, n) {
                void 0 === e && (e = !0), void 0 === n && (n = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = n, this.static = e, this.id = F++, this.disposeRunner = new a.a('disposeBuffer')
            }
            return t.prototype.update = function (t) {
                Array.isArray(t) && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++
            }, t.prototype.dispose = function () {
                this.disposeRunner.emit(this, !1)
            }, t.prototype.destroy = function () {
                this.dispose(), this.data = null
            }, Object.defineProperty(t.prototype, 'index', {
                get() {
                    return this.type === i.d.ELEMENT_ARRAY_BUFFER
                },
                set(t) {
                    this.type = t ? i.d.ELEMENT_ARRAY_BUFFER : i.d.ARRAY_BUFFER
                },
                enumerable: !1,
                configurable: !0
            }), t.from = function (e) {
                return Array.isArray(e) && (e = new Float32Array(e)), new t(e)
            }, t
        }())
        let U = {
            Float32Array,
            Uint32Array,
            Int32Array,
            Uint8Array
        }
        const G = {
            5126: 4,
            5123: 2,
            5121: 1
        }
        let X = 0
        const H = {
            Float32Array,
            Uint32Array,
            Int32Array,
            Uint8Array,
            Uint16Array
        }
        var V = (function () {
            function t(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = X++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new a.a('disposeGeometry'), this.refCount = 0
            }
            return t.prototype.addAttribute = function (t, e, n, r, i, o, a, s) {
                if (void 0 === n && (n = 0), void 0 === r && (r = !1), void 0 === s && (s = !1), !e) throw new Error('You must pass a buffer when creating an attribute')
                e instanceof B || (Array.isArray(e) && (e = new Float32Array(e)), e = new B(e))
                let u = t.split('|')
                if (u.length > 1) {
                    for (let c = 0; c < u.length; c++) this.addAttribute(u[c], e, n, r, i)
                    return this
                }
                let l = this.buffers.indexOf(e)
                return l === -1 && (this.buffers.push(e), l = this.buffers.length - 1), this.attributes[t] = new L(l, n, r, i, o, a, s), this.instanced = this.instanced || s, this
            }, t.prototype.getAttribute = function (t) {
                return this.attributes[t]
            }, t.prototype.getBuffer = function (t) {
                return this.buffers[this.getAttribute(t).buffer]
            }, t.prototype.addIndex = function (t) {
                return t instanceof B || (Array.isArray(t) && (t = new Uint16Array(t)), t = new B(t)), t.type = i.d.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, !this.buffers.includes(t) && this.buffers.push(t), this
            }, t.prototype.getIndex = function () {
                return this.indexBuffer
            }, t.prototype.interleave = function () {
                if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this
                let t; const e = []
                var n = []
                var r = new B()
                for (t in this.attributes) {
                    const i = this.attributes[t]
                    var a = this.buffers[i.buffer]
                    e.push(a.data), n.push(i.size * G[i.type] / 4), i.buffer = 0
                }
                for (r.data = (function (t, e) {
                    for (var n = 0, r = 0, i = {}, a = 0; a < t.length; a++) r += e[a], n += t[a].length
                    var s = new ArrayBuffer(4 * n)
                                    var u = null
                                    var c = 0
                    for (a = 0; a < t.length; a++) {
                        let l = e[a]
                                        var h = t[a]
                                        var f = new Object(o.getBufferType)(h)
                        i[f] || (i[f] = new U[f](s)), u = i[f]
                        for (let d = 0; d < h.length; d++) {
                            u[(d / l | 0) * r + c + d % l] = h[d]
                        }
                        c += l
                    }
                    return new Float32Array(s)
                }(e, n)), t = 0; t < this.buffers.length; t++) this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy()
                return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this
            }, t.prototype.getSize = function () {
                for (const t in this.attributes) {
                    const e = this.attributes[t]
                    return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
                }
                return 0
            }, t.prototype.dispose = function () {
                this.disposeRunner.emit(this, !1)
            }, t.prototype.destroy = function () {
                this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
            }, t.prototype.clone = function () {
                for (var e = new t(), n = 0; n < this.buffers.length; n++) e.buffers[n] = new B(this.buffers[n].data.slice(0))
                for (var n in this.attributes) {
                    const r = this.attributes[n]
                    e.attributes[n] = new L(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance)
                }
                return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.type = i.d.ELEMENT_ARRAY_BUFFER), e
            }, t.merge = function (e) {
                for (var n, r = new t(), a = [], s = [], u = [], c = 0; c < e.length; c++) {
                    n = e[c]
                    for (var l = 0; l < n.buffers.length; l++) s[l] = s[l] || 0, s[l] += n.buffers[l].data.length, u[l] = 0
                }
                for (c = 0; c < n.buffers.length; c++) a[c] = new (H[new Object(o.getBufferType)(n.buffers[c].data)])(s[c]), r.buffers[c] = new B(a[c])
                for (c = 0; c < e.length; c++) {
                    n = e[c]
                    for (l = 0; l < n.buffers.length; l++) a[l].set(n.buffers[l].data, u[l]), u[l] += n.buffers[l].data.length
                }
                if (r.attributes = n.attributes, n.indexBuffer) {
                    r.indexBuffer = r.buffers[n.buffers.indexOf(n.indexBuffer)], r.indexBuffer.type = i.d.ELEMENT_ARRAY_BUFFER
                    let h = 0
                    var f = 0
                    var d = 0
                    var p = 0
                    for (c = 0; c < n.buffers.length; c++) {
                        if (n.buffers[c] !== n.indexBuffer) {
                            p = c
                            break
                        }
                    }
                    for (var c in n.attributes) {
                        const m = n.attributes[c];
                        (0 | m.buffer) === p && (f += m.size * G[m.type] / 4)
                    }
                    for (c = 0; c < e.length; c++) {
                        const y = e[c].indexBuffer.data
                        for (l = 0; l < y.length; l++) r.indexBuffer.data[l + d] += h
                        h += e[c].buffers[p].data.length / f, d += y.length
                    }
                }
                return r
            }, t
        }())
        var W = (function (t) {
            function e() {
                const e = t.call(this) || this
                return e.addAttribute('aVertexPosition', new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e
            }
            return f(e, t), e
        }(V))
        var Y = (function (t) {
            function e() {
                const e = t.call(this) || this
                return e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e.vertexBuffer = new B(e.vertices), e.uvBuffer = new B(e.uvs), e.addAttribute('aVertexPosition', e.vertexBuffer).addAttribute('aTextureCoord', e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e
            }
            return f(e, t), e.prototype.map = function (t, e) {
                let n = 0
                var r = 0
                return this.uvs[0] = n, this.uvs[1] = r, this.uvs[2] = n + e.width / t.width, this.uvs[3] = r, this.uvs[4] = n + e.width / t.width, this.uvs[5] = r + e.height / t.height, this.uvs[6] = n, this.uvs[7] = r + e.height / t.height, n = e.x, r = e.y, this.vertices[0] = n, this.vertices[1] = r, this.vertices[2] = n + e.width, this.vertices[3] = r, this.vertices[4] = n + e.width, this.vertices[5] = r + e.height, this.vertices[6] = n, this.vertices[7] = r + e.height, this.invalidate(), this
            }, e.prototype.invalidate = function () {
                return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
            }, e
        }(V))
        let z = 0
        var q = (function () {
            function t(t, e, n) {
                this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = z++, this.static = !!e, this.ubo = !!n, t instanceof B ? (this.buffer = t, this.buffer.type = i.d.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new B(new Float32Array(1)), this.buffer.type = i.d.UNIFORM_BUFFER, this.autoManage = !0))
            }
            return t.prototype.update = function () {
                this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update()
            }, t.prototype.add = function (e, n, r) {
                if (this.ubo) throw new Error('[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them')
                this.uniforms[e] = new t(n, r)
            }, t.from = function (e, n, r) {
                return new t(e, n, r)
            }, t.uboFrom = function (e, n) {
                return new t(e, n == null || n, !0)
            }, t
        }())
        var K = (function () {
            function t() {
                this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = i.l.NONE, this.sourceFrame = new u.j(), this.destinationFrame = new u.j(), this.bindingSourceFrame = new u.j(), this.bindingDestinationFrame = new u.j(), this.filters = [], this.transform = null
            }
            return t.prototype.clear = function () {
                this.target = null, this.filters = null, this.renderTexture = null
            }, t
        }())
        const Z = [new u.g(), new u.g(), new u.g(), new u.g()]
        const $ = new u.d()
        var J = (function () {
            function t(t) {
                this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new D(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new W(), this.quadUv = new Y(), this.tempRect = new u.j(), this.activeState = {}, this.globalUniforms = new q({
                    outputFrame: new u.j(),
                    inputSize: new Float32Array(4),
                    inputPixel: new Float32Array(4),
                    inputClamp: new Float32Array(4),
                    resolution: 1,
                    filterArea: new Float32Array(4),
                    filterClamp: new Float32Array(4)
                }, !0), this.forceClear = !1, this.useMaxPadding = !1
            }
            return t.prototype.push = function (t, e) {
                for (var n = this.renderer, r = this.defaultFilterStack, i = this.statePool.pop() || new K(), o = this.renderer.renderTexture, a = e[0].resolution, s = e[0].multisample, u = e[0].padding, c = e[0].autoFit, l = e[0].legacy, h = 1; h < e.length; h++) {
                    const f = e[h]
                    a = Math.min(a, f.resolution), s = Math.min(s, f.multisample), u = this.useMaxPadding ? Math.max(u, f.padding) : u + f.padding, c = c && f.autoFit, l = l || f.legacy
                }
                if (r.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current), r.push(i), i.resolution = a, i.multisample = s, i.legacy = l, i.target = t, i.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), i.sourceFrame.pad(u), c) {
                    const d = this.tempRect.copyFrom(o.sourceFrame)
                    n.projection.transform && this.transformAABB($.copyFrom(n.projection.transform).invert(), d), i.sourceFrame.fit(d)
                }
                this.roundFrame(i.sourceFrame, o.current ? o.current.resolution : n.resolution, o.sourceFrame, o.destinationFrame, n.projection.transform), i.renderTexture = this.getOptimalFilterTexture(i.sourceFrame.width, i.sourceFrame.height, a, s), i.filters = e, i.destinationFrame.width = i.renderTexture.width, i.destinationFrame.height = i.renderTexture.height
                let p = this.tempRect
                p.x = 0, p.y = 0, p.width = i.sourceFrame.width, p.height = i.sourceFrame.height, i.renderTexture.filterFrame = i.sourceFrame, i.bindingSourceFrame.copyFrom(o.sourceFrame), i.bindingDestinationFrame.copyFrom(o.destinationFrame), i.transform = n.projection.transform, n.projection.transform = null, o.bind(i.renderTexture, i.sourceFrame, p), n.framebuffer.clear(0, 0, 0, 0)
            }, t.prototype.pop = function () {
                const t = this.defaultFilterStack
                var e = t.pop()
                var n = e.filters
                this.activeState = e
                let r = this.globalUniforms.uniforms
                r.outputFrame = e.sourceFrame, r.resolution = e.resolution
                let o = r.inputSize
                var a = r.inputPixel
                var s = r.inputClamp
                if (o[0] = e.destinationFrame.width, o[1] = e.destinationFrame.height, o[2] = 1 / o[0], o[3] = 1 / o[1], a[0] = Math.round(o[0] * e.resolution), a[1] = Math.round(o[1] * e.resolution), a[2] = 1 / a[0], a[3] = 1 / a[1], s[0] = 0.5 * a[2], s[1] = 0.5 * a[3], s[2] = e.sourceFrame.width * o[2] - 0.5 * a[2], s[3] = e.sourceFrame.height * o[3] - 0.5 * a[3], e.legacy) {
                    const u = r.filterArea
                    u[0] = e.destinationFrame.width, u[1] = e.destinationFrame.height, u[2] = e.sourceFrame.x, u[3] = e.sourceFrame.y, r.filterClamp = r.inputClamp
                }
                this.globalUniforms.update()
                let c = t[t.length - 1]
                if (this.renderer.framebuffer.blit(), n.length === 1) { n[0].apply(this, e.renderTexture, c.renderTexture, i.e.BLEND, e), this.returnFilterTexture(e.renderTexture)
                }
                else {
                    let l = e.renderTexture
                    var h = this.getOptimalFilterTexture(l.width, l.height, e.resolution)
                    h.filterFrame = l.filterFrame
                    let f = 0
                    for (f = 0; f < n.length - 1; ++f) {
                        f === 1 && e.multisample > 1 && ((h = this.getOptimalFilterTexture(l.width, l.height, e.resolution)).filterFrame = l.filterFrame), n[f].apply(this, l, h, i.e.CLEAR, e)
                        let d = l
                        l = h, h = d
                    }
                    n[f].apply(this, l, c.renderTexture, i.e.BLEND, e), f > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(l), this.returnFilterTexture(h)
                }
                e.clear(), this.statePool.push(e)
            }, t.prototype.bindAndClear = function (t, e) {
                void 0 === e && (e = i.e.CLEAR)
                let n = this.renderer
                var r = n.renderTexture
                var o = n.state
                if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
                    const a = this.tempRect
                    a.x = 0, a.y = 0, a.width = t.filterFrame.width, a.height = t.filterFrame.height, r.bind(t, t.filterFrame, a)
                } else { t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? r.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame)
                }
                const s = 1 & o.stateId || this.forceClear;
                (e === i.e.CLEAR || e === i.e.BLIT && s) && this.renderer.framebuffer.clear(0, 0, 0, 0)
            }, t.prototype.applyFilter = function (t, e, n, r) {
                const o = this.renderer
                o.state.set(t.state), this.bindAndClear(n, r), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, o.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), o.geometry.bind(this.quadUv), o.geometry.draw(i.f.TRIANGLES)) : (o.geometry.bind(this.quad), o.geometry.draw(i.f.TRIANGLE_STRIP))
            }, t.prototype.calculateSpriteMatrix = function (t, e) {
                const n = this.activeState
                var r = n.sourceFrame
                var i = n.destinationFrame
                var o = e._texture.orig
                var a = t.set(i.width, 0, 0, i.height, r.x, r.y)
                var s = e.worldTransform.copyTo(u.d.TEMP_MATRIX)
                return s.invert(), a.prepend(s), a.scale(1 / o.width, 1 / o.height), a.translate(e.anchor.x, e.anchor.y), a
            }, t.prototype.destroy = function () {
                this.renderer = null, this.texturePool.clear(!1)
            }, t.prototype.getOptimalFilterTexture = function (t, e, n, r) {
                return void 0 === n && (n = 1), void 0 === r && (r = i.l.NONE), this.texturePool.getOptimalTexture(t, e, n, r)
            }, t.prototype.getFilterTexture = function (t, e, n) {
                if (typeof t == 'number') {
                    const r = t
                    t = e, e = r
                }
                t = t || this.activeState.renderTexture
                let o = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, n || i.l.NONE)
                return o.filterFrame = t.filterFrame, o
            }, t.prototype.returnFilterTexture = function (t) {
                this.texturePool.returnTexture(t)
            }, t.prototype.emptyPool = function () {
                this.texturePool.clear(!0)
            }, t.prototype.resize = function () {
                this.texturePool.setScreenSize(this.renderer.view)
            }, t.prototype.transformAABB = function (t, e) {
                const n = Z[0]
                var r = Z[1]
                var i = Z[2]
                var o = Z[3]
                n.set(e.left, e.top), r.set(e.left, e.bottom), i.set(e.right, e.top), o.set(e.right, e.bottom), t.apply(n, n), t.apply(r, r), t.apply(i, i), t.apply(o, o)
                let a = Math.min(n.x, r.x, i.x, o.x)
                var s = Math.min(n.y, r.y, i.y, o.y)
                var u = Math.max(n.x, r.x, i.x, o.x)
                var c = Math.max(n.y, r.y, i.y, o.y)
                e.x = a, e.y = s, e.width = u - a, e.height = c - s
            }, t.prototype.roundFrame = function (t, e, n, r, i) {
                if (i) {
                    const o = i.a
                    var a = i.b
                    var s = i.c
                    var u = i.d
                    if ((Math.abs(a) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(u) > 1e-4)) return
                }(i = i ? $.copyFrom(i) : $.identity()).translate(-n.x, -n.y).scale(r.width / n.width, r.height / n.height).translate(r.x, r.y), this.transformAABB(i, t), t.ceil(e), this.transformAABB(i.invert(), t)
            }, t
        }())
        var Q = (function () {
            function t(t) {
                this.renderer = t
            }
            return t.prototype.flush = function () {}, t.prototype.destroy = function () {
                this.renderer = null
            }, t.prototype.start = function () {}, t.prototype.stop = function () {
                this.flush()
            }, t.prototype.render = function (t) {}, t
        }())
        var tt = (function () {
            function t(t) {
                this.renderer = t, this.emptyRenderer = new Q(t), this.currentRenderer = this.emptyRenderer
            }
            return t.prototype.setObjectRenderer = function (t) {
                this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
            }, t.prototype.flush = function () {
                this.setObjectRenderer(this.emptyRenderer)
            }, t.prototype.reset = function () {
                this.setObjectRenderer(this.emptyRenderer)
            }, t.prototype.copyBoundTextures = function (t, e) {
                for (let n = this.renderer.texture.boundTextures, r = e - 1; r >= 0; --r) t[r] = n[r] || null, t[r] && (t[r]._batchLocation = r)
            }, t.prototype.boundArray = function (t, e, n, r) {
                for (let i = t.elements, o = t.ids, a = t.count, s = 0, u = 0; u < a; u++) {
                    const c = i[u]
                    var l = c._batchLocation
                    if (l >= 0 && l < r && e[l] === c) { o[u] = l
                    }
                    else {
                        for (; s < r;) {
                            let h = e[s]
                            if (!h || h._batchEnabled !== n || h._batchLocation !== s) {
                                o[u] = s, c._batchLocation = s, e[s] = c
                                break
                            }
                            s++
                        }
                    }
                }
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        let et = 0
        var nt = (function () {
            function t(t) {
                this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
                    uint32Indices: !1
                }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener('webglcontextlost', this.handleContextLost, !1), t.view.addEventListener('webglcontextrestored', this.handleContextRestored, !1)
            }
            return Object.defineProperty(t.prototype, 'isLost', {
                get() {
                    return !this.gl || this.gl.isContextLost()
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.contextChange = function (t) {
                this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = et++, t.isContextLost() && t.getExtension('WEBGL_lose_context') && t.getExtension('WEBGL_lose_context').restoreContext()
            }, t.prototype.initFromContext = function (t) {
                this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = et++, this.renderer.runners.contextChange.emit(t)
            }, t.prototype.initFromOptions = function (t) {
                const e = this.createContext(this.renderer.view, t)
                this.initFromContext(e)
            }, t.prototype.createContext = function (t, e) {
                let n
                if (r.b.PREFER_ENV >= i.g.WEBGL2 && (n = t.getContext('webgl2', e)), n) this.webGLVersion = 2
                else if (this.webGLVersion = 1, !(n = t.getContext('webgl', e) || t.getContext('experimental-webgl', e))) throw new Error('This browser does not support WebGL. Try using the canvas renderer')
                return this.gl = n, this.getExtensions(), this.gl
            }, t.prototype.getExtensions = function () {
                const t = this.gl
                var e = {
                    anisotropicFiltering: t.getExtension('EXT_texture_filter_anisotropic'),
                    floatTextureLinear: t.getExtension('OES_texture_float_linear'),
                    s3tc: t.getExtension('WEBGL_compressed_texture_s3tc'),
                    s3tc_sRGB: t.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
                    etc: t.getExtension('WEBGL_compressed_texture_etc'),
                    etc1: t.getExtension('WEBGL_compressed_texture_etc1'),
                    pvrtc: t.getExtension('WEBGL_compressed_texture_pvrtc') || t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
                    atc: t.getExtension('WEBGL_compressed_texture_atc'),
                    astc: t.getExtension('WEBGL_compressed_texture_astc')
                }
                this.webGLVersion === 1
                    ? Object.assign(this.extensions, e, {
                            drawBuffers: t.getExtension('WEBGL_draw_buffers'),
                            depthTexture: t.getExtension('WEBGL_depth_texture'),
                            loseContext: t.getExtension('WEBGL_lose_context'),
                            vertexArrayObject: t.getExtension('OES_vertex_array_object') || t.getExtension('MOZ_OES_vertex_array_object') || t.getExtension('WEBKIT_OES_vertex_array_object'),
                            uint32ElementIndex: t.getExtension('OES_element_index_uint'),
                            floatTexture: t.getExtension('OES_texture_float'),
                            floatTextureLinear: t.getExtension('OES_texture_float_linear'),
                            textureHalfFloat: t.getExtension('OES_texture_half_float'),
                            textureHalfFloatLinear: t.getExtension('OES_texture_half_float_linear')
                        })
                    : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
                        colorBufferFloat: t.getExtension('EXT_color_buffer_float')
                    })
            }, t.prototype.handleContextLost = function (t) {
                t.preventDefault()
            }, t.prototype.handleContextRestored = function () {
                this.renderer.runners.contextChange.emit(this.gl)
            }, t.prototype.destroy = function () {
                const t = this.renderer.view
                this.renderer = null, t.removeEventListener('webglcontextlost', this.handleContextLost), t.removeEventListener('webglcontextrestored', this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
            }, t.prototype.postrender = function () {
                this.renderer.renderingToScreen && this.gl.flush()
            }, t.prototype.validateContext = function (t) {
                const e = t.getContextAttributes()
                var n = 'WebGL2RenderingContext' in self && t instanceof self.WebGL2RenderingContext
                n && (this.webGLVersion = 2), e.stencil || console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly')
                let r = n || !!t.getExtension('OES_element_index_uint')
                this.supports.uint32Indices = r, r || console.warn('Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly')
            }, t
        }())
        var rt = function (t) {
            this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = i.l.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0
        }
        const it = new u.j()
        var ot = (function () {
            function t(t) {
                this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new A(10, 10), this.msaaSamples = null
            }
            return t.prototype.contextChange = function () {
                const t = this.gl = this.renderer.gl
                if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new u.j(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) {
                    let e = this.renderer.context.extensions.drawBuffers
                    var n = this.renderer.context.extensions.depthTexture
                    r.b.PREFER_ENV === i.g.WEBGL_LEGACY && (e = null, n = null), e
                        ? t.drawBuffers = function (t) {
                            return e.drawBuffersWEBGL(t)
                        }
                        : (this.hasMRT = !1, t.drawBuffers = function () {}), n || (this.writeDepthTexture = !1)
                } else { this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
                }
            }, t.prototype.bind = function (t, e, n) {
                void 0 === n && (n = 0)
                let r = this.gl
                if (t) {
                    const i = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t)
                    this.current !== t && (this.current = t, r.bindFramebuffer(r.FRAMEBUFFER, i.framebuffer)), i.mipLevel !== n && (t.dirtyId++, t.dirtyFormat++, i.mipLevel = n), i.dirtyId !== t.dirtyId && (i.dirtyId = t.dirtyId, i.dirtyFormat !== t.dirtyFormat ? (i.dirtyFormat = t.dirtyFormat, i.dirtySize = t.dirtySize, this.updateFramebuffer(t, n)) : i.dirtySize !== t.dirtySize && (i.dirtySize = t.dirtySize, this.resizeFramebuffer(t)))
                    for (let o = 0; o < t.colorTextures.length; o++) {
                        const a = t.colorTextures[o]
                        this.renderer.texture.unbind(a.parentTextureArray || a)
                    }
                    if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
                        var s = e.width >> n
                        var u = e.height >> n
                        var c = s / e.width
                        this.setViewport(e.x * c, e.y * c, s, u)
                    } else {
                        s = t.width >> n, u = t.height >> n
                        this.setViewport(0, 0, s, u)
                    }
                } else { this.current && (this.current = null, r.bindFramebuffer(r.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
                }
            }, t.prototype.setViewport = function (t, e, n, r) {
                const i = this.viewport
                t = Math.round(t), e = Math.round(e), n = Math.round(n), r = Math.round(r), i.width === n && i.height === r && i.x === t && i.y === e || (i.x = t, i.y = e, i.width = n, i.height = r, this.gl.viewport(t, e, n, r))
            }, Object.defineProperty(t.prototype, 'size', {
                get() {
                    return this.current
                        ? {
                                x: 0,
                                y: 0,
                                width: this.current.width,
                                height: this.current.height
                            }
                        : {
                                x: 0,
                                y: 0,
                                width: this.renderer.width,
                                height: this.renderer.height
                            }
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.clear = function (t, e, n, r, o) {
                void 0 === o && (o = i.c.COLOR | i.c.DEPTH)
                let a = this.gl
                a.clearColor(t, e, n, r), a.clear(o)
            }, t.prototype.initFramebuffer = function (t) {
                const e = this.gl
                var n = new rt(e.createFramebuffer())
                return n.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = n, this.managedFramebuffers.push(t), t.disposeRunner.add(this), n
            }, t.prototype.resizeFramebuffer = function (t) {
                const e = this.gl
                var n = t.glFramebuffers[this.CONTEXT_UID]
                n.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, n.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, n.multisample, e.RGBA8, t.width, t.height)), n.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, n.stencil), n.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, n.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height))
                let r = t.colorTextures
                var i = r.length
                e.drawBuffers || (i = Math.min(i, 1))
                for (let o = 0; o < i; o++) {
                    const a = r[o]
                    var s = a.parentTextureArray || a
                    this.renderer.texture.bind(s, 0)
                }
                t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
            }, t.prototype.updateFramebuffer = function (t, e) {
                const n = this.gl
                var r = t.glFramebuffers[this.CONTEXT_UID]
                var i = t.colorTextures
                var o = i.length
                n.drawBuffers || (o = Math.min(o, 1)), r.multisample > 1 && this.canMultisampleFramebuffer(t) ? (r.msaaBuffer = r.msaaBuffer || n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, r.msaaBuffer), n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, n.RGBA8, t.width, t.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, r.msaaBuffer)) : r.msaaBuffer && (n.deleteRenderbuffer(r.msaaBuffer), r.msaaBuffer = null, r.blitFramebuffer && (r.blitFramebuffer.dispose(), r.blitFramebuffer = null))
                for (var a = [], s = 0; s < o; s++) {
                    const u = i[s]
                    var c = u.parentTextureArray || u
                    this.renderer.texture.bind(c, 0), s === 0 && r.msaaBuffer || (n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + s, u.target, c._glTextures[this.CONTEXT_UID].texture, e), a.push(n.COLOR_ATTACHMENT0 + s))
                }
                if ((a.length > 1 && n.drawBuffers(a), t.depthTexture) && this.writeDepthTexture) {
                    const l = t.depthTexture
                    this.renderer.texture.bind(l, 0), n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, l._glTextures[this.CONTEXT_UID].texture, e)
                }!t.stencil && !t.depth || t.depthTexture && this.writeDepthTexture ? r.stencil && (n.deleteRenderbuffer(r.stencil), r.stencil = null) : (r.stencil = r.stencil || n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, r.stencil), r.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, n.DEPTH24_STENCIL8, t.width, t.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, t.width, t.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r.stencil))
            }, t.prototype.canMultisampleFramebuffer = function (t) {
                return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
            }, t.prototype.detectSamples = function (t) {
                const e = this.msaaSamples
                var n = i.l.NONE
                if (t <= 1 || e === null) return n
                for (let r = 0; r < e.length; r++) {
                    if (e[r] <= t) {
                        n = e[r]
                        break
                    }
                }
                return n === 1 && (n = i.l.NONE), n
            }, t.prototype.blit = function (t, e, n) {
                const r = this.current
                var i = this.renderer
                var o = this.gl
                var a = this.CONTEXT_UID
                if (i.context.webGLVersion === 2 && r) {
                    const s = r.glFramebuffers[a]
                    if (s) {
                        if (!t) {
                            if (!s.msaaBuffer) return
                            let u = r.colorTextures[0]
                            if (!u) return
                            s.blitFramebuffer || (s.blitFramebuffer = new A(r.width, r.height), s.blitFramebuffer.addColorTexture(0, u)), (t = s.blitFramebuffer).colorTextures[0] !== u && (t.colorTextures[0] = u, t.dirtyId++, t.dirtyFormat++), t.width === r.width && t.height === r.height || (t.width = r.width, t.height = r.height, t.dirtyId++, t.dirtySize++)
                        }
                        e || ((e = it).width = r.width, e.height = r.height), n || (n = e)
                        let c = e.width === n.width && e.height === n.height
                        this.bind(t), o.bindFramebuffer(o.READ_FRAMEBUFFER, s.framebuffer), o.blitFramebuffer(e.x, e.y, e.width, e.height, n.x, n.y, n.width, n.height, o.COLOR_BUFFER_BIT, c ? o.NEAREST : o.LINEAR)
                    }
                }
            }, t.prototype.disposeFramebuffer = function (t, e) {
                const n = t.glFramebuffers[this.CONTEXT_UID]
                var r = this.gl
                if (n) {
                    delete t.glFramebuffers[this.CONTEXT_UID]
                    let i = this.managedFramebuffers.indexOf(t)
                    i >= 0 && this.managedFramebuffers.splice(i, 1), t.disposeRunner.remove(this), e || (r.deleteFramebuffer(n.framebuffer), n.msaaBuffer && r.deleteRenderbuffer(n.msaaBuffer), n.stencil && r.deleteRenderbuffer(n.stencil)), n.blitFramebuffer && n.blitFramebuffer.dispose()
                }
            }, t.prototype.disposeAll = function (t) {
                const e = this.managedFramebuffers
                this.managedFramebuffers = []
                for (let n = 0; n < e.length; n++) this.disposeFramebuffer(e[n], t)
            }, t.prototype.forceStencil = function () {
                const t = this.current
                if (t) {
                    const e = t.glFramebuffers[this.CONTEXT_UID]
                    if (e && !e.stencil) {
                        t.stencil = !0
                        let n = t.width
                        var r = t.height
                        var i = this.gl
                        var o = i.createRenderbuffer()
                        i.bindRenderbuffer(i.RENDERBUFFER, o), e.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, e.multisample, i.DEPTH24_STENCIL8, n, r) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, n, r), e.stencil = o, i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, o)
                    }
                }
            }, t.prototype.reset = function () {
                this.current = this.unknownFramebuffer, this.viewport = new u.j()
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        const at = {
            5126: 4,
            5123: 2,
            5121: 1
        }
        var st = (function () {
            function t(t) {
                this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {}
            }
            return t.prototype.contextChange = function () {
                this.disposeAll(!0)
                let t = this.gl = this.renderer.gl
                var e = this.renderer.context
                if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
                    let n = this.renderer.context.extensions.vertexArrayObject
                    r.b.PREFER_ENV === i.g.WEBGL_LEGACY && (n = null), n
                        ? (t.createVertexArray = function () {
                                return n.createVertexArrayOES()
                            }, t.bindVertexArray = function (t) {
                                return n.bindVertexArrayOES(t)
                            }, t.deleteVertexArray = function (t) {
                                return n.deleteVertexArrayOES(t)
                            })
                        : (this.hasVao = !1, t.createVertexArray = function () {
                                return null
                            }, t.bindVertexArray = function () {
                                return null
                            }, t.deleteVertexArray = function () {
                                return null
                            })
                }
                if (e.webGLVersion !== 2) {
                    const o = t.getExtension('ANGLE_instanced_arrays')
                    o
                        ? (t.vertexAttribDivisor = function (t, e) {
                                return o.vertexAttribDivisorANGLE(t, e)
                            }, t.drawElementsInstanced = function (t, e, n, r, i) {
                                return o.drawElementsInstancedANGLE(t, e, n, r, i)
                            }, t.drawArraysInstanced = function (t, e, n, r) {
                                return o.drawArraysInstancedANGLE(t, e, n, r)
                            })
                        : this.hasInstance = !1
                }
                this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex
            }, t.prototype.bind = function (t, e) {
                e = e || this.renderer.shader.shader
                let n = this.gl
                var r = t.glVertexArrayObjects[this.CONTEXT_UID]
                var i = !1
                r || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}, i = !0)
                let o = r[e.program.id] || this.initGeometryVao(t, e, i)
                this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? n.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers()
            }, t.prototype.reset = function () {
                this.unbind()
            }, t.prototype.updateBuffers = function () {
                for (let t = this._activeGeometry, e = this.renderer.buffer, n = 0; n < t.buffers.length; n++) {
                    const r = t.buffers[n]
                    e.update(r)
                }
            }, t.prototype.checkCompatibility = function (t, e) {
                const n = t.attributes
                var r = e.attributeData
                for (const i in r) {
                    if (!n[i]) throw new Error(`shader and geometry incompatible, geometry missing the "${ i }" attribute`)
                }
            }, t.prototype.getSignature = function (t, e) {
                const n = t.attributes
                var r = e.attributeData
                var i = ['g', t.id]
                for (const o in n) r[o] && i.push(o)
                return i.join('-')
            }, t.prototype.initGeometryVao = function (t, e, n) {
                void 0 === n && (n = !0)
                let r = this.gl
                var i = this.CONTEXT_UID
                var o = this.renderer.buffer
                var a = e.program
                a.glPrograms[i] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, a)
                let s = this.getSignature(t, a)
                var u = t.glVertexArrayObjects[this.CONTEXT_UID]
                var c = u[s]
                if (c) return u[a.id] = c, c
                let l = t.buffers
                var h = t.attributes
                var f = {}
                var d = {}
                for (var p in l) f[p] = 0, d[p] = 0
                for (var p in h) !h[p].size && a.attributeData[p] ? h[p].size = a.attributeData[p].size : h[p].size || console.warn(`PIXI Geometry attribute '${ p }' size cannot be determined (likely the bound shader does not have the attribute)`), f[h[p].buffer] += h[p].size * at[h[p].type]
                for (var p in h) {
                    const m = h[p]
                    var y = m.size
                    void 0 === m.stride && (f[m.buffer] === y * at[m.type] ? m.stride = 0 : m.stride = f[m.buffer]), void 0 === m.start && (m.start = d[m.buffer], d[m.buffer] += y * at[m.type])
                }
                c = r.createVertexArray(), r.bindVertexArray(c)
                for (let v = 0; v < l.length; v++) {
                    const _ = l[v]
                    o.bind(_), n && _._glBuffers[i].refCount++
                }
                return this.activateVao(t, a), this._activeVao = c, u[a.id] = c, u[s] = c, c
            }, t.prototype.disposeGeometry = function (t, e) {
                let n
                if (this.managedGeometries[t.id]) {
                    delete this.managedGeometries[t.id]
                    let r = t.glVertexArrayObjects[this.CONTEXT_UID]
                    var i = this.gl
                    var o = t.buffers
                    var a = (n = this.renderer) === null || void 0 === n ? void 0 : n.buffer
                    if (t.disposeRunner.remove(this), r) {
                        if (a) {
                            for (let s = 0; s < o.length; s++) {
                                let u = o[s]._glBuffers[this.CONTEXT_UID]
                                u && (u.refCount--, u.refCount !== 0 || e || a.dispose(o[s], e))
                            }
                        }
                        if (!e) {
                            for (const c in r) {
                                if ('g' === c[0]) {
                                    var l = r[c]
                                            this._activeVao === l && this.unbind(), i.deleteVertexArray(l)
                                }
                            }
                        }
                        delete t.glVertexArrayObjects[this.CONTEXT_UID]
                    }
                }
            }, t.prototype.disposeAll = function (t) {
                for (let e = Object.keys(this.managedGeometries), n = 0; n < e.length; n++) this.disposeGeometry(this.managedGeometries[e[n]], t)
            }, t.prototype.activateVao = function (t, e) {
                const n = this.gl
                var r = this.CONTEXT_UID
                var i = this.renderer.buffer
                var o = t.buffers
                var a = t.attributes
                t.indexBuffer && i.bind(t.indexBuffer)
                let s = null
                for (const u in a) {
                    const c = a[u]
                    var l = o[c.buffer]
                    var h = l._glBuffers[r]
                    if (e.attributeData[u]) {
                        s !== h && (i.bind(l), s = h)
                        let f = e.attributeData[u].location
                        if (n.enableVertexAttribArray(f), n.vertexAttribPointer(f, c.size, c.type || n.FLOAT, c.normalized, c.stride, c.start), c.instance) {
                            if (!this.hasInstance) throw new Error('geometry error, GPU Instancing is not supported on this device')
                            n.vertexAttribDivisor(f, 1)
                        }
                    }
                }
            }, t.prototype.draw = function (t, e, n, r) {
                const i = this.gl
                var o = this._activeGeometry
                if (o.indexBuffer) {
                    const a = o.indexBuffer.data.BYTES_PER_ELEMENT
                    var s = a === 2 ? i.UNSIGNED_SHORT : i.UNSIGNED_INT
                    a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? i.drawElementsInstanced(t, e || o.indexBuffer.data.length, s, (n || 0) * a, r || 1) : i.drawElements(t, e || o.indexBuffer.data.length, s, (n || 0) * a) : console.warn('unsupported index buffer type: uint32')
                } else { o.instanced ? i.drawArraysInstanced(t, n, e || o.getSize(), r || 1) : i.drawArrays(t, n, e || o.getSize())
                }
                return this
            }, t.prototype.unbind = function () {
                this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        var ut = (function () {
            function t(t) {
                void 0 === t && (t = null), this.type = i.j.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = r.b.FILTER_MULTISAMPLE, this.enabled = !0, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._target = null
            }
            return Object.defineProperty(t.prototype, 'filter', {
                get() {
                    return this._filters ? this._filters[0] : null
                },
                set(t) {
                    t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.reset = function () {
                this.pooled && (this.maskObject = null, this.type = i.j.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null
            }, t.prototype.copyCountersOrReset = function (t) {
                t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
            }, t
        }())

        function ct(t, e, n) {
            const r = t.createShader(e)
            return t.shaderSource(r, n), t.compileShader(r), r
        }

        function lt(t, e) {
            const n = t.getShaderSource(e).split('\n').map((t, e) => {
                return `${e}: ${t}`
            })
            const r = t.getShaderInfoLog(e)
            const i = r.split('\n')
            const o = {}
            const a = i.map((t) => {
                return Number.parseFloat(t.replace(/^ERROR: 0:(\d+):.*$/, '$1'))
            }).filter((t) => {
                return !(!t || o[t]) && (o[t] = !0, !0)
            })
            const s = ['']
            a.forEach((t) => {
                n[t - 1] = `%c${n[t - 1]}%c`, s.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px')
            })
            const u = n.join('\n')
            s[0] = u, console.error(r), console.groupCollapsed('click to view full shader code'), console.warn.apply(console, s), console.groupEnd()
        }

        function ht(t) {
            for (var e = new Array(t), n = 0; n < e.length; n++) e[n] = !1
            return e
        }

        function ft(t, e) {
            switch (t) {
                case 'float':
                    return 0
                case 'vec2':
                    return new Float32Array(2 * e)
                case 'vec3':
                    return new Float32Array(3 * e)
                case 'vec4':
                    return new Float32Array(4 * e)
                case 'int':
                case 'uint':
                case 'sampler2D':
                case 'sampler2DArray':
                    return 0
                case 'ivec2':
                    return new Int32Array(2 * e)
                case 'ivec3':
                    return new Int32Array(3 * e)
                case 'ivec4':
                    return new Int32Array(4 * e)
                case 'uvec2':
                    return new Uint32Array(2 * e)
                case 'uvec3':
                    return new Uint32Array(3 * e)
                case 'uvec4':
                    return new Uint32Array(4 * e)
                case 'bool':
                    return !1
                case 'bvec2':
                    return ht(2 * e)
                case 'bvec3':
                    return ht(3 * e)
                case 'bvec4':
                    return ht(4 * e)
                case 'mat2':
                    return new Float32Array([1, 0, 0, 1])
                case 'mat3':
                    return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
                case 'mat4':
                    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
            }
            return null
        }
        let dt; const pt = {}
        let mt = pt

        function yt() {
            if (mt === pt || mt && mt.isContextLost()) {
                const t = document.createElement('canvas')
                let e = void 0
                r.b.PREFER_ENV >= i.g.WEBGL2 && (e = t.getContext('webgl2', {})), e || ((e = t.getContext('webgl', {}) || t.getContext('experimental-webgl', {})) ? e.getExtension('WEBGL_draw_buffers') : e = null), mt = e
            }
            return mt
        }

        function vt(t, e, n) {
            if (t.substring(0, 9) !== 'precision') {
                let r = e
                return e === i.m.HIGH && n !== i.m.HIGH && (r = i.m.MEDIUM), `precision ${r} float;\n${t}`
            }
            return n !== i.m.HIGH && t.substring(0, 15) === 'precision highp' ? t.replace('precision highp', 'precision mediump') : t
        }
        const _t = {
            float: 1,
            vec2: 2,
            vec3: 3,
            vec4: 4,
            int: 1,
            ivec2: 2,
            ivec3: 3,
            ivec4: 4,
            uint: 1,
            uvec2: 2,
            uvec3: 3,
            uvec4: 4,
            bool: 1,
            bvec2: 2,
            bvec3: 3,
            bvec4: 4,
            mat2: 4,
            mat3: 9,
            mat4: 16,
            sampler2D: 1
        }

        function gt(t) {
            return _t[t]
        }
        let bt = null
        const Et = {
            FLOAT: 'float',
            FLOAT_VEC2: 'vec2',
            FLOAT_VEC3: 'vec3',
            FLOAT_VEC4: 'vec4',
            INT: 'int',
            INT_VEC2: 'ivec2',
            INT_VEC3: 'ivec3',
            INT_VEC4: 'ivec4',
            UNSIGNED_INT: 'uint',
            UNSIGNED_INT_VEC2: 'uvec2',
            UNSIGNED_INT_VEC3: 'uvec3',
            UNSIGNED_INT_VEC4: 'uvec4',
            BOOL: 'bool',
            BOOL_VEC2: 'bvec2',
            BOOL_VEC3: 'bvec3',
            BOOL_VEC4: 'bvec4',
            FLOAT_MAT2: 'mat2',
            FLOAT_MAT3: 'mat3',
            FLOAT_MAT4: 'mat4',
            SAMPLER_2D: 'sampler2D',
            INT_SAMPLER_2D: 'sampler2D',
            UNSIGNED_INT_SAMPLER_2D: 'sampler2D',
            SAMPLER_CUBE: 'samplerCube',
            INT_SAMPLER_CUBE: 'samplerCube',
            UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',
            SAMPLER_2D_ARRAY: 'sampler2DArray',
            INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
            UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray'
        }

        function xt(t, e) {
            if (!bt) {
                const n = Object.keys(Et)
                bt = {}
                for (let r = 0; r < n.length; ++r) {
                    const i = n[r]
                    bt[t[i]] = Et[i]
                }
            }
            return bt[e]
        }
        var Tt = [{
            test(t) {
                return t.type === 'float' && t.size === 1
            },
            code(t) {
                return `\n            if(uv["${t}"] !== ud["${t}"].value)\n            {\n                ud["${t}"].value = uv["${t}"]\n                gl.uniform1f(ud["${t}"].location, uv["${t}"])\n            }\n            `
            }
        }, {
            test(t) {
                return (t.type === 'sampler2D' || t.type === 'samplerCube' || t.type === 'sampler2DArray') && t.size === 1 && !t.isArray
            },
            code(t) {
                return `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${t}"], t);\n\n            if(ud["${t}"].value !== t)\n            {\n                ud["${t}"].value = t;\n                gl.uniform1i(ud["${t}"].location, t);\n; // eslint-disable-line max-len\n            }`
            }
        }, {
            test(t, e) {
                return t.type === 'mat3' && t.size === 1 && void 0 !== e.a
            },
            code(t) {
                return `\n            gl.uniformMatrix3fv(ud["${t}"].location, false, uv["${t}"].toArray(true));\n            `
            },
            codeUbo(t) {
                return `\n                var ${t}_matrix = uv.${t}.toArray(true);\n\n                data[offset] = ${t}_matrix[0];\n                data[offset+1] = ${t}_matrix[1];\n                data[offset+2] = ${t}_matrix[2];\n        \n                data[offset + 4] = ${t}_matrix[3];\n                data[offset + 5] = ${t}_matrix[4];\n                data[offset + 6] = ${t}_matrix[5];\n        \n                data[offset + 8] = ${t}_matrix[6];\n                data[offset + 9] = ${t}_matrix[7];\n                data[offset + 10] = ${t}_matrix[8];\n            `
            }
        }, {
            test(t, e) {
                return t.type === 'vec2' && t.size === 1 && void 0 !== e.x
            },
            code(t) {
                return `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${t}"].location, v.x, v.y);\n                }`
            },
            codeUbo(t) {
                return `\n                v = uv.${t};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `
            }
        }, {
            test(t) {
                return t.type === 'vec2' && t.size === 1
            },
            code(t) {
                return `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${t}"].location, v[0], v[1]);\n                }\n            `
            }
        }, {
            test(t, e) {
                return t.type === 'vec4' && t.size === 1 && void 0 !== e.width
            },
            code(t) {
                return `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${t}"].location, v.x, v.y, v.width, v.height)\n                }`
            },
            codeUbo(t) {
                return `\n                    v = uv.${t};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `
            }
        }, {
            test(t) {
                return t.type === 'vec4' && t.size === 1
            },
            code(t) {
                return `\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${t}"].location, v[0], v[1], v[2], v[3])\n                }`
            }
        }]
        const St = {
            float: '\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }',
            vec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }',
            vec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }',
            vec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }',
            int: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }',
            ivec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
            ivec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
            ivec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
            uint: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }',
            uvec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }',
            uvec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }',
            uvec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }',
            bool: '\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }',
            bvec2: '\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
            bvec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
            bvec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
            mat2: 'gl.uniformMatrix2fv(location, false, v)',
            mat3: 'gl.uniformMatrix3fv(location, false, v)',
            mat4: 'gl.uniformMatrix4fv(location, false, v)',
            sampler2D: 'gl.uniform1i(location, v)',
            samplerCube: 'gl.uniform1i(location, v)',
            sampler2DArray: 'gl.uniform1i(location, v)'
        }
        const wt = {
            float: 'gl.uniform1fv(location, v)',
            vec2: 'gl.uniform2fv(location, v)',
            vec3: 'gl.uniform3fv(location, v)',
            vec4: 'gl.uniform4fv(location, v)',
            mat4: 'gl.uniformMatrix4fv(location, false, v)',
            mat3: 'gl.uniformMatrix3fv(location, false, v)',
            mat2: 'gl.uniformMatrix2fv(location, false, v)',
            int: 'gl.uniform1iv(location, v)',
            ivec2: 'gl.uniform2iv(location, v)',
            ivec3: 'gl.uniform3iv(location, v)',
            ivec4: 'gl.uniform4iv(location, v)',
            uint: 'gl.uniform1uiv(location, v)',
            uvec2: 'gl.uniform2uiv(location, v)',
            uvec3: 'gl.uniform3uiv(location, v)',
            uvec4: 'gl.uniform4uiv(location, v)',
            bool: 'gl.uniform1iv(location, v)',
            bvec2: 'gl.uniform2iv(location, v)',
            bvec3: 'gl.uniform3iv(location, v)',
            bvec4: 'gl.uniform4iv(location, v)',
            sampler2D: 'gl.uniform1iv(location, v)',
            samplerCube: 'gl.uniform1iv(location, v)',
            sampler2DArray: 'gl.uniform1iv(location, v)'
        }
        let Ot; const Pt = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join('\n')

        function Rt(t) {
            for (var e = '', n = 0; n < t; ++n) n > 0 && (e += '\nelse '), n < t - 1 && (e += `if(test == ${n}.0){}`)
            return e
        }

        function At(t, e) {
            if (t === 0) throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`')
            for (let n = e.createShader(e.FRAGMENT_SHADER); ;) {
                const r = Pt.replace(/%forloop%/gi, Rt(t))
                if (e.shaderSource(n, r), e.compileShader(n), e.getShaderParameter(n, e.COMPILE_STATUS)) break
                t = t / 2 | 0
            }
            return t
        }
        let It = 0
        const Ct = {}
        var kt = (function () {
            function t(e, n, o) {
                void 0 === o && (o = 'pixi-shader'), this.id = It++, this.vertexSrc = e || t.defaultVertexSrc, this.fragmentSrc = n || t.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== '#version' && (o = o.replace(/\s+/g, '-'), Ct[o] ? (Ct[o]++, o += `-${ Ct[o]}`) : Ct[o] = 1, this.vertexSrc = `#define SHADER_NAME ${ o }\n${ this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${ o }\n${ this.fragmentSrc}`, this.vertexSrc = vt(this.vertexSrc, r.b.PRECISION_VERTEX, i.m.HIGH), this.fragmentSrc = vt(this.fragmentSrc, r.b.PRECISION_FRAGMENT, (function () {
                    if (!dt) {
                        dt = i.m.MEDIUM
                        var t = yt()
                        if (t && t.getShaderPrecisionFormat) {
                            let e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                            dt = e.precision ? i.m.HIGH : i.m.MEDIUM
                        }
                    }
                    return dt
                }()))), this.glPrograms = {}, this.syncUniforms = null
            }
            return Object.defineProperty(t, 'defaultVertexSrc', {
                get() {
                    return 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n'
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t, 'defaultFragmentSrc', {
                get() {
                    return 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}'
                },
                enumerable: !1,
                configurable: !0
            }), t.from = function (e, n, r) {
                const i = e + n
                var a = o.ProgramCache[i]
                return a || (o.ProgramCache[i] = a = new t(e, n, r)), a
            }, t
        }())
        var Nt = (function () {
            function t(t, e) {
                this.uniformBindCount = 0, this.program = t, this.uniformGroup = e ? e instanceof q ? e : new q(e) : new q({})
            }
            return t.prototype.checkUniformExists = function (t, e) {
                if (e.uniforms[t]) return !0
                for (const n in e.uniforms) {
                    const r = e.uniforms[n]
                    if (r.group && this.checkUniformExists(t, r)) return !0
                }
                return !1
            }, t.prototype.destroy = function () {
                this.uniformGroup = null
            }, Object.defineProperty(t.prototype, 'uniforms', {
                get() {
                    return this.uniformGroup.uniforms
                },
                enumerable: !1,
                configurable: !0
            }), t.from = function (e, n, r) {
                return new t(kt.from(e, n), r)
            }, t
        }())
        var Mt = (function () {
            function t() {
                this.data = 0, this.blendMode = i.b.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
            }
            return Object.defineProperty(t.prototype, 'blend', {
                get() {
                    return !!(1 & this.data)
                },
                set(t) {
                    !!(1 & this.data) !== t && (this.data ^= 1)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'offsets', {
                get() {
                    return !!(2 & this.data)
                },
                set(t) {
                    !!(2 & this.data) !== t && (this.data ^= 2)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'culling', {
                get() {
                    return !!(4 & this.data)
                },
                set(t) {
                    !!(4 & this.data) !== t && (this.data ^= 4)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'depthTest', {
                get() {
                    return !!(8 & this.data)
                },
                set(t) {
                    !!(8 & this.data) !== t && (this.data ^= 8)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'depthMask', {
                get() {
                    return !!(32 & this.data)
                },
                set(t) {
                    !!(32 & this.data) !== t && (this.data ^= 32)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'clockwiseFrontFace', {
                get() {
                    return !!(16 & this.data)
                },
                set(t) {
                    !!(16 & this.data) !== t && (this.data ^= 16)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'blendMode', {
                get() {
                    return this._blendMode
                },
                set(t) {
                    this.blend = t !== i.b.NONE, this._blendMode = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'polygonOffset', {
                get() {
                    return this._polygonOffset
                },
                set(t) {
                    this.offsets = !!t, this._polygonOffset = t
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.toString = function () {
                return `[@pixi/core:State blendMode=${ this.blendMode } clockwiseFrontFace=${ this.clockwiseFrontFace } culling=${ this.culling } depthMask=${ this.depthMask } polygonOffset=${ this.polygonOffset }]`
            }, t.for2d = function () {
                const e = new t()
                return e.depthTest = !1, e.blend = !0, e
            }, t
        }())
        var jt = (function (t) {
            function e(n, i, o) {
                let a = this
                var s = kt.from(n || e.defaultVertexSrc, i || e.defaultFragmentSrc)
                return (a = t.call(this, s, o) || this).padding = 0, a.resolution = r.b.FILTER_RESOLUTION, a.multisample = r.b.FILTER_MULTISAMPLE, a.enabled = !0, a.autoFit = !0, a.state = new Mt(), a
            }
            return f(e, t), e.prototype.apply = function (t, e, n, r, i) {
                t.applyFilter(this, e, n, r)
            }, Object.defineProperty(e.prototype, 'blendMode', {
                get() {
                    return this.state.blendMode
                },
                set(t) {
                    this.state.blendMode = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'resolution', {
                get() {
                    return this._resolution
                },
                set(t) {
                    this._resolution = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e, 'defaultVertexSrc', {
                get() {
                    return 'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n'
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e, 'defaultFragmentSrc', {
                get() {
                    return 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n'
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(Nt))
        const Dt = new u.d()
        var Lt = (function () {
            function t(t, e) {
                this._texture = t, this.mapCoord = new u.d(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === e ? 0.5 : e, this.isSimple = !1
            }
            return Object.defineProperty(t.prototype, 'texture', {
                get() {
                    return this._texture
                },
                set(t) {
                    this._texture = t, this._textureID = -1
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.multiplyUvs = function (t, e) {
                void 0 === e && (e = t)
                for (let n = this.mapCoord, r = 0; r < t.length; r += 2) {
                    const i = t[r]
                    var o = t[r + 1]
                    e[r] = i * n.a + o * n.c + n.tx, e[r + 1] = i * n.b + o * n.d + n.ty
                }
                return e
            }, t.prototype.update = function (t) {
                const e = this._texture
                if (!e || !e.valid) return !1
                if (!t && this._textureID === e._updateID) return !1
                this._textureID = e._updateID, this._updateID++
                let n = e._uvs
                this.mapCoord.set(n.x1 - n.x0, n.y1 - n.y0, n.x3 - n.x0, n.y3 - n.y0, n.x0, n.y0)
                let r = e.orig
                var i = e.trim
                i && (Dt.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(Dt))
                let o = e.baseTexture
                var a = this.uClampFrame
                var s = this.clampMargin / o.resolution
                var u = this.clampOffset
                return a[0] = (e._frame.x + s + u) / o.width, a[1] = (e._frame.y + s + u) / o.height, a[2] = (e._frame.x + e._frame.width - s + u) / o.width, a[3] = (e._frame.y + e._frame.height - s + u) / o.height, this.uClampOffset[0] = u / o.realWidth, this.uClampOffset[1] = u / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && e.rotate === 0, !0
            }, t
        }())
        var Ft = (function (t) {
            function e(e, n, r) {
                let i = this
                var o = null
                return typeof e != 'string' && void 0 === n && void 0 === r && (o = e, e = void 0, n = void 0, r = void 0), (i = t.call(this, e || 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n', n || 'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n', r) || this).maskSprite = o, i.maskMatrix = new u.d(), i
            }
            return f(e, t), Object.defineProperty(e.prototype, 'maskSprite', {
                get() {
                    return this._maskSprite
                },
                set(t) {
                    this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1)
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.apply = function (t, e, n, r) {
                const i = this._maskSprite
                var o = i._texture
                o.valid && (o.uvMatrix || (o.uvMatrix = new Lt(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, i).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = i.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, e, n, r))
            }, e
        }(jt))
        var Bt = (function () {
            function t(t) {
                this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
            }
            return t.prototype.setMaskStack = function (t) {
                this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
            }, t.prototype.push = function (t, e) {
                let n = e
                if (!n.isMaskData) {
                    const r = this.maskDataPool.pop() || new ut()
                    r.pooled = !0, r.maskObject = e, n = r
                }
                const o = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null
                if (n.copyCountersOrReset(o), n.autoDetect && this.detect(n), n._target = t, n.type !== i.j.SPRITE && this.maskStack.push(n), n.enabled) { switch (n.type) {
                    case i.j.SCISSOR:
                        this.renderer.scissor.push(n)
                        break;
                    case i.j.STENCIL:
                        this.renderer.stencil.push(n)
                        break;
                    case i.j.SPRITE:
                        n.copyCountersOrReset(null), this.pushSpriteMask(n)
                }
                }
                n.type === i.j.SPRITE && this.maskStack.push(n)
            }, t.prototype.pop = function (t) {
                const e = this.maskStack.pop()
                if (e && e._target === t) {
                    if (e.enabled) { switch (e.type) {
                        case i.j.SCISSOR:
                            this.renderer.scissor.pop()
                            break;
                        case i.j.STENCIL:
                            this.renderer.stencil.pop(e.maskObject)
                            break;
                        case i.j.SPRITE:
                            this.popSpriteMask(e)
                    }
                    }
                    if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
                        const n = this.maskStack[this.maskStack.length - 1]
                        n.type === i.j.SPRITE && n._filters && (n._filters[0].maskSprite = n.maskObject)
                    }
                }
            }, t.prototype.detect = function (t) {
                t.maskObject.isSprite ? t.type = i.j.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = i.j.SCISSOR : t.type = i.j.STENCIL
            }, t.prototype.pushSpriteMask = function (t) {
                let e; let n; const r = t.maskObject
                var i = t._target
                var o = t._filters
                o || (o = this.alphaMaskPool[this.alphaMaskIndex]) || (o = this.alphaMaskPool[this.alphaMaskIndex] = [new Ft()])
                let a; let s; const u = this.renderer
                var c = u.renderTexture
                if (c.current) {
                    const l = c.current
                    a = t.resolution || l.resolution, s = (e = t.multisample) !== null && void 0 !== e ? e : l.multisample
                } else { a = t.resolution || u.resolution, s = (n = t.multisample) !== null && void 0 !== n ? n : u.multisample
                }
                o[0].resolution = a, o[0].multisample = s, o[0].maskSprite = r
                let h = i.filterArea
                i.filterArea = r.getBounds(!0), u.filter.push(i, o), i.filterArea = h, t._filters || this.alphaMaskIndex++
            }, t.prototype.popSpriteMask = function (t) {
                this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        const Ut = (function () {
            function t(t) {
                this.renderer = t, this.maskStack = [], this.glConst = 0
            }
            return t.prototype.getStackLength = function () {
                return this.maskStack.length
            }, t.prototype.setMaskStack = function (t) {
                let e = this.renderer.gl
                            var n = this.getStackLength()
                this.maskStack = t
                var r = this.getStackLength()
                r !== n && (r === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()))
            }, t.prototype._useCurrent = function () {}, t.prototype.destroy = function () {
                this.renderer = null, this.maskStack = null
            }, t
        }())
        const Gt = new u.d()
        var Xt = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.glConst = WebGLRenderingContext.SCISSOR_TEST, n
            }
            return f(e, t), e.prototype.getStackLength = function () {
                const t = this.maskStack[this.maskStack.length - 1]
                return t ? t._scissorCounter : 0
            }, e.prototype.calcScissorRect = function (t) {
                if (!t._scissorRectLocal) {
                    const e = t._scissorRect
                    var n = t.maskObject
                    var r = this.renderer
                    var i = r.renderTexture
                    n.renderable = !0
                    let o = n.getBounds()
                    this.roundFrameToPixels(o, i.current ? i.current.resolution : r.resolution, i.sourceFrame, i.destinationFrame, r.projection.transform), n.renderable = !1, e && o.fit(e), t._scissorRectLocal = o
                }
            }, e.isMatrixRotated = function (t) {
                if (!t) return !1
                let e = t.a
                var n = t.b
                var r = t.c
                var i = t.d
                return (Math.abs(n) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(i) > 1e-4)
            }, e.prototype.testScissor = function (t) {
                const n = t.maskObject
                if (!n.isFastRect || !n.isFastRect()) return !1
                if (e.isMatrixRotated(n.worldTransform)) return !1
                if (e.isMatrixRotated(this.renderer.projection.transform)) return !1
                this.calcScissorRect(t)
                let r = t._scissorRectLocal
                return r.width > 0 && r.height > 0
            }, e.prototype.roundFrameToPixels = function (t, n, r, i, o) {
                e.isMatrixRotated(o) || ((o = o ? Gt.copyFrom(o) : Gt.identity()).translate(-r.x, -r.y).scale(i.width / r.width, i.height / r.height).translate(i.x, i.y), this.renderer.filter.transformAABB(o, t), t.fit(i), t.x = Math.round(t.x * n), t.y = Math.round(t.y * n), t.width = Math.round(t.width * n), t.height = Math.round(t.height * n))
            }, e.prototype.push = function (t) {
                t._scissorRectLocal || this.calcScissorRect(t)
                let e = this.renderer.gl
                t._scissorRect || e.enable(e.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = t._scissorRectLocal, this._useCurrent()
            }, e.prototype.pop = function () {
                const t = this.renderer.gl
                this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
            }, e.prototype._useCurrent = function () {
                let t; const e = this.maskStack[this.maskStack.length - 1]._scissorRect
                t = this.renderer.renderTexture.current ? e.y : this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, t, e.width, e.height)
            }, e
        }(Ut))
        var Ht = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.glConst = WebGLRenderingContext.STENCIL_TEST, n
            }
            return f(e, t), e.prototype.getStackLength = function () {
                const t = this.maskStack[this.maskStack.length - 1]
                return t ? t._stencilCounter : 0
            }, e.prototype.push = function (t) {
                const e = t.maskObject
                var n = this.renderer.gl
                var r = t._stencilCounter
                r === 0 && (this.renderer.framebuffer.forceStencil(), n.enable(n.STENCIL_TEST)), t._stencilCounter++, n.colorMask(!1, !1, !1, !1), n.stencilFunc(n.EQUAL, r, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, this._useCurrent()
            }, e.prototype.pop = function (t) {
                const e = this.renderer.gl
                this.getStackLength() === 0 ? (e.disable(e.STENCIL_TEST), e.clearStencil(0), e.clear(e.STENCIL_BUFFER_BIT)) : (e.colorMask(!1, !1, !1, !1), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, this._useCurrent())
            }, e.prototype._useCurrent = function () {
                const t = this.renderer.gl
                t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
            }, e
        }(Ut))
        var Vt = (function () {
            function t(t) {
                this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new u.d(), this.transform = null
            }
            return t.prototype.update = function (t, e, n, r) {
                this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, n, r), this.transform && this.projectionMatrix.append(this.transform)
                let i = this.renderer
                i.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, i.globalUniforms.update(), i.shader.shader && i.shader.syncUniformGroup(i.shader.shader.uniforms.globals)
            }, t.prototype.calculateProjection = function (t, e, n, r) {
                const i = this.projectionMatrix
                var o = r ? -1 : 1
                i.identity(), i.a = 1 / e.width * 2, i.d = o * (1 / e.height * 2), i.tx = -1 - e.x * i.a, i.ty = -o - e.y * i.d
            }, t.prototype.setTransform = function (t) {}, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        const Wt = new u.j()
        const Yt = new u.j()
        var zt = (function () {
            function t(t) {
                this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new u.j(), this.destinationFrame = new u.j(), this.viewportFrame = new u.j()
            }
            return t.prototype.bind = function (t, e, n) {
                void 0 === t && (t = null)
                let r; let i; let o; const a = this.renderer
                this.current = t, t ? (o = (r = t.baseTexture).resolution, e || (Wt.width = t.frame.width, Wt.height = t.frame.height, e = Wt), n || (Yt.x = t.frame.x, Yt.y = t.frame.y, Yt.width = e.width, Yt.height = e.height, n = Yt), i = r.framebuffer) : (o = a.resolution, e || (Wt.width = a.screen.width, Wt.height = a.screen.height, e = Wt), n || ((n = Wt).width = e.width, n.height = e.height))
                const s = this.viewportFrame
                s.x = n.x * o, s.y = n.y * o, s.width = n.width * o, s.height = n.height * o, t || (s.y = a.view.height - (s.y + s.height)), s.ceil(), this.renderer.framebuffer.bind(i, s), this.renderer.projection.update(n, e, o, !i), t ? this.renderer.mask.setMaskStack(r.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(n)
            }, t.prototype.clear = function (t, e) {
                t = this.current ? t || this.current.baseTexture.clearColor : t || this.clearColor
                const n = this.destinationFrame
                let r = this.current ? this.current.baseTexture : this.renderer.screen
                let i = n.width !== r.width || n.height !== r.height
                if (i) {
                    const o = this.viewportFrame
                    let a = o.x
                    let s = o.y
                    let u = o.width
                    let c = o.height
                    a = Math.round(a), s = Math.round(s), u = Math.round(u), c = Math.round(c), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(a, s, u, c)
                }
                this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), i && this.renderer.scissor.pop()
            }, t.prototype.resize = function () {
                this.bind(null)
            }, t.prototype.reset = function () {
                this.bind(null)
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())

        function qt(t, e, n, r, i) {
            n.buffer.update(i)
        }
        const Kt = {
            float: '\n        data[offset] = v;\n    ',
            vec2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ',
            vec3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ',
            vec4: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ',
            mat2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ',
            mat3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ',
            mat4: '\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    '
        }
        const Zt = {
            float: 4,
            vec2: 8,
            vec3: 12,
            vec4: 16,
            int: 4,
            ivec2: 8,
            ivec3: 12,
            ivec4: 16,
            uint: 4,
            uvec2: 8,
            uvec3: 12,
            uvec4: 16,
            bool: 4,
            bvec2: 8,
            bvec3: 12,
            bvec4: 16,
            mat2: 32,
            mat3: 48,
            mat4: 64
        }

        function $t(t) {
            for (var e = t.map((t) => {
                    return {
                        data: t,
                        offset: 0,
                        dataLen: 0,
                        dirty: 0
                    }
                }), n = 0, r = 0, i = 0, o = 0; o < e.length; o++) {
                const a = e[o]
                if (n = Zt[a.data.type], a.data.size > 1 && (n = Math.max(n, 16) * a.data.size), a.dataLen = n, r % n != 0 && r < 16) {
                    const s = r % n % 16
                    r += s, i += s
                }
                r + n > 16 ? (i = 16 * Math.ceil(i / 16), a.offset = i, i += n, r = n) : (a.offset = i, r += n, i += n)
            }
            return {
                uboElements: e,
                size: i = 16 * Math.ceil(i / 16)
            }
        }

        function Jt(t, e) {
            const n = []
            for (const r in t) e[r] && n.push(e[r])
            return n.sort((t, e) => {
                return t.index - e.index
            }), n
        }

        function Qt(t, e) {
            if (!t.autoManage) { return {
                size: 0,
                syncFunc: qt
            }
            }
            for (var n = $t(Jt(t.uniforms, e)), r = n.uboElements, i = n.size, o = ['\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    '], a = 0; a < r.length; a++) {
                for (var s = r[a], u = t.uniforms[s.data.name], c = s.data.name, l = !1, h = 0; h < Tt.length; h++) {
                    const f = Tt[h]
                    if (f.codeUbo && f.test(s.data, u)) {
                        o.push(`offset = ${s.offset / 4};`, Tt[h].codeUbo(s.data.name, u)), l = !0
                        break
                    }
                }
                if (!l) {
                    if (s.data.size > 1) {
                        const d = gt(s.data.type)
                        let p = Math.max(Zt[s.data.type] / 16, 1)
                        let m = d / p
                        let y = (4 - m % 4) % 4
                        o.push(`\n                cv = ud.${c}.value;\n                v = uv.${c};\n                offset = ${s.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${s.data.size * p}; i++)\n                {\n                    for(var j = 0; j < ${m}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${y};\n                }\n\n                `)
                    } else {
                        const v = Kt[s.data.type]
                        o.push(`\n                cv = ud.${c}.value;\n                v = uv.${c};\n                offset = ${s.offset / 4};\n                ${v};\n                `)
                    }
                }
            }
            return o.push('\n       renderer.buffer.update(buffer);\n    '), {
                size: i,
                syncFunc: new Function('ud', 'uv', 'renderer', 'syncData', 'buffer', o.join('\n'))
            }
        }
        var te = function () {}
        var ee = (function () {
            function t(t, e) {
                this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {}
            }
            return t.prototype.destroy = function () {
                this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null
            }, t
        }())

        function ne(t, e) {
            const n = ct(t, t.VERTEX_SHADER, e.vertexSrc)
            const r = ct(t, t.FRAGMENT_SHADER, e.fragmentSrc)
            const i = t.createProgram()
            if (t.attachShader(i, n), t.attachShader(i, r), t.linkProgram(i), t.getProgramParameter(i, t.LINK_STATUS) || (function (t, e, n, r) {
                t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || lt(t, n), t.getShaderParameter(r, t.COMPILE_STATUS) || lt(t, r), console.error('PixiJS Error: Could not initialize shader.'), t.getProgramInfoLog(e) !== '' && console.warn('PixiJS Warning: gl.getProgramInfoLog()', t.getProgramInfoLog(e)))
            }(t, i, n, r)), e.attributeData = (function (t, e) {
                for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
                    const o = e.getActiveAttrib(t, i)
                    if (o.name.indexOf('gl_') !== 0) {
                        const a = xt(e, o.type)
                        let s = {
                            type: a,
                            name: o.name,
                            size: gt(a),
                            location: e.getAttribLocation(t, o.name)
                        }
                        n[o.name] = s
                    }
                }
                return n
            }(i, t)), e.uniformData = (function (t, e) {
                for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), i = 0; i < r; i++) {
                    const o = e.getActiveUniform(t, i)
                    let a = o.name.replace(/\[.*?\]$/, '')
                    let s = !!o.name.match(/\[.*?\]$/)
                    let u = xt(e, o.type)
                    n[a] = {
                        name: a,
                        index: i,
                        type: u,
                        size: o.size,
                        isArray: s,
                        value: ft(u, o.size)
                    }
                }
                return n
            }(i, t)), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
                const o = Object.keys(e.attributeData)
                o.sort((t, e) => {
                    return t > e ? 1 : -1
                })
                for (var a = 0; a < o.length; a++) e.attributeData[o[a]].location = a, t.bindAttribLocation(i, a, o[a])
                t.linkProgram(i)
            }
            t.deleteShader(n), t.deleteShader(r)
            const s = {}
            for (var a in e.uniformData) {
                const u = e.uniformData[a]
                s[a] = {
                    location: t.getUniformLocation(i, a),
                    value: ft(u.type, u.size)
                }
            }
            return new ee(i, s)
        }
        let re = 0
        const ie = {
            textureCount: 0,
            uboCount: 0
        }
        var oe = (function () {
            function t(t) {
                this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = re++
            }
            return t.prototype.systemCheck = function () {
                if (!(function () {
                    if (typeof Ot == 'boolean') return Ot
                    try {
                        const t = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;')
                        Ot = !0 === t({
                            a: 'b'
                        }, 'a', 'b')
                    } catch (t) {
                        Ot = !1
                    }
                    return Ot
                }())) { throw new Error('Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.')
                }
            }, t.prototype.contextChange = function (t) {
                this.gl = t, this.reset()
            }, t.prototype.bind = function (t, e) {
                t.uniforms.globals = this.renderer.globalUniforms
                const n = t.program
                let r = n.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t)
                return this.shader = t, this.program !== n && (this.program = n, this.gl.useProgram(r.program)), e || (ie.textureCount = 0, ie.uboCount = 0, this.syncUniformGroup(t.uniformGroup, ie)), r
            }, t.prototype.setUniforms = function (t) {
                const e = this.shader.program
                let n = e.glPrograms[this.renderer.CONTEXT_UID]
                e.syncUniforms(n.uniformData, t, this.renderer)
            }, t.prototype.syncUniformGroup = function (t, e) {
                const n = this.getGlProgram()
                t.static && t.dirtyId === n.uniformDirtyGroups[t.id] || (n.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, n, e))
            }, t.prototype.syncUniforms = function (t, e, n) {
                (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, n)
            }, t.prototype.createSyncGroups = function (t) {
                const e = this.getSignature(t, this.shader.program.uniformData, 'u')
                return this.cache[e] || (this.cache[e] = (function (t, e) {
                    let n; const r = ['\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    ']
                    for (const i in t.uniforms) {
                        const o = e[i]
                        if (o) {
                            for (var a = t.uniforms[i], s = !1, u = 0; u < Tt.length; u++) {
                                if (Tt[u].test(o, a)) {
                                    r.push(Tt[u].code(i, a)), s = !0
                                    break
                                }
                            }
                            if (!s) {
                                const c = (o.size === 1 ? St : wt)[o.type].replace('location', `ud["${ i }"].location`)
                                r.push(`\n            cu = ud["${i}"];\n            cv = cu.value;\n            v = uv["${i}"];\n            ${c};`)
                            }
                        } else { ((n = t.uniforms[i]) === null || void 0 === n ? void 0 : n.group) && (t.uniforms[i].ubo ? r.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${  i  }, '${  i  }');\n                    `) : r.push(`\n                        renderer.shader.syncUniformGroup(uv.${  i  }, syncData);\n                    `))
                        }
                    }
                    return new Function('ud', 'uv', 'renderer', 'syncData', r.join('\n'))
                }(t, this.shader.program.uniformData))), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id]
            }, t.prototype.syncUniformBufferGroup = function (t, e) {
                const n = this.getGlProgram()
                if (!t.static || t.dirtyId !== 0 || !n.uniformGroups[t.id]) {
                    t.dirtyId = 0
                    const r = n.uniformGroups[t.id] || this.createSyncBufferGroup(t, n, e)
                    t.buffer.update(), r(n.uniformData, t.uniforms, this.renderer, ie, t.buffer)
                }
                this.renderer.buffer.bindBufferBase(t.buffer, n.uniformBufferBindings[e])
            }, t.prototype.createSyncBufferGroup = function (t, e, n) {
                const r = this.renderer.gl
                this.renderer.buffer.bind(t.buffer)
                const i = this.gl.getUniformBlockIndex(e.program, n)
                e.uniformBufferBindings[n] = this.shader.uniformBindCount, r.uniformBlockBinding(e.program, i, this.shader.uniformBindCount), this.shader.uniformBindCount++
                const o = this.getSignature(t, this.shader.program.uniformData, 'ubo')
                let a = this._uboCache[o]
                if (a || (a = this._uboCache[o] = Qt(t, this.shader.program.uniformData)), t.autoManage) {
                    const s = new Float32Array(a.size / 4)
                    t.buffer.update(s)
                }
                return e.uniformGroups[t.id] = a.syncFunc, e.uniformGroups[t.id]
            }, t.prototype.getSignature = function (t, e, n) {
                const r = t.uniforms
                let i = [`${n}-`]
                for (const o in r) i.push(o), e[o] && i.push(e[o].type)
                return i.join('-')
            }, t.prototype.getGlProgram = function () {
                return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
            }, t.prototype.generateProgram = function (t) {
                const e = this.gl
                let n = t.program
                let r = ne(e, n)
                return n.glPrograms[this.renderer.CONTEXT_UID] = r, r
            }, t.prototype.reset = function () {
                this.program = null, this.shader = null
            }, t.prototype.destroy = function () {
                this.renderer = null, this.destroyed = !0
            }, t
        }())
        var ae = (function () {
            function t() {
                this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = i.b.NONE, this._blendEq = !1, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new Mt(), this.defaultState.blend = !0
            }
            return t.prototype.contextChange = function (t) {
                this.gl = t, this.blendModes = (function (t, e) {
                    return void 0 === e && (e = []), e[i.b.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.ADD] = [t.ONE, t.ONE], e[i.b.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.NONE] = [0, 0], e[i.b.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e[i.b.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.b.SRC_IN] = [t.DST_ALPHA, t.ZERO], e[i.b.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO], e[i.b.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[i.b.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE], e[i.b.DST_IN] = [t.ZERO, t.SRC_ALPHA], e[i.b.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], e[i.b.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA], e[i.b.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[i.b.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD], e
                }(t)), this.set(this.defaultState), this.reset()
            }, t.prototype.set = function (t) {
                if (t = t || this.defaultState, this.stateId !== t.data) {
                    for (var e = this.stateId ^ t.data, n = 0; e;) 1 & e && this.map[n].call(this, !!(t.data & 1 << n)), e >>= 1, n++
                    this.stateId = t.data
                }
                for (n = 0; n < this.checks.length; n++) this.checks[n](this, t)
            }, t.prototype.forceState = function (t) {
                t = t || this.defaultState
                for (var e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e))
                for (e = 0; e < this.checks.length; e++) this.checks[e](this, t)
                this.stateId = t.data
            }, t.prototype.setBlend = function (e) {
                this.updateCheck(t.checkBlendMode, e), this.gl[e ? 'enable' : 'disable'](this.gl.BLEND)
            }, t.prototype.setOffset = function (e) {
                this.updateCheck(t.checkPolygonOffset, e), this.gl[e ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL)
            }, t.prototype.setDepthTest = function (t) {
                this.gl[t ? 'enable' : 'disable'](this.gl.DEPTH_TEST)
            }, t.prototype.setDepthMask = function (t) {
                this.gl.depthMask(t)
            }, t.prototype.setCullFace = function (t) {
                this.gl[t ? 'enable' : 'disable'](this.gl.CULL_FACE)
            }, t.prototype.setFrontFace = function (t) {
                this.gl.frontFace(this.gl[t ? 'CW' : 'CCW'])
            }, t.prototype.setBlendMode = function (t) {
                if (t !== this.blendMode) {
                    this.blendMode = t
                    const e = this.blendModes[t]
                    let n = this.gl
                    e.length === 2 ? n.blendFunc(e[0], e[1]) : n.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, n.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD))
                }
            }, t.prototype.setPolygonOffset = function (t, e) {
                this.gl.polygonOffset(t, e)
            }, t.prototype.reset = function () {
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
            }, t.prototype.updateCheck = function (t, e) {
                const n = this.checks.indexOf(t)
                e && n === -1 ? this.checks.push(t) : e || n === -1 || this.checks.splice(n, 1)
            }, t.checkBlendMode = function (t, e) {
                t.setBlendMode(e.blendMode)
            }, t.checkPolygonOffset = function (t, e) {
                t.setPolygonOffset(1, e.polygonOffset)
            }, t.prototype.destroy = function () {
                this.gl = null
            }, t
        }())
        var se = (function () {
            function t(t) {
                this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = r.b.GC_MAX_IDLE, this.checkCountMax = r.b.GC_MAX_CHECK_COUNT, this.mode = r.b.GC_MODE
            }
            return t.prototype.postrender = function () {
                this.renderer.renderingToScreen && (this.count++, this.mode !== i.i.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
            }, t.prototype.run = function () {
                for (var t = this.renderer.texture, e = t.managedTextures, n = !1, r = 0; r < e.length; r++) {
                    const i = e[r]
                    !i.framebuffer && this.count - i.touched > this.maxIdle && (t.destroyTexture(i, !0), e[r] = null, n = !0)
                }
                if (n) {
                    let o = 0
                    for (r = 0; r < e.length; r++) e[r] !== null && (e[o++] = e[r])
                    e.length = o
                }
            }, t.prototype.unload = function (t) {
                const e = this.renderer.texture
                let n = t._texture
                n && !n.framebuffer && e.destroyTexture(n)
                for (let r = t.children.length - 1; r >= 0; r--) this.unload(t.children[r])
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        var ue = function (t) {
            this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = i.r.UNSIGNED_BYTE, this.internalFormat = i.h.RGBA, this.samplerType = 0
        }
        var ce = (function () {
            function t(t) {
                this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new v(), this.hasIntegerTextures = !1
            }
            return t.prototype.contextChange = function () {
                const t = this.gl = this.renderer.gl
                this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = (function (t) {
                    let e, n, r, o, a, s, u, c, l, h, f, d, p, m, y, v, _, g, b, E, x, T, S
                    return 'WebGL2RenderingContext' in self && t instanceof self.WebGL2RenderingContext ? ((e = {})[i.r.UNSIGNED_BYTE] = ((n = {})[i.h.RGBA] = t.RGBA8, n[i.h.RGB] = t.RGB8, n[i.h.RG] = t.RG8, n[i.h.RED] = t.R8, n[i.h.RGBA_INTEGER] = t.RGBA8UI, n[i.h.RGB_INTEGER] = t.RGB8UI, n[i.h.RG_INTEGER] = t.RG8UI, n[i.h.RED_INTEGER] = t.R8UI, n[i.h.ALPHA] = t.ALPHA, n[i.h.LUMINANCE] = t.LUMINANCE, n[i.h.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA, n), e[i.r.BYTE] = ((r = {})[i.h.RGBA] = t.RGBA8_SNORM, r[i.h.RGB] = t.RGB8_SNORM, r[i.h.RG] = t.RG8_SNORM, r[i.h.RED] = t.R8_SNORM, r[i.h.RGBA_INTEGER] = t.RGBA8I, r[i.h.RGB_INTEGER] = t.RGB8I, r[i.h.RG_INTEGER] = t.RG8I, r[i.h.RED_INTEGER] = t.R8I, r), e[i.r.UNSIGNED_SHORT] = ((o = {})[i.h.RGBA_INTEGER] = t.RGBA16UI, o[i.h.RGB_INTEGER] = t.RGB16UI, o[i.h.RG_INTEGER] = t.RG16UI, o[i.h.RED_INTEGER] = t.R16UI, o[i.h.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16, o), e[i.r.SHORT] = ((a = {})[i.h.RGBA_INTEGER] = t.RGBA16I, a[i.h.RGB_INTEGER] = t.RGB16I, a[i.h.RG_INTEGER] = t.RG16I, a[i.h.RED_INTEGER] = t.R16I, a), e[i.r.UNSIGNED_INT] = ((s = {})[i.h.RGBA_INTEGER] = t.RGBA32UI, s[i.h.RGB_INTEGER] = t.RGB32UI, s[i.h.RG_INTEGER] = t.RG32UI, s[i.h.RED_INTEGER] = t.R32UI, s[i.h.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24, s), e[i.r.INT] = ((u = {})[i.h.RGBA_INTEGER] = t.RGBA32I, u[i.h.RGB_INTEGER] = t.RGB32I, u[i.h.RG_INTEGER] = t.RG32I, u[i.h.RED_INTEGER] = t.R32I, u), e[i.r.FLOAT] = ((c = {})[i.h.RGBA] = t.RGBA32F, c[i.h.RGB] = t.RGB32F, c[i.h.RG] = t.RG32F, c[i.h.RED] = t.R32F, c[i.h.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F, c), e[i.r.HALF_FLOAT] = ((l = {})[i.h.RGBA] = t.RGBA16F, l[i.h.RGB] = t.RGB16F, l[i.h.RG] = t.RG16F, l[i.h.RED] = t.R16F, l), e[i.r.UNSIGNED_SHORT_5_6_5] = ((h = {})[i.h.RGB] = t.RGB565, h), e[i.r.UNSIGNED_SHORT_4_4_4_4] = ((f = {})[i.h.RGBA] = t.RGBA4, f), e[i.r.UNSIGNED_SHORT_5_5_5_1] = ((d = {})[i.h.RGBA] = t.RGB5_A1, d), e[i.r.UNSIGNED_INT_2_10_10_10_REV] = ((p = {})[i.h.RGBA] = t.RGB10_A2, p[i.h.RGBA_INTEGER] = t.RGB10_A2UI, p), e[i.r.UNSIGNED_INT_10F_11F_11F_REV] = ((m = {})[i.h.RGB] = t.R11F_G11F_B10F, m), e[i.r.UNSIGNED_INT_5_9_9_9_REV] = ((y = {})[i.h.RGB] = t.RGB9_E5, y), e[i.r.UNSIGNED_INT_24_8] = ((v = {})[i.h.DEPTH_STENCIL] = t.DEPTH24_STENCIL8, v), e[i.r.FLOAT_32_UNSIGNED_INT_24_8_REV] = ((_ = {})[i.h.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8, _), S = e) : ((g = {})[i.r.UNSIGNED_BYTE] = ((b = {})[i.h.RGBA] = t.RGBA, b[i.h.RGB] = t.RGB, b[i.h.ALPHA] = t.ALPHA, b[i.h.LUMINANCE] = t.LUMINANCE, b[i.h.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA, b), g[i.r.UNSIGNED_SHORT_5_6_5] = ((E = {})[i.h.RGB] = t.RGB, E), g[i.r.UNSIGNED_SHORT_4_4_4_4] = ((x = {})[i.h.RGBA] = t.RGBA, x), g[i.r.UNSIGNED_SHORT_5_5_5_1] = ((T = {})[i.h.RGBA] = t.RGBA, T), S = g), S
                }(t))
                let e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
                this.boundTextures.length = e
                for (var n = 0; n < e; n++) this.boundTextures[n] = null
                this.emptyTextures = {}
                let r = new ue(t.createTexture())
                t.bindTexture(t.TEXTURE_2D, r.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = r, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new ue(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture)
                for (n = 0; n < 6; n++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null)
                t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR)
                for (n = 0; n < this.boundTextures.length; n++) this.bind(null, n)
            }, t.prototype.bind = function (t, e) {
                void 0 === e && (e = 0)
                let n = this.gl
                if ((t = t == null ? void 0 : t.castToBaseTexture()) && t.valid && !t.parentTextureArray) {
                    t.touched = this.renderer.textureGC.count
                    let r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t)
                    this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), n.bindTexture(t.target, r.texture)), r.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t
                } else { this.currentLocation !== e && (this.currentLocation = e, n.activeTexture(n.TEXTURE0 + e)), n.bindTexture(n.TEXTURE_2D, this.emptyTextures[n.TEXTURE_2D].texture), this.boundTextures[e] = null
                }
            }, t.prototype.reset = function () {
                this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1
                for (let t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
            }, t.prototype.unbind = function (t) {
                const e = this.gl
                var n = this.boundTextures
                if (this._unknownBoundTextures) {
                    this._unknownBoundTextures = !1
                    for (var r = 0; r < n.length; r++) n[r] === this.unknownTexture && this.bind(null, r)
                }
                for (r = 0; r < n.length; r++) n[r] === t && (this.currentLocation !== r && (e.activeTexture(e.TEXTURE0 + r), this.currentLocation = r), e.bindTexture(t.target, this.emptyTextures[t.target].texture), n[r] = null)
            }, t.prototype.ensureSamplerType = function (t) {
                const e = this.boundTextures
                var n = this.hasIntegerTextures
                var r = this.CONTEXT_UID
                if (n) {
                    for (let o = t - 1; o >= 0; --o) {
                        let a = e[o]
                        if (a) a._glTextures[r].samplerType !== i.o.FLOAT && this.renderer.texture.unbind(a)
                    }
                }
            }, t.prototype.initTexture = function (t) {
                const e = new ue(this.gl.createTexture())
                return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on('dispose', this.destroyTexture, this), e
            }, t.prototype.initTextureType = function (t, e) {
                let n, r
                e.internalFormat = (r = (n = this.internalFormats[t.type]) === null || void 0 === n ? void 0 : n[t.format]) !== null && void 0 !== r ? r : t.format, this.webGLVersion === 2 && t.type === i.r.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type
            }, t.prototype.updateTexture = function (t) {
                const e = t._glTextures[this.CONTEXT_UID]
                if (e) {
                    const n = this.renderer
                    if (this.initTextureType(t, e), t.resource && t.resource.upload(n, t, e)) { e.samplerType !== i.o.FLOAT && (this.hasIntegerTextures = !0)
                    }
                    else {
                        const r = t.realWidth
                        var o = t.realHeight
                        var a = n.gl;
                        (e.width !== r || e.height !== o || e.dirtyId < 0) && (e.width = r, e.height = o, a.texImage2D(t.target, 0, e.internalFormat, r, o, 0, t.format, e.type, null))
                    }
                    t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId
                }
            }, t.prototype.destroyTexture = function (t, e) {
                const n = this.gl
                if ((t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t), n.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off('dispose', this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
                    const r = this.managedTextures.indexOf(t); r !== -1 && new Object(o.removeItems)(this.managedTextures, r, 1)
                }
            }, t.prototype.updateTextureStyle = function (t) {
                const e = t._glTextures[this.CONTEXT_UID]
                e && (t.mipmap !== i.k.POW2 && this.webGLVersion === 2 || t.isPowerOfTwo ? e.mipmap = t.mipmap >= 1 : e.mipmap = !1, this.webGLVersion === 2 || t.isPowerOfTwo ? e.wrapMode = t.wrapMode : e.wrapMode = i.s.CLAMP, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId)
            }, t.prototype.setStyle = function (t, e) {
                const n = this.gl
                if (e.mipmap && t.mipmap !== i.k.ON_MANUAL && n.generateMipmap(t.target), n.texParameteri(t.target, n.TEXTURE_WRAP_S, e.wrapMode), n.texParameteri(t.target, n.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
                    n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === i.p.LINEAR ? n.LINEAR_MIPMAP_LINEAR : n.NEAREST_MIPMAP_NEAREST)
                    let r = this.renderer.context.extensions.anisotropicFiltering
                    if (r && t.anisotropicLevel > 0 && t.scaleMode === i.p.LINEAR) {
                        const o = Math.min(t.anisotropicLevel, n.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT))
                        n.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, o)
                    }
                } else { n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === i.p.LINEAR ? n.LINEAR : n.NEAREST)
                }
                n.texParameteri(t.target, n.TEXTURE_MAG_FILTER, t.scaleMode === i.p.LINEAR ? n.LINEAR : n.NEAREST)
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        const le = {
            __proto__: null,
            FilterSystem: J,
            BatchSystem: tt,
            ContextSystem: nt,
            FramebufferSystem: ot,
            GeometrySystem: st,
            MaskSystem: Bt,
            ScissorSystem: Xt,
            StencilSystem: Ht,
            ProjectionSystem: Vt,
            RenderTextureSystem: zt,
            ShaderSystem: oe,
            StateSystem: ae,
            TextureGCSystem: se,
            TextureSystem: ce
        }
        const he = new u.d()
        var fe = (function (t) {
            function e(e, n) {
                void 0 === e && (e = i.n.UNKNOWN)
                let a = t.call(this) || this
                return n = Object.assign({}, r.b.RENDER_OPTIONS, n), a.options = n, a.type = e, a.screen = new u.j(0, 0, n.width, n.height), a.view = n.view || document.createElement('canvas'), a.resolution = n.resolution || r.b.RESOLUTION, a.useContextAlpha = n.useContextAlpha, a.autoDensity = !!n.autoDensity, a.preserveDrawingBuffer = n.preserveDrawingBuffer, a.clearBeforeRender = n.clearBeforeRender, a._backgroundColor = 0, a._backgroundColorRgba = [0, 0, 0, 1], a._backgroundColorString = '#000000', a.backgroundColor = n.backgroundColor || a._backgroundColor, a.backgroundAlpha = n.backgroundAlpha, void 0 !== n.transparent && (new Object(o.deprecation)('6.0.0', 'Option transparent is deprecated, please use backgroundAlpha instead.'), a.useContextAlpha = n.transparent, a.backgroundAlpha = n.transparent ? 0 : 1), a._lastObjectRendered = null, a.plugins = {}, a
            }
            return f(e, t), e.prototype.initPlugins = function (t) {
                for (const e in t) this.plugins[e] = new t[e](this)
            }, Object.defineProperty(e.prototype, 'width', {
                get() {
                    return this.view.width
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'height', {
                get() {
                    return this.view.height
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.resize = function (t, e) {
                this.view.width = Math.round(t * this.resolution), this.view.height = Math.round(e * this.resolution)
                let n = this.view.width / this.resolution
                var r = this.view.height / this.resolution
                this.screen.width = n, this.screen.height = r, this.autoDensity && (this.view.style.width = `${n}px`, this.view.style.height = `${r}px`), this.emit('resize', n, r)
            }, e.prototype.generateTexture = function (t, e, n, r) {
                void 0 === e && (e = {}), typeof e == 'number' && (new Object(o.deprecation)('6.1.0', 'generateTexture options (scaleMode, resolution, region) are now object options.'), e = {
                    scaleMode: e,
                    resolution: n,
                    region: r
                })
                let i = e.region
                var a = (function (t, e) {
                    let n = {}
                    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && !e.includes(r) && (n[r] = t[r])
                    if (t != null && typeof Object.getOwnPropertySymbols == 'function') {
                        let i = 0
                        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) !e.includes(r[i]) && (n[r[i]] = t[r[i]])
                    }
                    return n
                }(e, ['region']))
                (r = i || t.getLocalBounds(null, !0)).width === 0 && (r.width = 1), r.height === 0 && (r.height = 1)
                let s = j.create(d({
                    width: r.width,
                    height: r.height
                }, a))
                return he.tx = -r.x, he.ty = -r.y, this.render(t, {
                    renderTexture: s,
                    clear: !1,
                    transform: he,
                    skipUpdateTransform: !!t.parent
                }), s
            }, e.prototype.destroy = function (t) {
                for (const e in this.plugins) this.plugins[e].destroy(), this.plugins[e] = null
                t && this.view.parentNode && this.view.parentNode.removeChild(this.view)
                this.plugins = null, this.type = i.n.UNKNOWN, this.view = null, this.screen = null, this._tempDisplayObjectParent = null, this.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null
            }, Object.defineProperty(e.prototype, 'backgroundColor', {
                get() {
                    return this._backgroundColor
                },
                set(t) {
                    this._backgroundColor = t, this._backgroundColorString = new Object(o.hex2string)(t), new Object(o.hex2rgb)(t, this._backgroundColorRgba)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'backgroundAlpha', {
                get() {
                    return this._backgroundColorRgba[3]
                },
                set(t) {
                    this._backgroundColorRgba[3] = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(o.EventEmitter))
        const de = function (t) {
            this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
        }
        const pe = (function () {
            function t(t) {
                this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {}
            }
            return t.prototype.destroy = function () {
                this.renderer = null
            }, t.prototype.contextChange = function () {
                this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
            }, t.prototype.bind = function (t) {
                let e = this.gl
                            var n = this.CONTEXT_UID
                            var r = t._glBuffers[n] || this.createGLBuffer(t)
                e.bindBuffer(t.type, r.buffer)
            }, t.prototype.bindBufferBase = function (t, e) {
                let n = this.gl
                            var r = this.CONTEXT_UID
                if (this.boundBufferBases[e] !== t) {
                    let i = t._glBuffers[r] || this.createGLBuffer(t)
                    this.boundBufferBases[e] = t, n.bindBufferBase(n.UNIFORM_BUFFER, e, i.buffer)
                }
            }, t.prototype.bindBufferRange = function (t, e, n) {
                let r = this.gl
                            var i = this.CONTEXT_UID
                n = n || 0
                var o = t._glBuffers[i] || this.createGLBuffer(t)
                r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, o.buffer, 256 * n, 256)
            }, t.prototype.update = function (t) {
                let e = this.gl
                            var n = this.CONTEXT_UID
                            var r = t._glBuffers[n]
                if (t._updateID !== r.updateID) {
                    if (r.updateID = t._updateID, e.bindBuffer(t.type, r.buffer), r.byteLength >= t.data.byteLength) { e.bufferSubData(t.type, 0, t.data);
}
                    else {
                        var i = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW
                                r.byteLength = t.data.byteLength, e.bufferData(t.type, t.data, i)
                    }
                }
            }, t.prototype.dispose = function (t, e) {
                if (this.managedBuffers[t.id]) {
                    delete this.managedBuffers[t.id]
                    var n = t._glBuffers[this.CONTEXT_UID]
                                var r = this.gl
                    t.disposeRunner.remove(this), n && (e || r.deleteBuffer(n.buffer), delete t._glBuffers[this.CONTEXT_UID])
                }
            }, t.prototype.disposeAll = function (t) {
                for (let e = Object.keys(this.managedBuffers), n = 0; n < e.length; n++) this.dispose(this.managedBuffers[e[n]], t)
            }, t.prototype.createGLBuffer = function (t) {
                let e = this.CONTEXT_UID
                            var n = this.gl
                return t._glBuffers[e] = new de(n.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[e]
            }, t
        }())
        var me = (function (t) {
            function e(n) {
                const r = t.call(this, i.n.WEBGL, n) || this
                return n = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {
                    destroy: new a.a('destroy'),
                    contextChange: new a.a('contextChange'),
                    reset: new a.a('reset'),
                    update: new a.a('update'),
                    postrender: new a.a('postrender'),
                    prerender: new a.a('prerender'),
                    resize: new a.a('resize')
                }, r.runners.contextChange.add(r), r.globalUniforms = new q({
                    projectionMatrix: new u.d()
                }, !0), r.addSystem(Bt, 'mask').addSystem(nt, 'context').addSystem(ae, 'state').addSystem(oe, 'shader').addSystem(ce, 'texture').addSystem(pe, 'buffer').addSystem(st, 'geometry').addSystem(ot, 'framebuffer').addSystem(Xt, 'scissor').addSystem(Ht, 'stencil').addSystem(Vt, 'projection').addSystem(se, 'textureGC').addSystem(J, 'filter').addSystem(zt, 'renderTexture').addSystem(tt, 'batch'), r.initPlugins(e.__plugins), r.multisample = void 0, n.context
                    ? r.context.initFromContext(n.context)
                    : r.context.initFromOptions({
                            alpha: !!r.useContextAlpha,
                            antialias: n.antialias,
                            premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== 'notMultiplied',
                            stencil: !0,
                            preserveDrawingBuffer: n.preserveDrawingBuffer,
                            powerPreference: r.options.powerPreference
                        }), r.renderingToScreen = !0, new Object(o.sayHello)(r.context.webGLVersion === 2 ? 'WebGL 2' : 'WebGL 1'), r.resize(r.options.width, r.options.height), r
            }
            return f(e, t), e.create = function (t) {
                if (new Object(o.isWebGLSupported)()) return new e(t)
                throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.')
            }, e.prototype.contextChange = function () {
                let t; const e = this.gl
                if (this.context.webGLVersion === 1) {
                    var n = e.getParameter(e.FRAMEBUFFER_BINDING)
                    e.bindFramebuffer(e.FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, n)
                } else {
                    n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING)
                    e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n)
                }
                t >= i.l.HIGH ? this.multisample = i.l.HIGH : t >= i.l.MEDIUM ? this.multisample = i.l.MEDIUM : t >= i.l.LOW ? this.multisample = i.l.LOW : this.multisample = i.l.NONE
            }, e.prototype.addSystem = function (t, e) {
                const n = new t(this)
                if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`)
                for (const r in this[e] = n, this.runners) this.runners[r].add(n)
                return this
            }, e.prototype.render = function (t, e) {
                let n, r, i, a
                if (e && (e instanceof j ? (new Object(o.deprecation)('6.0.0', 'Renderer#render arguments changed, use options instead.'), n = e, r = arguments[2], i = arguments[3], a = arguments[4]) : (n = e.renderTexture, r = e.clear, i = e.transform, a = e.skipUpdateTransform)), this.renderingToScreen = !n, this.runners.prerender.emit(), this.emit('prerender'), this.projection.transform = i, !this.context.isLost) {
                    if (n || (this._lastObjectRendered = t), !a) {
                        const s = t.enableTempParent()
                        t.updateTransform(), t.disableTempParent(s)
                    }
                    this.renderTexture.bind(n), this.batch.currentRenderer.start(), (void 0 !== r ? r : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), n && n.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit('postrender')
                }
            }, e.prototype.generateTexture = function (e, n, r, i) {
                void 0 === n && (n = {})
                const o = t.prototype.generateTexture.call(this, e, n, r, i)
                return this.framebuffer.blit(), o
            }, e.prototype.resize = function (e, n) {
                t.prototype.resize.call(this, e, n), this.runners.resize.emit(this.screen.height, this.screen.width)
            }, e.prototype.reset = function () {
                return this.runners.reset.emit(), this
            }, e.prototype.clear = function () {
                this.renderTexture.bind(), this.renderTexture.clear()
            }, e.prototype.destroy = function (e) {
                for (const n in this.runners.destroy.emit(), this.runners) this.runners[n].destroy()
                t.prototype.destroy.call(this, e), this.gl = null
            }, Object.defineProperty(e.prototype, 'extract', {
                get() {
                    return new Object(o.deprecation)('6.0.0', 'Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.'), this.plugins.extract
                },
                enumerable: !1,
                configurable: !0
            }), e.registerPlugin = function (t, n) {
                e.__plugins = e.__plugins || {}, e.__plugins[t] = n
            }, e
        }(fe))

        function ye(t) {
            return me.create(t)
        }
        var ve = 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}'
        var _e = 'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n'
        var ge = (function () {
            function t(t) {
                new Object(o.deprecation)('6.1.0', 'System class is deprecated, implemement ISystem interface instead.'), this.renderer = t
            }
            return t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        var be = function () {
            this.texArray = null, this.blend = 0, this.type = i.f.TRIANGLES, this.start = 0, this.size = 0, this.data = null
        }
        var Ee = (function () {
            function t() {
                this.elements = [], this.ids = [], this.count = 0
            }
            return t.prototype.clear = function () {
                for (let t = 0; t < this.count; t++) this.elements[t] = null
                this.count = 0
            }, t
        }())
        var xe = (function () {
            function t(t) {
                typeof t == 'number' ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
            }
            return Object.defineProperty(t.prototype, 'int8View', {
                get() {
                    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'uint8View', {
                get() {
                    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'int16View', {
                get() {
                    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'uint16View', {
                get() {
                    return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'int32View', {
                get() {
                    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.view = function (t) {
                return this[`${t}View`]
            }, t.prototype.destroy = function () {
                this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
            }, t.sizeOf = function (t) {
                switch (t) {
                    case 'int8':
                    case 'uint8':
                        return 1
                    case 'int16':
                    case 'uint16':
                        return 2
                    case 'int32':
                    case 'uint32':
                    case 'float32':
                        return 4
                    default:
                        throw new Error(`${t} isn't a valid view type`)
                }
            }, t
        }())
        var Te = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.shaderGenerator = null, n.geometryClass = null, n.vertexSize = null, n.state = Mt.for2d(), n.size = 4 * r.b.SPRITE_BATCH_SIZE, n._vertexCount = 0, n._indexCount = 0, n._bufferedElements = [], n._bufferedTextures = [], n._bufferSize = 0, n._shader = null, n._packedGeometries = [], n._packedGeometryPoolSize = 2, n._flushId = 0, n._aBuffers = {}, n._iBuffers = {}, n.MAX_TEXTURES = 1, n.renderer.on('prerender', n.onPrerender, n), e.runners.contextChange.add(n), n._dcIndex = 0, n._aIndex = 0, n._iIndex = 0, n._attributeBuffer = null, n._indexBuffer = null, n._tempBoundTextures = [], n
            }
            return f(e, t), e.prototype.contextChange = function () {
                const t = this.renderer.gl
                r.b.PREFER_ENV === i.g.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), r.b.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = At(this.MAX_TEXTURES, t)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES)
                for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] = new this.geometryClass()
                this.initFlushBuffers()
            }, e.prototype.initFlushBuffers = function () {
                for (var t = e._drawCallPool, n = e._textureArrayPool, r = this.size / 4, i = Math.floor(r / this.MAX_TEXTURES) + 1; t.length < r;) t.push(new be())
                for (; n.length < i;) n.push(new Ee())
                for (let o = 0; o < this.MAX_TEXTURES; o++) this._tempBoundTextures[o] = null
            }, e.prototype.onPrerender = function () {
                this._flushId = 0
            }, e.prototype.render = function (t) {
                t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t)
            }, e.prototype.buildTexturesAndDrawCalls = function () {
                const t = this._bufferedTextures
                var n = this.MAX_TEXTURES
                var r = e._textureArrayPool
                var i = this.renderer.batch
                var o = this._tempBoundTextures
                var a = this.renderer.textureGC.count
                var s = ++v._globalBatch
                var u = 0
                var c = r[0]
                var l = 0
                i.copyBoundTextures(o, n)
                for (var h = 0; h < this._bufferSize; ++h) {
                    const f = t[h]
                    t[h] = null, f._batchEnabled !== s && (c.count >= n && (i.boundArray(c, o, s, n), this.buildDrawCalls(c, l, h), l = h, c = r[++u], ++s), f._batchEnabled = s, f.touched = a, c.elements[c.count++] = f)
                }
                c.count > 0 && (i.boundArray(c, o, s, n), this.buildDrawCalls(c, l, this._bufferSize), ++u, ++s)
                for (h = 0; h < o.length; h++) o[h] = null
                v._globalBatch = s
            }, e.prototype.buildDrawCalls = function (t, n, r) {
                const i = this._bufferedElements
                var a = this._attributeBuffer
                var s = this._indexBuffer
                var u = this.vertexSize
                var c = e._drawCallPool
                var l = this._dcIndex
                var h = this._aIndex
                var f = this._iIndex
                var d = c[l]
                d.start = this._iIndex, d.texArray = t
                for (let p = n; p < r; ++p) {
                    const m = i[p]
                    var y = m._texture.baseTexture
                    var v = o.premultiplyBlendMode[y.alphaMode ? 1 : 0][m.blendMode]
                    i[p] = null, n < p && d.blend !== v && (d.size = f - d.start, n = p, (d = c[++l]).texArray = t, d.start = f), this.packInterleavedGeometry(m, a, s, h, f), h += m.vertexData.length / 2 * u, f += m.indices.length, d.blend = v
                }
                n < r && (d.size = f - d.start, ++l), this._dcIndex = l, this._aIndex = h, this._iIndex = f
            }, e.prototype.bindAndClearTexArray = function (t) {
                for (let e = this.renderer.texture, n = 0; n < t.count; n++) e.bind(t.elements[n], t.ids[n]), t.elements[n] = null
                t.count = 0
            }, e.prototype.updateGeometry = function () {
                const t = this._packedGeometries
                var e = this._attributeBuffer
                var n = this._indexBuffer
                r.b.CAN_UPLOAD_SAME_BUFFER ? (t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(n), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t[this._flushId] = new this.geometryClass()), t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(n), this.renderer.geometry.bind(t[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
            }, e.prototype.drawBatches = function () {
                for (let t = this._dcIndex, n = this.renderer, r = n.gl, i = n.state, o = e._drawCallPool, a = null, s = 0; s < t; s++) {
                    const u = o[s]
                    var c = u.texArray
                    var l = u.type
                    var h = u.size
                    var f = u.start
                    var d = u.blend
                    a !== c && (a = c, this.bindAndClearTexArray(c)), this.state.blendMode = d, i.set(this.state), r.drawElements(l, h, r.UNSIGNED_SHORT, 2 * f)
                }
            }, e.prototype.flush = function () {
                this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
            }, e.prototype.start = function () {
                this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), r.b.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
            }, e.prototype.stop = function () {
                this.flush()
            }, e.prototype.destroy = function () {
                for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy()
                this.renderer.off('prerender', this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t.prototype.destroy.call(this)
            }, e.prototype.getAttributeBuffer = function (t) {
                const e = new Object(o.nextPow2)(Math.ceil(t / 8))
                var n = new Object(o.log2)(e)
                var r = 8 * e
                this._aBuffers.length <= n && (this._iBuffers.length = n + 1)
                let i = this._aBuffers[r]
                return i || (this._aBuffers[r] = i = new xe(r * this.vertexSize * 4)), i
            }, e.prototype.getIndexBuffer = function (t) {
                const e = new Object(o.nextPow2)(Math.ceil(t / 12))
                var n = new Object(o.log2)(e)
                var r = 12 * e
                this._iBuffers.length <= n && (this._iBuffers.length = n + 1)
                let i = this._iBuffers[n]
                return i || (this._iBuffers[n] = i = new Uint16Array(r)), i
            }, e.prototype.packInterleavedGeometry = function (t, e, n, r, i) {
                for (var a = e.uint32View, s = e.float32View, u = r / this.vertexSize, c = t.uvs, l = t.indices, h = t.vertexData, f = t._texture.baseTexture._batchLocation, d = Math.min(t.worldAlpha, 1), p = d < 1 && t._texture.baseTexture.alphaMode ? new Object(o.premultiplyTint)(t._tintRGB, d) : t._tintRGB + (255 * d << 24), m = 0; m < h.length; m += 2) s[r++] = h[m], s[r++] = h[m + 1], s[r++] = c[m], s[r++] = c[m + 1], a[r++] = p, s[r++] = f
                for (m = 0; m < l.length; m++) n[i++] = u + l[m]
            }, e._drawCallPool = [], e._textureArrayPool = [], e
        }(Q))
        var Se = (function () {
            function t(t, e) {
                if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, !e.includes('%count%')) throw new Error('Fragment template must contain "%count%".')
                if (!e.includes('%forloop%')) throw new Error('Fragment template must contain "%forloop%".')
            }
            return t.prototype.generateShader = function (t) {
                if (!this.programCache[t]) {
                    for (var e = new Int32Array(t), n = 0; n < t; n++) e[n] = n
                    this.defaultGroupCache[t] = q.from({
                        uSamplers: e
                    }, !0)
                    let r = this.fragTemplate
                    r = (r = r.replace(/%count%/gi, `${ t}`)).replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new kt(this.vertexSrc, r)
                }
                const i = {
                    tint: new Float32Array([1, 1, 1, 1]),
                    translationMatrix: new u.d(),
                    default: this.defaultGroupCache[t]
                }
                return new Nt(this.programCache[t], i)
            }, t.prototype.generateSampleSrc = function (t) {
                let e = ''
                e += '\n', e += '\n'
                for (let n = 0; n < t; n++) n > 0 && (e += '\nelse '), n < t - 1 && (e += `if(vTextureId < ${ n }.5)`), e += '\n{', e += `\n\tcolor = texture2D(uSamplers[${ n }], vTextureCoord);`, e += '\n}'
                return e += '\n', e += '\n'
            }, t
        }())
        var we = (function (t) {
            function e(e) {
                void 0 === e && (e = !1)
                let n = t.call(this) || this
                return n._buffer = new B(null, e, !1), n._indexBuffer = new B(null, e, !0), n.addAttribute('aVertexPosition', n._buffer, 2, !1, i.r.FLOAT).addAttribute('aTextureCoord', n._buffer, 2, !1, i.r.FLOAT).addAttribute('aColor', n._buffer, 4, !0, i.r.UNSIGNED_BYTE).addAttribute('aTextureId', n._buffer, 1, !0, i.r.FLOAT).addIndex(n._indexBuffer), n
            }
            return f(e, t), e
        }(V))
        let Oe = 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n'
        let Pe = 'varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n'
        var Re = (function () {
            function t() {}
            return t.create = function (t) {
                const e = Object.assign({
                    vertex: Oe,
                    fragment: Pe,
                    geometryClass: we,
                    vertexSize: 6
                }, t)
                var n = e.vertex
                var r = e.fragment
                var i = e.vertexSize
                var o = e.geometryClass
                return (function (t) {
                    function e(e) {
                        let a = t.call(this, e) || this
                        return a.shaderGenerator = new Se(n, r), a.geometryClass = o, a.vertexSize = i, a
                    }
                    return f(e, t), e
                }(Te))
            }, Object.defineProperty(t, 'defaultVertexSrc', {
                get() {
                    return Oe
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t, 'defaultFragmentTemplate', {
                get() {
                    return Pe
                },
                enumerable: !1,
                configurable: !0
            }), t
        }())
        var Ae = Re.create()
        var Ie = {}
        let Ce = function (t) {
            Object.defineProperty(Ie, t, {
                get() {
                    return new Object(o.deprecation)('6.0.0', `PIXI.systems.${t} has moved to PIXI.${t}`), P[t]
                }
            })
        }
        for (var ke in P) Ce(ke)
        var Ne = {}
        const Me = function (t) {
            Object.defineProperty(Ne, t, {
                get() {
                    return new Object(o.deprecation)('6.0.0', `PIXI.resources.${ t } has moved to PIXI.${ t}`), le[t]
                }
            })
        }
        for (var ke in le) Me(ke)
    },
    './node_modules/@pixi/display/dist/esm/display.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return a
        }), n.d(e, 'b', () => {
            return C
        }), n.d(e, 'c', () => {
            return R
        }), n.d(e, 'd', () => {
            return A
        })
        const r = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        const i = n('./node_modules/@pixi/math/dist/esm/math.js')
        const o = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        /*!
             * @pixi/display - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/display is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        r.b.SORTABLE_CHILDREN = !1
        var a = (function () {
            function t() {
                this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
            }
            return t.prototype.isEmpty = function () {
                return this.minX > this.maxX || this.minY > this.maxY
            }, t.prototype.clear = function () {
                this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
            }, t.prototype.getRectangle = function (t) {
                return this.minX > this.maxX || this.minY > this.maxY ? i.j.EMPTY : ((t = t || new i.j(0, 0, 1, 1)).x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
            }, t.prototype.addPoint = function (t) {
                this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
            }, t.prototype.addPointMatrix = function (t, e) {
                const n = t.a
                let r = t.b
                let i = t.c
                let o = t.d
                let a = t.tx
                let s = t.ty
                let u = n * e.x + i * e.y + a
                let c = r * e.x + o * e.y + s
                this.minX = Math.min(this.minX, u), this.maxX = Math.max(this.maxX, u), this.minY = Math.min(this.minY, c), this.maxY = Math.max(this.maxY, c)
            }, t.prototype.addQuad = function (t) {
                let e = this.minX
                let n = this.minY
                let r = this.maxX
                let i = this.maxY
                let o = t[0]
                let a = t[1]
                e = o < e ? o : e, n = a < n ? a : n, r = o > r ? o : r, i = a > i ? a : i, e = (o = t[2]) < e ? o : e, n = (a = t[3]) < n ? a : n, r = o > r ? o : r, i = a > i ? a : i, e = (o = t[4]) < e ? o : e, n = (a = t[5]) < n ? a : n, r = o > r ? o : r, i = a > i ? a : i, e = (o = t[6]) < e ? o : e, n = (a = t[7]) < n ? a : n, r = o > r ? o : r, i = a > i ? a : i, this.minX = e, this.minY = n, this.maxX = r, this.maxY = i
            }, t.prototype.addFrame = function (t, e, n, r, i) {
                this.addFrameMatrix(t.worldTransform, e, n, r, i)
            }, t.prototype.addFrameMatrix = function (t, e, n, r, i) {
                const o = t.a
                let a = t.b
                let s = t.c
                let u = t.d
                let c = t.tx
                let l = t.ty
                let h = this.minX
                let f = this.minY
                let d = this.maxX
                let p = this.maxY
                let m = o * e + s * n + c
                let y = a * e + u * n + l
                h = m < h ? m : h, f = y < f ? y : f, d = m > d ? m : d, p = y > p ? y : p, h = (m = o * r + s * n + c) < h ? m : h, f = (y = a * r + u * n + l) < f ? y : f, d = m > d ? m : d, p = y > p ? y : p, h = (m = o * e + s * i + c) < h ? m : h, f = (y = a * e + u * i + l) < f ? y : f, d = m > d ? m : d, p = y > p ? y : p, h = (m = o * r + s * i + c) < h ? m : h, f = (y = a * r + u * i + l) < f ? y : f, d = m > d ? m : d, p = y > p ? y : p, this.minX = h, this.minY = f, this.maxX = d, this.maxY = p
            }, t.prototype.addVertexData = function (t, e, n) {
                for (var r = this.minX, i = this.minY, o = this.maxX, a = this.maxY, s = e; s < n; s += 2) {
                    const u = t[s]
                    let c = t[s + 1]
                    r = u < r ? u : r, i = c < i ? c : i, o = u > o ? u : o, a = c > a ? c : a
                }
                this.minX = r, this.minY = i, this.maxX = o, this.maxY = a
            }, t.prototype.addVertices = function (t, e, n, r) {
                this.addVerticesMatrix(t.worldTransform, e, n, r)
            }, t.prototype.addVerticesMatrix = function (t, e, n, r, i, o) {
                void 0 === i && (i = 0), void 0 === o && (o = i)
                for (var a = t.a, s = t.b, u = t.c, c = t.d, l = t.tx, h = t.ty, f = this.minX, d = this.minY, p = this.maxX, m = this.maxY, y = n; y < r; y += 2) {
                    const v = e[y]
                    let _ = e[y + 1]
                    let g = a * v + u * _ + l
                    let b = c * _ + s * v + h
                    f = Math.min(f, g - i), p = Math.max(p, g + i), d = Math.min(d, b - o), m = Math.max(m, b + o)
                }
                this.minX = f, this.minY = d, this.maxX = p, this.maxY = m
            }, t.prototype.addBounds = function (t) {
                const e = this.minX
                let n = this.minY
                let r = this.maxX
                let i = this.maxY
                this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < n ? t.minY : n, this.maxX = t.maxX > r ? t.maxX : r, this.maxY = t.maxY > i ? t.maxY : i
            }, t.prototype.addBoundsMask = function (t, e) {
                const n = t.minX > e.minX ? t.minX : e.minX
                let r = t.minY > e.minY ? t.minY : e.minY
                let i = t.maxX < e.maxX ? t.maxX : e.maxX
                let o = t.maxY < e.maxY ? t.maxY : e.maxY
                if (n <= i && r <= o) {
                    const a = this.minX
                    let s = this.minY
                    let u = this.maxX
                    let c = this.maxY
                    this.minX = n < a ? n : a, this.minY = r < s ? r : s, this.maxX = i > u ? i : u, this.maxY = o > c ? o : c
                }
            }, t.prototype.addBoundsMatrix = function (t, e) {
                this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
            }, t.prototype.addBoundsArea = function (t, e) {
                const n = t.minX > e.x ? t.minX : e.x
                let r = t.minY > e.y ? t.minY : e.y
                let i = t.maxX < e.x + e.width ? t.maxX : e.x + e.width
                let o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height
                if (n <= i && r <= o) {
                    const a = this.minX
                    let s = this.minY
                    let u = this.maxX
                    let c = this.maxY
                    this.minX = n < a ? n : a, this.minY = r < s ? r : s, this.maxX = i > u ? i : u, this.maxY = o > c ? o : c
                }
            }, t.prototype.pad = function (t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e)
            }, t.prototype.addFramePad = function (t, e, n, r, i, o) {
                t -= i, e -= o, n += i, r += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > n ? this.maxX : n, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > r ? this.maxY : r
            }, t
        }())
        let s = function (t, e) {
            return (s = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0

            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.

            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
            ***************************************************************************** */
        function u(t, e) {
            function n() {
                this.constructor = t
            }
            s(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        let c; let l; let h; let f; let d; let p; let m; let y; let v; let _; let g; let b; let E; let x; let T; let S; let w; let O; let P; var R = (function (t) {
            function e() {
                const e = t.call(this) || this
                return e.tempDisplayObjectParent = null, e.transform = new i.m(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new a(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e
            }
            return u(e, t), e.mixin = function (t) {
                for (let n = Object.keys(t), r = 0; r < n.length; ++r) {
                    const i = n[r]
                    Object.defineProperty(e.prototype, i, Object.getOwnPropertyDescriptor(t, i))
                }
            }, Object.defineProperty(e.prototype, 'destroyed', {
                get() {
                    return this._destroyed
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype._recursivePostUpdateTransform = function () {
                this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
            }, e.prototype.updateTransform = function () {
                this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
            }, e.prototype.getBounds = function (t, e) {
                return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e || (this._boundsRect || (this._boundsRect = new i.j()), e = this._boundsRect), this._bounds.getRectangle(e)
            }, e.prototype.getLocalBounds = function (t) {
                t || (this._localBoundsRect || (this._localBoundsRect = new i.j()), t = this._localBoundsRect), this._localBounds || (this._localBounds = new a())
                let e = this.transform
                var n = this.parent
                this.parent = null, this.transform = this._tempDisplayObjectParent.transform
                let r = this._bounds
                var o = this._boundsID
                this._bounds = this._localBounds
                let s = this.getBounds(!1, t)
                return this.parent = n, this.transform = e, this._bounds = r, this._bounds.updateID += this._boundsID - o, s
            }, e.prototype.toGlobal = function (t, e, n) {
                return void 0 === n && (n = !1), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, e)
            }, e.prototype.toLocal = function (t, e, n, r) {
                return e && (t = e.toGlobal(t, n, r)), r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, n)
            }, e.prototype.setParent = function (t) {
                if (!t || !t.addChild) throw new Error('setParent: Argument must be a Container')
                return t.addChild(this), t
            }, e.prototype.setTransform = function (t, e, n, r, i, o, a, s, u) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), this.position.x = t, this.position.y = e, this.scale.x = n || 1, this.scale.y = r || 1, this.rotation = i, this.skew.x = o, this.skew.y = a, this.pivot.x = s, this.pivot.y = u, this
            }, e.prototype.destroy = function (t) {
                this.parent && this.parent.removeChild(this), this.emit('destroyed'), this.removeAllListeners(), this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this._destroyed = !0
            }, Object.defineProperty(e.prototype, '_tempDisplayObjectParent', {
                get() {
                    return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new A()), this.tempDisplayObjectParent
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.enableTempParent = function () {
                const t = this.parent
                return this.parent = this._tempDisplayObjectParent, t
            }, e.prototype.disableTempParent = function (t) {
                this.parent = t
            }, Object.defineProperty(e.prototype, 'x', {
                get() {
                    return this.position.x
                },
                set(t) {
                    this.transform.position.x = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'y', {
                get() {
                    return this.position.y
                },
                set(t) {
                    this.transform.position.y = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'worldTransform', {
                get() {
                    return this.transform.worldTransform
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'localTransform', {
                get() {
                    return this.transform.localTransform
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'position', {
                get() {
                    return this.transform.position
                },
                set(t) {
                    this.transform.position.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'scale', {
                get() {
                    return this.transform.scale
                },
                set(t) {
                    this.transform.scale.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'pivot', {
                get() {
                    return this.transform.pivot
                },
                set(t) {
                    this.transform.pivot.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'skew', {
                get() {
                    return this.transform.skew
                },
                set(t) {
                    this.transform.skew.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'rotation', {
                get() {
                    return this.transform.rotation
                },
                set(t) {
                    this.transform.rotation = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'angle', {
                get() {
                    return this.transform.rotation * i.i
                },
                set(t) {
                    this.transform.rotation = t * i.b
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'zIndex', {
                get() {
                    return this._zIndex
                },
                set(t) {
                    this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'worldVisible', {
                get() {
                    let t = this
                    do {
                        if (!t.visible) return !1
                        t = t.parent
                    } while (t)
                    return !0
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'mask', {
                get() {
                    return this._mask
                },
                set(t) {
                    if (this._mask !== t) {
                        let e
                        if (this._mask)(e = this._mask.maskObject || this._mask)._maskRefCount--, e._maskRefCount === 0 && (e.renderable = !0, e.isMask = !1)
                        if (this._mask = t, this._mask) (e = this._mask.maskObject || this._mask)._maskRefCount === 0 && (e.renderable = !1, e.isMask = !0), e._maskRefCount++
                    }
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(o.EventEmitter))
        var A = (function (t) {
            function e() {
                const e = t !== null && t.apply(this, arguments) || this
                return e.sortDirty = null, e
            }
            return u(e, t), e
        }(R))

        function I(t, e) {
            return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
        }
        R.prototype.displayObjectUpdateTransform = R.prototype.updateTransform,
        (function (t) {
            t[t.WEBGL_LEGACY = 0] = 'WEBGL_LEGACY', t[t.WEBGL = 1] = 'WEBGL', t[t.WEBGL2 = 2] = 'WEBGL2'
        }(c || (c = {}))),
        (function (t) {
            t[t.UNKNOWN = 0] = 'UNKNOWN', t[t.WEBGL = 1] = 'WEBGL', t[t.CANVAS = 2] = 'CANVAS'
        }(l || (l = {}))),
        (function (t) {
            t[t.COLOR = 16384] = 'COLOR', t[t.DEPTH = 256] = 'DEPTH', t[t.STENCIL = 1024] = 'STENCIL'
        }(h || (h = {}))),
        (function (t) {
            t[t.NORMAL = 0] = 'NORMAL', t[t.ADD = 1] = 'ADD', t[t.MULTIPLY = 2] = 'MULTIPLY', t[t.SCREEN = 3] = 'SCREEN', t[t.OVERLAY = 4] = 'OVERLAY', t[t.DARKEN = 5] = 'DARKEN', t[t.LIGHTEN = 6] = 'LIGHTEN', t[t.COLOR_DODGE = 7] = 'COLOR_DODGE', t[t.COLOR_BURN = 8] = 'COLOR_BURN', t[t.HARD_LIGHT = 9] = 'HARD_LIGHT', t[t.SOFT_LIGHT = 10] = 'SOFT_LIGHT', t[t.DIFFERENCE = 11] = 'DIFFERENCE', t[t.EXCLUSION = 12] = 'EXCLUSION', t[t.HUE = 13] = 'HUE', t[t.SATURATION = 14] = 'SATURATION', t[t.COLOR = 15] = 'COLOR', t[t.LUMINOSITY = 16] = 'LUMINOSITY', t[t.NORMAL_NPM = 17] = 'NORMAL_NPM', t[t.ADD_NPM = 18] = 'ADD_NPM', t[t.SCREEN_NPM = 19] = 'SCREEN_NPM', t[t.NONE = 20] = 'NONE', t[t.SRC_OVER = 0] = 'SRC_OVER', t[t.SRC_IN = 21] = 'SRC_IN', t[t.SRC_OUT = 22] = 'SRC_OUT', t[t.SRC_ATOP = 23] = 'SRC_ATOP', t[t.DST_OVER = 24] = 'DST_OVER', t[t.DST_IN = 25] = 'DST_IN', t[t.DST_OUT = 26] = 'DST_OUT', t[t.DST_ATOP = 27] = 'DST_ATOP', t[t.ERASE = 26] = 'ERASE', t[t.SUBTRACT = 28] = 'SUBTRACT', t[t.XOR = 29] = 'XOR'
        }(f || (f = {}))),
        (function (t) {
            t[t.POINTS = 0] = 'POINTS', t[t.LINES = 1] = 'LINES', t[t.LINE_LOOP = 2] = 'LINE_LOOP', t[t.LINE_STRIP = 3] = 'LINE_STRIP', t[t.TRIANGLES = 4] = 'TRIANGLES', t[t.TRIANGLE_STRIP = 5] = 'TRIANGLE_STRIP', t[t.TRIANGLE_FAN = 6] = 'TRIANGLE_FAN'
        }(d || (d = {}))),
        (function (t) {
            t[t.RGBA = 6408] = 'RGBA', t[t.RGB = 6407] = 'RGB', t[t.RG = 33319] = 'RG', t[t.RED = 6403] = 'RED', t[t.RGBA_INTEGER = 36249] = 'RGBA_INTEGER', t[t.RGB_INTEGER = 36248] = 'RGB_INTEGER', t[t.RG_INTEGER = 33320] = 'RG_INTEGER', t[t.RED_INTEGER = 36244] = 'RED_INTEGER', t[t.ALPHA = 6406] = 'ALPHA', t[t.LUMINANCE = 6409] = 'LUMINANCE', t[t.LUMINANCE_ALPHA = 6410] = 'LUMINANCE_ALPHA', t[t.DEPTH_COMPONENT = 6402] = 'DEPTH_COMPONENT', t[t.DEPTH_STENCIL = 34041] = 'DEPTH_STENCIL'
        }(p || (p = {}))),
        (function (t) {
            t[t.TEXTURE_2D = 3553] = 'TEXTURE_2D', t[t.TEXTURE_CUBE_MAP = 34067] = 'TEXTURE_CUBE_MAP', t[t.TEXTURE_2D_ARRAY = 35866] = 'TEXTURE_2D_ARRAY', t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = 'TEXTURE_CUBE_MAP_POSITIVE_X', t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = 'TEXTURE_CUBE_MAP_NEGATIVE_X', t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = 'TEXTURE_CUBE_MAP_POSITIVE_Y', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = 'TEXTURE_CUBE_MAP_NEGATIVE_Y', t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = 'TEXTURE_CUBE_MAP_POSITIVE_Z', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = 'TEXTURE_CUBE_MAP_NEGATIVE_Z'
        }(m || (m = {}))),
        (function (t) {
            t[t.UNSIGNED_BYTE = 5121] = 'UNSIGNED_BYTE', t[t.UNSIGNED_SHORT = 5123] = 'UNSIGNED_SHORT', t[t.UNSIGNED_SHORT_5_6_5 = 33635] = 'UNSIGNED_SHORT_5_6_5', t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = 'UNSIGNED_SHORT_4_4_4_4', t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = 'UNSIGNED_SHORT_5_5_5_1', t[t.UNSIGNED_INT = 5125] = 'UNSIGNED_INT', t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = 'UNSIGNED_INT_10F_11F_11F_REV', t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = 'UNSIGNED_INT_2_10_10_10_REV', t[t.UNSIGNED_INT_24_8 = 34042] = 'UNSIGNED_INT_24_8', t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = 'UNSIGNED_INT_5_9_9_9_REV', t[t.BYTE = 5120] = 'BYTE', t[t.SHORT = 5122] = 'SHORT', t[t.INT = 5124] = 'INT', t[t.FLOAT = 5126] = 'FLOAT', t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = 'FLOAT_32_UNSIGNED_INT_24_8_REV', t[t.HALF_FLOAT = 36193] = 'HALF_FLOAT'
        }(y || (y = {}))),
        (function (t) {
            t[t.FLOAT = 0] = 'FLOAT', t[t.INT = 1] = 'INT', t[t.UINT = 2] = 'UINT'
        }(v || (v = {}))),
        (function (t) {
            t[t.NEAREST = 0] = 'NEAREST', t[t.LINEAR = 1] = 'LINEAR'
        }(_ || (_ = {}))),
        (function (t) {
            t[t.CLAMP = 33071] = 'CLAMP', t[t.REPEAT = 10497] = 'REPEAT', t[t.MIRRORED_REPEAT = 33648] = 'MIRRORED_REPEAT'
        }(g || (g = {}))),
        (function (t) {
            t[t.OFF = 0] = 'OFF', t[t.POW2 = 1] = 'POW2', t[t.ON = 2] = 'ON', t[t.ON_MANUAL = 3] = 'ON_MANUAL'
        }(b || (b = {}))),
        (function (t) {
            t[t.NPM = 0] = 'NPM', t[t.UNPACK = 1] = 'UNPACK', t[t.PMA = 2] = 'PMA', t[t.NO_PREMULTIPLIED_ALPHA = 0] = 'NO_PREMULTIPLIED_ALPHA', t[t.PREMULTIPLY_ON_UPLOAD = 1] = 'PREMULTIPLY_ON_UPLOAD', t[t.PREMULTIPLY_ALPHA = 2] = 'PREMULTIPLY_ALPHA', t[t.PREMULTIPLIED_ALPHA = 2] = 'PREMULTIPLIED_ALPHA'
        }(E || (E = {}))),
        (function (t) {
            t[t.NO = 0] = 'NO', t[t.YES = 1] = 'YES', t[t.AUTO = 2] = 'AUTO', t[t.BLEND = 0] = 'BLEND', t[t.CLEAR = 1] = 'CLEAR', t[t.BLIT = 2] = 'BLIT'
        }(x || (x = {}))),
        (function (t) {
            t[t.AUTO = 0] = 'AUTO', t[t.MANUAL = 1] = 'MANUAL'
        }(T || (T = {}))),
        (function (t) {
            t.LOW = 'lowp', t.MEDIUM = 'mediump', t.HIGH = 'highp'
        }(S || (S = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.SCISSOR = 1] = 'SCISSOR', t[t.STENCIL = 2] = 'STENCIL', t[t.SPRITE = 3] = 'SPRITE'
        }(w || (w = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.LOW = 2] = 'LOW', t[t.MEDIUM = 4] = 'MEDIUM', t[t.HIGH = 8] = 'HIGH'
        }(O || (O = {}))),
        (function (t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = 'ELEMENT_ARRAY_BUFFER', t[t.ARRAY_BUFFER = 34962] = 'ARRAY_BUFFER', t[t.UNIFORM_BUFFER = 35345] = 'UNIFORM_BUFFER'
        }(P || (P = {})))
        var C = (function (t) {
            function e() {
                const e = t.call(this) || this
                return e.children = [], e.sortableChildren = r.b.SORTABLE_CHILDREN, e.sortDirty = !1, e
            }
            return u(e, t), e.prototype.onChildrenChange = function (t) {}, e.prototype.addChild = function () {
                for (var t = arguments, e = [], n = 0; n < arguments.length; n++) e[n] = t[n]
                if (e.length > 1) {
                    for (let r = 0; r < e.length; r++) this.addChild(e[r])
                }
                else {
                    const i = e[0]
                    i.parent && i.parent.removeChild(i), i.parent = this, this.sortDirty = !0, i.transform._parentID = -1, this.children.push(i), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit('childAdded', i, this, this.children.length - 1), i.emit('added', this)
                }
                return e[0]
            }, e.prototype.addChildAt = function (t, e) {
                if (e < 0 || e > this.children.length) throw new Error(`${t}addChildAt: The index ${e} supplied is out of bounds ${this.children.length}`)
                return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(e, 0, t), this._boundsID++, this.onChildrenChange(e), t.emit('added', this), this.emit('childAdded', t, this, e), t
            }, e.prototype.swapChildren = function (t, e) {
                if (t !== e) {
                    const n = this.getChildIndex(t)
                    let r = this.getChildIndex(e)
                    this.children[n] = e, this.children[r] = t, this.onChildrenChange(n < r ? n : r)
                }
            }, e.prototype.getChildIndex = function (t) {
                const e = this.children.indexOf(t)
                if (e === -1) throw new Error('The supplied DisplayObject must be a child of the caller')
                return e
            }, e.prototype.setChildIndex = function (t, e) {
                if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`)
                const n = this.getChildIndex(t)
                new Object(o.removeItems)(this.children, n, 1), this.children.splice(e, 0, t), this.onChildrenChange(e)
            }, e.prototype.getChildAt = function (t) {
                if (t < 0 || t >= this.children.length) throw new Error(`getChildAt: Index (${t}) does not exist.`)
                return this.children[t]
            }, e.prototype.removeChild = function () {
                for (var t = arguments, e = [], n = 0; n < arguments.length; n++) e[n] = t[n]
                if (e.length > 1) {
                    for (let r = 0; r < e.length; r++) this.removeChild(e[r])
                }
                else {
                    const i = e[0]
                    let a = this.children.indexOf(i)
                    if (a === -1) return null
                    i.parent = null, i.transform._parentID = -1, new Object(o.removeItems)(this.children, a, 1), this._boundsID++, this.onChildrenChange(a), i.emit('removed', this), this.emit('childRemoved', i, this, a)
                }
                return e[0]
            }, e.prototype.removeChildAt = function (t) {
                const e = this.getChildAt(t)
                return e.parent = null, e.transform._parentID = -1, new Object(o.removeItems)(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), e.emit('removed', this), this.emit('childRemoved', e, this, t), e
            }, e.prototype.removeChildren = function (t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = this.children.length)
                let n; const r = t
                let i = e - r
                if (i > 0 && i <= e) {
                    n = this.children.splice(r, i)
                    for (var o = 0; o < n.length; ++o) n[o].parent = null, n[o].transform && (n[o].transform._parentID = -1)
                    this._boundsID++, this.onChildrenChange(t)
                    for (o = 0; o < n.length; ++o) n[o].emit('removed', this), this.emit('childRemoved', n[o], this, o)
                    return n
                }
                if (i === 0 && this.children.length === 0) return []
                throw new RangeError('removeChildren: numeric values are outside the acceptable range.')
            }, e.prototype.sortChildren = function () {
                for (var t = !1, e = 0, n = this.children.length; e < n; ++e) {
                    const r = this.children[e]
                    r._lastSortedIndex = e, t || r.zIndex === 0 || (t = !0)
                }
                t && this.children.length > 1 && this.children.sort(I), this.sortDirty = !1
            }, e.prototype.updateTransform = function () {
                this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
                for (let t = 0, e = this.children.length; t < e; ++t) {
                    const n = this.children[t]
                    n.visible && n.updateTransform()
                }
            }, e.prototype.calculateBounds = function () {
                this._bounds.clear(), this._calculateBounds()
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t]
                    if (e.visible && e.renderable) {
                        if (e.calculateBounds(), e._mask) {
                            const n = e._mask.maskObject || e._mask
                            n.calculateBounds(), this._bounds.addBoundsMask(e._bounds, n._bounds)
                        } else { e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
                        }
                    }
                }
                this._bounds.updateID = this._boundsID
            }, e.prototype.getLocalBounds = function (e, n) {
                void 0 === n && (n = !1)
                const r = t.prototype.getLocalBounds.call(this, e)
                if (!n) {
                    for (let i = 0, o = this.children.length; i < o; ++i) {
                        const a = this.children[i]
                        a.visible && a.updateTransform()
                    }
                }
                return r
            }, e.prototype._calculateBounds = function () {}, e.prototype.render = function (t) {
                if (this.visible && !(this.worldAlpha <= 0) && this.renderable) {
                    if (this._mask || this.filters && this.filters.length) { this.renderAdvanced(t)
                    }
                    else {
                        this._render(t)
                        for (let e = 0, n = this.children.length; e < n; ++e) this.children[e].render(t)
                    }
                }
            }, e.prototype.renderAdvanced = function (t) {
                const e = this.filters
                let n = this._mask
                if (e) {
                    this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0
                    for (var r = 0; r < e.length; r++) e[r].enabled && this._enabledFilters.push(e[r])
                }
                const i = e && this._enabledFilters && this._enabledFilters.length || n && (!n.isMaskData || n.enabled && (n.autoDetect || n.type !== w.NONE))
                i && t.batch.flush(), e && this._enabledFilters && this._enabledFilters.length && t.filter.push(this, this._enabledFilters), n && t.mask.push(this, this._mask), this._render(t)
                r = 0
                for (let o = this.children.length; r < o; r++) this.children[r].render(t)
                i && t.batch.flush(), n && t.mask.pop(this), e && this._enabledFilters && this._enabledFilters.length && t.filter.pop()
            }, e.prototype._render = function (t) {}, e.prototype.destroy = function (e) {
                t.prototype.destroy.call(this), this.sortDirty = !1
                const n = typeof e == 'boolean' ? e : e && e.children
                let r = this.removeChildren(0, this.children.length)
                if (n) {
                    for (let i = 0; i < r.length; ++i) r[i].destroy(e)
                }
            }, Object.defineProperty(e.prototype, 'width', {
                get() {
                    return this.scale.x * this.getLocalBounds().width
                },
                set(t) {
                    const e = this.getLocalBounds().width
                    this.scale.x = e !== 0 ? t / e : 1, this._width = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'height', {
                get() {
                    return this.scale.y * this.getLocalBounds().height
                },
                set(t) {
                    const e = this.getLocalBounds().height
                    this.scale.y = e !== 0 ? t / e : 1, this._height = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(R))
        C.prototype.containerUpdateTransform = C.prototype.updateTransform
    },
    './node_modules/@pixi/graphics/dist/esm/graphics.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return h
        }), n.d(e, 'b', () => {
            return l
        }), n.d(e, 'c', () => {
            return B
        }), n.d(e, 'd', () => {
            return k
        }), n.d(e, 'e', () => {
            return j
        }), n.d(e, 'f', () => {
            return i
        }), n.d(e, 'g', () => {
            return r
        }), n.d(e, 'h', () => {
            return D
        }), n.d(e, 'i', () => {
            return U
        })
        let r; let i; const o = n('./node_modules/@pixi/core/dist/esm/core.js')
        const a = n('./node_modules/@pixi/math/dist/esm/math.js')
        const s = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        const u = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const c = n('./node_modules/@pixi/display/dist/esm/display.js')
        !(function (t) {
            t.MITER = 'miter', t.BEVEL = 'bevel', t.ROUND = 'round'
        }(r || (r = {}))),
        (function (t) {
            t.BUTT = 'butt', t.ROUND = 'round', t.SQUARE = 'square'
        }(i || (i = {})))
        var l = {
            adaptive: !0,
            maxLength: 10,
            minSegments: 8,
            maxSegments: 2048,
            epsilon: 1e-4,
            _segmentsCount(t, e) {
                if (void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)) return e
                let n = Math.ceil(t / this.maxLength)
                return n < this.minSegments ? n = this.minSegments : n > this.maxSegments && (n = this.maxSegments), n
            }
        }
        var h = (function () {
            function t() {
                this.color = 16777215, this.alpha = 1, this.texture = o.db.WHITE, this.matrix = null, this.visible = !1, this.reset()
            }
            return t.prototype.clone = function () {
                const e = new t()
                return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e
            }, t.prototype.reset = function () {
                this.color = 16777215, this.alpha = 1, this.texture = o.db.WHITE, this.matrix = null, this.visible = !1
            }, t.prototype.destroy = function () {
                this.texture = null, this.matrix = null
            }, t
        }())
        let f = function (t, e) {
            return (f = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }

        function d(t, e) {
            function n() {
                this.constructor = t
            }
            f(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        const p = {
            build(t) {
                t.points = t.shape.points.slice()
            },
            triangulate(t, e) {
                let n = t.points
                var r = t.holes
                var i = e.points
                var o = e.indices
                if (n.length >= 6) {
                    for (var a = [], u = 0; u < r.length; u++) {
                        let c = r[u]
                        a.push(n.length / 2), n = n.concat(c.points)
                    }
                    let l = new Object(s.earcut)(n, a, 2)
                    if (!l) return
                    let h = i.length / 2
                    for (u = 0; u < l.length; u += 3) o.push(l[u] + h), o.push(l[u + 1] + h), o.push(l[u + 2] + h)
                    for (u = 0; u < n.length; u++) i.push(n[u])
                }
            }
        }
        const m = {
            build(t) {
                let e; let n; let r = t.shape
                            var i = t.points
                            var o = r.x
                            var s = r.y
                if (i.length = 0, t.type === a.l.CIRC) { e = r.radius, n = r.radius
}
                else {
                    let u = t.shape
                    e = u.width, n = u.height
                }
                if (e !== 0 && n !== 0) {
                    let c = Math.floor(30 * Math.sqrt(r.radius)) || Math.floor(15 * Math.sqrt(e + n))
                    c /= 2.3
                    for (let l = 2 * Math.PI / c, h = 0; h < c - 0.5; h++) i.push(o + Math.sin(-l * h) * e, s + Math.cos(-l * h) * n)
                    i.push(i[0], i[1])
                }
            },
            triangulate(t, e) {
                let n = t.points
                            var r = e.points
                            var i = e.indices
                            var o = r.length / 2
                            var a = o
                            var s = t.shape
                            var u = t.matrix
                            var c = s.x
                            var l = s.y
                r.push(t.matrix ? u.a * c + u.c * l + u.tx : c, t.matrix ? u.b * c + u.d * l + u.ty : l)
                for (let h = 0; h < n.length; h += 2) r.push(n[h], n[h + 1]), i.push(o++, a, o)
            }
        }
        const y = {
            build(t) {
                let e = t.shape
                var n = e.x
                var r = e.y
                var i = e.width
                var o = e.height
                var a = t.points
                a.length = 0, a.push(n, r, n + i, r, n + i, r + o, n, r + o)
            },
            triangulate(t, e) {
                let n = t.points
                var r = e.points
                var i = r.length / 2
                r.push(n[0], n[1], n[2], n[3], n[6], n[7], n[4], n[5]), e.indices.push(i, i + 1, i + 2, i + 1, i + 2, i + 3)
            }
        }

        function v(t, e, n) {
            return t + (e - t) * n
        }

        function _(t, e, n, r, i, o, a) {
            void 0 === a && (a = [])
            for (var s = a, u = 0, c = 0, l = 0, h = 0, f = 0, d = 0, p = 0, m = 0; p <= 20; ++p) u = v(t, n, m = p / 20), c = v(e, r, m), l = v(n, i, m), h = v(r, o, m), f = v(u, l, m), d = v(c, h, m), p === 0 && s[s.length - 2] === f && s[s.length - 1] === d || s.push(f, d)
            return s
        }
        const g = {
            build(t) {
                const e = t.shape
                var n = t.points
                var r = e.x
                var i = e.y
                var o = e.width
                var a = e.height
                var s = Math.max(0, Math.min(e.radius, Math.min(o, a) / 2))
                n.length = 0, s ? (_(r, i + s, r, i, r + s, i, n), _(r + o - s, i, r + o, i, r + o, i + s, n), _(r + o, i + a - s, r + o, i + a, r + o - s, i + a, n), _(r + s, i + a, r, i + a, r, i + a - s, n)) : n.push(r, i, r + o, i, r + o, i + a, r, i + a)
            },
            triangulate(t, e) {
                for (var n = t.points, r = e.points, i = e.indices, o = r.length / 2, a = new Object(s.earcut)(n, null, 2), u = 0, c = a.length; u < c; u += 3) i.push(a[u] + o), i.push(a[u + 1] + o), i.push(a[u + 2] + o)
                for (u = 0, c = n.length; u < c; u++) r.push(n[u], n[++u])
            }
        }

        function b(t, e, n, r, i, o, a, s) {
            let u, c
            a ? (u = r, c = -n) : (u = -r, c = n)
            const l = t - n * i + u
            const h = e - r * i + c
            const f = t + n * o + u
            const d = e + r * o + c
            return s.push(l, h), s.push(f, d), 2
        }

        function E(t, e, n, r, i, o, a, s) {
            const u = n - t
            const c = r - e
            let l = Math.atan2(u, c)
            let h = Math.atan2(i - t, o - e)
            s && l < h ? l += 2 * Math.PI : !s && l > h && (h += 2 * Math.PI)
            let f = l
            const d = h - l
            const p = Math.abs(d)
            const m = Math.sqrt(u * u + c * c)
            const y = 1 + (15 * p * Math.sqrt(m) / Math.PI >> 0)
            const v = d / y
            if (f += v, s) {
                a.push(t, e), a.push(n, r)
                for (var _ = 1, g = f; _ < y; _++, g += v) a.push(t, e), a.push(t + Math.sin(g) * m, e + Math.cos(g) * m)
                a.push(t, e), a.push(i, o)
            } else {
                a.push(n, r), a.push(t, e)
                for (_ = 1, g = f; _ < y; _++, g += v) a.push(t + Math.sin(g) * m, e + Math.cos(g) * m), a.push(t, e)
                a.push(i, o), a.push(t, e)
            }
            return 2 * y
        }

        function x(t, e) {
            t.lineStyle.native
                ? (function (t, e) {
                        let n = 0
                        const r = t.shape
                        const i = t.points || r.points
                        const o = r.type !== a.l.POLY || r.closeStroke
                        if (i.length !== 0) {
                            const s = e.points
                            const u = e.indices
                            const c = i.length / 2
                            const l = s.length / 2
                            let h = l
                            for (s.push(i[0], i[1]), n = 1; n < c; n++) s.push(i[2 * n], i[2 * n + 1]), u.push(h, h + 1), h++
                            o && u.push(h, l)
                        }
                    }(t, e))
                : (function (t, e) {
                        const n = t.shape
                        let o = t.points || n.points.slice()
                        const s = e.closePointEps
                        if (o.length !== 0) {
                            const u = t.lineStyle
                            const c = new a.g(o[0], o[1])
                            const h = new a.g(o[o.length - 2], o[o.length - 1])
                            const f = n.type !== a.l.POLY || n.closeStroke
                            const d = Math.abs(c.x - h.x) < s && Math.abs(c.y - h.y) < s
                            if (f) {
                                o = o.slice(), d && (o.pop(), o.pop(), h.set(o[o.length - 2], o[o.length - 1]))
                                const p = 0.5 * (c.x + h.x)
                                const m = 0.5 * (h.y + c.y)
                                o.unshift(p, m), o.push(p, m)
                            }
                            const y = e.points
                            const v = o.length / 2
                            let _ = o.length
                            const g = y.length / 2
                            const x = u.width / 2
                            const T = x * x
                            const S = u.miterLimit * u.miterLimit
                            let w = o[0]
                            let O = o[1]
                            let P = o[2]
                            let R = o[3]
                            let A = 0
                            let I = 0
                            let C = -(O - R)
                            let k = w - P
                            let N = 0
                            let M = 0
                            let j = Math.sqrt(C * C + k * k)
                            C /= j, k /= j, C *= x, k *= x
                            const D = u.alignment
                            const L = 2 * (1 - D)
                            const F = 2 * D
                            f || (u.cap === i.ROUND ? _ += E(w - C * (L - F) * 0.5, O - k * (L - F) * 0.5, w - C * L, O - k * L, w + C * F, O + k * F, y, !0) + 2 : u.cap === i.SQUARE && (_ += b(w, O, C, k, L, F, !0, y))), y.push(w - C * L, O - k * L), y.push(w + C * F, O + k * F)
                            for (var B = 1; B < v - 1; ++B) {
                                w = o[2 * (B - 1)], O = o[2 * (B - 1) + 1], P = o[2 * B], R = o[2 * B + 1], A = o[2 * (B + 1)], I = o[2 * (B + 1) + 1], C = -(O - R), k = w - P, C /= j = Math.sqrt(C * C + k * k), k /= j, C *= x, k *= x, N = -(R - I), M = P - A, N /= j = Math.sqrt(N * N + M * M), M /= j, N *= x, M *= x
                                const U = P - w
                                const G = O - R
                                const X = P - A
                                const H = I - R
                                const V = G * X - H * U
                                const W = V < 0
                                if (Math.abs(V) < 0.1) { y.push(P - C * L, R - k * L), y.push(P + C * F, R + k * F)
                                }
                                else {
                                    const Y = (-C + w) * (-k + R) - (-C + P) * (-k + O)
                                    const z = (-N + A) * (-M + R) - (-N + P) * (-M + I)
                                    const q = (U * z - X * Y) / V
                                    const K = (H * Y - G * z) / V
                                    const Z = (q - P) * (q - P) + (K - R) * (K - R)
                                    const $ = P + (q - P) * L
                                    const J = R + (K - R) * L
                                    const Q = P - (q - P) * F
                                    const tt = R - (K - R) * F
                                    const et = W ? L : F
                                    Z <= Math.min(U * U + G * G, X * X + H * H) + et * et * T ? u.join === r.BEVEL || Z / T > S ? (W ? (y.push($, J), y.push(P + C * F, R + k * F), y.push($, J), y.push(P + N * F, R + M * F)) : (y.push(P - C * L, R - k * L), y.push(Q, tt), y.push(P - N * L, R - M * L), y.push(Q, tt)), _ += 2) : u.join === r.ROUND ? W ? (y.push($, J), y.push(P + C * F, R + k * F), _ += E(P, R, P + C * F, R + k * F, P + N * F, R + M * F, y, !0) + 4, y.push($, J), y.push(P + N * F, R + M * F)) : (y.push(P - C * L, R - k * L), y.push(Q, tt), _ += E(P, R, P - C * L, R - k * L, P - N * L, R - M * L, y, !1) + 4, y.push(P - N * L, R - M * L), y.push(Q, tt)) : (y.push($, J), y.push(Q, tt)) : (y.push(P - C * L, R - k * L), y.push(P + C * F, R + k * F), u.join === r.BEVEL || Z / T > S || (u.join === r.ROUND ? _ += W ? E(P, R, P + C * F, R + k * F, P + N * F, R + M * F, y, !0) + 2 : E(P, R, P - C * L, R - k * L, P - N * L, R - M * L, y, !1) + 2 : (W ? (y.push(Q, tt), y.push(Q, tt)) : (y.push($, J), y.push($, J)), _ += 2)), y.push(P - N * L, R - M * L), y.push(P + N * F, R + M * F), _ += 2)
                                }
                            }
                            w = o[2 * (v - 2)], O = o[2 * (v - 2) + 1], P = o[2 * (v - 1)], C = -(O - (R = o[2 * (v - 1) + 1])), k = w - P, C /= j = Math.sqrt(C * C + k * k), k /= j, C *= x, k *= x, y.push(P - C * L, R - k * L), y.push(P + C * F, R + k * F), f || (u.cap === i.ROUND ? _ += E(P - C * (L - F) * 0.5, R - k * (L - F) * 0.5, P - C * L, R - k * L, P + C * F, R + k * F, y, !1) + 2 : u.cap === i.SQUARE && (_ += b(P, R, C, k, L, F, !1, y)))
                            const nt = e.indices
                            const rt = l.epsilon * l.epsilon
                            for (B = g; B < _ + g - 2; ++B) w = y[2 * B], O = y[2 * B + 1], P = y[2 * (B + 1)], R = y[2 * (B + 1) + 1], A = y[2 * (B + 2)], I = y[2 * (B + 2) + 1], Math.abs(w * (R - I) + P * (I - O) + A * (O - R)) < rt || nt.push(B, B + 1, B + 2)
                        }
                    }(t, e))
        }
        let T; const S = (function () {
            function t() {}
            return t.curveTo = function (t, e, n, r, i, o) {
                let a = o[o.length - 2]
                            var s = o[o.length - 1] - e
                            var u = a - t
                            var c = r - e
                            var l = n - t
                            var h = Math.abs(s * l - u * c)
                if (h < 1e-8 || i === 0) return o[o.length - 2] === t && o[o.length - 1] === e || o.push(t, e), null
                var f = s * s + u * u
                            var d = c * c + l * l
                            var p = s * c + u * l
                            var m = i * Math.sqrt(f) / h
                            var y = i * Math.sqrt(d) / h
                            var v = m * p / f
                            var _ = y * p / d
                            var g = m * l + y * u
                            var b = m * c + y * s
                            var E = u * (y + v)
                            var x = s * (y + v)
                            var T = l * (m + _)
                            var S = c * (m + _)
                return {
                    cx: g + t,
                    cy: b + e,
                    radius: i,
                    startAngle: Math.atan2(x - b, E - g),
                    endAngle: Math.atan2(S - b, T - g),
                    anticlockwise: u * c > l * s
                }
            }, t.arc = function (t, e, n, r, i, o, s, u, c) {
                for (let h = s - o, f = l._segmentsCount(Math.abs(h) * i, 40 * Math.ceil(Math.abs(h) / a.f)), d = h / (2 * f), p = 2 * d, m = Math.cos(d), y = Math.sin(d), v = f - 1, _ = v % 1 / v, g = 0; g <= v; ++g) {
                    let b = d + o + p * (g + _ * g)
                                var E = Math.cos(b)
                                var x = -Math.sin(b)
                    c.push((m * E + y * x) * i + n, (m * -x + y * E) * i + r)
                }
            }, t
        }())
        const w = (function () {
            function t() {}
            return t.curveLength = function (t, e, n, r, i, o, a, s) {
                for (var u = 0, c = 0, l = 0, h = 0, f = 0, d = 0, p = 0, m = 0, y = 0, v = 0, _ = 0, g = t, b = e, E = 1; E <= 10; ++E) v = g - (m = (p = (d = (f = 1 - (c = E / 10)) * f) * f) * t + 3 * d * c * n + 3 * f * (l = c * c) * i + (h = l * c) * a), _ = b - (y = p * e + 3 * d * c * r + 3 * f * l * o + h * s), g = m, b = y, u += Math.sqrt(v * v + _ * _)
                return u
            }, t.curveTo = function (e, n, r, i, o, a, s) {
                let u = s[s.length - 2]
                            var c = s[s.length - 1]
                s.length -= 2
                var h = l._segmentsCount(t.curveLength(u, c, e, n, r, i, o, a))
                            var f = 0
                            var d = 0
                            var p = 0
                            var m = 0
                            var y = 0
                s.push(u, c)
                for (let v = 1, _ = 0; v <= h; ++v) p = (d = (f = 1 - (_ = v / h)) * f) * f, y = (m = _ * _) * _, s.push(p * u + 3 * d * _ * e + 3 * f * m * r + y * o, p * c + 3 * d * _ * n + 3 * f * m * i + y * a)
            }, t
        }())
        const O = (function () {
            function t() {}
            return t.curveLength = function (t, e, n, r, i, o) {
                let a = t - 2 * n + i
                            var s = e - 2 * r + o
                            var u = 2 * n - 2 * t
                            var c = 2 * r - 2 * e
                            var l = 4 * (a * a + s * s)
                            var h = 4 * (a * u + s * c)
                            var f = u * u + c * c
                            var d = 2 * Math.sqrt(l + h + f)
                            var p = Math.sqrt(l)
                            var m = 2 * l * p
                            var y = 2 * Math.sqrt(f)
                            var v = h / p
                return (m * d + p * h * (d - y) + (4 * f * l - h * h) * Math.log((2 * p + v + d) / (v + y))) / (4 * m)
            }, t.curveTo = function (e, n, r, i, o) {
                for (let a = o[o.length - 2], s = o[o.length - 1], u = l._segmentsCount(t.curveLength(a, s, e, n, r, i)), c = 0, h = 0, f = 1; f <= u; ++f) {
                    let d = f / u
                    c = a + (e - a) * d, h = s + (n - s) * d, o.push(c + (e + (r - e) * d - c) * d, h + (n + (i - n) * d - h) * d)
                }
            }, t
        }())
        const P = (function () {
            function t() {
                this.reset()
            }
            return t.prototype.begin = function (t, e, n) {
                this.reset(), this.style = t, this.start = e, this.attribStart = n
            }, t.prototype.end = function (t, e) {
                this.attribSize = e - this.attribStart, this.size = t - this.start
            }, t.prototype.reset = function () {
                this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
            }, t
        }())
        const R = ((T = {})[a.l.POLY] = p, T[a.l.CIRC] = m, T[a.l.ELIP] = m, T[a.l.RECT] = y, T[a.l.RREC] = g, T)
        const A = []
        const I = []

        function C(t) {
            for (var e = t.points, n = 0, r = 0; r < e.length - 2; r += 2) n += (e[r + 2] - e[r]) * (e[r + 3] + e[r + 1])
            return n > 0
        }
        var k = (function () {
            function t(t, e, n, r) {
                void 0 === e && (e = null), void 0 === n && (n = null), void 0 === r && (r = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = n, this.fillStyle = e, this.matrix = r, this.type = t.type
            }
            return t.prototype.clone = function () {
                return new t(this.shape, this.fillStyle, this.lineStyle, this.matrix)
            }, t.prototype.destroy = function () {
                this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
            }, t
        }())
        let N = new a.g()
        let M = new c.a()
        var j = (function (t) {
            function e() {
                const e = t.call(this) || this
                return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new c.a(), e.boundsDirty = -1, e
            }
            return d(e, t), Object.defineProperty(e.prototype, 'bounds', {
                get() {
                    return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.invalidate = function () {
                this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0
                for (var t = 0; t < this.drawCalls.length; t++) this.drawCalls[t].texArray.clear(), I.push(this.drawCalls[t])
                this.drawCalls.length = 0
                for (t = 0; t < this.batches.length; t++) {
                    const e = this.batches[t]
                    e.reset(), A.push(e)
                }
                this.batches.length = 0
            }, e.prototype.clear = function () {
                return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
            }, e.prototype.drawShape = function (t, e, n, r) {
                void 0 === e && (e = null), void 0 === n && (n = null), void 0 === r && (r = null)
                let i = new k(t, e, n, r)
                return this.graphicsData.push(i), this.dirty++, this
            }, e.prototype.drawHole = function (t, e) {
                if (void 0 === e && (e = null), !this.graphicsData.length) return null
                let n = new k(t, null, null, e)
                var r = this.graphicsData[this.graphicsData.length - 1]
                return n.lineStyle = r.lineStyle, r.holes.push(n), this.dirty++, this
            }, e.prototype.destroy = function () {
                t.prototype.destroy.call(this)
                for (let e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy()
                this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
            }, e.prototype.containsPoint = function (t) {
                for (let e = this.graphicsData, n = 0; n < e.length; ++n) {
                    const r = e[n]
                    if (r.fillStyle.visible && (r.shape && (r.matrix ? r.matrix.applyInverse(t, N) : N.copyFrom(t), r.shape.contains(N.x, N.y)))) {
                        let i = !1
                        if (r.holes) {
                            for (let o = 0; o < r.holes.length; o++) {
                                if (r.holes[o].shape.contains(N.x, N.y)) {
                                    i = !0
                                    break
                                }
                            }
                        }
                        if (!i) return !0
                    }
                }
                return !1
            }, e.prototype.updateBatches = function (t) {
                if (this.graphicsData.length) {
                    if (this.validateBatching()) {
                        this.cacheDirty = this.dirty
                        let e = this.uvs
                        var n = this.graphicsData
                        var r = null
                        var i = null
                        this.batches.length > 0 && (i = (r = this.batches[this.batches.length - 1]).style)
                        for (let o = this.shapeIndex; o < n.length; o++) {
                            this.shapeIndex++
                            let a = n[o]
                            var s = a.fillStyle
                            var c = a.lineStyle
                            R[a.type].build(a), a.matrix && this.transformPoints(a.points, a.matrix)
                            for (let l = 0; l < 2; l++) {
                                const h = l === 0 ? s : c
                                if (h.visible) {
                                    const f = h.texture.baseTexture
                                    var d = this.indices.length
                                    var p = this.points.length / 2
                                    f.wrapMode = u.s.REPEAT, l === 0 ? this.processFill(a) : this.processLine(a)
                                    let m = this.points.length / 2 - p
                                    m !== 0 && (r && !this._compareStyles(i, h) && (r.end(d, p), r = null), r || ((r = A.pop() || new P()).begin(h, d, p), this.batches.push(r), i = h), this.addUvs(this.points, e, h.texture, p, m, h.matrix))
                                }
                            }
                        }
                        const y = this.indices.length
                        var v = this.points.length / 2
                        if (r && r.end(y, v), this.batches.length !== 0) {
                            if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) { this.indicesUint16.set(this.indices)
                            }
                            else {
                                const _ = v > 65535 && t
                                this.indicesUint16 = _ ? new Uint32Array(this.indices) : new Uint16Array(this.indices)
                            }
                            this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
                        } else { this.batchable = !0
                        }
                    }
                } else { this.batchable = !0
                }
            }, e.prototype._compareStyles = function (t, e) {
                return !(!t || !e) && (t.texture.baseTexture === e.texture.baseTexture && (t.color + t.alpha === e.color + e.alpha && !!t.native == !!e.native))
            }, e.prototype.validateBatching = function () {
                if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1
                for (let t = 0, e = this.graphicsData.length; t < e; t++) {
                    const n = this.graphicsData[t]
                    var r = n.fillStyle
                    var i = n.lineStyle
                    if (r && !r.texture.baseTexture.valid) return !1
                    if (i && !i.texture.baseTexture.valid) return !1
                }
                return !0
            }, e.prototype.packBatches = function () {
                this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs)
                for (let t = this.batches, e = 0, n = t.length; e < n; e++) {
                    for (let r = t[e], i = 0; i < r.size; i++) {
                        let o = r.start + i
                        this.indicesUint16[o] = this.indicesUint16[o] - r.attribStart
                    }
                }
            }, e.prototype.isBatchable = function () {
                if (this.points.length > 131070) return !1
                for (let t = this.batches, n = 0; n < t.length; n++) {
                    if (t[n].style.native) return !1
                }
                return this.points.length < 2 * e.BATCHABLE_SIZE
            }, e.prototype.buildDrawCalls = function () {
                for (var t = ++o.h._globalBatch, e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), I.push(this.drawCalls[e])
                this.drawCalls.length = 0
                let n = this.colors
                var r = this.textureIds
                var i = I.pop()
                i || ((i = new o.i()).texArray = new o.o()), i.texArray.count = 0, i.start = 0, i.size = 0, i.type = u.f.TRIANGLES
                let a = 0
                var s = null
                var c = 0
                var l = !1
                var h = u.f.TRIANGLES
                var f = 0
                this.drawCalls.push(i)
                for (e = 0; e < this.batches.length; e++) {
                    const d = this.batches[e]
                    var p = d.style
                    var m = p.texture.baseTexture
                    l !== !!p.native && (h = (l = !!p.native) ? u.f.LINES : u.f.TRIANGLES, s = null, a = 8, t++), s !== m && (s = m, m._batchEnabled !== t && (a === 8 && (t++, a = 0, i.size > 0 && ((i = I.pop()) || ((i = new o.i()).texArray = new o.o()), this.drawCalls.push(i)), i.start = f, i.size = 0, i.texArray.count = 0, i.type = h), m.touched = 1, m._batchEnabled = t, m._batchLocation = a, m.wrapMode = u.s.REPEAT, i.texArray.elements[i.texArray.count++] = m, a++)), i.size += d.size, f += d.size, c = m._batchLocation, this.addColors(n, p.color, p.alpha, d.attribSize, d.attribStart), this.addTextureIds(r, c, d.attribSize, d.attribStart)
                }
                o.h._globalBatch = t, this.packAttributes()
            }, e.prototype.packAttributes = function () {
                for (var t = this.points, e = this.uvs, n = this.colors, r = this.textureIds, i = new ArrayBuffer(3 * t.length * 4), o = new Float32Array(i), a = new Uint32Array(i), s = 0, u = 0; u < t.length / 2; u++) o[s++] = t[2 * u], o[s++] = t[2 * u + 1], o[s++] = e[2 * u], o[s++] = e[2 * u + 1], a[s++] = n[u], o[s++] = r[u]
                this._buffer.update(i), this._indexBuffer.update(this.indicesUint16)
            }, e.prototype.processFill = function (t) {
                t.holes.length ? (this.processHoles(t.holes), p.triangulate(t, this)) : R[t.type].triangulate(t, this)
            }, e.prototype.processLine = function (t) {
                x(t, this)
                for (let e = 0; e < t.holes.length; e++) x(t.holes[e], this)
            }, e.prototype.processHoles = function (t) {
                for (let e = 0; e < t.length; e++) {
                    const n = t[e]
                    R[n.type].build(n), n.matrix && this.transformPoints(n.points, n.matrix)
                }
            }, e.prototype.calculateBounds = function () {
                const t = this._bounds
                var e = M
                var n = a.d.IDENTITY
                this._bounds.clear(), e.clear()
                for (let r = 0; r < this.graphicsData.length; r++) {
                    const i = this.graphicsData[r]
                    var o = i.shape
                    var s = i.type
                    var u = i.lineStyle
                    var c = i.matrix || a.d.IDENTITY
                    var l = 0
                    if (u && u.visible) {
                        const h = u.alignment
                        l = u.width, s === a.l.POLY ? C(o) ? l *= 1 - h : l *= h : l *= Math.max(0, h)
                    }
                    if (n !== c && (e.isEmpty() || (t.addBoundsMatrix(e, n), e.clear()), n = c), s === a.l.RECT || s === a.l.RREC) {
                        const f = o
                        e.addFramePad(f.x, f.y, f.x + f.width, f.y + f.height, l, l)
                    } else if (s === a.l.CIRC) {
                        const d = o
                        e.addFramePad(d.x, d.y, d.x, d.y, d.radius + l, d.radius + l)
                    } else if (s === a.l.ELIP) {
                        const p = o
                        e.addFramePad(p.x, p.y, p.x, p.y, p.width + l, p.height + l)
                    } else {
                        const m = o
                        t.addVerticesMatrix(n, m.points, 0, m.points.length, l, l)
                    }
                }
                e.isEmpty() || t.addBoundsMatrix(e, n), t.pad(this.boundsPadding, this.boundsPadding)
            }, e.prototype.transformPoints = function (t, e) {
                for (let n = 0; n < t.length / 2; n++) {
                    const r = t[2 * n]
                    var i = t[2 * n + 1]
                    t[2 * n] = e.a * r + e.c * i + e.tx, t[2 * n + 1] = e.b * r + e.d * i + e.ty
                }
            }, e.prototype.addColors = function (t, e, n, r, i) {
                void 0 === i && (i = 0)
                let o = (e >> 16) + (65280 & e) + ((255 & e) << 16)
                var a = new Object(s.premultiplyTint)(o, n)
                t.length = Math.max(t.length, i + r)
                for (let u = 0; u < r; u++) t[i + u] = a
            }, e.prototype.addTextureIds = function (t, e, n, r) {
                void 0 === r && (r = 0), t.length = Math.max(t.length, r + n)
                for (let i = 0; i < n; i++) t[r + i] = e
            }, e.prototype.addUvs = function (t, e, n, r, i, o) {
                void 0 === o && (o = null)
                for (var a = 0, s = e.length, u = n.frame; a < i;) {
                    let c = t[2 * (r + a)]
                    var l = t[2 * (r + a) + 1]
                    if (o) {
                        const h = o.a * c + o.c * l + o.tx
                        l = o.b * c + o.d * l + o.ty, c = h
                    }
                    a++, e.push(c / u.width, l / u.height)
                }
                const f = n.baseTexture;
                (u.width < f.width || u.height < f.height) && this.adjustUvs(e, n, s, i)
            }, e.prototype.adjustUvs = function (t, e, n, r) {
                for (var i = e.baseTexture, o = 1e-6, a = n + 2 * r, s = e.frame, u = s.width / i.width, c = s.height / i.height, l = s.x / s.width, h = s.y / s.height, f = Math.floor(t[n] + o), d = Math.floor(t[n + 1] + o), p = n + 2; p < a; p += 2) f = Math.min(f, Math.floor(t[p] + o)), d = Math.min(d, Math.floor(t[p + 1] + o))
                l -= f, h -= d
                for (p = n; p < a; p += 2) t[p] = (t[p] + l) * u, t[p + 1] = (t[p + 1] + h) * c
            }, e.BATCHABLE_SIZE = 100, e
        }(o.j))
        var D = (function (t) {
            function e() {
                const e = t !== null && t.apply(this, arguments) || this
                return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = i.BUTT, e.join = r.MITER, e.miterLimit = 10, e
            }
            return d(e, t), e.prototype.clone = function () {
                const t = new e()
                return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t
            }, e.prototype.reset = function () {
                t.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1
            }, e
        }(h))
        let L = new Float32Array(3)
        let F = {}
        var B = (function (t) {
            function e(e) {
                void 0 === e && (e = null)
                let n = t.call(this) || this
                return n.shader = null, n.pluginName = 'batch', n.currentPath = null, n.batches = [], n.batchTint = -1, n.batchDirty = -1, n.vertexData = null, n._fillStyle = new h(), n._lineStyle = new D(), n._matrix = null, n._holeMode = !1, n.state = o.Z.for2d(), n._geometry = e || new j(), n._geometry.refCount++, n._transformID = -1, n.tint = 16777215, n.blendMode = u.b.NORMAL, n
            }
            return d(e, t), Object.defineProperty(e.prototype, 'geometry', {
                get() {
                    return this._geometry
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.clone = function () {
                return this.finishPoly(), new e(this._geometry)
            }, Object.defineProperty(e.prototype, 'blendMode', {
                get() {
                    return this.state.blendMode
                },
                set(t) {
                    this.state.blendMode = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'tint', {
                get() {
                    return this._tint
                },
                set(t) {
                    this._tint = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'fill', {
                get() {
                    return this._fillStyle
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'line', {
                get() {
                    return this._lineStyle
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.lineStyle = function (t, e, n, r, i) {
                return void 0 === t && (t = null), void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = 0.5), void 0 === i && (i = !1), typeof t == 'number' && (t = {
                    width: t,
                    color: e,
                    alpha: n,
                    alignment: r,
                    native: i
                }), this.lineTextureStyle(t)
            }, e.prototype.lineTextureStyle = function (t) {
                t = Object.assign({
                    width: 0,
                    texture: o.db.WHITE,
                    color: t && t.texture ? 16777215 : 0,
                    alpha: 1,
                    matrix: null,
                    alignment: 0.5,
                    native: !1,
                    cap: i.BUTT,
                    join: r.MITER,
                    miterLimit: 10
                }, t), this.currentPath && this.startPoly()
                let e = t.width > 0 && t.alpha > 0
                return e
                    ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._lineStyle, {
                            visible: e
                        }, t))
                    : this._lineStyle.reset(), this
            }, e.prototype.startPoly = function () {
                if (this.currentPath) {
                    const t = this.currentPath.points
                    var e = this.currentPath.points.length
                    e > 2 && (this.drawShape(this.currentPath), this.currentPath = new a.h(), this.currentPath.closeStroke = !1, this.currentPath.points.push(t[e - 2], t[e - 1]))
                } else { this.currentPath = new a.h(), this.currentPath.closeStroke = !1
                }
            }, e.prototype.finishPoly = function () {
                this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
            }, e.prototype.moveTo = function (t, e) {
                return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = e, this
            }, e.prototype.lineTo = function (t, e) {
                this.currentPath || this.moveTo(0, 0)
                let n = this.currentPath.points
                var r = n[n.length - 2]
                var i = n[n.length - 1]
                return r === t && i === e || n.push(t, e), this
            }, e.prototype._initCurve = function (t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
            }, e.prototype.quadraticCurveTo = function (t, e, n, r) {
                this._initCurve()
                let i = this.currentPath.points
                return i.length === 0 && this.moveTo(0, 0), O.curveTo(t, e, n, r, i), this
            }, e.prototype.bezierCurveTo = function (t, e, n, r, i, o) {
                return this._initCurve(), w.curveTo(t, e, n, r, i, o, this.currentPath.points), this
            }, e.prototype.arcTo = function (t, e, n, r, i) {
                this._initCurve(t, e)
                let o = this.currentPath.points
                var a = S.curveTo(t, e, n, r, i, o)
                if (a) {
                    const s = a.cx
                    var u = a.cy
                    var c = a.radius
                    var l = a.startAngle
                    var h = a.endAngle
                    var f = a.anticlockwise
                    this.arc(s, u, c, l, h, f)
                }
                return this
            }, e.prototype.arc = function (t, e, n, r, i, o) {
                if (void 0 === o && (o = !1), r === i) return this
                if (!o && i <= r ? i += a.f : o && r <= i && (r += a.f), i - r === 0) return this
                let s = t + Math.cos(r) * n
                var u = e + Math.sin(r) * n
                var c = this._geometry.closePointEps
                var l = this.currentPath ? this.currentPath.points : null
                if (l) {
                    const h = Math.abs(l[l.length - 2] - s)
                    var f = Math.abs(l[l.length - 1] - u)
                    h < c && f < c || l.push(s, u)
                } else { this.moveTo(s, u), l = this.currentPath.points
                }
                return S.arc(s, u, t, e, n, r, i, o, l), this
            }, e.prototype.beginFill = function (t, e) {
                return void 0 === t && (t = 0), void 0 === e && (e = 1), this.beginTextureFill({
                    texture: o.db.WHITE,
                    color: t,
                    alpha: e
                })
            }, e.prototype.beginTextureFill = function (t) {
                t = Object.assign({
                    texture: o.db.WHITE,
                    color: 16777215,
                    alpha: 1,
                    matrix: null
                }, t), this.currentPath && this.startPoly()
                let e = t.alpha > 0
                return e
                    ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, {
                            visible: e
                        }, t))
                    : this._fillStyle.reset(), this
            }, e.prototype.endFill = function () {
                return this.finishPoly(), this._fillStyle.reset(), this
            }, e.prototype.drawRect = function (t, e, n, r) {
                return this.drawShape(new a.j(t, e, n, r))
            }, e.prototype.drawRoundedRect = function (t, e, n, r, i) {
                return this.drawShape(new a.k(t, e, n, r, i))
            }, e.prototype.drawCircle = function (t, e, n) {
                return this.drawShape(new a.a(t, e, n))
            }, e.prototype.drawEllipse = function (t, e, n, r) {
                return this.drawShape(new a.c(t, e, n, r))
            }, e.prototype.drawPolygon = function () {
                for (var t, e = arguments, n = [], r = 0; r < arguments.length; r++) n[r] = e[r]
                let i = !0
                var o = n[0]
                o.points ? (i = o.closeStroke, t = o.points) : t = Array.isArray(n[0]) ? n[0] : n
                let s = new a.h(t)
                return s.closeStroke = i, this.drawShape(s), this
            }, e.prototype.drawShape = function (t) {
                return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
            }, e.prototype.clear = function () {
                return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
            }, e.prototype.isFastRect = function () {
                const t = this._geometry.graphicsData
                return !(t.length !== 1 || t[0].shape.type !== a.l.RECT || t[0].holes.length || t[0].lineStyle.visible && t[0].lineStyle.width)
            }, e.prototype._render = function (t) {
                this.finishPoly()
                let e = this._geometry
                var n = t.context.supports.uint32Indices
                e.updateBatches(n), e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t))
            }, e.prototype._populateBatches = function () {
                const t = this._geometry
                var e = this.blendMode
                var n = t.batches.length
                this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.batches.length = n, this.vertexData = new Float32Array(t.points)
                for (let r = 0; r < n; r++) {
                    const i = t.batches[r]
                    var o = i.style.color
                    var a = new Float32Array(this.vertexData.buffer, 4 * i.attribStart * 2, 2 * i.attribSize)
                    var u = new Float32Array(t.uvsFloat32.buffer, 4 * i.attribStart * 2, 2 * i.attribSize)
                    var c = {
                        vertexData: a,
                        blendMode: e,
                        indices: new Uint16Array(t.indicesUint16.buffer, 2 * i.start, i.size),
                        uvs: u,
                        _batchRGB: new Object(s.hex2rgb)(o),
                        _tintRGB: o,
                        _texture: i.style.texture,
                        alpha: i.style.alpha,
                        worldAlpha: 1
                    }
                    this.batches[r] = c
                }
            }, e.prototype._renderBatched = function (t) {
                if (this.batches.length) {
                    t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints()
                    for (let e = 0, n = this.batches.length; e < n; e++) {
                        const r = this.batches[e]
                        r.worldAlpha = this.worldAlpha * r.alpha, t.plugins[this.pluginName].render(r)
                    }
                }
            }, e.prototype._renderDirect = function (t) {
                const e = this._resolveDirectShader(t)
                var n = this._geometry
                var r = this.tint
                var i = this.worldAlpha
                var o = e.uniforms
                var a = n.drawCalls
                o.translationMatrix = this.transform.worldTransform, o.tint[0] = (r >> 16 & 255) / 255 * i, o.tint[1] = (r >> 8 & 255) / 255 * i, o.tint[2] = (255 & r) / 255 * i, o.tint[3] = i, t.shader.bind(e), t.geometry.bind(n, e), t.state.set(this.state)
                for (let s = 0, u = a.length; s < u; s++) this._renderDrawCallDirect(t, n.drawCalls[s])
            }, e.prototype._renderDrawCallDirect = function (t, e) {
                for (var n = e.texArray, r = e.type, i = e.size, o = e.start, a = n.count, s = 0; s < a; s++) t.texture.bind(n.elements[s], s)
                t.geometry.draw(r, i, o)
            }, e.prototype._resolveDirectShader = function (t) {
                let e = this.shader
                var n = this.pluginName
                if (!e) {
                    if (!F[n]) {
                        for (var r = t.plugins.batch.MAX_TEXTURES, i = new Int32Array(r), s = 0; s < r; s++) i[s] = s
                        let u = {
                            tint: new Float32Array([1, 1, 1, 1]),
                            translationMatrix: new a.d(),
                            default: o.ib.from({
                                uSamplers: i
                            }, !0)
                        }
                        var c = t.plugins[n]._shader.program
                        F[n] = new o.W(c, u)
                    }
                    e = F[n]
                }
                return e
            }, e.prototype._calculateBounds = function () {
                this.finishPoly()
                let t = this._geometry
                if (t.graphicsData.length) {
                    const e = t.bounds
                    var n = e.minX
                    var r = e.minY
                    var i = e.maxX
                    var o = e.maxY
                    this._bounds.addFrame(this.transform, n, r, i, o)
                }
            }, e.prototype.containsPoint = function (t) {
                return this.worldTransform.applyInverse(t, e._TEMP_POINT), this._geometry.containsPoint(e._TEMP_POINT)
            }, e.prototype.calculateTints = function () {
                if (this.batchTint !== this.tint) {
                    this.batchTint = this.tint
                    for (let t = new Object(s.hex2rgb)(this.tint, L), e = 0; e < this.batches.length; e++) {
                        const n = this.batches[e]
                        var r = n._batchRGB
                        var i = (t[0] * r[0] * 255 << 16) + (t[1] * r[1] * 255 << 8) + (0 | t[2] * r[2] * 255)
                        n._tintRGB = (i >> 16) + (65280 & i) + ((255 & i) << 16)
                    }
                }
            }, e.prototype.calculateVertices = function () {
                const t = this.transform._worldID
                if (this._transformID !== t) {
                    this._transformID = t
                    for (let e = this.transform.worldTransform, n = e.a, r = e.b, i = e.c, o = e.d, a = e.tx, s = e.ty, u = this._geometry.points, c = this.vertexData, l = 0, h = 0; h < u.length; h += 2) {
                        const f = u[h]
                        var d = u[h + 1]
                        c[l++] = n * f + i * d + a, c[l++] = o * d + r * f + s
                    }
                }
            }, e.prototype.closePath = function () {
                const t = this.currentPath
                return t && (t.closeStroke = !0, this.finishPoly()), this
            }, e.prototype.setMatrix = function (t) {
                return this._matrix = t, this
            }, e.prototype.beginHole = function () {
                return this.finishPoly(), this._holeMode = !0, this
            }, e.prototype.endHole = function () {
                return this.finishPoly(), this._holeMode = !1, this
            }, e.prototype.destroy = function (e) {
                this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, t.prototype.destroy.call(this, e)
            }, e._TEMP_POINT = new a.g(), e
        }(c.b))
        var U = {
            buildPoly: p,
            buildCircle: m,
            buildRectangle: y,
            buildRoundedRectangle: g,
            buildLine: x,
            ArcUtils: S,
            BezierUtils: w,
            QuadraticUtils: O,
            BatchPart: P,
            FILL_COMMANDS: R,
            BATCH_POOL: A,
            DRAW_CALL_POOL: I
        }
    },
    './node_modules/@pixi/loaders/dist/esm/loaders.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return b
        }), n.d(e, 'b', () => {
            return g
        }), n.d(e, 'c', () => {
            return d
        }), n.d(e, 'd', () => {
            return E
        })
        const r = n('./node_modules/@pixi/core/dist/esm/core.js')
        const i = (function () {
            function t(t, e, n) {
                void 0 === e && (e = !1), this._fn = t, this._once = e, this._thisArg = n, this._next = this._prev = this._owner = null
            }
            return t.prototype.detach = function () {
                return this._owner !== null && (this._owner.detach(this), !0)
            }, t
        }())
        /*!
             * @pixi/loaders - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/loaders is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        function o(t, e) {
            return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e
        }
        const a = (function () {
            function t() {
                this._head = this._tail = void 0
            }
            return t.prototype.handlers = function (t) {
                void 0 === t && (t = !1)
                let e = this._head
                if (t) return !!e
                for (var n = []; e;) n.push(e), e = e._next
                return n
            }, t.prototype.has = function (t) {
                if (!(t instanceof i)) throw new Error('MiniSignal#has(): First arg must be a SignalBinding object.')
                return t._owner === this
            }, t.prototype.dispatch = function () {
                for (var t = arguments, e = [], n = 0; n < arguments.length; n++) e[n] = t[n]
                let r = this._head
                if (!r) return !1
                for (; r;) r._once && this.detach(r), r._fn.apply(r._thisArg, e), r = r._next
                return !0
            }, t.prototype.add = function (t, e) {
                if (void 0 === e && (e = null), typeof t != 'function') throw new Error('MiniSignal#add(): First arg must be a Function.')
                return o(this, new i(t, !1, e))
            }, t.prototype.once = function (t, e) {
                if (void 0 === e && (e = null), typeof t != 'function') throw new Error('MiniSignal#once(): First arg must be a Function.')
                return o(this, new i(t, !0, e))
            }, t.prototype.detach = function (t) {
                if (!(t instanceof i)) throw new Error('MiniSignal#detach(): First arg must be a SignalBinding object.')
                return t._owner !== this || (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null), this
            }, t.prototype.detachAll = function () {
                let t = this._head
                if (!t) return this
                for (this._head = this._tail = null; t;) t._owner = null, t = t._next
                return this
            }, t
        }())

        function s(t, e) {
            e = e || {}
            for (var n = {
                    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
                    q: {
                        name: 'queryKey',
                        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                    },
                    parser: {
                        strict: /^(?:([^:/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                        loose: /^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#/]*\.[^?#/.]+(?:[?#]|$)))*\/?)?([^?#/]*))(?:\?([^#]*))?(?:#(.*))?)/
                    }
                }, r = n.parser[e.strictMode ? 'strict' : 'loose'].exec(t), i = {}, o = 14; o--;) i[n.key[o]] = r[o] || ''
            return i[n.q.name] = {}, i[n.key[12]].replace(n.q.parser, (t, e, r) => {
                e && (i[n.q.name][e] = r)
            }), i
        }
        const u = !(!self.XDomainRequest || 'withCredentials' in new XMLHttpRequest())
        let c = null

        function l() {}

        function h(t, e, n) {
            e && e.indexOf('.') === 0 && (e = e.substring(1)), e && (t[e] = n)
        }

        function f(t) {
            return t.toString().replace('object ', '')
        }
        var d = (function () {
            function t(e, n, r) {
                if (this._dequeue = l, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof e != 'string' || typeof n != 'string') throw new Error('Both name and url are required for constructing a resource.')
                r = r || {}, this._flags = 0, this._setFlag(t.STATUS_FLAGS.DATA_URL, n.indexOf('data:') === 0), this.name = e, this.url = n, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === r.crossOrigin ? 'anonymous' : r.crossOrigin, this.timeout = r.timeout || 0, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = l, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new a(), this.onProgress = new a(), this.onComplete = new a(), this.onAfterMiddleware = new a()
            }
            return t.setExtensionLoadType = function (e, n) {
                h(t._loadTypeMap, e, n)
            }, t.setExtensionXhrType = function (e, n) {
                h(t._xhrTypeMap, e, n)
            }, Object.defineProperty(t.prototype, 'isDataUrl', {
                get() {
                    return this._hasFlag(t.STATUS_FLAGS.DATA_URL)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'isComplete', {
                get() {
                    return this._hasFlag(t.STATUS_FLAGS.COMPLETE)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'isLoading', {
                get() {
                    return this._hasFlag(t.STATUS_FLAGS.LOADING)
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.complete = function () {
                this._clearEvents(), this._finish()
            }, t.prototype.abort = function (e) {
                if (!this.error) {
                    if (this.error = new Error(e), this._clearEvents(), this.xhr) { this.xhr.abort()
                    }
                    else if (this.xdr) { this.xdr.abort()
                    }
                    else if (this.data) {
                        if (this.data.src) { this.data.src = t.EMPTY_GIF
                        }
                        else {
                            for (; this.data.firstChild;) this.data.removeChild(this.data.firstChild)
                        }
                    }
                    this._finish()
                }
            }, t.prototype.load = function (e) {
                const n = this
                if (!this.isLoading) {
                    if (this.isComplete) { e && setTimeout(() => {
                        return e(n)
                    }, 1)
                    }
                    else { switch (e && this.onComplete.once(e), this._setFlag(t.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && typeof this.crossOrigin == 'string' || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
                        case t.LOAD_TYPE.IMAGE:
                            this.type = t.TYPE.IMAGE, this._loadElement('image')
                            break;
                        case t.LOAD_TYPE.AUDIO:
                            this.type = t.TYPE.AUDIO, this._loadSourceElement('audio')
                            break;
                        case t.LOAD_TYPE.VIDEO:
                            this.type = t.TYPE.VIDEO, this._loadSourceElement('video')
                            break;
                        case t.LOAD_TYPE.XHR:
                        default:
                            u && this.crossOrigin ? this._loadXdr() : this._loadXhr()
                    }
                    }
                }
            }, t.prototype._hasFlag = function (t) {
                return (this._flags & t) != 0
            }, t.prototype._setFlag = function (t, e) {
                this._flags = e ? this._flags | t : this._flags & ~t
            }, t.prototype._clearEvents = function () {
                clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener('error', this._boundOnError, !1), this.data.removeEventListener('load', this._boundComplete, !1), this.data.removeEventListener('progress', this._boundOnProgress, !1), this.data.removeEventListener('canplaythrough', this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener('error', this._boundXhrOnError, !1), this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, !1), this.xhr.removeEventListener('abort', this._boundXhrOnAbort, !1), this.xhr.removeEventListener('progress', this._boundOnProgress, !1), this.xhr.removeEventListener('load', this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null))
            }, t.prototype._finish = function () {
                if (this.isComplete) throw new Error('Complete called again for an already completed resource.')
                this._setFlag(t.STATUS_FLAGS.COMPLETE, !0), this._setFlag(t.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this)
            }, t.prototype._loadElement = function (t) {
                this.metadata.loadElement ? this.data = this.metadata.loadElement : t === 'image' && void 0 !== self.Image ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener('error', this._boundOnError, !1), this.data.addEventListener('load', this._boundComplete, !1), this.data.addEventListener('progress', this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
            }, t.prototype._loadSourceElement = function (t) {
                if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === 'audio' && void 0 !== self.Audio ? this.data = new Audio() : this.data = document.createElement(t), this.data !== null) {
                    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource) {
                        if (navigator.isCocoonJS) { this.data.src = Array.isArray(this.url) ? this.url[0] : this.url
                        }
                        else if (Array.isArray(this.url)) {
                            for (var e = this.metadata.mimeType, n = 0; n < this.url.length; ++n) this.data.appendChild(this._createSource(t, this.url[n], Array.isArray(e) ? e[n] : e))
                        }
                        else {
                            e = this.metadata.mimeType
                            this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e))
                        }
                    }
                    this.data.addEventListener('error', this._boundOnError, !1), this.data.addEventListener('load', this._boundComplete, !1), this.data.addEventListener('progress', this._boundOnProgress, !1), this.data.addEventListener('canplaythrough', this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
                } else { this.abort(`Unsupported element: ${ t}`)
                }
            }, t.prototype._loadXhr = function () {
                typeof this.xhrType != 'string' && (this.xhrType = this._determineXhrType())
                const e = this.xhr = new XMLHttpRequest()
                e.open('GET', this.url, !0), e.timeout = this.timeout, this.xhrType === t.XHR_RESPONSE_TYPE.JSON || this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = t.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener('error', this._boundXhrOnError, !1), e.addEventListener('timeout', this._boundXhrOnTimeout, !1), e.addEventListener('abort', this._boundXhrOnAbort, !1), e.addEventListener('progress', this._boundOnProgress, !1), e.addEventListener('load', this._boundXhrOnLoad, !1), e.send()
            }, t.prototype._loadXdr = function () {
                typeof this.xhrType != 'string' && (this.xhrType = this._determineXhrType())
                const t = this.xhr = new self.XDomainRequest()
                t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open('GET', this.url, !0), setTimeout(() => {
                    return t.send()
                }, 1)
            }, t.prototype._createSource = function (t, e, n) {
                n || (n = `${t}/${this._getExtension(e)}`)
                const r = document.createElement('source')
                return r.src = e, r.type = n, r
            }, t.prototype._onError = function (t) {
                this.abort(`Failed to load element using: ${t.target.nodeName}`)
            }, t.prototype._onProgress = function (t) {
                t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total)
            }, t.prototype._onTimeout = function () {
                this.abort('Load timed out.')
            }, t.prototype._xhrOnError = function () {
                const t = this.xhr
                this.abort(`${f(t)} Request failed. Status: ${t.status}, text: "${t.statusText}"`)
            }, t.prototype._xhrOnTimeout = function () {
                const t = this.xhr
                this.abort(`${f(t)} Request timed out.`)
            }, t.prototype._xhrOnAbort = function () {
                const t = this.xhr
                this.abort(`${f(t)} Request was aborted by the user.`)
            }, t.prototype._xhrOnLoad = function () {
                const e = this.xhr
                let n = ''
                let r = void 0 === e.status ? 200 : e.status
                if (e.responseType !== '' && e.responseType !== 'text' && void 0 !== e.responseType || (n = e.responseText), r === 0 && (n.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER) ? r = 200 : r === 1223 && (r = 204), (r / 100 | 0) === 2) {
                    if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT) { this.data = n, this.type = t.TYPE.TEXT
                    }
                    else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON) { try {
                        this.data = JSON.parse(n), this.type = t.TYPE.JSON
                    } catch (t) {
                        return void this.abort(`Error trying to parse loaded json: ${ t}`)
                    }
                    } else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT) { try {
                        if (self.DOMParser) {
                            const i = new DOMParser()
                            this.data = i.parseFromString(n, 'text/xml')
                        } else {
                            const o = document.createElement('div')
                            o.innerHTML = n, this.data = o
                        }
                        this.type = t.TYPE.XML
                    } catch (t) {
                        return void this.abort(`Error trying to parse loaded xml: ${ t}`)
                    }
                    } else { this.data = e.response || n
                    }
                    this.complete()
                } else { this.abort(`[${ e.status }] ${ e.statusText }: ${ e.responseURL}`)
                }
            }, t.prototype._determineCrossOrigin = function (t, e) {
                if (t.indexOf('data:') === 0) return ''
                if (self.origin !== self.location.origin) return 'anonymous'
                e = e || self.location, c || (c = document.createElement('a')), c.href = t
                const n = s(c.href, {
                    strictMode: !0
                })
                let r = !n.port && e.port === '' || n.port === e.port
                let i = n.protocol ? `${n.protocol}:` : ''
                return n.host === e.hostname && r && i === e.protocol ? '' : 'anonymous'
            }, t.prototype._determineXhrType = function () {
                return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT
            }, t.prototype._determineLoadType = function () {
                return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR
            }, t.prototype._getExtension = function (t) {
                void 0 === t && (t = this.url)
                let e = ''
                if (this.isDataUrl) {
                    const n = t.indexOf('/')
                    e = t.substring(n + 1, t.indexOf(';', n))
                } else {
                    const r = t.indexOf('?')
                    let i = t.indexOf('#')
                    let o = Math.min(r > -1 ? r : t.length, i > -1 ? i : t.length)
                    e = (t = t.substring(0, o)).substring(t.lastIndexOf('.') + 1)
                }
                return e.toLowerCase()
            }, t.prototype._getMimeFromXhrType = function (e) {
                switch (e) {
                    case t.XHR_RESPONSE_TYPE.BUFFER:
                        return 'application/octet-binary'
                    case t.XHR_RESPONSE_TYPE.BLOB:
                        return 'application/blob'
                    case t.XHR_RESPONSE_TYPE.DOCUMENT:
                        return 'application/xml'
                    case t.XHR_RESPONSE_TYPE.JSON:
                        return 'application/json'
                    case t.XHR_RESPONSE_TYPE.DEFAULT:
                    case t.XHR_RESPONSE_TYPE.TEXT:
                    default:
                        return 'text/plain'
                }
            }, t
        }())

        function p() {}

        function m(t) {
            return function () {
                for (var e = arguments, n = [], r = 0; r < arguments.length; r++) n[r] = e[r]
                if (t === null) throw new Error('Callback was already called.')
                const i = t
                t = null, i.apply(this, n)
            }
        }!(function (t) {
            !(function (t) {
                t[t.NONE = 0] = 'NONE', t[t.DATA_URL = 1] = 'DATA_URL', t[t.COMPLETE = 2] = 'COMPLETE', t[t.LOADING = 4] = 'LOADING'
            }(t.STATUS_FLAGS || (t.STATUS_FLAGS = {}))),
            (function (t) {
                t[t.UNKNOWN = 0] = 'UNKNOWN', t[t.JSON = 1] = 'JSON', t[t.XML = 2] = 'XML', t[t.IMAGE = 3] = 'IMAGE', t[t.AUDIO = 4] = 'AUDIO', t[t.VIDEO = 5] = 'VIDEO', t[t.TEXT = 6] = 'TEXT'
            }(t.TYPE || (t.TYPE = {}))),
            (function (t) {
                t[t.XHR = 1] = 'XHR', t[t.IMAGE = 2] = 'IMAGE', t[t.AUDIO = 3] = 'AUDIO', t[t.VIDEO = 4] = 'VIDEO'
            }(t.LOAD_TYPE || (t.LOAD_TYPE = {}))),
            (function (t) {
                t.DEFAULT = 'text', t.BUFFER = 'arraybuffer', t.BLOB = 'blob', t.DOCUMENT = 'document', t.JSON = 'json', t.TEXT = 'text'
            }(t.XHR_RESPONSE_TYPE || (t.XHR_RESPONSE_TYPE = {}))), t._loadTypeMap = {
                'gif': t.LOAD_TYPE.IMAGE,
                'png': t.LOAD_TYPE.IMAGE,
                'bmp': t.LOAD_TYPE.IMAGE,
                'jpg': t.LOAD_TYPE.IMAGE,
                'jpeg': t.LOAD_TYPE.IMAGE,
                'tif': t.LOAD_TYPE.IMAGE,
                'tiff': t.LOAD_TYPE.IMAGE,
                'webp': t.LOAD_TYPE.IMAGE,
                'tga': t.LOAD_TYPE.IMAGE,
                'svg': t.LOAD_TYPE.IMAGE,
                'svg+xml': t.LOAD_TYPE.IMAGE,
                'mp3': t.LOAD_TYPE.AUDIO,
                'ogg': t.LOAD_TYPE.AUDIO,
                'wav': t.LOAD_TYPE.AUDIO,
                'mp4': t.LOAD_TYPE.VIDEO,
                'webm': t.LOAD_TYPE.VIDEO
            }, t._xhrTypeMap = {
                xhtml: t.XHR_RESPONSE_TYPE.DOCUMENT,
                html: t.XHR_RESPONSE_TYPE.DOCUMENT,
                htm: t.XHR_RESPONSE_TYPE.DOCUMENT,
                xml: t.XHR_RESPONSE_TYPE.DOCUMENT,
                tmx: t.XHR_RESPONSE_TYPE.DOCUMENT,
                svg: t.XHR_RESPONSE_TYPE.DOCUMENT,
                tsx: t.XHR_RESPONSE_TYPE.DOCUMENT,
                gif: t.XHR_RESPONSE_TYPE.BLOB,
                png: t.XHR_RESPONSE_TYPE.BLOB,
                bmp: t.XHR_RESPONSE_TYPE.BLOB,
                jpg: t.XHR_RESPONSE_TYPE.BLOB,
                jpeg: t.XHR_RESPONSE_TYPE.BLOB,
                tif: t.XHR_RESPONSE_TYPE.BLOB,
                tiff: t.XHR_RESPONSE_TYPE.BLOB,
                webp: t.XHR_RESPONSE_TYPE.BLOB,
                tga: t.XHR_RESPONSE_TYPE.BLOB,
                json: t.XHR_RESPONSE_TYPE.JSON,
                text: t.XHR_RESPONSE_TYPE.TEXT,
                txt: t.XHR_RESPONSE_TYPE.TEXT,
                ttf: t.XHR_RESPONSE_TYPE.BUFFER,
                otf: t.XHR_RESPONSE_TYPE.BUFFER
            }, t.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='
        }(d || (d = {})))
        const y = function (t, e) {
            this.data = t, this.callback = e
        }
        const v = (function () {
            function t(t, e) {
                let n = this
                if (void 0 === e && (e = 1), this.workers = 0, this.saturated = p, this.unsaturated = p, this.empty = p, this.drain = p, this.error = p, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function (t, e, r) {
                    if (r && typeof r != 'function') throw new Error('task callback must be a function')
                    if (n.started = !0, t == null && n.idle()) { setTimeout(function() {
                                    return n.drain()
                                }, 1)
}
                    else {
                        let i = new y(t, typeof r == 'function' ? r : p)
                        e ? n._tasks.unshift(i) : n._tasks.push(i), setTimeout(n.process, 1)
                    }
                }, this.process = function () {
                    for (; !n.paused && n.workers < n.concurrency && n._tasks.length;) {
                        let t = n._tasks.shift()
                        0 === n._tasks.length && n.empty(), n.workers += 1, n.workers === n.concurrency && n.saturated(), n._worker(t.data, m(n._next(t)))
                    }
                }, this._worker = t, e === 0) { throw new Error('Concurrency must not be zero');
                }
                this.concurrency = e, this.buffer = e / 4
            }
            return t.prototype._next = function (t) {
                let e = this
                return function () {
                    for (var n = arguments, r = [], i = 0; i < arguments.length; i++) r[i] = n[i]
                    e.workers -= 1, t.callback.apply(t, r), r[0] != null && e.error(r[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process()
                }
            }, t.prototype.push = function (t, e) {
                this._insert(t, !1, e)
            }, t.prototype.kill = function () {
                this.workers = 0, this.drain = p, this.started = !1, this._tasks = []
            }, t.prototype.unshift = function (t, e) {
                this._insert(t, !0, e)
            }, t.prototype.length = function () {
                return this._tasks.length
            }, t.prototype.running = function () {
                return this.workers
            }, t.prototype.idle = function () {
                return this._tasks.length + this.workers === 0
            }, t.prototype.pause = function () {
                !0 !== this.paused && (this.paused = !0)
            }, t.prototype.resume = function () {
                if (!1 !== this.paused) {
                    this.paused = !1
                    for (let t = 1; t <= this.concurrency; t++) this.process()
                }
            }, t.eachSeries = function (t, e, n, r) {
                let i = 0
                            var o = t.length
                !(function a(s) {
                    s || i === o
? n && n(s)
: r
? setTimeout(function() {
                                e(t[i++], a)
                            }, 1)
: e(t[i++], a)
                }())
            }, t.queue = function (e, n) {
                return new t(e, n)
            }, t
        }())
        const _ = /(#[\w-]+)?$/
        var g = (function () {
            function t(e, n) {
                const r = this
                void 0 === e && (e = ''), void 0 === n && (n = 10), this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function (t, e) {
                    return r._loadResource(t, e)
                }, this.resources = {}, this.baseUrl = e, this.progress = 0, this.loading = !1, this.defaultQueryString = '', this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function (t, e) {
                    return r._loadResource(t, e)
                }, this._queue = v.queue(this._boundLoadResource, n), this._queue.pause(), this.resources = {}, this.onProgress = new a(), this.onError = new a(), this.onLoad = new a(), this.onStart = new a(), this.onComplete = new a()
                for (let i = 0; i < t._plugins.length; ++i) {
                    const o = t._plugins[i]
                    let s = o.pre
                    let u = o.use
                    s && this.pre(s), u && this.use(u)
                }
                this._protected = !1
            }
            return t.prototype._add = function (t, e, n, r) {
                if (this.loading && (!n || !n.parentResource)) throw new Error('Cannot add resources while the loader is running.')
                if (this.resources[t]) throw new Error(`Resource named "${t}" already exists.`)
                if (e = this._prepareUrl(e), this.resources[t] = new d(t, e, n), typeof r == 'function' && this.resources[t].onAfterMiddleware.once(r), this.loading) {
                    for (var i = n.parentResource, o = [], a = 0; a < i.children.length; ++a) i.children[a].isComplete || o.push(i.children[a])
                    const s = i.progressChunk * (o.length + 1) / (o.length + 2)
                    i.children.push(this.resources[t]), i.progressChunk = s
                    for (a = 0; a < o.length; ++a) o[a].progressChunk = s
                    this.resources[t].progressChunk = s
                }
                return this._queue.push(this.resources[t]), this
            }, t.prototype.pre = function (t) {
                return this._beforeMiddleware.push(t), this
            }, t.prototype.use = function (t) {
                return this._afterMiddleware.push(t), this
            }, t.prototype.reset = function () {
                for (const t in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) {
                    const e = this.resources[t]
                    e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort('loader reset')
                }
                return this.resources = {}, this
            }, t.prototype.load = function (t) {
                if (typeof t == 'function' && this.onComplete.once(t), this.loading) return this
                if (this._queue.idle()) { this._onStart(), this._onComplete()
                }
                else {
                    for (let e = 100 / this._queue._tasks.length, n = 0; n < this._queue._tasks.length; ++n) this._queue._tasks[n].data.progressChunk = e
                    this._onStart(), this._queue.resume()
                }
                return this
            }, Object.defineProperty(t.prototype, 'concurrency', {
                get() {
                    return this._queue.concurrency
                },
                set(t) {
                    this._queue.concurrency = t
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype._prepareUrl = function (t) {
                let e; const n = s(t, {
                    strictMode: !0
                })
                if (e = n.protocol || !n.path || t.indexOf('//') === 0 ? t : this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && t.charAt(0) !== '/' ? `${this.baseUrl}/${t}` : this.baseUrl + t, this.defaultQueryString) {
                    const r = _.exec(e)[0]; (e = e.substr(0, e.length - r.length)).includes('?') ? e += `&${this.defaultQueryString}` : e += `?${this.defaultQueryString}`, e += r
                }
                return e
            }, t.prototype._loadResource = function (t, e) {
                const n = this
                t._dequeue = e, v.eachSeries(this._beforeMiddleware, (e, r) => {
                    e.call(n, t, () => {
                        r(t.isComplete ? {} : null)
                    })
                }, () => {
                    t.isComplete ? n._onLoad(t) : (t._onLoadBinding = t.onComplete.once(n._onLoad, n), t.load())
                }, !0)
            }, t.prototype._onStart = function () {
                this.progress = 0, this.loading = !0, this.onStart.dispatch(this)
            }, t.prototype._onComplete = function () {
                this.progress = 100, this.loading = !1, this.onComplete.dispatch(this, this.resources)
            }, t.prototype._onLoad = function (t) {
                const e = this
                t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), v.eachSeries(this._afterMiddleware, (n, r) => {
                    n.call(e, t, r)
                }, () => {
                    t.onAfterMiddleware.dispatch(t), e.progress = Math.min(100, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete()
                }, !0)
            }, t.prototype.destroy = function () {
                this._protected || this.reset()
            }, Object.defineProperty(t, 'shared', {
                get() {
                    let e = t._shared
                    return e || ((e = new t())._protected = !0, t._shared = e), e
                },
                enumerable: !1,
                configurable: !0
            }), t.registerPlugin = function (e) {
                return t._plugins.push(e), e.add && e.add(), t
            }, t._plugins = [], t
        }())
        g.prototype.add = function (t, e, n, r) {
            if (Array.isArray(t)) {
                for (let i = 0; i < t.length; ++i) this.add(t[i])
                return this
            }
            if (typeof t == 'object' && (n = t, r = e || n.callback || n.onComplete, e = n.url, t = n.name || n.key || n.url), typeof e != 'string' && (r = n, n = e, e = t), typeof e != 'string') throw new Error('No url passed to add resource to loader.')
            return typeof n == 'function' && (r = n, n = null), this._add(t, e, n, r)
        }
        var b = (function () {
            function t() {}
            return t.init = function (t) {
                t = Object.assign({
                    sharedLoader: !1
                }, t), this.loader = t.sharedLoader ? g.shared : new g()
            }, t.destroy = function () {
                this.loader && (this.loader.destroy(), this.loader = null)
            }, t
        }())
        var E = (function () {
            function t() {}
            return t.add = function () {
                d.setExtensionLoadType('svg', d.LOAD_TYPE.XHR), d.setExtensionXhrType('svg', d.XHR_RESPONSE_TYPE.TEXT)
            }, t.use = function (t, e) {
                if (!t.data || t.type !== d.TYPE.IMAGE && t.extension !== 'svg') { e()
                }
                else {
                    const n = t.data
                    let i = t.url
                    let o = t.name
                    let a = t.metadata
                    r.db.fromLoader(n, i, o, a).then((n) => {
                        t.texture = n, e()
                    }).catch(e)
                }
            }, t
        }())
        const x = self.URL || self.webkitURL
        g.registerPlugin({
            use(t, e) {
                if (t.data) {
                    if (t.xhr && t.xhrType === d.XHR_RESPONSE_TYPE.BLOB) {
                        if (self.Blob && typeof t.data != 'string') {
                            if (t.data.type.indexOf('image') === 0) {
                                const n = x.createObjectURL(t.data)
                                return t.blob = t.data, t.data = new Image(), t.data.src = n, t.type = d.TYPE.IMAGE, void (t.data.onload = function () {
                                    x.revokeObjectURL(n), t.data.onload = null, e()
                                })
                            }
                        } else {
                            const r = t.xhr.getResponseHeader('content-type')
                            if (r && r.indexOf('image') === 0) { return t.data = new Image(), t.data.src = `data:${  r  };base64,${  function(t) {
                                    for (var e = "", n = 0; n < t.length;) {
                                        for (var r = [0, 0, 0], i = [0, 0, 0, 0], o = 0; o < r.length; ++o) n < t.length ? r[o] = 255 & t.charCodeAt(n++) : r[o] = 0;
                                        switch (i[0] = r[0] >> 2, i[1] = (3 & r[0]) << 4 | r[1] >> 4, i[2] = (15 & r[1]) << 2 | r[2] >> 6, i[3] = 63 & r[2], n - (t.length - 1)) {
                                            case 2:
                                                i[3] = 64, i[2] = 64;
                                                break;
                                            case 1:
                                                i[3] = 64
                                        }
                                        for (o = 0; o < i.length; ++o) e += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(i[o])
                                    }
                                    return e
                                }(t.xhr.responseText)}`, t.type = d.TYPE.IMAGE, void (t.data.onload = function () {
                                t.data.onload = null, e()
                            })
                            }
                        }
                    }
                    e()
                } else { e()
                }
            }
        }), g.registerPlugin(E)
    },
    './node_modules/@pixi/math/dist/esm/math.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return u
        }), n.d(e, 'b', () => {
            return a
        }), n.d(e, 'c', () => {
            return c
        }), n.d(e, 'd', () => {
            return p
        }), n.d(e, 'e', () => {
            return d
        }), n.d(e, 'f', () => {
            return i
        }), n.d(e, 'g', () => {
            return f
        }), n.d(e, 'h', () => {
            return l
        }), n.d(e, 'i', () => {
            return o
        }), n.d(e, 'j', () => {
            return s
        }), n.d(e, 'k', () => {
            return h
        }), n.d(e, 'l', () => {
            return r
        }), n.d(e, 'm', () => {
            return T
        }), n.d(e, 'n', () => {
            return x
        })
        /*!
             * @pixi/math - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/math is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        let r; var i = 2 * Math.PI
        var o = 180 / Math.PI
        var a = Math.PI / 180
        !(function (t) {
            t[t.POLY = 0] = 'POLY', t[t.RECT = 1] = 'RECT', t[t.CIRC = 2] = 'CIRC', t[t.ELIP = 3] = 'ELIP', t[t.RREC = 4] = 'RREC'
        }(r || (r = {})))
        var s = (function () {
            function t(t, e, n, i) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = Number(t), this.y = Number(e), this.width = Number(n), this.height = Number(i), this.type = r.RECT
            }
            return Object.defineProperty(t.prototype, 'left', {
                get() {
                    return this.x
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'right', {
                get() {
                    return this.x + this.width
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'top', {
                get() {
                    return this.y
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'bottom', {
                get() {
                    return this.y + this.height
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t, 'EMPTY', {
                get() {
                    return new t(0, 0, 0, 0)
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.clone = function () {
                return new t(this.x, this.y, this.width, this.height)
            }, t.prototype.copyFrom = function (t) {
                return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
            }, t.prototype.copyTo = function (t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            }, t.prototype.contains = function (t, e) {
                return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height)
            }, t.prototype.pad = function (t, e) {
                return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this
            }, t.prototype.fit = function (t) {
                const e = Math.max(this.x, t.x)
                let n = Math.min(this.x + this.width, t.x + t.width)
                let r = Math.max(this.y, t.y)
                let i = Math.min(this.y + this.height, t.y + t.height)
                return this.x = e, this.width = Math.max(n - e, 0), this.y = r, this.height = Math.max(i - r, 0), this
            }, t.prototype.ceil = function (t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = 0.001)
                const n = Math.ceil((this.x + this.width - e) * t) / t
                let r = Math.ceil((this.y + this.height - e) * t) / t
                return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = n - this.x, this.height = r - this.y, this
            }, t.prototype.enlarge = function (t) {
                const e = Math.min(this.x, t.x)
                let n = Math.max(this.x + this.width, t.x + t.width)
                let r = Math.min(this.y, t.y)
                let i = Math.max(this.y + this.height, t.y + t.height)
                return this.x = e, this.width = n - e, this.y = r, this.height = i - r, this
            }, t.prototype.toString = function () {
                return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
            }, t
        }())
        var u = (function () {
            function t(t, e, n) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.radius = n, this.type = r.CIRC
            }
            return t.prototype.clone = function () {
                return new t(this.x, this.y, this.radius)
            }, t.prototype.contains = function (t, e) {
                if (this.radius <= 0) return !1
                let n = this.radius * this.radius
                var r = this.x - t
                var i = this.y - e
                return (r *= r) + (i *= i) <= n
            }, t.prototype.getBounds = function () {
                return new s(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius)
            }, t.prototype.toString = function () {
                return `[@pixi/math:Circle x=${ this.x } y=${ this.y } radius=${ this.radius }]`
            }, t
        }())
        var c = (function () {
            function t(t, e, n, i) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.width = n, this.height = i, this.type = r.ELIP
            }
            return t.prototype.clone = function () {
                return new t(this.x, this.y, this.width, this.height)
            }, t.prototype.contains = function (t, e) {
                if (this.width <= 0 || this.height <= 0) return !1
                let n = (t - this.x) / this.width
                var r = (e - this.y) / this.height
                return (n *= n) + (r *= r) <= 1
            }, t.prototype.getBounds = function () {
                return new s(this.x - this.width, this.y - this.height, this.width, this.height)
            }, t.prototype.toString = function () {
                return `[@pixi/math:Ellipse x=${ this.x } y=${ this.y } width=${ this.width } height=${ this.height }]`
            }, t
        }())
        var l = (function () {
            function t() {
                for (var t = arguments, e = [], n = 0; n < arguments.length; n++) e[n] = t[n]
                let i = Array.isArray(e[0]) ? e[0] : e
                if (typeof i[0] != 'number') {
                    for (var o = [], a = 0, s = i.length; a < s; a++) o.push(i[a].x, i[a].y)
                    i = o
                }
                this.points = i, this.type = r.POLY, this.closeStroke = !0
            }
            return t.prototype.clone = function () {
                const e = new t(this.points.slice())
                return e.closeStroke = this.closeStroke, e
            }, t.prototype.contains = function (t, e) {
                for (var n = !1, r = this.points.length / 2, i = 0, o = r - 1; i < r; o = i++) {
                    const a = this.points[2 * i]
                    var s = this.points[2 * i + 1]
                    var u = this.points[2 * o]
                    var c = this.points[2 * o + 1]
                    s > e != c > e && t < (e - s) / (c - s) * (u - a) + a && (n = !n)
                }
                return n
            }, t.prototype.toString = function () {
                return `[@pixi/math:PolygoncloseStroke=${ this.closeStroke }points=${ this.points.reduce((t, e) => {
                    return `${t  }, ${  e}`
                }, '') }]`
            }, t
        }())
        var h = (function () {
            function t(t, e, n, i, o) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === o && (o = 20), this.x = t, this.y = e, this.width = n, this.height = i, this.radius = o, this.type = r.RREC
            }
            return t.prototype.clone = function () {
                return new t(this.x, this.y, this.width, this.height, this.radius)
            }, t.prototype.contains = function (t, e) {
                if (this.width <= 0 || this.height <= 0) return !1
                if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
                    if (e >= this.y + this.radius && e <= this.y + this.height - this.radius || t >= this.x + this.radius && t <= this.x + this.width - this.radius) return !0
                    let n = t - (this.x + this.radius)
                    var r = e - (this.y + this.radius)
                    var i = this.radius * this.radius
                    if (n * n + r * r <= i) return !0
                    if ((n = t - (this.x + this.width - this.radius)) * n + r * r <= i) return !0
                    if (n * n + (r = e - (this.y + this.height - this.radius)) * r <= i) return !0
                    if ((n = t - (this.x + this.radius)) * n + r * r <= i) return !0
                }
                return !1
            }, t.prototype.toString = function () {
                return `[@pixi/math:RoundedRectangle x=${ this.x } y=${ this.y }width=${ this.width } height=${ this.height } radius=${ this.radius }]`
            }, t
        }())
        var f = (function () {
            function t(t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e
            }
            return t.prototype.clone = function () {
                return new t(this.x, this.y)
            }, t.prototype.copyFrom = function (t) {
                return this.set(t.x, t.y), this
            }, t.prototype.copyTo = function (t) {
                return t.set(this.x, this.y), t
            }, t.prototype.equals = function (t) {
                return t.x === this.x && t.y === this.y
            }, t.prototype.set = function (t, e) {
                return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this
            }, t.prototype.toString = function () {
                return `[@pixi/math:Point x=${ this.x } y=${ this.y }]`
            }, t
        }())
        var d = (function () {
            function t(t, e, n, r) {
                void 0 === n && (n = 0), void 0 === r && (r = 0), this._x = n, this._y = r, this.cb = t, this.scope = e
            }
            return t.prototype.clone = function (e, n) {
                return void 0 === e && (e = this.cb), void 0 === n && (n = this.scope), new t(e, n, this._x, this._y)
            }, t.prototype.set = function (t, e) {
                return void 0 === t && (t = 0), void 0 === e && (e = t), this._x === t && this._y === e || (this._x = t, this._y = e, this.cb.call(this.scope)), this
            }, t.prototype.copyFrom = function (t) {
                return this._x === t.x && this._y === t.y || (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
            }, t.prototype.copyTo = function (t) {
                return t.set(this._x, this._y), t
            }, t.prototype.equals = function (t) {
                return t.x === this._x && t.y === this._y
            }, t.prototype.toString = function () {
                return `[@pixi/math:ObservablePoint x=0 y=0 scope=${ this.scope }]`
            }, Object.defineProperty(t.prototype, 'x', {
                get() {
                    return this._x
                },
                set(t) {
                    this._x !== t && (this._x = t, this.cb.call(this.scope))
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'y', {
                get() {
                    return this._y
                },
                set(t) {
                    this._y !== t && (this._y = t, this.cb.call(this.scope))
                },
                enumerable: !1,
                configurable: !0
            }), t
        }())
        var p = (function () {
            function t(t, e, n, r, i, o) {
                void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), this.array = null, this.a = t, this.b = e, this.c = n, this.d = r, this.tx = i, this.ty = o
            }
            return t.prototype.fromArray = function (t) {
                this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
            }, t.prototype.set = function (t, e, n, r, i, o) {
                return this.a = t, this.b = e, this.c = n, this.d = r, this.tx = i, this.ty = o, this
            }, t.prototype.toArray = function (t, e) {
                this.array || (this.array = new Float32Array(9))
                let n = e || this.array
                return t ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n
            }, t.prototype.apply = function (t, e) {
                e = e || new f()
                let n = t.x
                var r = t.y
                return e.x = this.a * n + this.c * r + this.tx, e.y = this.b * n + this.d * r + this.ty, e
            }, t.prototype.applyInverse = function (t, e) {
                e = e || new f()
                let n = 1 / (this.a * this.d + this.c * -this.b)
                var r = t.x
                var i = t.y
                return e.x = this.d * n * r + -this.c * n * i + (this.ty * this.c - this.tx * this.d) * n, e.y = this.a * n * i + -this.b * n * r + (-this.ty * this.a + this.tx * this.b) * n, e
            }, t.prototype.translate = function (t, e) {
                return this.tx += t, this.ty += e, this
            }, t.prototype.scale = function (t, e) {
                return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
            }, t.prototype.rotate = function (t) {
                const e = Math.cos(t)
                var n = Math.sin(t)
                var r = this.a
                var i = this.c
                var o = this.tx
                return this.a = r * e - this.b * n, this.b = r * n + this.b * e, this.c = i * e - this.d * n, this.d = i * n + this.d * e, this.tx = o * e - this.ty * n, this.ty = o * n + this.ty * e, this
            }, t.prototype.append = function (t) {
                const e = this.a
                var n = this.b
                var r = this.c
                var i = this.d
                return this.a = t.a * e + t.b * r, this.b = t.a * n + t.b * i, this.c = t.c * e + t.d * r, this.d = t.c * n + t.d * i, this.tx = t.tx * e + t.ty * r + this.tx, this.ty = t.tx * n + t.ty * i + this.ty, this
            }, t.prototype.setTransform = function (t, e, n, r, i, o, a, s, u) {
                return this.a = Math.cos(a + u) * i, this.b = Math.sin(a + u) * i, this.c = -Math.sin(a - s) * o, this.d = Math.cos(a - s) * o, this.tx = t - (n * this.a + r * this.c), this.ty = e - (n * this.b + r * this.d), this
            }, t.prototype.prepend = function (t) {
                const e = this.tx
                if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
                    const n = this.a
                    var r = this.c
                    this.a = n * t.a + this.b * t.c, this.b = n * t.b + this.b * t.d, this.c = r * t.a + this.d * t.c, this.d = r * t.b + this.d * t.d
                }
                return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this
            }, t.prototype.decompose = function (t) {
                const e = this.a
                var n = this.b
                var r = this.c
                var o = this.d
                var a = t.pivot
                var s = -Math.atan2(-r, o)
                var u = Math.atan2(n, e)
                var c = Math.abs(s + u)
                return c < 1e-5 || Math.abs(i - c) < 1e-5 ? (t.rotation = u, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = s, t.skew.y = u), t.scale.x = Math.sqrt(e * e + n * n), t.scale.y = Math.sqrt(r * r + o * o), t.position.x = this.tx + (a.x * e + a.y * r), t.position.y = this.ty + (a.x * n + a.y * o), t
            }, t.prototype.invert = function () {
                const t = this.a
                var e = this.b
                var n = this.c
                var r = this.d
                var i = this.tx
                var o = t * r - e * n
                return this.a = r / o, this.b = -e / o, this.c = -n / o, this.d = t / o, this.tx = (n * this.ty - r * i) / o, this.ty = -(t * this.ty - e * i) / o, this
            }, t.prototype.identity = function () {
                return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
            }, t.prototype.clone = function () {
                const e = new t()
                return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
            }, t.prototype.copyTo = function (t) {
                return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
            }, t.prototype.copyFrom = function (t) {
                return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
            }, t.prototype.toString = function () {
                return `[@pixi/math:Matrix a=${ this.a } b=${ this.b } c=${ this.c } d=${ this.d } tx=${ this.tx } ty=${ this.ty }]`
            }, Object.defineProperty(t, 'IDENTITY', {
                get() {
                    return new t()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t, 'TEMP_MATRIX', {
                get() {
                    return new t()
                },
                enumerable: !1,
                configurable: !0
            }), t
        }())
        let m = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
        let y = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
        let v = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
        let _ = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
        let g = []
        let b = []
        let E = Math.sign
        !(function () {
            for (var t = 0; t < 16; t++) {
                const e = []
                g.push(e)
                for (let n = 0; n < 16; n++) {
                    for (let r = E(m[t] * m[n] + v[t] * y[n]), i = E(y[t] * m[n] + _[t] * y[n]), o = E(m[t] * v[n] + v[t] * _[n]), a = E(y[t] * v[n] + _[t] * _[n]), s = 0; s < 16; s++) {
                        if (m[s] === r && y[s] === i && v[s] === o && _[s] === a) {
                            e.push(s)
                            break
                        }
                    }
                }
            }
            for (t = 0; t < 16; t++) {
                const u = new p()
                u.set(m[t], y[t], v[t], _[t], 0, 0), b.push(u)
            }
        }())
        var x = {
            E: 0,
            SE: 1,
            S: 2,
            SW: 3,
            W: 4,
            NW: 5,
            N: 6,
            NE: 7,
            MIRROR_VERTICAL: 8,
            MAIN_DIAGONAL: 10,
            MIRROR_HORIZONTAL: 12,
            REVERSE_DIAGONAL: 14,
            uX(t) {
                return m[t]
            },
            uY(t) {
                return y[t]
            },
            vX(t) {
                return v[t]
            },
            vY(t) {
                return _[t]
            },
            inv(t) {
                return 8 & t ? 15 & t : 7 & -t
            },
            add(t, e) {
                return g[t][e]
            },
            sub(t, e) {
                return g[t][x.inv(e)]
            },
            rotate180(t) {
                return 4 ^ t
            },
            isVertical(t) {
                return (3 & t) == 2
            },
            byDirection(t, e) {
                return 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? x.S : x.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? x.E : x.W : e > 0 ? t > 0 ? x.SE : x.SW : t > 0 ? x.NE : x.NW
            },
            matrixAppendRotationInv(t, e, n, r) {
                void 0 === n && (n = 0), void 0 === r && (r = 0)
                const i = b[x.inv(e)]
                i.tx = n, i.ty = r, t.append(i)
            }
        }
        var T = (function () {
            function t() {
                this.worldTransform = new p(), this.localTransform = new p(), this.position = new d(this.onChange, this, 0, 0), this.scale = new d(this.onChange, this, 1, 1), this.pivot = new d(this.onChange, this, 0, 0), this.skew = new d(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
            }
            return t.prototype.onChange = function () {
                this._localID++
            }, t.prototype.updateSkew = function () {
                this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
            }, t.prototype.toString = function () {
                return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
            }, t.prototype.updateLocalTransform = function () {
                const t = this.localTransform
                this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1)
            }, t.prototype.updateTransform = function (t) {
                const e = this.localTransform
                if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
                    const n = t.worldTransform
                    let r = this.worldTransform
                    r.a = e.a * n.a + e.b * n.c, r.b = e.a * n.b + e.b * n.d, r.c = e.c * n.a + e.d * n.c, r.d = e.c * n.b + e.d * n.d, r.tx = e.tx * n.a + e.ty * n.c + n.tx, r.ty = e.tx * n.b + e.ty * n.d + n.ty, this._parentID = t._worldID, this._worldID++
                }
            }, t.prototype.setFromMatrix = function (t) {
                t.decompose(this), this._localID++
            }, Object.defineProperty(t.prototype, 'rotation', {
                get() {
                    return this._rotation
                },
                set(t) {
                    this._rotation !== t && (this._rotation = t, this.updateSkew())
                },
                enumerable: !1,
                configurable: !0
            }), t.IDENTITY = new t(), t
        }())
    },
    './node_modules/@pixi/mesh-extras/dist/esm/mesh-extras.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return d
        }), n.d(e, 'b', () => {
            return u
        }), n.d(e, 'c', () => {
            return c
        }), n.d(e, 'd', () => {
            return f
        }), n.d(e, 'e', () => {
            return h
        }), n.d(e, 'f', () => {
            return l
        })
        const r = n('./node_modules/@pixi/mesh/dist/esm/mesh.js')
        const i = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const o = n('./node_modules/@pixi/core/dist/esm/core.js')
        let a = function (t, e) {
            return (a = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }

        function s(t, e) {
            function n() {
                this.constructor = t
            }
            a(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        var u = (function (t) {
            function e(e, n, r, i) {
                void 0 === e && (e = 100), void 0 === n && (n = 100), void 0 === r && (r = 10), void 0 === i && (i = 10)
                const o = t.call(this) || this
                return o.segWidth = r, o.segHeight = i, o.width = e, o.height = n, o.build(), o
            }
            return s(e, t), e.prototype.build = function () {
                for (var t = this.segWidth * this.segHeight, e = [], n = [], r = [], i = this.segWidth - 1, o = this.segHeight - 1, a = this.width / i, s = this.height / o, u = 0; u < t; u++) {
                    const c = u % this.segWidth
                    let l = u / this.segWidth | 0
                    e.push(c * a, l * s), n.push(c / i, l / o)
                }
                const h = i * o
                for (u = 0; u < h; u++) {
                    const f = u % i
                    let d = u / i | 0
                    let p = d * this.segWidth + f
                    let m = d * this.segWidth + f + 1
                    let y = (d + 1) * this.segWidth + f
                    let v = (d + 1) * this.segWidth + f + 1
                    r.push(p, m, y, m, v, y)
                }
                this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint16Array(r), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
            }, e
        }(r.c))
        var c = (function (t) {
            function e(e, n, r) {
                void 0 === e && (e = 200), void 0 === r && (r = 0)
                let i = t.call(this, new Float32Array(4 * n.length), new Float32Array(4 * n.length), new Uint16Array(6 * (n.length - 1))) || this
                return i.points = n, i._width = e, i.textureScale = r, i.build(), i
            }
            return s(e, t), Object.defineProperty(e.prototype, 'width', {
                get() {
                    return this._width
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.build = function () {
                const t = this.points
                if (t) {
                    const e = this.getBuffer('aVertexPosition')
                    var n = this.getBuffer('aTextureCoord')
                    var r = this.getIndex()
                    if (!(t.length < 1)) {
                        e.data.length / 4 !== t.length && (e.data = new Float32Array(4 * t.length), n.data = new Float32Array(4 * t.length), r.data = new Uint16Array(6 * (t.length - 1)))
                        let i = n.data
                        var o = r.data
                        i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1
                        for (var a = 0, s = t[0], u = this._width * this.textureScale, c = t.length, l = 0; l < c; l++) {
                            var h = 4 * l
                            if (this.textureScale > 0) {
                                const f = s.x - t[l].x
                                var d = s.y - t[l].y
                                var p = Math.sqrt(f * f + d * d)
                                s = t[l], a += p / u
                            } else { a = l / (c - 1)
                            }
                            i[h] = a, i[h + 1] = 0, i[h + 2] = a, i[h + 3] = 1
                        }
                        let m = 0
                        for (l = 0; l < c - 1; l++) {
                            h = 2 * l
                            o[m++] = h, o[m++] = h + 1, o[m++] = h + 2, o[m++] = h + 2, o[m++] = h + 1, o[m++] = h + 3
                        }
                        n.update(), r.update(), this.updateVertices()
                    }
                }
            }, e.prototype.updateVertices = function () {
                const t = this.points
                if (!(t.length < 1)) {
                    for (var e, n = t[0], r = 0, i = 0, o = this.buffers[0].data, a = t.length, s = 0; s < a; s++) {
                        const u = t[s]
                        var c = 4 * s
                        i = -((e = s < t.length - 1 ? t[s + 1] : u).x - n.x), r = e.y - n.y
                        let l = Math.sqrt(r * r + i * i)
                        var h = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2
                        r /= l, i /= l, r *= h, i *= h, o[c] = u.x + r, o[c + 1] = u.y + i, o[c + 2] = u.x - r, o[c + 3] = u.y - i, n = u
                    }
                    this.buffers[0].update()
                }
            }, e.prototype.update = function () {
                this.textureScale > 0 ? this.build() : this.updateVertices()
            }, e
        }(r.c))
        var l = (function (t) {
            function e(e, n, o) {
                void 0 === o && (o = 0)
                let a = this
                var s = new c(e.height, n, o)
                var u = new r.d(e)
                return o > 0 && (e.baseTexture.wrapMode = i.s.REPEAT), (a = t.call(this, s, u) || this).autoUpdate = !0, a
            }
            return s(e, t), e.prototype._render = function (e) {
                const n = this.geometry;
                (this.autoUpdate || n._width !== this.shader.texture.height) && (n._width = this.shader.texture.height, n.update()), t.prototype._render.call(this, e)
            }, e
        }(r.a))
        var h = (function (t) {
            function e(e, n, i) {
                let a = this
                var s = new u(e.width, e.height, n, i)
                var c = new r.d(o.db.WHITE)
                return (a = t.call(this, s, c) || this).texture = e, a.autoResize = !0, a
            }
            return s(e, t), e.prototype.textureUpdated = function () {
                this._textureID = this.shader.texture._updateID
                let t = this.geometry
                var e = this.shader.texture
                var n = e.width
                var r = e.height
                !this.autoResize || t.width === n && t.height === r || (t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build())
            }, Object.defineProperty(e.prototype, 'texture', {
                get() {
                    return this.shader.texture
                },
                set(t) {
                    this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once('update', this.textureUpdated, this))
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype._render = function (e) {
                this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t.prototype._render.call(this, e)
            }, e.prototype.destroy = function (e) {
                this.shader.texture.off('update', this.textureUpdated, this), t.prototype.destroy.call(this, e)
            }, e
        }(r.a))
        var f = (function (t) {
            function e(e, n, i, a, s) {
                void 0 === e && (e = o.db.EMPTY)
                let u = this
                var c = new r.c(n, i, a)
                c.getBuffer('aVertexPosition').static = !1
                let l = new r.d(e)
                return (u = t.call(this, c, l, null, s) || this).autoUpdate = !0, u
            }
            return s(e, t), Object.defineProperty(e.prototype, 'vertices', {
                get() {
                    return this.geometry.getBuffer('aVertexPosition').data
                },
                set(t) {
                    this.geometry.getBuffer('aVertexPosition').data = t
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype._render = function (e) {
                this.autoUpdate && this.geometry.getBuffer('aVertexPosition').update(), t.prototype._render.call(this, e)
            }, e
        }(r.a))
        var d = (function (t) {
            function e(e, n, r, i, a) {
                void 0 === n && (n = 10), void 0 === r && (r = 10), void 0 === i && (i = 10), void 0 === a && (a = 10)
                const s = t.call(this, o.db.WHITE, 4, 4) || this
                return s._origWidth = e.orig.width, s._origHeight = e.orig.height, s._width = s._origWidth, s._height = s._origHeight, s._leftWidth = n, s._rightWidth = i, s._topHeight = r, s._bottomHeight = a, s.texture = e, s
            }
            return s(e, t), e.prototype.textureUpdated = function () {
                this._textureID = this.shader.texture._updateID, this._refresh()
            }, Object.defineProperty(e.prototype, 'vertices', {
                get() {
                    return this.geometry.getBuffer('aVertexPosition').data
                },
                set(t) {
                    this.geometry.getBuffer('aVertexPosition').data = t
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.updateHorizontalVertices = function () {
                const t = this.vertices
                let e = this._getMinScale()
                t[9] = t[11] = t[13] = t[15] = this._topHeight * e, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e, t[25] = t[27] = t[29] = t[31] = this._height
            }, e.prototype.updateVerticalVertices = function () {
                const t = this.vertices
                let e = this._getMinScale()
                t[2] = t[10] = t[18] = t[26] = this._leftWidth * e, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e, t[6] = t[14] = t[22] = t[30] = this._width
            }, e.prototype._getMinScale = function () {
                const t = this._leftWidth + this._rightWidth
                let e = this._width > t ? 1 : this._width / t
                let n = this._topHeight + this._bottomHeight
                let r = this._height > n ? 1 : this._height / n
                return Math.min(e, r)
            }, Object.defineProperty(e.prototype, 'width', {
                get() {
                    return this._width
                },
                set(t) {
                    this._width = t, this._refresh()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'height', {
                get() {
                    return this._height
                },
                set(t) {
                    this._height = t, this._refresh()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'leftWidth', {
                get() {
                    return this._leftWidth
                },
                set(t) {
                    this._leftWidth = t, this._refresh()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'rightWidth', {
                get() {
                    return this._rightWidth
                },
                set(t) {
                    this._rightWidth = t, this._refresh()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'topHeight', {
                get() {
                    return this._topHeight
                },
                set(t) {
                    this._topHeight = t, this._refresh()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'bottomHeight', {
                get() {
                    return this._bottomHeight
                },
                set(t) {
                    this._bottomHeight = t, this._refresh()
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype._refresh = function () {
                const t = this.texture
                let e = this.geometry.buffers[1].data
                this._origWidth = t.orig.width, this._origHeight = t.orig.height
                const n = 1 / this._origWidth
                let r = 1 / this._origHeight
                e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1, e[2] = e[10] = e[18] = e[26] = n * this._leftWidth, e[4] = e[12] = e[20] = e[28] = 1 - n * this._rightWidth, e[9] = e[11] = e[13] = e[15] = r * this._topHeight, e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
            }, e
        }(h))
    },
    './node_modules/@pixi/mesh/dist/esm/mesh.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return p
        }), n.d(e, 'b', () => {
            return h
        }), n.d(e, 'c', () => {
            return y
        }), n.d(e, 'd', () => {
            return m
        })
        const r = n('./node_modules/@pixi/core/dist/esm/core.js')
        const i = n('./node_modules/@pixi/math/dist/esm/math.js')
        const o = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const a = n('./node_modules/@pixi/display/dist/esm/display.js')
        const s = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        const u = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        let c = function (t, e) {
            return (c = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }

        function l(t, e) {
            function n() {
                this.constructor = t
            }
            c(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        var h = (function () {
            function t(t, e) {
                this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
            }
            return t.prototype.update = function (t) {
                if (t || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) {
                    this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID
                    const e = this.uvBuffer.data
                    this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++
                }
            }, t
        }())
        let f = new i.g()
        let d = new i.h()
        var p = (function (t) {
            function e(e, n, i, a) {
                void 0 === a && (a = o.f.TRIANGLES)
                let u = t.call(this) || this
                return u.geometry = e, u.shader = n, u.state = i || r.Z.for2d(), u.drawMode = a, u.start = 0, u.size = 0, u.uvs = null, u.indices = null, u.vertexData = new Float32Array(1), u.vertexDirty = -1, u._transformID = -1, u._roundPixels = s.b.ROUND_PIXELS, u.batchUvs = null, u
            }
            return l(e, t), Object.defineProperty(e.prototype, 'geometry', {
                get() {
                    return this._geometry
                },
                set(t) {
                    this._geometry !== t && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = t, this._geometry && this._geometry.refCount++, this.vertexDirty = -1)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'uvBuffer', {
                get() {
                    return this.geometry.buffers[1]
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'verticesBuffer', {
                get() {
                    return this.geometry.buffers[0]
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'material', {
                get() {
                    return this.shader
                },
                set(t) {
                    this.shader = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'blendMode', {
                get() {
                    return this.state.blendMode
                },
                set(t) {
                    this.state.blendMode = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'roundPixels', {
                get() {
                    return this._roundPixels
                },
                set(t) {
                    this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'tint', {
                get() {
                    return 'tint' in this.shader ? this.shader.tint : null
                },
                set(t) {
                    this.shader.tint = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'texture', {
                get() {
                    return 'texture' in this.shader ? this.shader.texture : null
                },
                set(t) {
                    this.shader.texture = t
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype._render = function (t) {
                const n = this.geometry.buffers[0].data
                this.shader.batchable && this.drawMode === o.f.TRIANGLES && n.length < 2 * e.BATCHABLE_SIZE ? this._renderToBatch(t) : this._renderDefault(t)
            }, e.prototype._renderDefault = function (t) {
                const e = this.shader
                e.alpha = this.worldAlpha, e.update && e.update(), t.batch.flush(), e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), t.shader.bind(e), t.state.set(this.state), t.geometry.bind(this.geometry, e), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
            }, e.prototype._renderToBatch = function (t) {
                const e = this.geometry
                var n = this.shader
                n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e.indexBuffer.data, this._tintRGB = n._tintRGB, this._texture = n.texture
                let r = this.material.pluginName
                t.batch.setObjectRenderer(t.plugins[r]), t.plugins[r].render(this)
            }, e.prototype.calculateVertices = function () {
                const t = this.geometry.buffers[0]
                var e = t.data
                var n = t._updateID
                if (n !== this.vertexDirty || this._transformID !== this.transform._worldID) {
                    this._transformID = this.transform._worldID, this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length))
                    for (var r = this.transform.worldTransform, i = r.a, o = r.b, a = r.c, u = r.d, c = r.tx, l = r.ty, h = this.vertexData, f = 0; f < h.length / 2; f++) {
                        const d = e[2 * f]
                        var p = e[2 * f + 1]
                        h[2 * f] = i * d + a * p + c, h[2 * f + 1] = o * d + u * p + l
                    }
                    if (this._roundPixels) {
                        const m = s.b.RESOLUTION
                        for (f = 0; f < h.length; ++f) h[f] = Math.round((h[f] * m | 0) / m)
                    }
                    this.vertexDirty = n
                }
            }, e.prototype.calculateUvs = function () {
                const t = this.geometry.buffers[1]
                var e = this.shader
                e.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new h(t, e.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
            }, e.prototype._calculateBounds = function () {
                this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
            }, e.prototype.containsPoint = function (t) {
                if (!this.getBounds().contains(t.x, t.y)) return !1
                this.worldTransform.applyInverse(t, f)
                for (let e = this.geometry.getBuffer('aVertexPosition').data, n = d.points, r = this.geometry.getIndex().data, i = r.length, o = this.drawMode === 4 ? 3 : 1, a = 0; a + 2 < i; a += o) {
                    const s = 2 * r[a]
                    var u = 2 * r[a + 1]
                    var c = 2 * r[a + 2]
                    if (n[0] = e[s], n[1] = e[s + 1], n[2] = e[u], n[3] = e[u + 1], n[4] = e[c], n[5] = e[c + 1], d.contains(f.x, f.y)) return !0
                }
                return !1
            }, e.prototype.destroy = function (e) {
                t.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
            }, e.BATCHABLE_SIZE = 100, e
        }(a.b))
        var m = (function (t) {
            function e(e, n) {
                let o = this
                var a = {
                    uSampler: e,
                    alpha: 1,
                    uTextureMatrix: i.d.IDENTITY,
                    uColor: new Float32Array([1, 1, 1, 1])
                }
                return (n = Object.assign({
                    tint: 16777215,
                    alpha: 1,
                    pluginName: 'batch'
                }, n)).uniforms && Object.assign(a, n.uniforms), (o = t.call(this, n.program || r.L.from('attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n'), a) || this)._colorDirty = !1, o.uvMatrix = new r.fb(e), o.batchable = void 0 === n.program, o.pluginName = n.pluginName, o.tint = n.tint, o.alpha = n.alpha, o
            }
            return l(e, t), Object.defineProperty(e.prototype, 'texture', {
                get() {
                    return this.uniforms.uSampler
                },
                set(t) {
                    this.uniforms.uSampler !== t && (this.uniforms.uSampler = t, this.uvMatrix.texture = t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'alpha', {
                get() {
                    return this._alpha
                },
                set(t) {
                    t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'tint', {
                get() {
                    return this._tint
                },
                set(t) {
                    t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16), this._colorDirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.update = function () {
                if (this._colorDirty) {
                    this._colorDirty = !1
                    let t = this.texture.baseTexture
                    new Object(u.premultiplyTintToRgba)(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
                }
                this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
            }, e
        }(r.W))
        var y = (function (t) {
            function e(e, n, i) {
                const a = t.call(this) || this
                let s = new r.p(e)
                let u = new r.p(n, !0)
                let c = new r.p(i, !0, !0)
                return a.addAttribute('aVertexPosition', s, 2, !1, o.r.FLOAT).addAttribute('aTextureCoord', u, 2, !1, o.r.FLOAT).addIndex(c), a._updateId = -1, a
            }
            return l(e, t), Object.defineProperty(e.prototype, 'vertexDirtyId', {
                get() {
                    return this.buffers[0]._updateID
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(r.C))
    },
    './node_modules/@pixi/particle-container/dist/esm/particle-container.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return l
        }), n.d(e, 'b', () => {
            return f
        })
        const r = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const i = n('./node_modules/@pixi/display/dist/esm/display.js')
        const o = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        const a = n('./node_modules/@pixi/core/dist/esm/core.js')
        const s = n('./node_modules/@pixi/math/dist/esm/math.js')
        let u = function (t, e) {
            return (u = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }

        function c(t, e) {
            function n() {
                this.constructor = t
            }
            u(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        var l = (function (t) {
            function e(e, n, i, o) {
                void 0 === e && (e = 1500), void 0 === i && (i = 16384), void 0 === o && (o = !1)
                const a = t.call(this) || this
                return i > 16384 && (i = 16384), a._properties = [!1, !0, !1, !1, !1], a._maxSize = e, a._batchSize = i, a._buffers = null, a._bufferUpdateIDs = [], a._updateID = 0, a.interactiveChildren = !1, a.blendMode = r.b.NORMAL, a.autoResize = o, a.roundPixels = !0, a.baseTexture = null, a.setProperties(n), a._tint = 0, a.tintRgb = new Float32Array(4), a.tint = 16777215, a
            }
            return c(e, t), e.prototype.setProperties = function (t) {
                t && (this._properties[0] = 'vertices' in t || 'scale' in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = 'position' in t ? !!t.position : this._properties[1], this._properties[2] = 'rotation' in t ? !!t.rotation : this._properties[2], this._properties[3] = 'uvs' in t ? !!t.uvs : this._properties[3], this._properties[4] = 'tint' in t || 'alpha' in t ? !!t.tint || !!t.alpha : this._properties[4])
            }, e.prototype.updateTransform = function () {
                this.displayObjectUpdateTransform()
            }, Object.defineProperty(e.prototype, 'tint', {
                get() {
                    return this._tint
                },
                set(t) {
                    this._tint = t, new Object(o.hex2rgb)(t, this.tintRgb)
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.render = function (t) {
                const e = this
                this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once('update', () => {
                    return e.onChildrenChange(0)
                })), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
            }, e.prototype.onChildrenChange = function (t) {
                for (var e = Math.floor(t / this._batchSize); this._bufferUpdateIDs.length < e;) this._bufferUpdateIDs.push(0)
                this._bufferUpdateIDs[e] = ++this._updateID
            }, e.prototype.dispose = function () {
                if (this._buffers) {
                    for (let t = 0; t < this._buffers.length; ++t) this._buffers[t].destroy()
                    this._buffers = null
                }
            }, e.prototype.destroy = function (e) {
                t.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
            }, e
        }(i.b))
        let h = (function () {
            function t(t, e, n) {
                this.geometry = new a.C(), this.indexBuffer = null, this.size = n, this.dynamicProperties = [], this.staticProperties = []
                for (let i = 0; i < t.length; ++i) {
                    let o = t[i]
                    o = {
                        attributeName: o.attributeName,
                        size: o.size,
                        uploadFunction: o.uploadFunction,
                        type: o.type || r.r.FLOAT,
                        offset: o.offset
                    }, e[i] ? this.dynamicProperties.push(o) : this.staticProperties.push(o)
                }
                this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
            }
            return t.prototype.initBuffers = function () {
                const t = this.geometry
                var e = 0
                this.indexBuffer = new a.p(new Object(o.createIndicesForQuads)(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0
                for (var n = 0; n < this.dynamicProperties.length; ++n) {
                    (c = this.dynamicProperties[n]).offset = e, e += c.size, this.dynamicStride += c.size
                }
                const i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4)
                this.dynamicData = new Float32Array(i), this.dynamicDataUint32 = new Uint32Array(i), this.dynamicBuffer = new a.p(this.dynamicData, !1, !1)
                let s = 0
                this.staticStride = 0
                for (n = 0; n < this.staticProperties.length; ++n) {
                    (c = this.staticProperties[n]).offset = s, s += c.size, this.staticStride += c.size
                }
                const u = new ArrayBuffer(this.size * this.staticStride * 4 * 4)
                this.staticData = new Float32Array(u), this.staticDataUint32 = new Uint32Array(u), this.staticBuffer = new a.p(this.staticData, !0, !1)
                for (n = 0; n < this.dynamicProperties.length; ++n) {
                    var c = this.dynamicProperties[n]
                    t.addAttribute(c.attributeName, this.dynamicBuffer, 0, c.type === r.r.UNSIGNED_BYTE, c.type, 4 * this.dynamicStride, 4 * c.offset)
                }
                for (n = 0; n < this.staticProperties.length; ++n) {
                    c = this.staticProperties[n]
                    t.addAttribute(c.attributeName, this.staticBuffer, 0, c.type === r.r.UNSIGNED_BYTE, c.type, 4 * this.staticStride, 4 * c.offset)
                }
            }, t.prototype.uploadDynamic = function (t, e, n) {
                for (let i = 0; i < this.dynamicProperties.length; i++) {
                    const o = this.dynamicProperties[i]
                    o.uploadFunction(t, e, n, o.type === r.r.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, o.offset)
                }
                this.dynamicBuffer._updateID++
            }, t.prototype.uploadStatic = function (t, e, n) {
                for (let i = 0; i < this.staticProperties.length; i++) {
                    const o = this.staticProperties[i]
                    o.uploadFunction(t, e, n, o.type === r.r.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, o.offset)
                }
                this.staticBuffer._updateID++
            }, t.prototype.destroy = function () {
                this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
            }, t
        }())
        var f = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.shader = null, n.properties = null, n.tempMatrix = new s.d(), n.properties = [{
                    attributeName: 'aVertexPosition',
                    size: 2,
                    uploadFunction: n.uploadVertices,
                    offset: 0
                }, {
                    attributeName: 'aPositionCoord',
                    size: 2,
                    uploadFunction: n.uploadPosition,
                    offset: 0
                }, {
                    attributeName: 'aRotation',
                    size: 1,
                    uploadFunction: n.uploadRotation,
                    offset: 0
                }, {
                    attributeName: 'aTextureCoord',
                    size: 2,
                    uploadFunction: n.uploadUvs,
                    offset: 0
                }, {
                    attributeName: 'aColor',
                    size: 1,
                    type: r.r.UNSIGNED_BYTE,
                    uploadFunction: n.uploadTint,
                    offset: 0
                }], n.shader = a.W.from('attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n', 'varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}', {}), n.state = a.Z.for2d(), n
            }
            return c(e, t), e.prototype.render = function (t) {
                const e = t.children
                let n = t._maxSize
                let r = t._batchSize
                let i = this.renderer
                let a = e.length
                if (a !== 0) {
                    a > n && !t.autoResize && (a = n)
                    let s = t._buffers
                    s || (s = t._buffers = this.generateBuffers(t))
                    const u = e[0]._texture.baseTexture
                    this.state.blendMode = new Object(o.correctBlendMode)(t.blendMode, u.alphaMode), i.state.set(this.state)
                    const c = i.gl
                    let l = t.worldTransform.copyTo(this.tempMatrix)
                    l.prepend(i.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = l.toArray(!0), this.shader.uniforms.uColor = new Object(o.premultiplyRgba)(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, u.alphaMode), this.shader.uniforms.uSampler = u, this.renderer.shader.bind(this.shader)
                    for (let h = !1, f = 0, d = 0; f < a; f += r, d += 1) {
                        let p = a - f
                        p > r && (p = r), d >= s.length && s.push(this._generateOneMoreBuffer(t))
                        const m = s[d]
                        m.uploadDynamic(e, f, p)
                        const y = t._bufferUpdateIDs[d] || 0;
                        (h = h || m._updateID < y) && (m._updateID = t._updateID, m.uploadStatic(e, f, p)), i.geometry.bind(m.geometry), c.drawElements(c.TRIANGLES, 6 * p, c.UNSIGNED_SHORT, 0)
                    }
                }
            }, e.prototype.generateBuffers = function (t) {
                for (var e = [], n = t._maxSize, r = t._batchSize, i = t._properties, o = 0; o < n; o += r) e.push(new h(this.properties, i, r))
                return e
            }, e.prototype._generateOneMoreBuffer = function (t) {
                const e = t._batchSize
                let n = t._properties
                return new h(this.properties, n, e)
            }, e.prototype.uploadVertices = function (t, e, n, r, i, o) {
                for (let a = 0, s = 0, u = 0, c = 0, l = 0; l < n; ++l) {
                    const h = t[e + l]
                    let f = h._texture
                    let d = h.scale.x
                    let p = h.scale.y
                    let m = f.trim
                    let y = f.orig
                    m ? (a = (s = m.x - h.anchor.x * y.width) + m.width, u = (c = m.y - h.anchor.y * y.height) + m.height) : (a = y.width * (1 - h.anchor.x), s = y.width * -h.anchor.x, u = y.height * (1 - h.anchor.y), c = y.height * -h.anchor.y), r[o] = s * d, r[o + 1] = c * p, r[o + i] = a * d, r[o + i + 1] = c * p, r[o + 2 * i] = a * d, r[o + 2 * i + 1] = u * p, r[o + 3 * i] = s * d, r[o + 3 * i + 1] = u * p, o += 4 * i
                }
            }, e.prototype.uploadPosition = function (t, e, n, r, i, o) {
                for (let a = 0; a < n; a++) {
                    const s = t[e + a].position
                    r[o] = s.x, r[o + 1] = s.y, r[o + i] = s.x, r[o + i + 1] = s.y, r[o + 2 * i] = s.x, r[o + 2 * i + 1] = s.y, r[o + 3 * i] = s.x, r[o + 3 * i + 1] = s.y, o += 4 * i
                }
            }, e.prototype.uploadRotation = function (t, e, n, r, i, o) {
                for (let a = 0; a < n; a++) {
                    const s = t[e + a].rotation
                    r[o] = s, r[o + i] = s, r[o + 2 * i] = s, r[o + 3 * i] = s, o += 4 * i
                }
            }, e.prototype.uploadUvs = function (t, e, n, r, i, o) {
                for (let a = 0; a < n; ++a) {
                    const s = t[e + a]._texture._uvs
                    s ? (r[o] = s.x0, r[o + 1] = s.y0, r[o + i] = s.x1, r[o + i + 1] = s.y1, r[o + 2 * i] = s.x2, r[o + 2 * i + 1] = s.y2, r[o + 3 * i] = s.x3, r[o + 3 * i + 1] = s.y3, o += 4 * i) : (r[o] = 0, r[o + 1] = 0, r[o + i] = 0, r[o + i + 1] = 0, r[o + 2 * i] = 0, r[o + 2 * i + 1] = 0, r[o + 3 * i] = 0, r[o + 3 * i + 1] = 0, o += 4 * i)
                }
            }, e.prototype.uploadTint = function (t, e, n, r, i, a) {
                for (let s = 0; s < n; ++s) {
                    const u = t[e + s]
                    let c = u._texture.baseTexture.alphaMode > 0
                    let l = u.alpha
                    let h = l < 1 && c ? new Object(o.premultiplyTint)(u._tintRGB, l) : u._tintRGB + (255 * l << 24)
                    r[a] = h, r[a + i] = h, r[a + 2 * i] = h, r[a + 3 * i] = h, a += 4 * i
                }
            }, e.prototype.destroy = function () {
                t.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
            }, e
        }(a.K))
    },
    './node_modules/@pixi/prepare/dist/esm/prepare.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return _
        }), n.d(e, 'b', () => {
            return l
        }), n.d(e, 'c', () => {
            return x
        }), n.d(e, 'd', () => {
            return T
        })
        const r = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        const i = n('./node_modules/@pixi/core/dist/esm/core.js')
        const o = n('./node_modules/@pixi/graphics/dist/esm/graphics.js')
        const a = n('./node_modules/@pixi/ticker/dist/esm/ticker.js')
        const s = n('./node_modules/@pixi/display/dist/esm/display.js')
        const u = n('./node_modules/@pixi/text/dist/esm/text.js')
        /*!
             * @pixi/prepare - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/prepare is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        r.b.UPLOADS_PER_FRAME = 4
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0

            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.

            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
            ***************************************************************************** */
        let c = function (t, e) {
            return (c = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        var l = (function () {
            function t(t) {
                this.maxItemsPerFrame = t, this.itemsLeft = 0
            }
            return t.prototype.beginFrame = function () {
                this.itemsLeft = this.maxItemsPerFrame
            }, t.prototype.allowedToUpload = function () {
                return this.itemsLeft-- > 0
            }, t
        }())

        function h(t, e) {
            let n = !1
            if (t && t._textures && t._textures.length) {
                for (let r = 0; r < t._textures.length; r++) {
                    if (t._textures[r] instanceof i.db) {
                        const o = t._textures[r].baseTexture; !e.includes(o) && (e.push(o), n = !0)
                    }
                }
            }
            return n
        }

        function f(t, e) {
            if (t.baseTexture instanceof i.h) {
                const n = t.baseTexture
                return !e.includes(n) && e.push(n), !0
            }
            return !1
        }

        function d(t, e) {
            if (t._texture && t._texture instanceof i.db) {
                const n = t._texture.baseTexture
                return !e.includes(n) && e.push(n), !0
            }
            return !1
        }

        function p(t, e) {
            return e instanceof u.b && (e.updateText(!0), !0)
        }

        function m(t, e) {
            if (e instanceof u.d) {
                const n = e.toFontString()
                return u.c.measureFont(n), !0
            }
            return !1
        }

        function y(t, e) {
            if (t instanceof u.b) {
                !e.includes(t.style) && e.push(t.style), !e.includes(t) && e.push(t)
                const n = t._texture.baseTexture
                return !e.includes(n) && e.push(n), !0
            }
            return !1
        }

        function v(t, e) {
            return t instanceof u.d && (!e.includes(t) && e.push(t), !0)
        }
        var _ = (function () {
            function t(t) {
                const e = this
                this.limiter = new l(r.b.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function () {
                    e.queue && e.prepareItems()
                }, this.registerFindHook(y), this.registerFindHook(v), this.registerFindHook(h), this.registerFindHook(f), this.registerFindHook(d), this.registerUploadHook(p), this.registerUploadHook(m)
            }
            return t.prototype.upload = function (t, e) {
                typeof t == 'function' && (e = t, t = null), t && this.add(t), this.queue.length ? (e && this.completes.push(e), this.ticking || (this.ticking = !0, a.a.system.addOnce(this.tick, this, a.c.UTILITY))) : e && e()
            }, t.prototype.tick = function () {
                setTimeout(this.delayedTick, 0)
            }, t.prototype.prepareItems = function () {
                for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
                    const t = this.queue[0]
                    let e = !1
                    if (t && !t._destroyed) {
                        for (var n = 0, r = this.uploadHooks.length; n < r; n++) {
                            if (this.uploadHooks[n](this.uploadHookHelper, t)) {
                                this.queue.shift(), e = !0
                                break
                            }
                        }
                    }
                    e || this.queue.shift()
                }
                if (this.queue.length) { a.a.system.addOnce(this.tick, this, a.c.UTILITY)
                }
                else {
                    this.ticking = !1
                    const i = this.completes.slice(0)
                    this.completes.length = 0
                    for (n = 0, r = i.length; n < r; n++) i[n]()
                }
            }, t.prototype.registerFindHook = function (t) {
                return t && this.addHooks.push(t), this
            }, t.prototype.registerUploadHook = function (t) {
                return t && this.uploadHooks.push(t), this
            }, t.prototype.add = function (t) {
                for (var e = 0, n = this.addHooks.length; e < n && !this.addHooks[e](t, this.queue); e++);
                if (t instanceof s.b) {
                    for (e = t.children.length - 1; e >= 0; e--) this.add(t.children[e])
                }
                return this
            }, t.prototype.destroy = function () {
                this.ticking && a.a.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
            }, t
        }())

        function g(t, e) {
            return e instanceof i.h && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0)
        }

        function b(t, e) {
            if (!(e instanceof o.c)) return !1
            const n = e.geometry
            e.finishPoly(), n.updateBatches()
            for (let r = n.batches, i = 0; i < r.length; i++) {
                const a = r[i].style.texture
                a && g(t, a.baseTexture)
            }
            return n.batchable || t.geometry.bind(n, e._resolveDirectShader(t)), !0
        }

        function E(t, e) {
            return t instanceof o.c && (e.push(t), !0)
        }
        var x = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.uploadHookHelper = n.renderer, n.registerFindHook(E), n.registerUploadHook(g), n.registerUploadHook(b), n
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                c(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e
        }(_))
        var T = (function () {
            function t(t) {
                this.maxMilliseconds = t, this.frameStart = 0
            }
            return t.prototype.beginFrame = function () {
                this.frameStart = Date.now()
            }, t.prototype.allowedToUpload = function () {
                return Date.now() - this.frameStart < this.maxMilliseconds
            }, t
        }())
    },
    './node_modules/@pixi/runner/dist/esm/runner.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return r
        })
        /*!
             * @pixi/runner - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/runner is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        var r = (function () {
            function t(t) {
                this.items = [], this._name = t, this._aliasCount = 0
            }
            return t.prototype.emit = function (t, e, n, r, i, o, a, s) {
                if (arguments.length > 8) throw new Error('max arguments reached')
                const u = this
                let c = u.name
                let l = u.items
                this._aliasCount++
                for (let h = 0, f = l.length; h < f; h++) l[h][c](t, e, n, r, i, o, a, s)
                return l === this.items && this._aliasCount--, this
            }, t.prototype.ensureNonAliasedItems = function () {
                this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
            }, t.prototype.add = function (t) {
                return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
            }, t.prototype.remove = function (t) {
                const e = this.items.indexOf(t)
                return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this
            }, t.prototype.contains = function (t) {
                return this.items.includes(t)
            }, t.prototype.removeAll = function () {
                return this.ensureNonAliasedItems(), this.items.length = 0, this
            }, t.prototype.destroy = function () {
                this.removeAll(), this.items = null, this._name = null
            }, Object.defineProperty(t.prototype, 'empty', {
                get() {
                    return this.items.length === 0
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'name', {
                get() {
                    return this._name
                },
                enumerable: !1,
                configurable: !0
            }), t
        }())
        Object.defineProperties(r.prototype, {
            dispatch: {
                value: r.prototype.emit
            },
            run: {
                value: r.prototype.emit
            }
        })
    },
    './node_modules/@pixi/settings/dist/esm/settings.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return F
        }), n.d(e, 'b', () => {
            return B
        })
        const r = /iPhone/i
        const i = /iPod/i
        const o = /iPad/i
        const a = /\biOS-universal.+Mac\b/i
        const s = /\bAndroid.+Mobile\b/i
        const u = /Android/i
        const c = /(?:SD4930UR|\bSilk.+Mobile\b)/i
        const l = /Silk/i
        const h = /Windows Phone/i
        const f = /\bWindows.+ARM\b/i
        const d = /BlackBerry/i
        const p = /BB10/i
        const m = /Opera Mini/i
        const y = /\b(CriOS|Chrome).+Mobile/i
        const v = /Mobile.+Firefox\b/i
        const _ = function (t) {
            return void 0 !== t && t.platform === 'MacIntel' && typeof t.maxTouchPoints == 'number' && t.maxTouchPoints > 1 && typeof MSStream == 'undefined'
        }
        /*!
             * @pixi/settings - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/settings is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        let g; let b; let E; let x; let T; let S; let w; let O; let P; let R; let A; let I; let C; let k; let N; let M; let j; let D; let L; var F = (function (t) {
            let e = {
                userAgent: '',
                platform: '',
                maxTouchPoints: 0
            }
            t || typeof navigator == 'undefined'
                ? typeof t == 'string'
                    ? e.userAgent = t
                    : t && t.userAgent && (e = {
                        userAgent: t.userAgent,
                        platform: t.platform,
                        maxTouchPoints: t.maxTouchPoints || 0
                    })
                : e = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    maxTouchPoints: navigator.maxTouchPoints || 0
                }
            let n = e.userAgent
            let g = n.split('[FBAN')
            void 0 !== g[1] && (n = g[0]), void 0 !== (g = n.split('Twitter'))[1] && (n = g[0])
            const b = (function (t) {
                return function (e) {
                    return e.test(t)
                }
            }(n))
            var E = {
                apple: {
                    phone: b(r) && !b(h),
                    ipod: b(i),
                    tablet: !b(r) && (b(o) || _(e)) && !b(h),
                    universal: b(a),
                    device: (b(r) || b(i) || b(o) || b(a) || _(e)) && !b(h)
                },
                amazon: {
                    phone: b(c),
                    tablet: !b(c) && b(l),
                    device: b(c) || b(l)
                },
                android: {
                    phone: !b(h) && b(c) || !b(h) && b(s),
                    tablet: !b(h) && !b(c) && !b(s) && (b(l) || b(u)),
                    device: !b(h) && (b(c) || b(l) || b(s) || b(u)) || b(/\bokhttp\b/i)
                },
                windows: {
                    phone: b(h),
                    tablet: b(f),
                    device: b(h) || b(f)
                },
                other: {
                    blackberry: b(d),
                    blackberry10: b(p),
                    opera: b(m),
                    firefox: b(v),
                    chrome: b(y),
                    device: b(d) || b(p) || b(m) || b(v) || b(y)
                },
                any: !1,
                phone: !1,
                tablet: !1
            }
            return E.any = E.apple.device || E.android.device || E.windows.device || E.other.device, E.phone = E.apple.phone || E.android.phone || E.windows.phone, E.tablet = E.apple.tablet || E.android.tablet || E.windows.tablet, E
        }(self.navigator))
        !(function (t) {
            t[t.WEBGL_LEGACY = 0] = 'WEBGL_LEGACY', t[t.WEBGL = 1] = 'WEBGL', t[t.WEBGL2 = 2] = 'WEBGL2'
        }(g || (g = {}))),
        (function (t) {
            t[t.UNKNOWN = 0] = 'UNKNOWN', t[t.WEBGL = 1] = 'WEBGL', t[t.CANVAS = 2] = 'CANVAS'
        }(b || (b = {}))),
        (function (t) {
            t[t.COLOR = 16384] = 'COLOR', t[t.DEPTH = 256] = 'DEPTH', t[t.STENCIL = 1024] = 'STENCIL'
        }(E || (E = {}))),
        (function (t) {
            t[t.NORMAL = 0] = 'NORMAL', t[t.ADD = 1] = 'ADD', t[t.MULTIPLY = 2] = 'MULTIPLY', t[t.SCREEN = 3] = 'SCREEN', t[t.OVERLAY = 4] = 'OVERLAY', t[t.DARKEN = 5] = 'DARKEN', t[t.LIGHTEN = 6] = 'LIGHTEN', t[t.COLOR_DODGE = 7] = 'COLOR_DODGE', t[t.COLOR_BURN = 8] = 'COLOR_BURN', t[t.HARD_LIGHT = 9] = 'HARD_LIGHT', t[t.SOFT_LIGHT = 10] = 'SOFT_LIGHT', t[t.DIFFERENCE = 11] = 'DIFFERENCE', t[t.EXCLUSION = 12] = 'EXCLUSION', t[t.HUE = 13] = 'HUE', t[t.SATURATION = 14] = 'SATURATION', t[t.COLOR = 15] = 'COLOR', t[t.LUMINOSITY = 16] = 'LUMINOSITY', t[t.NORMAL_NPM = 17] = 'NORMAL_NPM', t[t.ADD_NPM = 18] = 'ADD_NPM', t[t.SCREEN_NPM = 19] = 'SCREEN_NPM', t[t.NONE = 20] = 'NONE', t[t.SRC_OVER = 0] = 'SRC_OVER', t[t.SRC_IN = 21] = 'SRC_IN', t[t.SRC_OUT = 22] = 'SRC_OUT', t[t.SRC_ATOP = 23] = 'SRC_ATOP', t[t.DST_OVER = 24] = 'DST_OVER', t[t.DST_IN = 25] = 'DST_IN', t[t.DST_OUT = 26] = 'DST_OUT', t[t.DST_ATOP = 27] = 'DST_ATOP', t[t.ERASE = 26] = 'ERASE', t[t.SUBTRACT = 28] = 'SUBTRACT', t[t.XOR = 29] = 'XOR'
        }(x || (x = {}))),
        (function (t) {
            t[t.POINTS = 0] = 'POINTS', t[t.LINES = 1] = 'LINES', t[t.LINE_LOOP = 2] = 'LINE_LOOP', t[t.LINE_STRIP = 3] = 'LINE_STRIP', t[t.TRIANGLES = 4] = 'TRIANGLES', t[t.TRIANGLE_STRIP = 5] = 'TRIANGLE_STRIP', t[t.TRIANGLE_FAN = 6] = 'TRIANGLE_FAN'
        }(T || (T = {}))),
        (function (t) {
            t[t.RGBA = 6408] = 'RGBA', t[t.RGB = 6407] = 'RGB', t[t.RG = 33319] = 'RG', t[t.RED = 6403] = 'RED', t[t.RGBA_INTEGER = 36249] = 'RGBA_INTEGER', t[t.RGB_INTEGER = 36248] = 'RGB_INTEGER', t[t.RG_INTEGER = 33320] = 'RG_INTEGER', t[t.RED_INTEGER = 36244] = 'RED_INTEGER', t[t.ALPHA = 6406] = 'ALPHA', t[t.LUMINANCE = 6409] = 'LUMINANCE', t[t.LUMINANCE_ALPHA = 6410] = 'LUMINANCE_ALPHA', t[t.DEPTH_COMPONENT = 6402] = 'DEPTH_COMPONENT', t[t.DEPTH_STENCIL = 34041] = 'DEPTH_STENCIL'
        }(S || (S = {}))),
        (function (t) {
            t[t.TEXTURE_2D = 3553] = 'TEXTURE_2D', t[t.TEXTURE_CUBE_MAP = 34067] = 'TEXTURE_CUBE_MAP', t[t.TEXTURE_2D_ARRAY = 35866] = 'TEXTURE_2D_ARRAY', t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = 'TEXTURE_CUBE_MAP_POSITIVE_X', t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = 'TEXTURE_CUBE_MAP_NEGATIVE_X', t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = 'TEXTURE_CUBE_MAP_POSITIVE_Y', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = 'TEXTURE_CUBE_MAP_NEGATIVE_Y', t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = 'TEXTURE_CUBE_MAP_POSITIVE_Z', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = 'TEXTURE_CUBE_MAP_NEGATIVE_Z'
        }(w || (w = {}))),
        (function (t) {
            t[t.UNSIGNED_BYTE = 5121] = 'UNSIGNED_BYTE', t[t.UNSIGNED_SHORT = 5123] = 'UNSIGNED_SHORT', t[t.UNSIGNED_SHORT_5_6_5 = 33635] = 'UNSIGNED_SHORT_5_6_5', t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = 'UNSIGNED_SHORT_4_4_4_4', t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = 'UNSIGNED_SHORT_5_5_5_1', t[t.UNSIGNED_INT = 5125] = 'UNSIGNED_INT', t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = 'UNSIGNED_INT_10F_11F_11F_REV', t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = 'UNSIGNED_INT_2_10_10_10_REV', t[t.UNSIGNED_INT_24_8 = 34042] = 'UNSIGNED_INT_24_8', t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = 'UNSIGNED_INT_5_9_9_9_REV', t[t.BYTE = 5120] = 'BYTE', t[t.SHORT = 5122] = 'SHORT', t[t.INT = 5124] = 'INT', t[t.FLOAT = 5126] = 'FLOAT', t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = 'FLOAT_32_UNSIGNED_INT_24_8_REV', t[t.HALF_FLOAT = 36193] = 'HALF_FLOAT'
        }(O || (O = {}))),
        (function (t) {
            t[t.FLOAT = 0] = 'FLOAT', t[t.INT = 1] = 'INT', t[t.UINT = 2] = 'UINT'
        }(P || (P = {}))),
        (function (t) {
            t[t.NEAREST = 0] = 'NEAREST', t[t.LINEAR = 1] = 'LINEAR'
        }(R || (R = {}))),
        (function (t) {
            t[t.CLAMP = 33071] = 'CLAMP', t[t.REPEAT = 10497] = 'REPEAT', t[t.MIRRORED_REPEAT = 33648] = 'MIRRORED_REPEAT'
        }(A || (A = {}))),
        (function (t) {
            t[t.OFF = 0] = 'OFF', t[t.POW2 = 1] = 'POW2', t[t.ON = 2] = 'ON', t[t.ON_MANUAL = 3] = 'ON_MANUAL'
        }(I || (I = {}))),
        (function (t) {
            t[t.NPM = 0] = 'NPM', t[t.UNPACK = 1] = 'UNPACK', t[t.PMA = 2] = 'PMA', t[t.NO_PREMULTIPLIED_ALPHA = 0] = 'NO_PREMULTIPLIED_ALPHA', t[t.PREMULTIPLY_ON_UPLOAD = 1] = 'PREMULTIPLY_ON_UPLOAD', t[t.PREMULTIPLY_ALPHA = 2] = 'PREMULTIPLY_ALPHA', t[t.PREMULTIPLIED_ALPHA = 2] = 'PREMULTIPLIED_ALPHA'
        }(C || (C = {}))),
        (function (t) {
            t[t.NO = 0] = 'NO', t[t.YES = 1] = 'YES', t[t.AUTO = 2] = 'AUTO', t[t.BLEND = 0] = 'BLEND', t[t.CLEAR = 1] = 'CLEAR', t[t.BLIT = 2] = 'BLIT'
        }(k || (k = {}))),
        (function (t) {
            t[t.AUTO = 0] = 'AUTO', t[t.MANUAL = 1] = 'MANUAL'
        }(N || (N = {}))),
        (function (t) {
            t.LOW = 'lowp', t.MEDIUM = 'mediump', t.HIGH = 'highp'
        }(M || (M = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.SCISSOR = 1] = 'SCISSOR', t[t.STENCIL = 2] = 'STENCIL', t[t.SPRITE = 3] = 'SPRITE'
        }(j || (j = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.LOW = 2] = 'LOW', t[t.MEDIUM = 4] = 'MEDIUM', t[t.HIGH = 8] = 'HIGH'
        }(D || (D = {}))),
        (function (t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = 'ELEMENT_ARRAY_BUFFER', t[t.ARRAY_BUFFER = 34962] = 'ARRAY_BUFFER', t[t.UNIFORM_BUFFER = 35345] = 'UNIFORM_BUFFER'
        }(L || (L = {})))
        var B = {
            MIPMAP_TEXTURES: I.POW2,
            ANISOTROPIC_LEVEL: 0,
            RESOLUTION: 1,
            FILTER_RESOLUTION: 1,
            FILTER_MULTISAMPLE: D.NONE,
            SPRITE_MAX_TEXTURES: (function (t) {
                let e = !0
                if (F.tablet || F.phone) {
                    let n
                    if (F.apple.device) {
                        if (n = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) Number.parseInt(n[1], 10) < 11 && (e = !1)
                    }
                    if (F.android.device) {
                        if (n = navigator.userAgent.match(/Android\s([0-9.]*)/)) Number.parseInt(n[1], 10) < 7 && (e = !1)
                    }
                }
                return e ? t : 4
            }(32)),
            SPRITE_BATCH_SIZE: 4096,
            RENDER_OPTIONS: {
                view: null,
                antialias: !1,
                autoDensity: !1,
                backgroundColor: 0,
                backgroundAlpha: 1,
                useContextAlpha: !0,
                clearBeforeRender: !0,
                preserveDrawingBuffer: !1,
                width: 800,
                height: 600,
                legacy: !1
            },
            GC_MODE: N.AUTO,
            GC_MAX_IDLE: 3600,
            GC_MAX_CHECK_COUNT: 600,
            WRAP_MODE: A.CLAMP,
            SCALE_MODE: R.LINEAR,
            PRECISION_VERTEX: M.HIGH,
            PRECISION_FRAGMENT: F.apple.device ? M.HIGH : M.MEDIUM,
            CAN_UPLOAD_SAME_BUFFER: !F.apple.device,
            CREATE_IMAGE_BITMAP: !1,
            ROUND_PIXELS: !1
        }
    },
    './node_modules/@pixi/sprite-tiling/dist/esm/sprite-tiling.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return h
        }), n.d(e, 'b', () => {
            return p
        })
        const r = n('./node_modules/@pixi/core/dist/esm/core.js')
        const i = n('./node_modules/@pixi/math/dist/esm/math.js')
        const o = n('./node_modules/@pixi/sprite/dist/esm/sprite.js')
        const a = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const s = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        let u = function (t, e) {
            return (u = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }

        function c(t, e) {
            function n() {
                this.constructor = t
            }
            u(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        const l = new i.g()
        var h = (function (t) {
            function e(e, n, o) {
                void 0 === n && (n = 100), void 0 === o && (o = 100)
                let a = t.call(this, e) || this
                return a.tileTransform = new i.m(), a._width = n, a._height = o, a.uvMatrix = a.texture.uvMatrix || new r.fb(e), a.pluginName = 'tilingSprite', a.uvRespectAnchor = !1, a
            }
            return c(e, t), Object.defineProperty(e.prototype, 'clampMargin', {
                get() {
                    return this.uvMatrix.clampMargin
                },
                set(t) {
                    this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'tileScale', {
                get() {
                    return this.tileTransform.scale
                },
                set(t) {
                    this.tileTransform.scale.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'tilePosition', {
                get() {
                    return this.tileTransform.position
                },
                set(t) {
                    this.tileTransform.position.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype._onTextureUpdate = function () {
                this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
            }, e.prototype._render = function (t) {
                const e = this._texture
                e && e.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this))
            }, e.prototype._calculateBounds = function () {
                const t = this._width * -this._anchor._x
                var e = this._height * -this._anchor._y
                var n = this._width * (1 - this._anchor._x)
                var r = this._height * (1 - this._anchor._y)
                this._bounds.addFrame(this.transform, t, e, n, r)
            }, e.prototype.getLocalBounds = function (e) {
                return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new i.j()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
            }, e.prototype.containsPoint = function (t) {
                this.worldTransform.applyInverse(t, l)
                let e = this._width
                var n = this._height
                var r = -e * this.anchor._x
                if (l.x >= r && l.x < r + e) {
                    const i = -n * this.anchor._y
                    if (l.y >= i && l.y < i + n) return !0
                }
                return !1
            }, e.prototype.destroy = function (e) {
                t.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null
            }, e.from = function (t, n) {
                return new e(t instanceof r.db ? t : r.db.from(t, n), n.width, n.height)
            }, Object.defineProperty(e.prototype, 'width', {
                get() {
                    return this._width
                },
                set(t) {
                    this._width = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'height', {
                get() {
                    return this._height
                },
                set(t) {
                    this._height = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(o.a))
        let f = '#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n'
        let d = new i.d()
        var p = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return e.runners.contextChange.add(n), n.quad = new r.O(), n.state = r.Z.for2d(), n
            }
            return c(e, t), e.prototype.contextChange = function () {
                const t = this.renderer
                let e = {
                    globals: t.globalUniforms
                }
                this.simpleShader = r.W.from(f, '#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n', e), this.shader = t.context.webGLVersion > 1 ? r.W.from('#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', '#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n', e) : r.W.from(f, '#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n', e)
            }, e.prototype.render = function (t) {
                const e = this.renderer
                let n = this.quad
                let r = n.vertices
                r[0] = r[6] = t._width * -t.anchor.x, r[1] = r[3] = t._height * -t.anchor.y, r[2] = r[4] = t._width * (1 - t.anchor.x), r[5] = r[7] = t._height * (1 - t.anchor.y)
                const i = t.uvRespectAnchor ? t.anchor.x : 0
                let o = t.uvRespectAnchor ? t.anchor.y : 0;
                (r = n.uvs)[0] = r[6] = -i, r[1] = r[3] = -o, r[2] = r[4] = 1 - i, r[5] = r[7] = 1 - o, n.invalidate()
                const u = t._texture
                let c = u.baseTexture
                let l = t.tileTransform.localTransform
                let h = t.uvMatrix
                let f = c.isPowerOfTwo && u.frame.width === c.width && u.frame.height === c.height
                f && (c._glTextures[e.CONTEXT_UID] ? f = c.wrapMode !== a.s.CLAMP : c.wrapMode === a.s.CLAMP && (c.wrapMode = a.s.REPEAT))
                const p = f ? this.simpleShader : this.shader
                let m = u.width
                let y = u.height
                let v = t._width
                let _ = t._height
                d.set(l.a * m / v, l.b * m / _, l.c * y / v, l.d * y / _, l.tx / v, l.ty / _), d.invert(), f ? d.prepend(h.mapCoord) : (p.uniforms.uMapCoord = h.mapCoord.toArray(!0), p.uniforms.uClampFrame = h.uClampFrame, p.uniforms.uClampOffset = h.uClampOffset), p.uniforms.uTransform = d.toArray(!0), p.uniforms.uColor = new Object(s.premultiplyTintToRgba)(t.tint, t.worldAlpha, p.uniforms.uColor, c.alphaMode), p.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), p.uniforms.uSampler = u, e.shader.bind(p), e.geometry.bind(n), this.state.blendMode = new Object(s.correctBlendMode)(t.blendMode, c.alphaMode), e.state.set(this.state), e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
            }, e
        }(r.K))
    },
    './node_modules/@pixi/sprite/dist/esm/sprite.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return f
        })
        const r = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const i = n('./node_modules/@pixi/core/dist/esm/core.js')
        const o = n('./node_modules/@pixi/display/dist/esm/display.js')
        const a = n('./node_modules/@pixi/math/dist/esm/math.js')
        const s = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        const u = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        let c = function (t, e) {
            return (c = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        const l = new a.g()
        let h = new Uint16Array([0, 1, 2, 0, 2, 3])
        var f = (function (t) {
            function e(e) {
                const n = t.call(this) || this
                return n._anchor = new a.e(n._onAnchorUpdate, n, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), n._texture = null, n._width = 0, n._height = 0, n._tint = null, n._tintRGB = null, n.tint = 16777215, n.blendMode = r.b.NORMAL, n._cachedTint = 16777215, n.uvs = null, n.texture = e || i.db.EMPTY, n.vertexData = new Float32Array(8), n.vertexTrimmedData = null, n._transformID = -1, n._textureID = -1, n._transformTrimmedID = -1, n._textureTrimmedID = -1, n.indices = h, n.pluginName = 'batch', n.isSprite = !0, n._roundPixels = s.b.ROUND_PIXELS, n
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                c(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype._onTextureUpdate = function () {
                this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = new Object(u.sign)(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = new Object(u.sign)(this.scale.y) * this._height / this._texture.orig.height)
            }, e.prototype._onAnchorUpdate = function () {
                this._transformID = -1, this._transformTrimmedID = -1
            }, e.prototype.calculateVertices = function () {
                const t = this._texture
                if (this._transformID !== this.transform._worldID || this._textureID !== t._updateID) {
                    this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID
                    const e = this.transform.worldTransform
                    let n = e.a
                    let r = e.b
                    let i = e.c
                    let o = e.d
                    let a = e.tx
                    let u = e.ty
                    let c = this.vertexData
                    let l = t.trim
                    let h = t.orig
                    let f = this._anchor
                    let d = 0
                    let p = 0
                    let m = 0
                    let y = 0
                    if (l ? (d = (p = l.x - f._x * h.width) + l.width, m = (y = l.y - f._y * h.height) + l.height) : (d = (p = -f._x * h.width) + h.width, m = (y = -f._y * h.height) + h.height), c[0] = n * p + i * y + a, c[1] = o * y + r * p + u, c[2] = n * d + i * y + a, c[3] = o * y + r * d + u, c[4] = n * d + i * m + a, c[5] = o * m + r * d + u, c[6] = n * p + i * m + a, c[7] = o * m + r * p + u, this._roundPixels) {
                        for (let v = s.b.RESOLUTION, _ = 0; _ < c.length; ++_) c[_] = Math.round((c[_] * v | 0) / v)
                    }
                }
            }, e.prototype.calculateTrimmedVertices = function () {
                if (this.vertexTrimmedData) {
                    if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return
                } else { this.vertexTrimmedData = new Float32Array(8)
                }
                this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID
                const t = this._texture
                let e = this.vertexTrimmedData
                let n = t.orig
                let r = this._anchor
                let i = this.transform.worldTransform
                let o = i.a
                let a = i.b
                let s = i.c
                let u = i.d
                let c = i.tx
                let l = i.ty
                let h = -r._x * n.width
                let f = h + n.width
                let d = -r._y * n.height
                let p = d + n.height
                e[0] = o * h + s * d + c, e[1] = u * d + a * h + l, e[2] = o * f + s * d + c, e[3] = u * d + a * f + l, e[4] = o * f + s * p + c, e[5] = u * p + a * f + l, e[6] = o * h + s * p + c, e[7] = u * p + a * h + l
            }, e.prototype._render = function (t) {
                this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
            }, e.prototype._calculateBounds = function () {
                const t = this._texture.trim
                let e = this._texture.orig
                !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
            }, e.prototype.getLocalBounds = function (e) {
                return this.children.length === 0 ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new a.j()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
            }, e.prototype.containsPoint = function (t) {
                this.worldTransform.applyInverse(t, l)
                const e = this._texture.orig.width
                let n = this._texture.orig.height
                let r = -e * this.anchor.x
                let i = 0
                return l.x >= r && l.x < r + e && (i = -n * this.anchor.y, l.y >= i && l.y < i + n)
            }, e.prototype.destroy = function (e) {
                if (t.prototype.destroy.call(this, e), this._texture.off('update', this._onTextureUpdate, this), this._anchor = null, typeof e == 'boolean' ? e : e && e.texture) {
                    const n = typeof e == 'boolean' ? e : e && e.baseTexture
                    this._texture.destroy(!!n)
                }
                this._texture = null
            }, e.from = function (t, n) {
                return new e(t instanceof i.db ? t : i.db.from(t, n))
            }, Object.defineProperty(e.prototype, 'roundPixels', {
                get() {
                    return this._roundPixels
                },
                set(t) {
                    this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'width', {
                get() {
                    return Math.abs(this.scale.x) * this._texture.orig.width
                },
                set(t) {
                    let e = new Object(u.sign)(this.scale.x) || 1
                    this.scale.x = e * t / this._texture.orig.width, this._width = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'height', {
                get() {
                    return Math.abs(this.scale.y) * this._texture.orig.height
                },
                set(t) {
                    let e = new Object(u.sign)(this.scale.y) || 1
                    this.scale.y = e * t / this._texture.orig.height, this._height = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'anchor', {
                get() {
                    return this._anchor
                },
                set(t) {
                    this._anchor.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'tint', {
                get() {
                    return this._tint
                },
                set(t) {
                    this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'texture', {
                get() {
                    return this._texture
                },
                set(t) {
                    this._texture !== t && (this._texture && this._texture.off('update', this._onTextureUpdate, this), this._texture = t || i.db.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once('update', this._onTextureUpdate, this)))
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(o.b))
    },
    './node_modules/@pixi/spritesheet/dist/esm/spritesheet.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return s
        }), n.d(e, 'b', () => {
            return u
        })
        const r = n('./node_modules/@pixi/math/dist/esm/math.js')
        const i = n('./node_modules/@pixi/core/dist/esm/core.js')
        const o = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        const a = n('./node_modules/@pixi/loaders/dist/esm/loaders.js')
        var s = (function () {
            function t(t, e, n) {
                void 0 === n && (n = null), this._texture = t instanceof i.db ? t : null, this.baseTexture = t instanceof i.h ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e
                let r = this.baseTexture.resource
                this.resolution = this._updateResolution(n || (r ? r.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
            }
            return t.prototype._updateResolution = function (t) {
                void 0 === t && (t = null)
                let e = this.data.meta.scale
                var n = new Object(o.getResolutionOfUrl)(t, null)
                return n === null && (n = void 0 !== e ? Number.parseFloat(e) : 1), n !== 1 && this.baseTexture.setResolution(n), n
            }, t.prototype.parse = function (e) {
                this._batchIndex = 0, this._callback = e, this._frameKeys.length <= t.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
            }, t.prototype._processFrames = function (e) {
                for (let n = e, o = t.BATCH_SIZE; n - e < o && n < this._frameKeys.length;) {
                    const a = this._frameKeys[n]
                    var s = this._frames[a]
                    var u = s.frame
                    if (u) {
                        let c = null
                        var l = null
                        var h = !1 !== s.trimmed && s.sourceSize ? s.sourceSize : s.frame
                        var f = new r.j(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution)
                        c = s.rotated ? new r.j(Math.floor(u.x) / this.resolution, Math.floor(u.y) / this.resolution, Math.floor(u.h) / this.resolution, Math.floor(u.w) / this.resolution) : new r.j(Math.floor(u.x) / this.resolution, Math.floor(u.y) / this.resolution, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution), !1 !== s.trimmed && s.spriteSourceSize && (l = new r.j(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution)), this.textures[a] = new i.db(this.baseTexture, c, f, l, s.rotated ? 2 : 0, s.anchor), i.db.addToCache(this.textures[a], a)
                    }
                    n++
                }
            }, t.prototype._processAnimations = function () {
                const t = this.data.animations || {}
                for (const e in t) {
                    this.animations[e] = []
                    for (let n = 0; n < t[e].length; n++) {
                        const r = t[e][n]
                        this.animations[e].push(this.textures[r])
                    }
                }
            }, t.prototype._parseComplete = function () {
                const t = this._callback
                this._callback = null, this._batchIndex = 0, t.call(this, this.textures)
            }, t.prototype._nextBatch = function () {
                const e = this
                this._processFrames(this._batchIndex * t.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
                    e._batchIndex * t.BATCH_SIZE < e._frameKeys.length ? e._nextBatch() : (e._processAnimations(), e._parseComplete())
                }, 0)
            }, t.prototype.destroy = function (t) {
                let e
                for (const n in void 0 === t && (t = !1), this.textures) this.textures[n].destroy()
                this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || void 0 === e || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null
            }, t.BATCH_SIZE = 1e3, t
        }())
        var u = (function () {
            function t() {}
            return t.use = function (e, n) {
                let r; let i; const u = this
                let c = `${e.name}_image`
                if (e.data && e.type === a.c.TYPE.JSON && e.data.frames && !u.resources[c]) {
                    const l = (i = (r = e.data) === null || void 0 === r ? void 0 : r.meta) === null || void 0 === i ? void 0 : i.related_multi_packs
                    if (Array.isArray(l)) {
                        for (let h = function (t) {
                                if (typeof t != 'string') return 'continue'
                                let n = t.replace('.json', '')
                                var r = o.url.resolve(e.url.replace(u.baseUrl, ''), t)
                                if (u.resources[n] || Object.values(u.resources).some((t) => {
                                    return o.url.format(o.url.parse(t.url)) === r
                                })) { return 'continue'
                                }
                                const i = {
                                    crossOrigin: e.crossOrigin,
                                    loadType: a.c.LOAD_TYPE.XHR,
                                    xhrType: a.c.XHR_RESPONSE_TYPE.JSON,
                                    parentResource: e,
                                    metadata: e.metadata
                                }
                                u.add(n, r, i)
                            }, f = 0, d = l; f < d.length; f++) {
                            h(d[f])
                        }
                    }
                    const p = {
                        crossOrigin: e.crossOrigin,
                        metadata: e.metadata.imageMetadata,
                        parentResource: e
                    }
                    let m = t.getResourcePath(e, u.baseUrl)
                    u.add(c, m, p, (t) => {
                        if (t.error) { n(t.error)
                        }
                        else {
                            const r = new s(t.texture, e.data, e.url)
                            r.parse(() => {
                                e.spritesheet = r, e.textures = r.textures, n()
                            })
                        }
                    })
                } else { n()
                }
            }, t.getResourcePath = function (t, e) {
                return t.isDataUrl ? t.data.meta.image : o.url.resolve(t.url.replace(e, ''), t.data.meta.image)
            }, t
        }())
    },
    './node_modules/@pixi/text-bitmap/dist/esm/text-bitmap.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return x
        }), n.d(e, 'b', () => {
            return d
        }), n.d(e, 'c', () => {
            return P
        }), n.d(e, 'd', () => {
            return O
        })
        const r = n('./node_modules/@pixi/math/dist/esm/math.js')
        const i = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        const o = n('./node_modules/@pixi/mesh/dist/esm/mesh.js')
        const a = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        const s = n('./node_modules/@pixi/core/dist/esm/core.js')
        const u = n('./node_modules/@pixi/text/dist/esm/text.js')
        const c = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const l = n('./node_modules/@pixi/display/dist/esm/display.js')
        const h = n('./node_modules/@pixi/loaders/dist/esm/loaders.js')
        let f = function (t, e) {
            return (f = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        var d = function () {
            this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = []
        }
        const p = (function () {
            function t() {}
            return t.test = function (t) {
                return typeof t == 'string' && t.indexOf('info face=') === 0
            }, t.parse = function (t) {
                let e = t.match(/^[a-z]+\s+(?:\S.*|[\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF])$/gm);
                var n = {
                    info: [],
                    common: [],
                    page: [],
                    char: [],
                    chars: [],
                    kerning: [],
                    kernings: [],
                    distanceField: []
                };
                for (const r in e) {
                    let i = e[r].match(/^[a-z]+/gm)[0]
                                var o = e[r].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/g);
                    var a = {}
                    for (const s in o) {
                        let u = o[s].split('=')
                                    var c = u[0]
                                    var l = u[1].replace(/"/g, '');
                        var h = Number.parseFloat(l)
                                    var f = isNaN(h) ? l : h
                        a[c] = f
                    }
                    n[i].push(a)
                }
                let p = new d()
                return n.info.forEach((t) => {
                    return p.info.push({
                        face: t.face,
                        size: Number.parseInt(t.size, 10)
                    })
                }), n.common.forEach((t) => {
                    return p.common.push({
                        lineHeight: Number.parseInt(t.lineHeight, 10)
                    })
                }), n.page.forEach((t) => {
                    return p.page.push({
                        id: Number.parseInt(t.id, 10),
                        file: t.file
                    })
                }), n.char.forEach((t) => {
                    return p.char.push({
                        id: Number.parseInt(t.id, 10),
                        page: Number.parseInt(t.page, 10),
                        x: Number.parseInt(t.x, 10),
                        y: Number.parseInt(t.y, 10),
                        width: Number.parseInt(t.width, 10),
                        height: Number.parseInt(t.height, 10),
                        xoffset: Number.parseInt(t.xoffset, 10),
                        yoffset: Number.parseInt(t.yoffset, 10),
                        xadvance: Number.parseInt(t.xadvance, 10)
                    })
                }), n.kerning.forEach((t) => {
                    return p.kerning.push({
                        first: Number.parseInt(t.first, 10),
                        second: Number.parseInt(t.second, 10),
                        amount: Number.parseInt(t.amount, 10)
                    })
                }), n.distanceField.forEach((t) => {
                    return p.distanceField.push({
                        distanceRange: Number.parseInt(t.distanceRange, 10),
                        fieldType: t.fieldType
                    })
                }), p
            }, t
        }())
        const m = (function () {
            function t() {}
            return t.test = function (t) {
                return t instanceof XMLDocument && t.getElementsByTagName('page').length && t.getElementsByTagName('info')[0].getAttribute('face') !== null
            }, t.parse = function (t) {
                for (var e = new d(), n = t.getElementsByTagName('info'), r = t.getElementsByTagName('common'), i = t.getElementsByTagName('page'), o = t.getElementsByTagName('char'), a = t.getElementsByTagName('kerning'), s = t.getElementsByTagName('distanceField'), u = 0; u < n.length; u++) { e.info.push({
                    face: n[u].getAttribute('face'),
                    size: Number.parseInt(n[u].getAttribute('size'), 10)
                })
}
                for (u = 0; u < r.length; u++) { e.common.push({
                    lineHeight: Number.parseInt(r[u].getAttribute('lineHeight'), 10)
                })
}
                for (u = 0; u < i.length; u++) { e.page.push({
                    id: Number.parseInt(i[u].getAttribute('id'), 10) || 0,
                    file: i[u].getAttribute('file')
                })
}
                for (u = 0; u < o.length; u++) {
                    let c = o[u]
                    e.char.push({
                        id: Number.parseInt(c.getAttribute('id'), 10),
                        page: Number.parseInt(c.getAttribute('page'), 10) || 0,
                        x: Number.parseInt(c.getAttribute('x'), 10),
                        y: Number.parseInt(c.getAttribute('y'), 10),
                        width: Number.parseInt(c.getAttribute('width'), 10),
                        height: Number.parseInt(c.getAttribute('height'), 10),
                        xoffset: Number.parseInt(c.getAttribute('xoffset'), 10),
                        yoffset: Number.parseInt(c.getAttribute('yoffset'), 10),
                        xadvance: Number.parseInt(c.getAttribute('xadvance'), 10)
                    })
                }
                for (u = 0; u < a.length; u++) { e.kerning.push({
                    first: Number.parseInt(a[u].getAttribute('first'), 10),
                    second: Number.parseInt(a[u].getAttribute('second'), 10),
                    amount: Number.parseInt(a[u].getAttribute('amount'), 10)
                })
}
                for (u = 0; u < s.length; u++) { e.distanceField.push({
                    fieldType: s[u].getAttribute('fieldType'),
                    distanceRange: Number.parseInt(s[u].getAttribute('distanceRange'), 10)
                })
}
                return e
            }, t
        }())
        const y = (function () {
            function t() {}
            return t.test = function (t) {
                if (typeof t == 'string' && t.includes('<font>')) {
                    let e = (new self.DOMParser()).parseFromString(t, 'text/xml')
                    return m.test(e)
                }
                return !1
            }, t.parse = function (t) {
                let e = (new self.DOMParser()).parseFromString(t, 'text/xml')
                return m.parse(e)
            }, t
        }())
        const v = [p, m, y]

        function _(t) {
            for (let e = 0; e < v.length; e++) {
                if (v[e].test(t)) return v[e]
            }
            return null
        }

        function g(t, e, n, r, i, o, s) {
            const c = n.text
            const l = n.fontProperties
            e.translate(r, i), e.scale(o, o)
            const h = s.strokeThickness / 2
            const f = -s.strokeThickness / 2
            e.font = s.toFontString(), e.lineWidth = s.strokeThickness, e.textBaseline = s.textBaseline, e.lineJoin = s.lineJoin, e.miterLimit = s.miterLimit, e.fillStyle = (function (t, e, n, r, i, o) {
                let a; const s = n.fill
                if (!Array.isArray(s)) return s
                if (s.length === 1) return s[0]
                const c = n.dropShadow ? n.dropShadowDistance : 0
                let l = n.padding || 0
                let h = t.width / r - c - 2 * l
                let f = t.height / r - c - 2 * l
                let d = s.slice()
                let p = n.fillGradientStops.slice()
                if (!p.length) {
                    for (var m = d.length + 1, y = 1; y < m; ++y) p.push(y / m)
                }
                if (d.unshift(s[0]), p.unshift(0), d.push(s[s.length - 1]), p.push(1), n.fillGradientType === u.a.LINEAR_VERTICAL) {
                    a = e.createLinearGradient(h / 2, l, h / 2, f + l)
                    let v = 0
                    let _ = (o.fontProperties.fontSize + n.strokeThickness) / f
                    for (y = 0; y < i.length; y++) {
                        for (let g = o.lineHeight * y, b = 0; b < d.length; b++) {
                            const E = g / f + (typeof p[b] == 'number' ? p[b] : b / d.length) * _
                            var x = Math.max(v, E)
                            x = Math.min(x, 1), a.addColorStop(x, d[b]), v = x
                        }
                    }
                } else {
                    a = e.createLinearGradient(l, f / 2, h + l, f / 2)
                    const T = d.length + 1
                    let S = 1
                    for (y = 0; y < d.length; y++) {
                        let w = void 0
                        w = typeof p[y] == 'number' ? p[y] : S / T, a.addColorStop(w, d[y]), S++
                    }
                }
                return a
            }(t, e, s, o, [c], n)), e.strokeStyle = s.stroke
            const d = s.dropShadowColor
            const p = new Object(a.hex2rgb)(typeof d == 'number' ? d : new Object(a.string2hex)(d))
            s.dropShadow ? (e.shadowColor = `rgba(${255 * p[0]},${255 * p[1]},${255 * p[2]},${s.dropShadowAlpha})`, e.shadowBlur = s.dropShadowBlur, e.shadowOffsetX = Math.cos(s.dropShadowAngle) * s.dropShadowDistance, e.shadowOffsetY = Math.sin(s.dropShadowAngle) * s.dropShadowDistance) : (e.shadowColor = 'black', e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0), s.stroke && s.strokeThickness && e.strokeText(c, h, f + n.lineHeight - l.descent), s.fill && e.fillText(c, h, f + n.lineHeight - l.descent), e.setTransform(1, 0, 0, 1, 0, 0), e.fillStyle = 'rgba(0, 0, 0, 0)'
        }

        function b(t) {
            return Array.from ? Array.from(t) : t.split('')
        }

        function E(t) {
            return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0)
        }
        var x = (function () {
            function t(t, e, n) {
                let i; let o; const u = t.info[0]
                let l = t.common[0]
                let h = t.page[0]
                let f = t.distanceField[0]
                let d = new Object(a.getResolutionOfUrl)(h.file)
                let p = {}
                this._ownsTextures = n, this.font = u.face, this.size = u.size, this.lineHeight = l.lineHeight / d, this.chars = {}, this.pageTextures = p
                for (var m = 0; m < t.page.length; m++) {
                    const y = t.page[m]
                    var v = y.id
                    let _ = y.file
                    p[v] = Array.isArray(e) ? e[m] : e[_], (f == null ? void 0 : f.fieldType) && f.fieldType !== 'none' && (p[v].baseTexture.alphaMode = c.a.NO_PREMULTIPLIED_ALPHA)
                }
                for (m = 0; m < t.char.length; m++) {
                    const g = t.char[m]
                    let b = (v = g.id, g.page)
                    let E = t.char[m]
                    let x = E.x
                    let T = E.y
                    let S = E.width
                    let w = E.height
                    let O = E.xoffset
                    let P = E.yoffset
                    let R = E.xadvance
                    x /= d, T /= d, S /= d, w /= d, O /= d, P /= d, R /= d
                    const A = new r.j(x + p[b].frame.x / d, T + p[b].frame.y / d, S, w)
                    this.chars[v] = {
                        xOffset: O,
                        yOffset: P,
                        xAdvance: R,
                        kerning: {},
                        texture: new s.db(p[b].baseTexture, A),
                        page: b
                    }
                }
                for (m = 0; m < t.kerning.length; m++) {
                    const I = t.kerning[m]
                    let C = I.first
                    let k = I.second
                    let N = I.amount
                    C /= d, k /= d, N /= d, this.chars[k] && (this.chars[k].kerning[C] = N)
                }
                this.distanceFieldRange = f == null ? void 0 : f.distanceRange, this.distanceFieldType = (o = (i = f == null ? void 0 : f.fieldType) === null || void 0 === i ? void 0 : i.toLowerCase()) !== null && void 0 !== o ? o : 'none'
            }
            return t.prototype.destroy = function () {
                for (var t in this.chars) this.chars[t].texture.destroy(), this.chars[t].texture = null
                for (var t in this.pageTextures) this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null
                this.chars = null, this.pageTextures = null
            }, t.install = function (e, n, r) {
                let i
                if (e instanceof d) { i = e
                }
                else {
                    const o = _(e)
                    if (!o) throw new Error('Unrecognized data format for font.')
                    i = o.parse(e)
                }
                n instanceof s.db && (n = [n])
                const a = new t(i, n, r)
                return t.available[a.font] = a, a
            }, t.uninstall = function (e) {
                const n = t.available[e]
                if (!n) throw new Error(`No font found named '${e}'`)
                n.destroy(), delete t.available[e]
            }, t.from = function (e, n, r) {
                if (!e) throw new Error('[BitmapFont] Property `name` is required.')
                let i = Object.assign({}, t.defaultOptions, r)
                let o = i.chars
                let a = i.padding
                let c = i.resolution
                let l = i.textureWidth
                let h = i.textureHeight
                let f = (function (t) {
                    'string' == typeof t && (t = [t])
                    for (var e = [], n = 0, r = t.length; n < r; n++) {
                        let i = t[n]
                        if (Array.isArray(i)) {
                            if (i.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${  i.length  }.`);
                            let o = i[0].charCodeAt(0)
                                            var a = i[1].charCodeAt(0)
                            if (a < o) throw new Error('[BitmapFont]: Invalid character range.')
                            for (let s = o, u = a; s <= u; s++) e.push(String.fromCharCode(s))
                        } else { e.push.apply(e, b(i))
                        }
                    }
                    if (e.length === 0) throw new Error('[BitmapFont]: Empty set when resolving characters.')
                    return e
                }(o))
                let p = n instanceof u.d ? n : new u.d(n)
                let m = l
                let y = new d()
                y.info[0] = {
                    face: p.fontFamily,
                    size: p.fontSize
                }, y.common[0] = {
                    lineHeight: p.fontSize
                }
                for (var v, _, x, T = 0, S = 0, w = 0, O = [], P = 0; P < f.length; P++) {
                    v || ((v = document.createElement('canvas')).width = l, v.height = h, _ = v.getContext('2d'), x = new s.h(v, {
                        resolution: c
                    }), O.push(new s.db(x)), y.page.push({
                        id: O.length - 1,
                        file: ''
                    }))
                    const R = u.c.measureText(f[P], p, !1, v)
                    let A = R.width
                    let I = Math.ceil(R.height)
                    let C = Math.ceil((p.fontStyle === 'italic' ? 2 : 1) * A)
                    if (S >= h - I * c) {
                        if (S === 0) throw new Error(`[BitmapFont] textureHeight ${h}px is too small for ${p.fontSize}px fonts`)
                        --P, v = null, _ = null, x = null, S = 0, T = 0, w = 0
                    } else if (w = Math.max(I + R.fontProperties.descent, w), C * c + T >= m) { --P, S += w * c, S = Math.ceil(S), T = 0, w = 0
                    }
                    else {
                        g(v, _, R, T, S, c, p)
                        const k = E(R.text)
                        y.char.push({
                            id: k,
                            page: O.length - 1,
                            x: T / c,
                            y: S / c,
                            width: C,
                            height: I,
                            xoffset: 0,
                            yoffset: 0,
                            xadvance: Math.ceil(A - (p.dropShadow ? p.dropShadowDistance : 0) - (p.stroke ? p.strokeThickness : 0))
                        }), T += (C + 2 * a) * c, T = Math.ceil(T)
                    }
                }
                P = 0
                for (let N = f.length; P < N; P++) {
                    for (let M = f[P], j = 0; j < N; j++) {
                        const D = f[j]
                        var L = _.measureText(M).width
                        var F = _.measureText(D).width
                        var B = _.measureText(M + D).width - (L + F)
                        B && y.kerning.push({
                            first: E(M),
                            second: E(D),
                            amount: B
                        })
                    }
                }
                const U = new t(y, O, !0)
                return void 0 !== t.available[e] && t.uninstall(e), t.available[e] = U, U
            }, t.ALPHA = [
                ['a', 'z'],
                ['A', 'Z'],
                ' '
            ], t.NUMERIC = [
                ['0', '9']
            ], t.ALPHANUMERIC = [
                ['a', 'z'],
                ['A', 'Z'],
                ['0', '9'],
                ' '
            ], t.ASCII = [
                [' ', '~']
            ], t.defaultOptions = {
                resolution: 1,
                textureWidth: 512,
                textureHeight: 512,
                padding: 4,
                chars: t.ALPHANUMERIC
            }, t.available = {}, t
        }())
        let T = []
        let S = []
        let w = []
        var O = (function (t) {
            function e(n, o) {
                void 0 === o && (o = {})
                let a = t.call(this) || this
                a._tint = 16777215
                let s = Object.assign({}, e.styleDefaults, o)
                var u = s.align
                var c = s.tint
                var l = s.maxWidth
                var h = s.letterSpacing
                var f = s.fontName
                var d = s.fontSize
                if (!x.available[f]) throw new Error(`Missing BitmapFont "${f}"`)
                return a._activePagesMeshData = [], a._textWidth = 0, a._textHeight = 0, a._align = u, a._tint = c, a._fontName = f, a._fontSize = d || x.available[f].size, a._text = n, a._maxWidth = l, a._maxLineHeight = 0, a._letterSpacing = h, a._anchor = new r.e(() => {
                            a.dirty = !0
                        }, a, 0, 0), a._roundPixels = i.b.ROUND_PIXELS, a.dirty = !0, a._textureCache = {}, a
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                f(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype.updateText = function () {
                for (var t, e = x.available[this._fontName], n = this._fontSize / e.size, i = new r.g(), u = [], l = [], h = [], f = b(this._text.replace(/\r\n|\r/g, '\n') || ' '), d = this._maxWidth * e.size / this._fontSize, p = e.distanceFieldType === 'none' ? T : S, m = null, y = 0, v = 0, _ = 0, g = -1, O = 0, P = 0, R = 0, A = 0, I = 0; I < f.length; I++) {
                    const C = E($ = f[I])
                    if (/\s/.test($) && (g = I, O = y, A++), $ !== '\r' && $ !== '\n') {
                        const k = e.chars[C]
                        if (k) {
                            m && k.kerning[m] && (i.x += k.kerning[m])
                            let N = w.pop() || {
                                texture: s.db.EMPTY,
                                line: 0,
                                charCode: 0,
                                prevSpaces: 0,
                                position: new r.g()
                            }
                            N.texture = k.texture, N.line = _, N.charCode = C, N.position.x = i.x + k.xOffset + this._letterSpacing / 2, N.position.y = i.y + k.yOffset, N.prevSpaces = A, u.push(N), y = N.position.x + k.texture.orig.width, i.x += k.xAdvance + this._letterSpacing, R = Math.max(R, k.yOffset + k.texture.height), m = C, g !== -1 && d > 0 && i.x > d && (++P, new Object(a.removeItems)(u, 1 + g - P, 1 + I - g), I = g, g = -1, l.push(O), h.push(u.length > 0 ? u[u.length - 1].prevSpaces : 0), v = Math.max(v, O), _++, i.x = 0, i.y += e.lineHeight, m = null, A = 0)
                        }
                    } else { l.push(y), h.push(-1), v = Math.max(v, y), ++_, ++P, i.x = 0, i.y += e.lineHeight, m = null, A = 0
                    }
                }
                const M = f[f.length - 1]
                '\r' !== M && M !== '\n' && (/\s/.test(M) && (y = O), l.push(y), v = Math.max(v, y), h.push(-1))
                let j = []
                for (I = 0; I <= _; I++) {
                    let D = 0
                    'right' === this._align ? D = v - l[I] : this._align === 'center' ? D = (v - l[I]) / 2 : this._align === 'justify' && (D = h[I] < 0 ? 0 : (v - l[I]) / h[I]), j.push(D)
                }
                const L = u.length
                var F = {}
                var B = []
                var U = this._activePagesMeshData
                for (I = 0; I < U.length; I++) p.push(U[I])
                for (I = 0; I < L; I++) {
                    const G = (Q = u[I].texture).baseTexture.uid
                    if (!F[G]) {
                        if (!(at = p.pop())) {
                            const X = new o.c();
                            var H = void 0
                                var V = void 0
                            'none' === e.distanceFieldType
                                ? (H = new o.d(s.db.EMPTY), V = c.b.NORMAL)
                                : (H = new o.d(s.db.EMPTY, {
                                        program: s.L.from('// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n', '// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n'),
                                        uniforms: {
                                            uFWidth: 0
                                        }
                                    }), V = c.b.NORMAL_NPM)
                            let W = new o.a(X, H)
                            W.blendMode = V, at = {
                                index: 0,
                                indexCount: 0,
                                vertexCount: 0,
                                uvsCount: 0,
                                total: 0,
                                mesh: W,
                                vertices: null,
                                uvs: null,
                                indices: null
                            }
                        }
                        at.index = 0, at.indexCount = 0, at.vertexCount = 0, at.uvsCount = 0, at.total = 0
                        let Y = this._textureCache
                        Y[G] = Y[G] || new s.db(Q.baseTexture), at.mesh.texture = Y[G], at.mesh.tint = this._tint, B.push(at), F[G] = at
                    }
                    F[G].total++
                }
                for (I = 0; I < U.length; I++) !B.includes(U[I]) && this.removeChild(U[I].mesh)
                for (I = 0; I < B.length; I++) B[I].mesh.parent !== this && this.addChild(B[I].mesh)
                for (var I in this._activePagesMeshData = B, F) {
                    const z = (at = F[I]).total
                    if (!(((t = at.indices) === null || void 0 === t ? void 0 : t.length) > 6 * z) || at.vertices.length < 2 * o.a.BATCHABLE_SIZE) { at.vertices = new Float32Array(8 * z), at.uvs = new Float32Array(8 * z), at.indices = new Uint16Array(6 * z)
                    }
                    else {
                        for (let q = at.total, K = at.vertices, Z = 4 * q * 2; Z < K.length; Z++) K[Z] = 0
                    }
                    at.mesh.size = 6 * z
                }
                for (I = 0; I < L; I++) {
                    var $; let J = ($ = u[I]).position.x + j[$.line] * (this._align === 'justify' ? $.prevSpaces : 1)
                    this._roundPixels && (J = Math.round(J))
                    var Q; const tt = J * n
                    var et = $.position.y * n
                    var nt = F[(Q = $.texture).baseTexture.uid]
                    var rt = Q.frame
                    var it = Q._uvs
                    var ot = nt.index++
                    nt.indices[6 * ot + 0] = 0 + 4 * ot, nt.indices[6 * ot + 1] = 1 + 4 * ot, nt.indices[6 * ot + 2] = 2 + 4 * ot, nt.indices[6 * ot + 3] = 0 + 4 * ot, nt.indices[6 * ot + 4] = 2 + 4 * ot, nt.indices[6 * ot + 5] = 3 + 4 * ot, nt.vertices[8 * ot + 0] = tt, nt.vertices[8 * ot + 1] = et, nt.vertices[8 * ot + 2] = tt + rt.width * n, nt.vertices[8 * ot + 3] = et, nt.vertices[8 * ot + 4] = tt + rt.width * n, nt.vertices[8 * ot + 5] = et + rt.height * n, nt.vertices[8 * ot + 6] = tt, nt.vertices[8 * ot + 7] = et + rt.height * n, nt.uvs[8 * ot + 0] = it.x0, nt.uvs[8 * ot + 1] = it.y0, nt.uvs[8 * ot + 2] = it.x1, nt.uvs[8 * ot + 3] = it.y1, nt.uvs[8 * ot + 4] = it.x2, nt.uvs[8 * ot + 5] = it.y2, nt.uvs[8 * ot + 6] = it.x3, nt.uvs[8 * ot + 7] = it.y3
                }
                for (var I in this._textWidth = v * n, this._textHeight = (i.y + e.lineHeight) * n, F) {
                    var at = F[I]
                    if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                        for (let st = 0, ut = this._textWidth * this.anchor.x, ct = this._textHeight * this.anchor.y, lt = 0; lt < at.total; lt++) at.vertices[st++] -= ut, at.vertices[st++] -= ct, at.vertices[st++] -= ut, at.vertices[st++] -= ct, at.vertices[st++] -= ut, at.vertices[st++] -= ct, at.vertices[st++] -= ut, at.vertices[st++] -= ct
                    }
                    this._maxLineHeight = R * n
                    let ht = at.mesh.geometry.getBuffer('aVertexPosition')
                    var ft = at.mesh.geometry.getBuffer('aTextureCoord')
                    var dt = at.mesh.geometry.getIndex()
                    ht.data = at.vertices, ft.data = at.uvs, dt.data = at.indices, ht.update(), ft.update(), dt.update()
                }
                for (I = 0; I < u.length; I++) w.push(u[I])
            }, e.prototype.updateTransform = function () {
                this.validate(), this.containerUpdateTransform()
            }, e.prototype._render = function (e) {
                const n = x.available[this._fontName]
                var r = n.distanceFieldRange
                var i = n.distanceFieldType
                var o = n.size
                if (i !== 'none') {
                    for (let a = this.worldTransform, s = a.a, u = a.b, c = a.c, l = a.d, h = Math.sqrt(s * s + u * u), f = Math.sqrt(c * c + l * l), d = (Math.abs(h) + Math.abs(f)) / 2, p = this._fontSize / o, m = 0, y = this._activePagesMeshData; m < y.length; m++) {
                        y[m].mesh.shader.uniforms.uFWidth = d * r * p * e.resolution
                    }
                }
                t.prototype._render.call(this, e)
            }, e.prototype.getLocalBounds = function () {
                return this.validate(), t.prototype.getLocalBounds.call(this)
            }, e.prototype.validate = function () {
                this.dirty && (this.updateText(), this.dirty = !1)
            }, Object.defineProperty(e.prototype, 'tint', {
                get() {
                    return this._tint
                },
                set(t) {
                    if (this._tint !== t) {
                        this._tint = t
                        for (let e = 0; e < this._activePagesMeshData.length; e++) this._activePagesMeshData[e].mesh.tint = t
                    }
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'align', {
                get() {
                    return this._align
                },
                set(t) {
                    this._align !== t && (this._align = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'fontName', {
                get() {
                    return this._fontName
                },
                set(t) {
                    if (!x.available[t]) throw new Error(`Missing BitmapFont "${ t }"`)
                    this._fontName !== t && (this._fontName = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'fontSize', {
                get() {
                    return this._fontSize
                },
                set(t) {
                    this._fontSize !== t && (this._fontSize = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'anchor', {
                get() {
                    return this._anchor
                },
                set(t) {
                    'number' == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'text', {
                get() {
                    return this._text
                },
                set(t) {
                    t = String(t == null ? '' : t), this._text !== t && (this._text = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'maxWidth', {
                get() {
                    return this._maxWidth
                },
                set(t) {
                    this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'maxLineHeight', {
                get() {
                    return this.validate(), this._maxLineHeight
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'textWidth', {
                get() {
                    return this.validate(), this._textWidth
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'letterSpacing', {
                get() {
                    return this._letterSpacing
                },
                set(t) {
                    this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'roundPixels', {
                get() {
                    return this._roundPixels
                },
                set(t) {
                    t !== this._roundPixels && (this._roundPixels = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'textHeight', {
                get() {
                    return this.validate(), this._textHeight
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.destroy = function (e) {
                const n = this._textureCache
                for (const r in n) {
                    n[r].destroy(), delete n[r]
                }
                this._textureCache = null, t.prototype.destroy.call(this, e)
            }, e.styleDefaults = {
                align: 'left',
                tint: 16777215,
                maxWidth: 0,
                letterSpacing: 0
            }, e
        }(l.b))
        var P = (function () {
            function t() {}
            return t.add = function () {
                h.c.setExtensionXhrType('fnt', h.c.XHR_RESPONSE_TYPE.TEXT)
            }, t.use = function (e, n) {
                const r = _(e.data)
                if (r) {
                    for (var i = t.getBaseUrl(this, e), o = r.parse(e.data), a = {}, s = function (t) {
                            a[t.metadata.pageFile] = t.texture, Object.keys(a).length === o.page.length && (e.bitmapFont = x.install(o, a, !0), n())
                        }, u = 0; u < o.page.length; ++u) {
                        const c = o.page[u].file
                        var l = i + c
                        var f = !1
                        for (const d in this.resources) {
                            const p = this.resources[d]
                            if (p.url === l) {
                                p.metadata.pageFile = c, p.texture ? s(p) : p.onAfterMiddleware.add(s), f = !0
                                break
                            }
                        }
                        if (!f) {
                            const m = {
                                crossOrigin: e.crossOrigin,
                                loadType: h.c.LOAD_TYPE.IMAGE,
                                metadata: Object.assign({
                                    pageFile: c
                                }, e.metadata.imageMetadata),
                                parentResource: e
                            }
                            this.add(l, m, s)
                        }
                    }
                } else { n()
                }
            }, t.getBaseUrl = function (e, n) {
                let r = n.isDataUrl ? '' : t.dirname(n.url)
                return n.isDataUrl && (r === '.' && (r = ''), e.baseUrl && r && e.baseUrl.charAt(e.baseUrl.length - 1) === '/' && (r += '/')), (r = r.replace(e.baseUrl, '')) && r.charAt(r.length - 1) !== '/' && (r += '/'), r
            }, t.dirname = function (t) {
                const e = t.replace(/\\/g, '/').replace(/\/$/, '').replace(/\/[^/]*$/, '')
                return e === t ? '.' : e === '' ? '/' : e
            }, t
        }())
    },
    './node_modules/@pixi/text/dist/esm/text.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return r
        }), n.d(e, 'b', () => {
            return b
        }), n.d(e, 'c', () => {
            return y
        }), n.d(e, 'd', () => {
            return f
        })
        let r; const i = n('./node_modules/@pixi/sprite/dist/esm/sprite.js')
        const o = n('./node_modules/@pixi/core/dist/esm/core.js')
        const a = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        const s = n('./node_modules/@pixi/math/dist/esm/math.js')
        const u = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        let c = function (t, e) {
            return (c = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        !(function (t) {
            t[t.LINEAR_VERTICAL = 0] = 'LINEAR_VERTICAL', t[t.LINEAR_HORIZONTAL = 1] = 'LINEAR_HORIZONTAL'
        }(r || (r = {})))
        const l = {
            align: 'left',
            breakWords: !1,
            dropShadow: !1,
            dropShadowAlpha: 1,
            dropShadowAngle: Math.PI / 6,
            dropShadowBlur: 0,
            dropShadowColor: 'black',
            dropShadowDistance: 5,
            fill: 'black',
            fillGradientType: r.LINEAR_VERTICAL,
            fillGradientStops: [],
            fontFamily: 'Arial',
            fontSize: 26,
            fontStyle: 'normal',
            fontVariant: 'normal',
            fontWeight: 'normal',
            letterSpacing: 0,
            lineHeight: 0,
            lineJoin: 'miter',
            miterLimit: 10,
            padding: 0,
            stroke: 'black',
            strokeThickness: 0,
            textBaseline: 'alphabetic',
            trim: !1,
            whiteSpace: 'pre',
            wordWrap: !1,
            wordWrapWidth: 100,
            leading: 0
        }
        const h = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui']
        var f = (function () {
            function t(t) {
                this.styleID = 0, this.reset(), m(this, t, t)
            }
            return t.prototype.clone = function () {
                const e = {}
                return m(e, this, l), new t(e)
            }, t.prototype.reset = function () {
                m(this, l, l)
            }, Object.defineProperty(t.prototype, 'align', {
                get() {
                    return this._align
                },
                set(t) {
                    this._align !== t && (this._align = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'breakWords', {
                get() {
                    return this._breakWords
                },
                set(t) {
                    this._breakWords !== t && (this._breakWords = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'dropShadow', {
                get() {
                    return this._dropShadow
                },
                set(t) {
                    this._dropShadow !== t && (this._dropShadow = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'dropShadowAlpha', {
                get() {
                    return this._dropShadowAlpha
                },
                set(t) {
                    this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'dropShadowAngle', {
                get() {
                    return this._dropShadowAngle
                },
                set(t) {
                    this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'dropShadowBlur', {
                get() {
                    return this._dropShadowBlur
                },
                set(t) {
                    this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'dropShadowColor', {
                get() {
                    return this._dropShadowColor
                },
                set(t) {
                    const e = p(t)
                    this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'dropShadowDistance', {
                get() {
                    return this._dropShadowDistance
                },
                set(t) {
                    this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'fill', {
                get() {
                    return this._fill
                },
                set(t) {
                    const e = p(t)
                    this._fill !== e && (this._fill = e, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'fillGradientType', {
                get() {
                    return this._fillGradientType
                },
                set(t) {
                    this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'fillGradientStops', {
                get() {
                    return this._fillGradientStops
                },
                set(t) {
                    (function (t, e) {
                        if (!Array.isArray(t) || !Array.isArray(e)) return !1
                        if (t.length !== e.length) return !1
                        for (let n = 0; n < t.length; ++n) {
                            if (t[n] !== e[n]) return !1
                        }
                        return !0
                    })(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'fontFamily', {
                get() {
                    return this._fontFamily
                },
                set(t) {
                    this.fontFamily !== t && (this._fontFamily = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'fontSize', {
                get() {
                    return this._fontSize
                },
                set(t) {
                    this._fontSize !== t && (this._fontSize = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'fontStyle', {
                get() {
                    return this._fontStyle
                },
                set(t) {
                    this._fontStyle !== t && (this._fontStyle = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'fontVariant', {
                get() {
                    return this._fontVariant
                },
                set(t) {
                    this._fontVariant !== t && (this._fontVariant = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'fontWeight', {
                get() {
                    return this._fontWeight
                },
                set(t) {
                    this._fontWeight !== t && (this._fontWeight = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'letterSpacing', {
                get() {
                    return this._letterSpacing
                },
                set(t) {
                    this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'lineHeight', {
                get() {
                    return this._lineHeight
                },
                set(t) {
                    this._lineHeight !== t && (this._lineHeight = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'leading', {
                get() {
                    return this._leading
                },
                set(t) {
                    this._leading !== t && (this._leading = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'lineJoin', {
                get() {
                    return this._lineJoin
                },
                set(t) {
                    this._lineJoin !== t && (this._lineJoin = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'miterLimit', {
                get() {
                    return this._miterLimit
                },
                set(t) {
                    this._miterLimit !== t && (this._miterLimit = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'padding', {
                get() {
                    return this._padding
                },
                set(t) {
                    this._padding !== t && (this._padding = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'stroke', {
                get() {
                    return this._stroke
                },
                set(t) {
                    const e = p(t)
                    this._stroke !== e && (this._stroke = e, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'strokeThickness', {
                get() {
                    return this._strokeThickness
                },
                set(t) {
                    this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'textBaseline', {
                get() {
                    return this._textBaseline
                },
                set(t) {
                    this._textBaseline !== t && (this._textBaseline = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'trim', {
                get() {
                    return this._trim
                },
                set(t) {
                    this._trim !== t && (this._trim = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'whiteSpace', {
                get() {
                    return this._whiteSpace
                },
                set(t) {
                    this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'wordWrap', {
                get() {
                    return this._wordWrap
                },
                set(t) {
                    this._wordWrap !== t && (this._wordWrap = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'wordWrapWidth', {
                get() {
                    return this._wordWrapWidth
                },
                set(t) {
                    this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++)
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.toFontString = function () {
                const t = typeof this.fontSize == 'number' ? `${this.fontSize}px` : this.fontSize
                let e = this.fontFamily
                Array.isArray(this.fontFamily) || (e = this.fontFamily.split(','))
                for (let n = e.length - 1; n >= 0; n--) {
                    let r = e[n].trim()
                    !/(["'])[^'"]+\1/.test(r) && !h.includes(r) && (r = `"${r}"`), e[n] = r
                }
                return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${t} ${e.join(',')}`
            }, t
        }())

        function d(t) {
            return typeof t == 'number' ? new Object(u.hex2string)(t) : (typeof t == 'string' && t.indexOf('0x') === 0 && (t = t.replace('0x', '#')), t)
        }

        function p(t) {
            if (Array.isArray(t)) {
                for (let e = 0; e < t.length; ++e) t[e] = d(t[e])
                return t
            }
            return d(t)
        }

        function m(t, e, n) {
            for (const r in n) Array.isArray(e[r]) ? t[r] = e[r].slice() : t[r] = e[r]
        }
        var y = (function () {
            function t(t, e, n, r, i, o, a, s, u) {
                this.text = t, this.style = e, this.width = n, this.height = r, this.lines = i, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = s, this.fontProperties = u
            }
            return t.measureText = function (e, n, r, i) {
                void 0 === i && (i = t._canvas), r = r == null ? n.wordWrap : r
                const o = n.toFontString()
                let a = t.measureFont(o)
                a.fontSize === 0 && (a.fontSize = n.fontSize, a.ascent = n.fontSize)
                const s = i.getContext('2d')
                s.font = o
                for (var u = (r ? t.wordWrap(e, n, i) : e).split(/\r\n|\r|\n/), c = Array.from({ length: u.length }), l = 0, h = 0; h < u.length; h++) {
                    const f = s.measureText(u[h]).width + (u[h].length - 1) * n.letterSpacing
                    c[h] = f, l = Math.max(l, f)
                }
                let d = l + n.strokeThickness
                n.dropShadow && (d += n.dropShadowDistance)
                const p = n.lineHeight || a.fontSize + n.strokeThickness
                let m = Math.max(p, a.fontSize + n.strokeThickness) + (u.length - 1) * (p + n.leading)
                return n.dropShadow && (m += n.dropShadowDistance), new t(e, n, d, m, u, c, p + n.leading, l, a)
            }, t.wordWrap = function (e, n, r) {
                void 0 === r && (r = t._canvas)
                for (var i = r.getContext('2d'), o = 0, a = '', s = '', u = Object.create(null), c = n.letterSpacing, l = n.whiteSpace, h = t.collapseSpaces(l), f = t.collapseNewlines(l), d = !h, p = n.wordWrapWidth + c, m = t.tokenize(e), y = 0; y < m.length; y++) {
                    let v = m[y]
                    if (t.isNewline(v)) {
                        if (!f) {
                            s += t.addLine(a), d = !h, a = '', o = 0
                            continue
                        }
                        v = ' '
                    }
                    if (h) {
                        const _ = t.isBreakingSpace(v)
                        let g = t.isBreakingSpace(a[a.length - 1])
                        if (_ && g) continue
                    }
                    const b = t.getFromCache(v, c, u, i)
                    if (b > p) {
                        if (a !== '' && (s += t.addLine(a), a = '', o = 0), t.canBreakWords(v, n.breakWords)) {
                            for (let E = t.wordWrapSplit(v), x = 0; x < E.length; x++) {
                                for (var T = E[x], S = 1; E[x + S];) {
                                    let w = E[x + S]
                                                var O = T[T.length - 1]
                                    if (t.canBreakChars(O, w, v, x, n.breakWords)) break
                                    T += w, S++
                                }
                                x += T.length - 1
                                var P = t.getFromCache(T, c, u, i)
                                P + o > p && (s += t.addLine(a), d = !1, a = '', o = 0), a += T, o += P
                            }
                        } else {
                            a.length > 0 && (s += t.addLine(a), a = '', o = 0)
                            let R = y === m.length - 1
                            s += t.addLine(v, !R), d = !1, a = '', o = 0
                        }
                    } else { b + o > p && (d = !1, s += t.addLine(a), a = '', o = 0), (a.length > 0 || !t.isBreakingSpace(v) || d) && (a += v, o += b)
                    }
                }
                return s += t.addLine(a, !1)
            }, t.addLine = function (e, n) {
                return void 0 === n && (n = !0), e = t.trimRight(e), e = n ? `${e}\n` : e
            }, t.getFromCache = function (t, e, n, r) {
                let i = n[t]
                if (typeof i != 'number') {
                    const o = t.length * e
                    i = r.measureText(t).width + o, n[t] = i
                }
                return i
            }, t.collapseSpaces = function (t) {
                return t === 'normal' || t === 'pre-line'
            }, t.collapseNewlines = function (t) {
                return t === 'normal'
            }, t.trimRight = function (e) {
                if (typeof e != 'string') return ''
                for (let n = e.length - 1; n >= 0; n--) {
                    const r = e[n]
                    if (!t.isBreakingSpace(r)) break
                    e = e.slice(0, -1)
                }
                return e
            }, t.isNewline = function (e) {
                return typeof e == 'string' && t._newlines.includes(e.charCodeAt(0))
            }, t.isBreakingSpace = function (e, n) {
                return typeof e == 'string' && t._breakingSpaces.includes(e.charCodeAt(0))
            }, t.tokenize = function (e) {
                const n = []
                let r = ''
                if (typeof e != 'string') return n
                for (let i = 0; i < e.length; i++) {
                    const o = e[i]
                    let a = e[i + 1]
                    t.isBreakingSpace(o, a) || t.isNewline(o) ? (r !== '' && (n.push(r), r = ''), n.push(o)) : r += o
                }
                return r !== '' && n.push(r), n
            }, t.canBreakWords = function (t, e) {
                return e
            }, t.canBreakChars = function (t, e, n, r, i) {
                return !0
            }, t.wordWrapSplit = function (t) {
                return t.split('')
            }, t.measureFont = function (e) {
                if (t._fonts[e]) return t._fonts[e]
                const n = {
                    ascent: 0,
                    descent: 0,
                    fontSize: 0
                }
                let r = t._canvas
                let i = t._context
                i.font = e
                const o = t.METRICS_STRING + t.BASELINE_SYMBOL
                let a = Math.ceil(i.measureText(o).width)
                let s = Math.ceil(i.measureText(t.BASELINE_SYMBOL).width)
                let u = Math.ceil(t.HEIGHT_MULTIPLIER * s)
                s = s * t.BASELINE_MULTIPLIER | 0, r.width = a, r.height = u, i.fillStyle = '#f00', i.fillRect(0, 0, a, u), i.font = e, i.textBaseline = 'alphabetic', i.fillStyle = '#000', i.fillText(o, 0, s)
                const c = i.getImageData(0, 0, a, u).data
                let l = c.length
                let h = 4 * a
                let f = 0
                let d = 0
                let p = !1
                for (f = 0; f < s; ++f) {
                    for (var m = 0; m < h; m += 4) {
                        if (c[d + m] !== 255) {
                            p = !0
                            break
                        }
                    }
                    if (p) break
                    d += h
                }
                for (n.ascent = s - f, d = l - h, p = !1, f = u; f > s; --f) {
                    for (m = 0; m < h; m += 4) {
                        if (c[d + m] !== 255) {
                            p = !0
                            break
                        }
                    }
                    if (p) break
                    d -= h
                }
                return n.descent = f - s, n.fontSize = n.ascent + n.descent, t._fonts[e] = n, n
            }, t.clearMetrics = function (e) {
                void 0 === e && (e = ''), e ? delete t._fonts[e] : t._fonts = {}
            }, t
        }())
        let v = (function () {
            try {
                const t = new OffscreenCanvas(0, 0)
                let e = t.getContext('2d')
                return e && e.measureText ? t : document.createElement('canvas')
            } catch (t) {
                return document.createElement('canvas')
            }
        }())
        v.width = v.height = 10, y._canvas = v, y._context = v.getContext('2d'), y._fonts = {}, y.METRICS_STRING = '|ÉqÅ', y.BASELINE_SYMBOL = 'M', y.BASELINE_MULTIPLIER = 1.4, y.HEIGHT_MULTIPLIER = 2, y._newlines = [10, 13], y._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288]
        const _ = {
            texture: !0,
            children: !1,
            baseTexture: !0
        }
        const g = 'letterSpacing' in CanvasRenderingContext2D.prototype || 'textLetterSpacing' in CanvasRenderingContext2D.prototype
        var b = (function (t) {
            function e(e, n, r) {
                let i = this
                let u = !1
                r || (r = document.createElement('canvas'), u = !0), r.width = 3, r.height = 3
                const c = o.db.from(r)
                return c.orig = new s.j(), c.trim = new s.j(), (i = t.call(this, c) || this)._ownCanvas = u, i.canvas = r, i.context = i.canvas.getContext('2d'), i._resolution = a.b.RESOLUTION, i._autoResolution = !0, i._text = null, i._style = null, i._styleListener = null, i._font = '', i.text = e, i.style = n, i.localStyleID = -1, i
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                c(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype.updateText = function (t) {
                const n = this._style
                if (this.localStyleID !== n.styleID && (this.dirty = !0, this.localStyleID = n.styleID), this.dirty || !t) {
                    this._font = this._style.toFontString()
                    let r; let i; const o = this.context
                    let a = y.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas)
                    let s = a.width
                    let c = a.height
                    let l = a.lines
                    let h = a.lineHeight
                    let f = a.lineWidths
                    let d = a.maxLineWidth
                    let p = a.fontProperties
                    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, s) + 2 * n.padding) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, c) + 2 * n.padding) * this._resolution), o.scale(this._resolution, this._resolution), o.clearRect(0, 0, this.canvas.width, this.canvas.height), o.font = this._font, o.lineWidth = n.strokeThickness, o.textBaseline = n.textBaseline, o.lineJoin = n.lineJoin, o.miterLimit = n.miterLimit
                    for (let m = n.dropShadow ? 2 : 1, v = 0; v < m; ++v) {
                        const _ = n.dropShadow && v === 0
                        var g = _ ? Math.ceil(Math.max(1, c) + 2 * n.padding) : 0
                        var b = g * this._resolution
                        if (_) {
                            o.fillStyle = 'black', o.strokeStyle = 'black'
                            const E = n.dropShadowColor
                            let x = new Object(u.hex2rgb)(typeof E == 'number' ? E : new Object(u.string2hex)(E))
                            o.shadowColor = `rgba(${255 * x[0]},${255 * x[1]},${255 * x[2]},${n.dropShadowAlpha})`, o.shadowBlur = n.dropShadowBlur, o.shadowOffsetX = Math.cos(n.dropShadowAngle) * n.dropShadowDistance, o.shadowOffsetY = Math.sin(n.dropShadowAngle) * n.dropShadowDistance + b
                        } else { o.fillStyle = this._generateFillStyle(n, l, a), o.strokeStyle = n.stroke, o.shadowColor = 'black', o.shadowBlur = 0, o.shadowOffsetX = 0, o.shadowOffsetY = 0
                        }
                        let T = (h - p.fontSize) / 2;
                        (!e.nextLineHeightBehavior || h - p.fontSize < 0) && (T = 0)
                        for (let S = 0; S < l.length; S++) r = n.strokeThickness / 2, i = n.strokeThickness / 2 + S * h + p.ascent + T, n.align === 'right' ? r += d - f[S] : n.align === 'center' && (r += (d - f[S]) / 2), n.stroke && n.strokeThickness && this.drawLetterSpacing(l[S], r + n.padding, i + n.padding - g, !0), n.fill && this.drawLetterSpacing(l[S], r + n.padding, i + n.padding - g)
                    }
                    this.updateTexture()
                }
            }, e.prototype.drawLetterSpacing = function (t, e, n, r) {
                void 0 === r && (r = !1)
                const i = this._style.letterSpacing
                if (i === 0 || g) return g && (this.context.letterSpacing = i, this.context.textLetterSpacing = i), void (r ? this.context.strokeText(t, e, n) : this.context.fillText(t, e, n))
                for (let o = e, a = Array.from ? Array.from(t) : t.split(''), s = this.context.measureText(t).width, u = 0, c = 0; c < a.length; ++c) {
                    const l = a[c]
                    r ? this.context.strokeText(l, o, n) : this.context.fillText(l, o, n), o += s - (u = this.context.measureText(t.substring(c + 1)).width) + i, s = u
                }
            }, e.prototype.updateTexture = function () {
                const t = this.canvas
                if (this._style.trim) {
                    const e = new Object(u.trimCanvas)(t)
                    e.data && (t.width = e.width, t.height = e.height, this.context.putImageData(e.data, 0, 0))
                }
                const n = this._texture
                let r = this._style
                let i = r.trim ? 0 : r.padding
                let o = n.baseTexture
                n.trim.width = n._frame.width = t.width / this._resolution, n.trim.height = n._frame.height = t.height / this._resolution, n.trim.x = -i, n.trim.y = -i, n.orig.width = n._frame.width - 2 * i, n.orig.height = n._frame.height - 2 * i, this._onTextureUpdate(), o.setRealSize(t.width, t.height, this._resolution), n.updateUvs(), this._recursivePostUpdateTransform(), this.dirty = !1
            }, e.prototype._render = function (e) {
                this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), t.prototype._render.call(this, e)
            }, e.prototype.getLocalBounds = function (e) {
                return this.updateText(!0), t.prototype.getLocalBounds.call(this, e)
            }, e.prototype._calculateBounds = function () {
                this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData)
            }, e.prototype._generateFillStyle = function (t, e, n) {
                let i; const o = t.fill
                if (!Array.isArray(o)) return o
                if (o.length === 1) return o[0]
                const a = t.dropShadow ? t.dropShadowDistance : 0
                let s = t.padding || 0
                let u = this.canvas.width / this._resolution - a - 2 * s
                let c = this.canvas.height / this._resolution - a - 2 * s
                let l = o.slice()
                let h = t.fillGradientStops.slice()
                if (!h.length) {
                    for (var f = l.length + 1, d = 1; d < f; ++d) h.push(d / f)
                }
                if (l.unshift(o[0]), h.unshift(0), l.push(o[o.length - 1]), h.push(1), t.fillGradientType === r.LINEAR_VERTICAL) {
                    i = this.context.createLinearGradient(u / 2, s, u / 2, c + s)
                    const p = n.fontProperties.fontSize + t.strokeThickness
                    for (d = 0; d < e.length; d++) {
                        const m = n.lineHeight * (d - 1) + p
                        let y = n.lineHeight * d
                        let v = y
                        d > 0 && m > y && (v = (y + m) / 2)
                        const _ = y + p
                        let g = n.lineHeight * (d + 1)
                        let b = _
                        d + 1 < e.length && g < _ && (b = (_ + g) / 2)
                        for (let E = (b - v) / c, x = 0; x < l.length; x++) {
                            let T = 0
                            T = typeof h[x] == 'number' ? h[x] : x / l.length
                            let S = Math.min(1, Math.max(0, v / c + T * E))
                            S = Number(S.toFixed(5)), i.addColorStop(S, l[x])
                        }
                    }
                } else {
                    i = this.context.createLinearGradient(s, c / 2, u + s, c / 2)
                    const w = l.length + 1
                    let O = 1
                    for (d = 0; d < l.length; d++) {
                        let P = void 0
                        P = typeof h[d] == 'number' ? h[d] : O / w, i.addColorStop(P, l[d]), O++
                    }
                }
                return i
            }, e.prototype.destroy = function (e) {
                typeof e == 'boolean' && (e = {
                    children: e
                }), e = Object.assign({}, _, e), t.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
            }, Object.defineProperty(e.prototype, 'width', {
                get() {
                    return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
                },
                set(t) {
                    this.updateText(!0)
                    let e = new Object(u.sign)(this.scale.x) || 1
                    this.scale.x = e * t / this._texture.orig.width, this._width = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'height', {
                get() {
                    return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
                },
                set(t) {
                    this.updateText(!0)
                    let e = new Object(u.sign)(this.scale.y) || 1
                    this.scale.y = e * t / this._texture.orig.height, this._height = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'style', {
                get() {
                    return this._style
                },
                set(t) {
                    t = t || {}, this._style = t instanceof f ? t : new f(t), this.localStyleID = -1, this.dirty = !0
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'text', {
                get() {
                    return this._text
                },
                set(t) {
                    t = String(t == null ? '' : t), this._text !== t && (this._text = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'resolution', {
                get() {
                    return this._resolution
                },
                set(t) {
                    this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0)
                },
                enumerable: !1,
                configurable: !0
            }), e.nextLineHeightBehavior = !1, e
        }(i.a))
    },
    './node_modules/@pixi/ticker/dist/esm/ticker.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return a
        }), n.d(e, 'b', () => {
            return s
        }), n.d(e, 'c', () => {
            return r
        })
        let r; const i = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        /*!
             * @pixi/ticker - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/ticker is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        i.b.TARGET_FPMS = 0.06,
        (function (t) {
            t[t.INTERACTION = 50] = 'INTERACTION', t[t.HIGH = 25] = 'HIGH', t[t.NORMAL = 0] = 'NORMAL', t[t.LOW = -25] = 'LOW', t[t.UTILITY = -50] = 'UTILITY'
        }(r || (r = {})))
        const o = (function () {
            function t(t, e, n, r) {
                void 0 === e && (e = null), void 0 === n && (n = 0), void 0 === r && (r = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = n, this.once = r
            }
            return t.prototype.match = function (t, e) {
                return void 0 === e && (e = null), this.fn === t && this.context === e
            }, t.prototype.emit = function (t) {
                this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t))
                let e = this.next
                return this.once && this.destroy(!0), this._destroyed && (this.next = null), e
            }, t.prototype.connect = function (t) {
                this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
            }, t.prototype.destroy = function (t) {
                void 0 === t && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous)
                let e = this.next
                return this.next = t ? null : e, this.previous = null, e
            }, t
        }())
        var a = (function () {
            function t() {
                const t = this
                this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new o(null, null, 1 / 0), this.deltaMS = 1 / i.b.TARGET_FPMS, this.elapsedMS = 1 / i.b.TARGET_FPMS, this._tick = function (e) {
                    t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)))
                }
            }
            return t.prototype._requestIfNeeded = function () {
                this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
            }, t.prototype._cancelIfNeeded = function () {
                this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null)
            }, t.prototype._startIfPossible = function () {
                this.started ? this._requestIfNeeded() : this.autoStart && this.start()
            }, t.prototype.add = function (t, e, n) {
                return void 0 === n && (n = r.NORMAL), this._addListener(new o(t, e, n))
            }, t.prototype.addOnce = function (t, e, n) {
                return void 0 === n && (n = r.NORMAL), this._addListener(new o(t, e, n, !0))
            }, t.prototype._addListener = function (t) {
                let e = this._head.next
                var n = this._head
                if (e) {
                    for (; e;) {
                        if (t.priority > e.priority) {
                            t.connect(n)
                            break
                        }
                        n = e, e = e.next
                    }
                    t.previous || t.connect(n)
                } else { t.connect(n)
                }
                return this._startIfPossible(), this
            }, t.prototype.remove = function (t, e) {
                for (let n = this._head.next; n;) n = n.match(t, e) ? n.destroy() : n.next
                return this._head.next || this._cancelIfNeeded(), this
            }, Object.defineProperty(t.prototype, 'count', {
                get() {
                    if (!this._head) return 0
                    for (var t = 0, e = this._head; e = e.next;) t++
                    return t
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.start = function () {
                this.started || (this.started = !0, this._requestIfNeeded())
            }, t.prototype.stop = function () {
                this.started && (this.started = !1, this._cancelIfNeeded())
            }, t.prototype.destroy = function () {
                if (!this._protected) {
                    this.stop()
                    for (let t = this._head.next; t;) t = t.destroy(!0)
                    this._head.destroy(), this._head = null
                }
            }, t.prototype.update = function (t) {
                let e
                if (void 0 === t && (t = performance.now()), t > this.lastTime) {
                    if ((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
                        const n = t - this._lastFrame | 0
                        if (n < this._minElapsedMS) return
                        this._lastFrame = t - n % this._minElapsedMS
                    }
                    this.deltaMS = e, this.deltaTime = this.deltaMS * i.b.TARGET_FPMS
                    for (var r = this._head, o = r.next; o;) o = o.emit(this.deltaTime)
                    r.next || this._cancelIfNeeded()
                } else { this.deltaTime = this.deltaMS = this.elapsedMS = 0
                }
                this.lastTime = t
            }, Object.defineProperty(t.prototype, 'FPS', {
                get() {
                    return 1e3 / this.elapsedMS
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'minFPS', {
                get() {
                    return 1e3 / this._maxElapsedMS
                },
                set(t) {
                    let e = Math.min(this.maxFPS, t)
                                var n = Math.min(Math.max(0, e) / 1e3, i.b.TARGET_FPMS)
                    this._maxElapsedMS = 1 / n
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'maxFPS', {
                get() {
                    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
                },
                set(t) {
                    if (t === 0) { this._minElapsedMS = 0
}
                    else {
                        let e = Math.max(this.minFPS, t)
                        this._minElapsedMS = 1 / (e / 1e3)
                    }
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t, 'shared', {
                get() {
                    if (!t._shared) {
                        let e = t._shared = new t()
                        e.autoStart = !0, e._protected = !0
                    }
                    return t._shared
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t, 'system', {
                get() {
                    if (!t._system) {
                        let e = t._system = new t()
                        e.autoStart = !0, e._protected = !0
                    }
                    return t._system
                },
                enumerable: !1,
                configurable: !0
            }), t
        }())
        var s = (function () {
            function t() {}
            return t.init = function (t) {
                const e = this
                t = Object.assign({
                    autoStart: !0,
                    sharedTicker: !1
                }, t), Object.defineProperty(this, 'ticker', {
                    set(t) {
                        this._ticker && this._ticker.remove(this.render, this), this._ticker = t, t && t.add(this.render, this, r.LOW)
                    },
                    get() {
                        return this._ticker
                    }
                }), this.stop = function () {
                    e._ticker.stop()
                }, this.start = function () {
                    e._ticker.start()
                }, this._ticker = null, this.ticker = t.sharedTicker ? a.shared : new a(), t.autoStart && this.start()
            }, t.destroy = function () {
                if (this._ticker) {
                    const t = this._ticker
                    this.ticker = null, t.destroy()
                }
            }, t
        }())
    },
    './node_modules/@pixi/utils/dist/esm/utils.js': function (t, e, n) {
        'use strict'
        n.r(e), n.d(e, 'BaseTextureCache', () => {
            return G
        }), n.d(e, 'CanvasRenderTarget', () => {
            return V
        }), n.d(e, 'DATA_URI', () => {
            return z
        }), n.d(e, 'ProgramCache', () => {
            return B
        }), n.d(e, 'TextureCache', () => {
            return U
        }), n.d(e, 'clearTextureCache', () => {
            return H
        }), n.d(e, 'correctBlendMode', () => {
            return x
        }), n.d(e, 'createIndicesForQuads', () => {
            return O
        }), n.d(e, 'decomposeDataUri', () => {
            return q
        }), n.d(e, 'deprecation', () => {
            return F
        }), n.d(e, 'destroyTextureCache', () => {
            return X
        }), n.d(e, 'determineCrossOrigin', () => {
            return K
        }), n.d(e, 'getBufferType', () => {
            return P
        }), n.d(e, 'getResolutionOfUrl', () => {
            return Z
        }), n.d(e, 'hex2rgb', () => {
            return v
        }), n.d(e, 'hex2string', () => {
            return _
        }), n.d(e, 'interleaveTypedArrays', () => {
            return A
        }), n.d(e, 'isPow2', () => {
            return C
        }), n.d(e, 'isWebGLSupported', () => {
            return m
        }), n.d(e, 'log2', () => {
            return k
        }), n.d(e, 'nextPow2', () => {
            return I
        }), n.d(e, 'premultiplyBlendMode', () => {
            return E
        }), n.d(e, 'premultiplyRgba', () => {
            return T
        }), n.d(e, 'premultiplyTint', () => {
            return S
        }), n.d(e, 'premultiplyTintToRgba', () => {
            return w
        }), n.d(e, 'removeItems', () => {
            return N
        }), n.d(e, 'rgb2hex', () => {
            return b
        }), n.d(e, 'sayHello', () => {
            return p
        }), n.d(e, 'sign', () => {
            return M
        }), n.d(e, 'skipHello', () => {
            return d
        }), n.d(e, 'string2hex', () => {
            return g
        }), n.d(e, 'trimCanvas', () => {
            return W
        }), n.d(e, 'uid', () => {
            return D
        }), n.d(e, 'url', () => {
            return l
        })
        const r = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        n.d(e, 'isMobile', () => {
            return r.a
        })
        const i = n('./node_modules/eventemitter3/index.js')
        const o = n.n(i)
        n.d(e, 'EventEmitter', () => {
            return o.a
        })
        const a = n('./node_modules/earcut/src/earcut.js')
        const s = n.n(a)
        n.d(e, 'earcut', () => {
            return s.a
        })
        const u = n('./node_modules/url/url.js')
        const c = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        var l = {
            parse: u.parse,
            format: u.format,
            resolve: u.resolve
        }
        r.b.RETINA_PREFIX = /@([0-9.]+)x/, r.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1
        let h; let f = !1

        function d() {
            f = !0
        }

        function p(t) {
            let e
            if (!f) {
                if (navigator.userAgent.toLowerCase().includes('chrome')) {
                    const n = [`\n %c %c %c PixiJS 6.2.0 - ✰ ${t} ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n`, 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;'];
                    (e = self.console).log.apply(e, n)
                } else { self.console && self.console.log(`PixiJS 6.2.0 - ${t} - http://www.pixijs.com/`)
                }
                f = !0
            }
        }

        function m() {
            return void 0 === h && (h = (function () {
                const t = {
                    stencil: !0,
                    failIfMajorPerformanceCaveat: r.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
                }
                try {
                    if (!self.WebGLRenderingContext) return !1
                    const e = document.createElement('canvas')
                    let n = e.getContext('webgl', t) || e.getContext('experimental-webgl', t)
                    let i = !(!n || !n.getContextAttributes().stencil)
                    if (n) {
                        const o = n.getExtension('WEBGL_lose_context')
                        o && o.loseContext()
                    }
                    return n = null, i
                } catch (t) {
                    return !1
                }
            }())), h
        }
        const y = {
            aliceblue: '#f0f8ff',
            antiquewhite: '#faebd7',
            aqua: '#00ffff',
            aquamarine: '#7fffd4',
            azure: '#f0ffff',
            beige: '#f5f5dc',
            bisque: '#ffe4c4',
            black: '#000000',
            blanchedalmond: '#ffebcd',
            blue: '#0000ff',
            blueviolet: '#8a2be2',
            brown: '#a52a2a',
            burlywood: '#deb887',
            cadetblue: '#5f9ea0',
            chartreuse: '#7fff00',
            chocolate: '#d2691e',
            coral: '#ff7f50',
            cornflowerblue: '#6495ed',
            cornsilk: '#fff8dc',
            crimson: '#dc143c',
            cyan: '#00ffff',
            darkblue: '#00008b',
            darkcyan: '#008b8b',
            darkgoldenrod: '#b8860b',
            darkgray: '#a9a9a9',
            darkgreen: '#006400',
            darkgrey: '#a9a9a9',
            darkkhaki: '#bdb76b',
            darkmagenta: '#8b008b',
            darkolivegreen: '#556b2f',
            darkorange: '#ff8c00',
            darkorchid: '#9932cc',
            darkred: '#8b0000',
            darksalmon: '#e9967a',
            darkseagreen: '#8fbc8f',
            darkslateblue: '#483d8b',
            darkslategray: '#2f4f4f',
            darkslategrey: '#2f4f4f',
            darkturquoise: '#00ced1',
            darkviolet: '#9400d3',
            deeppink: '#ff1493',
            deepskyblue: '#00bfff',
            dimgray: '#696969',
            dimgrey: '#696969',
            dodgerblue: '#1e90ff',
            firebrick: '#b22222',
            floralwhite: '#fffaf0',
            forestgreen: '#228b22',
            fuchsia: '#ff00ff',
            gainsboro: '#dcdcdc',
            ghostwhite: '#f8f8ff',
            goldenrod: '#daa520',
            gold: '#ffd700',
            gray: '#808080',
            green: '#008000',
            greenyellow: '#adff2f',
            grey: '#808080',
            honeydew: '#f0fff0',
            hotpink: '#ff69b4',
            indianred: '#cd5c5c',
            indigo: '#4b0082',
            ivory: '#fffff0',
            khaki: '#f0e68c',
            lavenderblush: '#fff0f5',
            lavender: '#e6e6fa',
            lawngreen: '#7cfc00',
            lemonchiffon: '#fffacd',
            lightblue: '#add8e6',
            lightcoral: '#f08080',
            lightcyan: '#e0ffff',
            lightgoldenrodyellow: '#fafad2',
            lightgray: '#d3d3d3',
            lightgreen: '#90ee90',
            lightgrey: '#d3d3d3',
            lightpink: '#ffb6c1',
            lightsalmon: '#ffa07a',
            lightseagreen: '#20b2aa',
            lightskyblue: '#87cefa',
            lightslategray: '#778899',
            lightslategrey: '#778899',
            lightsteelblue: '#b0c4de',
            lightyellow: '#ffffe0',
            lime: '#00ff00',
            limegreen: '#32cd32',
            linen: '#faf0e6',
            magenta: '#ff00ff',
            maroon: '#800000',
            mediumaquamarine: '#66cdaa',
            mediumblue: '#0000cd',
            mediumorchid: '#ba55d3',
            mediumpurple: '#9370db',
            mediumseagreen: '#3cb371',
            mediumslateblue: '#7b68ee',
            mediumspringgreen: '#00fa9a',
            mediumturquoise: '#48d1cc',
            mediumvioletred: '#c71585',
            midnightblue: '#191970',
            mintcream: '#f5fffa',
            mistyrose: '#ffe4e1',
            moccasin: '#ffe4b5',
            navajowhite: '#ffdead',
            navy: '#000080',
            oldlace: '#fdf5e6',
            olive: '#808000',
            olivedrab: '#6b8e23',
            orange: '#ffa500',
            orangered: '#ff4500',
            orchid: '#da70d6',
            palegoldenrod: '#eee8aa',
            palegreen: '#98fb98',
            paleturquoise: '#afeeee',
            palevioletred: '#db7093',
            papayawhip: '#ffefd5',
            peachpuff: '#ffdab9',
            peru: '#cd853f',
            pink: '#ffc0cb',
            plum: '#dda0dd',
            powderblue: '#b0e0e6',
            purple: '#800080',
            rebeccapurple: '#663399',
            red: '#ff0000',
            rosybrown: '#bc8f8f',
            royalblue: '#4169e1',
            saddlebrown: '#8b4513',
            salmon: '#fa8072',
            sandybrown: '#f4a460',
            seagreen: '#2e8b57',
            seashell: '#fff5ee',
            sienna: '#a0522d',
            silver: '#c0c0c0',
            skyblue: '#87ceeb',
            slateblue: '#6a5acd',
            slategray: '#708090',
            slategrey: '#708090',
            snow: '#fffafa',
            springgreen: '#00ff7f',
            steelblue: '#4682b4',
            tan: '#d2b48c',
            teal: '#008080',
            thistle: '#d8bfd8',
            tomato: '#ff6347',
            turquoise: '#40e0d0',
            violet: '#ee82ee',
            wheat: '#f5deb3',
            white: '#ffffff',
            whitesmoke: '#f5f5f5',
            yellow: '#ffff00',
            yellowgreen: '#9acd32'
        }

        function v(t, e) {
            return void 0 === e && (e = []), e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255, e
        }

        function _(t) {
            let e = t.toString(16)
            return `#${e = '000000'.substr(0, 6 - e.length) + e}`
        }

        function g(t) {
            return typeof t == 'string' && (t = y[t.toLowerCase()] || t)[0] === '#' && (t = t.substr(1)), Number.parseInt(t, 16)
        }

        function b(t) {
            return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0)
        }
        var E = (function () {
            for (var t = [], e = [], n = 0; n < 32; n++) t[n] = n, e[n] = n
            t[c.b.NORMAL_NPM] = c.b.NORMAL, t[c.b.ADD_NPM] = c.b.ADD, t[c.b.SCREEN_NPM] = c.b.SCREEN, e[c.b.NORMAL] = c.b.NORMAL_NPM, e[c.b.ADD] = c.b.ADD_NPM, e[c.b.SCREEN] = c.b.SCREEN_NPM
            const r = []
            return r.push(e), r.push(t), r
        }())

        function x(t, e) {
            return E[e ? 1 : 0][t]
        }

        function T(t, e, n, r) {
            return n = n || new Float32Array(4), r || void 0 === r ? (n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e) : (n[0] = t[0], n[1] = t[1], n[2] = t[2]), n[3] = e, n
        }

        function S(t, e) {
            if (e === 1) return (255 * e << 24) + t
            if (e === 0) return 0
            let n = t >> 16 & 255
            let r = t >> 8 & 255
            let i = 255 & t
            return (255 * e << 24) + ((n = n * e + 0.5 | 0) << 16) + ((r = r * e + 0.5 | 0) << 8) + (i = i * e + 0.5 | 0)
        }

        function w(t, e, n, r) {
            return (n = n || new Float32Array(4))[0] = (t >> 16 & 255) / 255, n[1] = (t >> 8 & 255) / 255, n[2] = (255 & t) / 255, (r || void 0 === r) && (n[0] *= e, n[1] *= e, n[2] *= e), n[3] = e, n
        }

        function O(t, e) {
            void 0 === e && (e = null)
            const n = 6 * t
            if ((e = e || new Uint16Array(n)).length !== n) throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${n}`)
            for (let r = 0, i = 0; r < n; r += 6, i += 4) e[r + 0] = i + 0, e[r + 1] = i + 1, e[r + 2] = i + 2, e[r + 3] = i + 0, e[r + 4] = i + 2, e[r + 5] = i + 3
            return e
        }

        function P(t) {
            if (t.BYTES_PER_ELEMENT === 4) return t instanceof Float32Array ? 'Float32Array' : t instanceof Uint32Array ? 'Uint32Array' : 'Int32Array'
            if (t.BYTES_PER_ELEMENT === 2) {
                if (t instanceof Uint16Array) return 'Uint16Array'
            } else if (t.BYTES_PER_ELEMENT === 1 && t instanceof Uint8Array) { return 'Uint8Array'
            }
            return null
        }
        const R = {
            Float32Array,
            Uint32Array,
            Int32Array,
            Uint8Array
        }

        function A(t, e) {
            for (var n = 0, r = 0, i = {}, o = 0; o < t.length; o++) r += e[o], n += t[o].length
            const a = new ArrayBuffer(4 * n)
            let s = null
            let u = 0
            for (o = 0; o < t.length; o++) {
                const c = e[o]
                const l = t[o]
                const h = P(l)
                i[h] || (i[h] = new R[h](a)), s = i[h]
                for (let f = 0; f < l.length; f++) {
                    s[(f / c | 0) * r + u + f % c] = l[f]
                }
                u += c
            }
            return new Float32Array(a)
        }

        function I(t) {
            return t += t === 0 ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, (t |= t >>> 16) + 1
        }

        function C(t) {
            return !(t & t - 1 || !t)
        }

        function k(t) {
            let e = (t > 65535 ? 1 : 0) << 4
            let n = ((t >>>= e) > 255 ? 1 : 0) << 3
            return e |= n, e |= n = ((t >>>= n) > 15 ? 1 : 0) << 2, (e |= n = ((t >>>= n) > 3 ? 1 : 0) << 1) | (t >>>= n) >> 1
        }

        function N(t, e, n) {
            let r; const i = t.length
            if (!(e >= i || n === 0)) {
                const o = i - (n = e + n > i ? i - e : n)
                for (r = e; r < o; ++r) t[r] = t[r + n]
                t.length = o
            }
        }

        function M(t) {
            return t === 0 ? 0 : t < 0 ? -1 : 1
        }
        let j = 0

        function D() {
            return ++j
        }
        const L = {}

        function F(t, e, n) {
            if (void 0 === n && (n = 3), !L[e]) {
                let r = (new Error()).stack
                void 0 === r ? console.warn('PixiJS Deprecation Warning: ', `${e}\nDeprecated since v${t}`) : (r = r.split('\n').splice(n).join('\n'), console.groupCollapsed ? (console.groupCollapsed('%cPixiJS Deprecation Warning: %c%s', 'color:#614108;background:#fffbe6', 'font-weight:normal;color:#614108;background:#fffbe6', `${e}\nDeprecated since v${t}`), console.warn(r), console.groupEnd()) : (console.warn('PixiJS Deprecation Warning: ', `${e}\nDeprecated since v${t}`), console.warn(r))), L[e] = !0
            }
        }
        var B = {}
        var U = Object.create(null)
        var G = Object.create(null)

        function X() {
            let t
            for (t in U) U[t].destroy()
            for (t in G) G[t].destroy()
        }

        function H() {
            let t
            for (t in U) delete U[t]
            for (t in G) delete G[t]
        }
        var V = (function () {
            function t(t, e, n) {
                this.canvas = document.createElement('canvas'), this.context = this.canvas.getContext('2d'), this.resolution = n || r.b.RESOLUTION, this.resize(t, e)
            }
            return t.prototype.clear = function () {
                this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
            }, t.prototype.resize = function (t, e) {
                this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution)
            }, t.prototype.destroy = function () {
                this.context = null, this.canvas = null
            }, Object.defineProperty(t.prototype, 'width', {
                get() {
                    return this.canvas.width
                },
                set(t) {
                    this.canvas.width = Math.round(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'height', {
                get() {
                    return this.canvas.height
                },
                set(t) {
                    this.canvas.height = Math.round(t)
                },
                enumerable: !1,
                configurable: !0
            }), t
        }())

        function W(t) {
            let e; let n; let r; let i = t.width
            let o = t.height
            const a = t.getContext('2d')
            const s = a.getImageData(0, 0, i, o).data
            const u = s.length
            const c = {
                top: null,
                left: null,
                right: null,
                bottom: null
            }
            let l = null
            for (e = 0; e < u; e += 4) s[e + 3] !== 0 && (n = e / 4 % i, r = ~~(e / 4 / i), c.top === null && (c.top = r), (c.left === null || n < c.left) && (c.left = n), (c.right === null || c.right < n) && (c.right = n + 1), (c.bottom === null || c.bottom < r) && (c.bottom = r))
            return c.top !== null && (i = c.right - c.left, o = c.bottom - c.top + 1, l = a.getImageData(c.left, c.top, i, o)), {
                height: o,
                width: i,
                data: l
            }
        }
        let Y; var z = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i

        function q(t) {
            const e = z.exec(t)
            if (e) { return {
                mediaType: e[1] ? e[1].toLowerCase() : void 0,
                subType: e[2] ? e[2].toLowerCase() : void 0,
                charset: e[3] ? e[3].toLowerCase() : void 0,
                encoding: e[4] ? e[4].toLowerCase() : void 0,
                data: e[5]
            }
            }
        }

        function K(t, e) {
            if (void 0 === e && (e = self.location), t.indexOf('data:') === 0) return ''
            e = e || self.location, Y || (Y = document.createElement('a')), Y.href = t
            const n = l.parse(Y.href)
            const r = !n.port && e.port === '' || n.port === e.port
            return n.hostname === e.hostname && r && n.protocol === e.protocol ? '' : 'anonymous'
        }

        function Z(t, e) {
            const n = r.b.RETINA_PREFIX.exec(t)
            return n ? Number.parseFloat(n[1]) : void 0 !== e ? e : 1
        }
    },
    './node_modules/browser-detect/dist/browser-detect.es5.js': function (t, e, n) {
        'use strict';
        (function (t) {
            /*! *****************************************************************************
                Copyright (c) Microsoft Corporation. All rights reserved.
                Licensed under the Apache License, Version 2.0 (the "License"); you may not use
                this file except in compliance with the License. You may obtain a copy of the
                License at http://www.apache.org/licenses/LICENSE-2.0

                THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
                KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
                WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
                MERCHANTABLITY OR NON-INFRINGEMENT.

                See the Apache Version 2.0 License for specific language governing permissions
                and limitations under the License.
                ***************************************************************************** */
            const n = Object.assign || function (t) {
                for (var e, n = 1, r = arguments.length; n < r; n++) {
                    for (const i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
                }
                return t
            }
            const r = [
                ['firefox', /Firefox\/([0-9.]+)(?:\s|$)/],
                ['opera', /Opera\/([0-9.]+)(?:\s|$)/],
                ['opera', /OPR\/([0-9.]+)(:?\s|$)$/],
                ['edge', /Edge\/([0-9._]+)/],
                ['ie', /Trident\/7\.0.*rv:([0-9.]+)\).*Gecko$/],
                ['ie', /MSIE\s([0-9.]+);.*Trident\/[4-7].0/],
                ['ie', /MSIE\s(7\.0)/],
                ['safari', /Version\/([0-9._]+).*Safari/],
                ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9.]+)(:?\s|$)/],
                ['bb10', /BB10;\sTouch.*Version\/([0-9.]+)/],
                ['android', /Android\s([0-9.]+)/],
                ['ios', /Version\/([0-9._]+).*Mobile.*Safari.*/],
                ['yandexbrowser', /YaBrowser\/([0-9._]+)/],
                ['crios', /CriOS\/([0-9.]+)(:?\s|$)/]
            ]
            const i = ['Windows Phone', 'Android', 'CentOS', {
                name: 'Chrome OS',
                pattern: 'CrOS'
            }, 'Debian', 'Fedora', 'FreeBSD', 'Gentoo', 'Haiku', 'Kubuntu', 'Linux Mint', 'OpenBSD', 'Red Hat', 'SuSE', 'Ubuntu', 'Xubuntu', 'Cygwin', 'Symbian OS', 'hpwOS', 'webOS ', 'webOS', 'Tablet OS', 'Tizen', 'Linux', 'Mac OS X', 'Macintosh', 'Mac', 'Windows 98;', 'Windows ']
            const o = {
                '10.0': '10',
                '6.4': '10 Technical Preview',
                '6.3': '8.1',
                '6.2': '8',
                '6.1': 'Server 2008 R2 / 7',
                '6.0': 'Server 2008 / Vista',
                '5.2': 'Server 2003 / XP 64-bit',
                '5.1': 'XP',
                '5.01': '2000 SP1',
                '5.0': '2000',
                '4.0': 'NT',
                '4.90': 'ME'
            }
            const a = new RegExp(['(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|', 'compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|', 'midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)', '\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|', 'wap|windows ce|xda|xiino'].join(''), 'i')
            const s = new RegExp(['1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|', 'ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|', 'avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|', 'cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|', 'ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|', 'g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|', 'hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|', 'i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|', 'kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])', '|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|', 'mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|', 'n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|', 'op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|', 'po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|', 'raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|', 'se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|k\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|', 'so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|', 'tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|', 'veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|', 'w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-'].join(''), 'i')
            const u = (function () {
                function t(t, e, n) {
                    this.navigator = e, this.process = n, this.userAgent = t || (this.navigator ? e.userAgent || e.vendor : '')
                }
                return t.prototype.detect = function () {
                    if (this.process && !this.userAgent) {
                        const t = this.process.version.slice(1).split('.').slice(0, 3)
                        var e = Array.prototype.slice.call(t, 1).join('') || '0'
                        return {
                            name: 'node',
                            version: t.join('.'),
                            versionNumber: Number.parseFloat(`${t[0]}.${e}`),
                            mobile: !1,
                            os: this.process.platform
                        }
                    }
                    return this.userAgent || this.handleMissingError(), n({}, this.checkBrowser(), this.checkMobile(), this.checkOs())
                }, t.prototype.checkBrowser = function () {
                    const t = this
                    return r.filter((e) => {
                        return e[1].test(t.userAgent)
                    }).map((e) => {
                        let n = e[1].exec(t.userAgent)
                                    var r = n && n[1].split(/[._]/).slice(0, 3)
                                    var i = Array.prototype.slice.call(r, 1).join('') || '0'
                        return r && r.length < 3 && Array.prototype.push.apply(r, r.length === 1 ? [0, 0] : [0]), {
                            name: String(e[0]),
                            version: r.join('.'),
                            versionNumber: Number(`${r[0] }.${ i}`)
                        }
                    }).shift()
                }, t.prototype.checkMobile = function () {
                    const t = this.userAgent.substr(0, 4)
                    return {
                        mobile: a.test(this.userAgent) || s.test(t)
                    }
                }, t.prototype.checkOs = function () {
                    const t = this
                    return i.map((e) => {
                        let n = e.name || e
                                    var r = t.getOsPattern(e)
                        return {
                            name: n,
                            pattern: r,
                            value: new RegExp(`\\b${  r.replace(/([ -])(?!$)/g, '$1?')  }(?:x?[\\d._]+|[ \\w.]*)`, 'i').exec(t.userAgent)
                        }
                    }).filter((t) => {
                        return t.value
                    }).map((t) => {
                        let e; let n = t.value[0] || ''
                        return t.pattern && t.name && /^Win/i.test(n) && !/^Windows Phone /i.test(n) && (e = o[n.replace(/[^\d.]/g, '')]) && (n = `Windows ${  e}`), t.pattern && t.name && (n = n.replace(new RegExp(t.pattern, 'i'), t.name)), n = n.replace(/ ce$/i, ' CE').replace(/\bhpw/i, 'web').replace(/\bMacintosh\b/, 'Mac OS').replace(/_PowerPC\b/i, ' OS').replace(/\b(OS X) [^ \d]+/i, '$1').replace(/\bMac (OS X)\b/, '$1').replace(/\/(\d)/, ' $1').replace(/_/g, '.').replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '').replace(/\bx86\.64\b/gi, 'x86_64').replace(/\b(Windows Phone) OS\b/, '$1').replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1').split(' on ')[0].trim(), {
                            os: n = /^(?:webOS|i(?:OS|P))/.test(n) ? n : n.charAt(0).toUpperCase() + n.slice(1)
                        }
                    }).shift()
                }, t.prototype.getOsPattern = function (t) {
                    const e = t
                    return (typeof t == 'string' ? t : void 0) || e.pattern || e.name
                }, t.prototype.handleMissingError = function () {
                    throw new Error('Please give user-agent.\n> browser(navigator.userAgent or res.headers[\'user-agent\']).')
                }, t
            }())

            function c(t, e) {
                return t(e = {
                    exports: {}
                }, e.exports), e.exports
            }
            const l = c((t) => {
                const e = t.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : new Function('return this')()
                'number' == typeof __g && (__g = e)
            })
            const h = c((t) => {
                let e = t.exports = {
                    version: '2.5.7'
                }
                "number" == typeof __e && (__e = e)
            })
            const f = (h.version, function (t) {
                return typeof t == 'object' ? t !== null : typeof t == 'function'
            })
            const d = function (t) {
                if (!f(t)) throw new TypeError(`${t} is not an object!`)
                return t
            }
            const p = function (t) {
                try {
                    return !!t()
                } catch (t) {
                    return !0
                }
            }
            const m = !p(() => {
                return Object.defineProperty({}, 'a', {
                    get: function () {
                        return 7
                    }
                }).a != 7
            })
            const y = l.document
            const v = f(y) && f(y.createElement)
            const _ = !m && !p(() => {
                return Object.defineProperty((t = 'div', v ? y.createElement(t) : {}), 'a', {
                    get: function () {
                        return 7
                    }
                }).a != 7
                var t
            })
            const g = Object.defineProperty
            const b = {
                f: m
                    ? Object.defineProperty
                    : function (t, e, n) {
                        if (d(t), e = (function (t, e) {
                            if (!f(t)) return t
                            var n, r
                            if (e && typeof (n = t.toString) == 'function' && !f(r = n.call(t))) return r
                            if (typeof (n = t.valueOf) == 'function' && !f(r = n.call(t))) return r
                            if (!e && typeof (n = t.toString) == 'function' && !f(r = n.call(t))) return r
                            throw new TypeError('Can\'t convert object to primitive value')
                        }(e, !0)), d(n), _) { try {
                            return g(t, e, n)
                        } catch (t) {}
                        }
                        if ('get' in n || 'set' in n) throw new TypeError('Accessors not supported!')
                        return 'value' in n && (t[e] = n.value), t
                    }
            }
            const E = m
                ? function (t, e, n) {
                    return b.f(t, e, (function (t, e) {
                        return {
                            enumerable: !(1 & t),
                            configurable: !(2 & t),
                            writable: !(4 & t),
                            value: e
                        }
                    }(1, n)))
                }
                : function (t, e, n) {
                    return t[e] = n, t
                }
            const x = {}.hasOwnProperty
            const T = function (t, e) {
                return x.call(t, e)
            }
            let S = 0
            const w = Math.random()
            const O = function (t) {
                return 'Symbol('.concat(void 0 === t ? '' : t, ')_', (++S + w).toString(36))
            }
            const P = c((t) => {
                let e = O('src')
                            var n = Function.toString
                            var r = (`${  n}`).split('toString')
                h.inspectSource = function (t) {
                    return n.call(t)
                }, (t.exports = function (t, n, i, o) {
                    let a = typeof i == 'function'
                    a && (T(i, 'name') || E(i, 'name', n)), t[n] !== i && (a && (T(i, e) || E(i, e, t[n] ? `${  t[n]}` : r.join(String(n)))), t === l ? t[n] = i : o ? t[n] ? t[n] = i : E(t, n, i) : (delete t[n], E(t, n, i)))
                })(Function.prototype, 'toString', function () {
                    return 'function' == typeof this && this[e] || n.call(this)
                })
            })
            const R = function (t, e, n) {
                if ((function (t) {
                    if (typeof t != 'function') throw new TypeError(`${t } is not a function!`)
                }(t)), void 0 === e) { return t
                }
                switch (n) {
                    case 1:
                        return function (n) {
                            return t.call(e, n)
                        }
                    case 2:
                        return function (n, r) {
                            return t.call(e, n, r)
                        }
                    case 3:
                        return function (n, r, i) {
                            return t.call(e, n, r, i)
                        }
                }
                return function () {
                    return t.apply(e, arguments)
                }
            }
            const A = function (t, e, n) {
                let r; let i; let o; let a; const s = t & A.F
                let u = t & A.G
                let c = t & A.S
                let f = t & A.P
                let d = t & A.B
                let p = u ? l : c ? l[e] || (l[e] = {}) : (l[e] || {}).prototype
                let m = u ? h : h[e] || (h[e] = {})
                let y = m.prototype || (m.prototype = {})
                for (r in u && (n = e), n) o = ((i = !s && p && void 0 !== p[r]) ? p : n)[r], a = d && i ? R(o, l) : f && typeof o == 'function' ? R(Function.call, o) : o, p && P(p, r, o, t & A.U), m[r] != o && E(m, r, a), f && y[r] != o && (y[r] = o)
            }
            l.core = h, A.F = 1, A.G = 2, A.S = 4, A.P = 8, A.B = 16, A.W = 32, A.U = 64, A.R = 128
            const I = A
            const C = {}.toString
            const k = function (t) {
                return C.call(t).slice(8, -1)
            }
            const N = new Object('z').propertyIsEnumerable(0)
                ? Object
                : function (t) {
                    return k(t) == 'String' ? t.split('') : new Object(t)
                }
            const M = function (t) {
                if (t == null) throw new TypeError(`Can't call method on  ${ t}`)
                return t
            }
            const j = Math.ceil
            const D = Math.floor
            const L = Math.min
            const F = function (t) {
                return t > 0
                    ? L((function (t) {
                            return isNaN(t = +t) ? 0 : (t > 0 ? D : j)(t)
                        }(t)), 9007199254740991)
                    : 0
            }
            const B = Array.isArray || function (t) {
                return k(t) == 'Array'
            }
            const U = c((t) => {
                let e = l['__core-js_shared__'] || (l['__core-js_shared__'] = {});
                (t.exports = function (t, n) {
                    return e[t] || (e[t] = void 0 !== n ? n : {})
                })('versions', []).push({
                    version: h.version,
                    mode: 'global',
                    copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
                })
            })
            const G = c((t) => {
                let e = U('wks')
                            var n = l.Symbol
                            var r = typeof n == 'function';
                (t.exports = function (t) {
                    return e[t] || (e[t] = r && n[t] || (r ? n : O)(`Symbol.${  t}`))
                }).store = e
            })('species')
            const X = function (t, e) {
                return new (function (t) {
                    let e
                    return B(t) && (typeof (e = t.constructor) != 'function' || e !== Array && !B(e.prototype) || (e = void 0), f(e) && (e = e[G]) === null && (e = void 0)), void 0 === e ? Array : e
                }(t))(e)
            }
            const H = function (t, e) {
                const n = t == 1;
                var r = t == 2
                    var i = t == 3
                    var o = t == 4
                    var a = t == 6
                    var s = t == 5 || a
                    var u = e || X
                return function (e, c, l) {
                    for (var h, f, d = new Object(M(e)), p = new N(d), m = R(c, l, 3), y = F(p.length), v = 0, _ = n ? u(e, y) : r ? u(e, 0) : void 0; y > v; v++) {
                        if ((s || v in p) && (f = m(h = p[v], v, d), t)) {
                            if (n) { _[v] = f;
}
                            else if (f) { switch (t) {
                                case 3:
                                    return !0;
                                case 5:
                                    return h;
                                case 6:
                                    return v;
                                case 2:
                                    _.push(h)
                            }
} else if (o) { return !1;
}
                        }
                    }
                    return a ? -1 : i || o ? o : _
                }
            }
            const V = function (t, e) {
                return !!t && p(() => {
                    e ? t.call(null, () => {}, 1) : t.call(null)
                })
            }
            const W = H(2)
            I(I.P + I.F * !V([].filter, !0), 'Array', {
                filter(t) {
                    return W(this, t, arguments[1])
                }
            })
            h.Array.filter
            const Y = H(1)
            I(I.P + I.F * !V([].map, !0), 'Array', {
                map(t) {
                    return Y(this, t, arguments[1])
                }
            })
            h.Array.map
            const z = '\t\n\v\f\r   ᠎             　\u2028\u2029\uFEFF'
            var q = `[${z}]`;
            let K = new RegExp(`^${q}${q}*`)
            var Z = new RegExp(`${q + q}*$`)
            var $ = function (t, e, n) {
                const r = {}
                let i = p(() => {
                    return !!z[t]() || '​' [t]() != '​'
                })
                var o = r[t] = i ? e(J) : z[t]
                n && (r[n] = o), I(I.P + I.F * i, 'String', r)
            }
            var J = $.trim = function (t, e) {
                return t = String(M(t)), 1 & e && (t = t.replace(K, '')), 2 & e && (t = t.replace(Z, '')), t
            }
            $('trim', (t) => {
                return function () {
                    return t(this, 3)
                }
            })
            h.String.trim
            const Q = typeof window != 'undefined' ? window.navigator : void 0
            const tt = void 0 !== t ? t : void 0
            e.a = function (t) {
                return new u(t, Q, tt).detect()
            }
        }).call(this, n('./node_modules/process/browser.js'))
    },
    './node_modules/earcut/src/earcut.js': function (t, e, n) {
        'use strict'

        function r(t, e, n) {
            n = n || 2
            let r; let s; let u; let c; let l; let d; let p; const y = e && e.length
            const v = y ? e[0] * n : t.length
            let _ = i(t, 0, v, n, !0)
            const g = []
            if (!_ || _.next === _.prev) return g
            if (y && (_ = (function (t, e, n, r) {
                let a; let s; let u; let c; let l; const d = []
                for (a = 0, s = e.length; a < s; a++) u = e[a] * r, c = a < s - 1 ? e[a + 1] * r : t.length, (l = i(t, u, c, r, !1)) === l.next && (l.steiner = !0), d.push(m(l))
                for (d.sort(h), a = 0; a < d.length; a++) n = o(n = f(d[a], n), n.next)
                return n
            }(t, e, _, n))), t.length > 80 * n) {
                r = u = t[0], s = c = t[1]
                for (let b = n; b < v; b += n)(l = t[b]) < r && (r = l), (d = t[b + 1]) < s && (s = d), l > u && (u = l), d > c && (c = d)
                p = (p = Math.max(u - r, c - s)) !== 0 ? 1 / p : 0
            }
            return a(_, g, n, r, s, p), g
        }

        function i(t, e, n, r, i) {
            let o, a
            if (i === R(t, e, n, r) > 0) {
                for (o = e; o < n; o += r) a = w(o, t[o], t[o + 1], a)
            }
            else {
                for (o = n - r; o >= e; o -= r) a = w(o, t[o], t[o + 1], a)
            }
            return a && g(a, a.next) && (O(a), a = a.next), a
        }

        function o(t, e) {
            if (!t) return t
            e || (e = t)
            let n; let r = t
            do {
                if (n = !1, r.steiner || !g(r, r.next) && _(r.prev, r, r.next) !== 0) { r = r.next
                }
                else {
                    if (O(r), (r = e = r.prev) === r.next) break
                    n = !0
                }
            } while (n || r !== e)
            return e
        }

        function a(t, e, n, r, i, h, f) {
            if (t) {
                !f && h && (function (t, e, n, r) {
                    let i = t
                    do {
                        i.z === null && (i.z = p(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                    } while (i !== t)
                    i.prevZ.nextZ = null, i.prevZ = null,
                    (function (t) {
                        let e; let n; let r; let i; let o; let a; let s; let u; let c = 1
                        do {
                            for (n = t, t = null, o = null, a = 0; n;) {
                                for (a++, r = n, s = 0, e = 0; e < c && (s++, r = r.nextZ); e++);
                                for (u = c; s > 0 || u > 0 && r;) s !== 0 && (u === 0 || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, u--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i
                                n = r
                            }
                            o.nextZ = null, c *= 2
                        } while (a > 1)
                    }(i))
                }(t, r, i, h))
                for (var d, m, y = t; t.prev !== t.next;) {
                    if (d = t.prev, m = t.next, h ? u(t, r, i, h) : s(t)) { e.push(d.i / n), e.push(t.i / n), e.push(m.i / n), O(t), t = m.next, y = m.next
                    }
                    else if ((t = m) === y) {
                        f ? f === 1 ? a(t = c(o(t), e, n), e, n, r, i, h, 2) : f === 2 && l(t, e, n, r, i, h) : a(o(t), e, n, r, i, h, 1)
                        break
                    }
                }
            }
        }

        function s(t) {
            const e = t.prev
            const n = t
            const r = t.next
            if (_(e, n, r) >= 0) return !1
            for (let i = t.next.next; i !== t.prev;) {
                if (y(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && _(i.prev, i, i.next) >= 0) return !1
                i = i.next
            }
            return !0
        }

        function u(t, e, n, r) {
            const i = t.prev
            const o = t
            const a = t.next
            if (_(i, o, a) >= 0) return !1
            for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, u = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, c = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, l = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, h = p(s, u, e, n, r), f = p(c, l, e, n, r), d = t.prevZ, m = t.nextZ; d && d.z >= h && m && m.z <= f;) {
                if (d !== t.prev && d !== t.next && y(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && _(d.prev, d, d.next) >= 0) return !1
                if (d = d.prevZ, m !== t.prev && m !== t.next && y(i.x, i.y, o.x, o.y, a.x, a.y, m.x, m.y) && _(m.prev, m, m.next) >= 0) return !1
                m = m.nextZ
            }
            for (; d && d.z >= h;) {
                if (d !== t.prev && d !== t.next && y(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && _(d.prev, d, d.next) >= 0) return !1
                d = d.prevZ
            }
            for (; m && m.z <= f;) {
                if (m !== t.prev && m !== t.next && y(i.x, i.y, o.x, o.y, a.x, a.y, m.x, m.y) && _(m.prev, m, m.next) >= 0) return !1
                m = m.nextZ
            }
            return !0
        }

        function c(t, e, n) {
            let r = t
            do {
                const i = r.prev
                const a = r.next.next
                !g(i, a) && b(i, r, r.next, a) && T(i, a) && T(a, i) && (e.push(i.i / n), e.push(r.i / n), e.push(a.i / n), O(r), O(r.next), r = t = a), r = r.next
            } while (r !== t)
            return o(r)
        }

        function l(t, e, n, r, i, s) {
            let u = t
            do {
                for (let c = u.next.next; c !== u.prev;) {
                    if (u.i !== c.i && v(u, c)) {
                        let l = S(u, c)
                        return u = o(u, u.next), l = o(l, l.next), a(u, e, n, r, i, s), void a(l, e, n, r, i, s)
                    }
                    c = c.next
                }
                u = u.next
            } while (u !== t)
        }

        function h(t, e) {
            return t.x - e.x
        }

        function f(t, e) {
            const n = (function (t, e) {
                let n; let r = e
                var i = t.x
                var o = t.y
                var a = -1 / 0
                do {
                    if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                        const s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y)
                        if (s <= i && s > a) {
                            if (a = s, s === i) {
                                if (o === r.y) return r
                                if (o === r.next.y) return r.next
                            }
                            n = r.x < r.next.x ? r : r.next
                        }
                    }
                    r = r.next
                } while (r !== e)
                if (!n) return null
                if (i === a) return n
                let u; const c = n
                var l = n.x
                var h = n.y
                var f = 1 / 0
                r = n
                do {
                    i >= r.x && r.x >= l && i !== r.x && y(o < h ? i : a, o, l, h, o < h ? a : i, o, r.x, r.y) && (u = Math.abs(o - r.y) / (i - r.x), T(r, t) && (u < f || u === f && (r.x > n.x || r.x === n.x && d(n, r))) && (n = r, f = u)), r = r.next
                } while (r !== c)
                return n
            }(t, e))
            if (!n) return e
            const r = S(n, t)
            const i = o(n, n.next)
            return o(r, r.next), e === n ? i : e
        }

        function d(t, e) {
            return _(t.prev, t, e.prev) < 0 && _(e.next, t, t.next) < 0
        }

        function p(t, e, n, r, i) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function m(t) {
            let e = t
            let n = t
            do {
                (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
            } while (e !== t)
            return n
        }

        function y(t, e, n, r, i, o, a, s) {
            return (i - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (r - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0
        }

        function v(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !(function (t, e) {
                let n = t
                do {
                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && b(n, n.next, t, e)) return !0
                    n = n.next
                } while (n !== t)
                return !1
            }(t, e)) && (T(t, e) && T(e, t) && (function (t, e) {
                let n = t
                let r = !1
                let i = (t.x + e.x) / 2
                let o = (t.y + e.y) / 2
                do {
                    n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                } while (n !== t)
                return r
            }(t, e)) && (_(t.prev, t, e.prev) || _(t, e.prev, e)) || g(t, e) && _(t.prev, t, t.next) > 0 && _(e.prev, e, e.next) > 0)
        }

        function _(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }

        function g(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function b(t, e, n, r) {
            const i = x(_(t, e, n))
            const o = x(_(t, e, r))
            const a = x(_(n, r, t))
            const s = x(_(n, r, e))
            return i !== o && a !== s || (!(i !== 0 || !E(t, n, e)) || (!(o !== 0 || !E(t, r, e)) || (!(a !== 0 || !E(n, t, r)) || !(s !== 0 || !E(n, e, r)))))
        }

        function E(t, e, n) {
            return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
        }

        function x(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }

        function T(t, e) {
            return _(t.prev, t, t.next) < 0 ? _(t, e, t.next) >= 0 && _(t, t.prev, e) >= 0 : _(t, e, t.prev) < 0 || _(t, t.next, e) < 0
        }

        function S(t, e) {
            const n = new P(t.i, t.x, t.y)
            const r = new P(e.i, e.x, e.y)
            const i = t.next
            const o = e.prev
            return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
        }

        function w(t, e, n, r) {
            const i = new P(t, e, n)
            return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
        }

        function O(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function P(t, e, n) {
            this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }

        function R(t, e, n, r) {
            for (var i = 0, o = e, a = n - r; o < n; o += r) i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o
            return i
        }
        t.exports = r, t.exports.default = r, r.deviation = function (t, e, n, r) {
            const i = e && e.length
            const o = i ? e[0] * n : t.length
            let a = Math.abs(R(t, 0, o, n))
            if (i) {
                for (var s = 0, u = e.length; s < u; s++) {
                    const c = e[s] * n
                    let l = s < u - 1 ? e[s + 1] * n : t.length
                    a -= Math.abs(R(t, c, l, n))
                }
            }
            let h = 0
            for (s = 0; s < r.length; s += 3) {
                const f = r[s] * n
                const d = r[s + 1] * n
                const p = r[s + 2] * n
                h += Math.abs((t[f] - t[p]) * (t[d + 1] - t[f + 1]) - (t[f] - t[d]) * (t[p + 1] - t[f + 1]))
            }
            return a === 0 && h === 0 ? 0 : Math.abs((h - a) / a)
        }, r.flatten = function (t) {
            for (var e = t[0][0].length, n = {
                    vertices: [],
                    holes: [],
                    dimensions: e
                }, r = 0, i = 0; i < t.length; i++) {
                for (let o = 0; o < t[i].length; o++) {
                    for (let a = 0; a < e; a++) n.vertices.push(t[i][o][a])
                }
                i > 0 && (r += t[i - 1].length, n.holes.push(r))
            }
            return n
        }
    },
    './node_modules/eventemitter3/index.js': function (t, e, n) {
        'use strict'
        const r = Object.prototype.hasOwnProperty
        let i = '~'

        function o() {}

        function a(t, e, n) {
            this.fn = t, this.context = e, this.once = n || !1
        }

        function s(t, e, n, r, o) {
            if (typeof n != 'function') throw new TypeError('The listener must be a function')
            const s = new a(n, r || t, o)
            const u = i ? i + e : e
            return t._events[u] ? t._events[u].fn ? t._events[u] = [t._events[u], s] : t._events[u].push(s) : (t._events[u] = s, t._eventsCount++), t
        }

        function u(t, e) {
            --t._eventsCount == 0 ? t._events = new o() : delete t._events[e]
        }

        function c() {
            this._events = new o(), this._eventsCount = 0
        }
        Object.create && (o.prototype = Object.create(null), (new o()).__proto__ || (i = !1)), c.prototype.eventNames = function () {
            let t; let e; const n = []
            if (this._eventsCount === 0) return n
            for (e in t = this._events) r.call(t, e) && n.push(i ? e.slice(1) : e)
            return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n
        }, c.prototype.listeners = function (t) {
            const e = i ? i + t : t
            const n = this._events[e]
            if (!n) return []
            if (n.fn) return [n.fn]
            for (var r = 0, o = n.length, a = new Array(o); r < o; r++) a[r] = n[r].fn
            return a
        }, c.prototype.listenerCount = function (t) {
            const e = i ? i + t : t
            const n = this._events[e]
            return n ? n.fn ? 1 : n.length : 0
        }, c.prototype.emit = function (t, e, n, r, o, a) {
            const s = i ? i + t : t
            if (!this._events[s]) return !1
            let u; let c; const l = this._events[s]
            const h = arguments.length
            if (l.fn) {
                switch (l.once && this.removeListener(t, l.fn, void 0, !0), h) {
                    case 1:
                        return l.fn.call(l.context), !0
                    case 2:
                        return l.fn.call(l.context, e), !0
                    case 3:
                        return l.fn.call(l.context, e, n), !0
                    case 4:
                        return l.fn.call(l.context, e, n, r), !0
                    case 5:
                        return l.fn.call(l.context, e, n, r, o), !0
                    case 6:
                        return l.fn.call(l.context, e, n, r, o, a), !0
                }
                for (c = 1, u = Array.from({ length: h - 1 }); c < h; c++) u[c - 1] = arguments[c]
                l.fn.apply(l.context, u)
            } else {
                let f; const d = l.length
                for (c = 0; c < d; c++) { switch (l[c].once && this.removeListener(t, l[c].fn, void 0, !0), h) {
                    case 1:
                        l[c].fn.call(l[c].context)
                        break
                    case 2:
                        l[c].fn.call(l[c].context, e)
                        break
                    case 3:
                        l[c].fn.call(l[c].context, e, n)
                        break
                    case 4:
                        l[c].fn.call(l[c].context, e, n, r)
                        break
                    default:
                        if (!u) {
                            for (f = 1, u = Array.from({ length: h - 1 }); f < h; f++) u[f - 1] = arguments[f]
                        }
                        l[c].fn.apply(l[c].context, u)
                }
                }
            }
            return !0
        }, c.prototype.on = function (t, e, n) {
            return s(this, t, e, n, !1)
        }, c.prototype.once = function (t, e, n) {
            return s(this, t, e, n, !0)
        }, c.prototype.removeListener = function (t, e, n, r) {
            const o = i ? i + t : t
            if (!this._events[o]) return this
            if (!e) return u(this, o), this
            const a = this._events[o]
            if (a.fn) { a.fn !== e || r && !a.once || n && a.context !== n || u(this, o)
            }
            else {
                for (var s = 0, c = [], l = a.length; s < l; s++)(a[s].fn !== e || r && !a[s].once || n && a[s].context !== n) && c.push(a[s])
                c.length ? this._events[o] = c.length === 1 ? c[0] : c : u(this, o)
            }
            return this
        }, c.prototype.removeAllListeners = function (t) {
            let e
            return t ? (e = i ? i + t : t, this._events[e] && u(this, e)) : (this._events = new o(), this._eventsCount = 0), this
        }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = i, c.EventEmitter = c, t.exports = c
    },
    './node_modules/howler/dist/howler.js': function (t, e, n) {
        (function (n) {
            let r
            /*!
                 *  howler.js v2.1.3
                 *  howlerjs.com
                 *
                 *  (c) 2013-2019, James Simpson of GoldFire Studios
                 *  goldfirestudios.com
                 *
                 *  MIT License
                 */
            !(function () {
                'use strict'
                const i = function () {
                    this.init()
                }
                i.prototype = {
                    init() {
                        const t = this || o
                        return t._counter = 1e3, t._html5AudioPool = [], t.html5PoolSize = 10, t._codecs = {}, t._howls = [], t._muted = !1, t._volume = 1, t._canPlayEvent = 'canplaythrough', t._navigator = typeof window != 'undefined' && window.navigator ? window.navigator : null, t.masterGain = null, t.noAudio = !1, t.usingWebAudio = !0, t.autoSuspend = !0, t.ctx = null, t.autoUnlock = !0, t._setup(), t
                    },
                    volume(t) {
                        const e = this || o
                        if (t = Number.parseFloat(t), e.ctx || d(), void 0 !== t && t >= 0 && t <= 1) {
                            if (e._volume = t, e._muted) return e
                            e.usingWebAudio && e.masterGain.gain.setValueAtTime(t, o.ctx.currentTime)
                            for (let n = 0; n < e._howls.length; n++) {
                                if (!e._howls[n]._webAudio) {
                                    for (let r = e._howls[n]._getSoundIds(), i = 0; i < r.length; i++) {
                                        var a = e._howls[n]._soundById(r[i])
                                            a && a._node && (a._node.volume = a._volume * t)
                                    }
                                }
                            }
                            return e
                        }
                        return e._volume
                    },
                    mute(t) {
                        const e = this || o
                        e.ctx || d(), e._muted = t, e.usingWebAudio && e.masterGain.gain.setValueAtTime(t ? 0 : e._volume, o.ctx.currentTime)
                        for (let n = 0; n < e._howls.length; n++) {
                            if (!e._howls[n]._webAudio) {
                                for (let r = e._howls[n]._getSoundIds(), i = 0; i < r.length; i++) {
                                    var a = e._howls[n]._soundById(r[i])
                                        a && a._node && (a._node.muted = !!t || a._muted)
                                }
                            }
                        }
                        return e
                    },
                    unload() {
                        for (var t = this || o, e = t._howls.length - 1; e >= 0; e--) t._howls[e].unload()
                        return t.usingWebAudio && t.ctx && void 0 !== t.ctx.close && (t.ctx.close(), t.ctx = null, d()), t
                    },
                    codecs(t) {
                        return (this || o)._codecs[t.replace(/^x-/, '')]
                    },
                    _setup() {
                        const t = this || o
                        if (t.state = t.ctx && t.ctx.state || 'suspended', t._autoSuspend(), !t.usingWebAudio) {
                            if (typeof Audio != 'undefined') { try {
                                void 0 === (new Audio()).oncanplaythrough && (t._canPlayEvent = 'canplay')
                            } catch (e) {
                                t.noAudio = !0
                            }
                            } else { t.noAudio = !0
}
                        }
                        try {
                            (new Audio()).muted && (t.noAudio = !0)
                        } catch (t) {}
                        return t.noAudio || t._setupCodecs(), t
                    },
                    _setupCodecs() {
                        const t = this || o
                        var e = null
                        try {
                            e = typeof Audio != 'undefined' ? new Audio() : null
                        } catch (e) {
                            return t
                        }
                        if (!e || typeof e.canPlayType != 'function') return t
                        let n = e.canPlayType('audio/mpeg;').replace(/^no$/, '')
                        var r = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g)
                        var i = r && Number.parseInt(r[0].split('/')[1], 10) < 33
                        return t._codecs = {
                            mp3: !(i || !n && !e.canPlayType('audio/mp3;').replace(/^no$/, '')),
                            mpeg: !!n,
                            opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
                            ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                            oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                            wav: !!e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
                            aac: !!e.canPlayType('audio/aac;').replace(/^no$/, ''),
                            caf: !!e.canPlayType('audio/x-caf;').replace(/^no$/, ''),
                            m4a: !!(e.canPlayType('audio/x-m4a;') || e.canPlayType('audio/m4a;') || e.canPlayType('audio/aac;')).replace(/^no$/, ''),
                            mp4: !!(e.canPlayType('audio/x-mp4;') || e.canPlayType('audio/mp4;') || e.canPlayType('audio/aac;')).replace(/^no$/, ''),
                            weba: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
                            webm: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
                            dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
                            flac: !!(e.canPlayType('audio/x-flac;') || e.canPlayType('audio/flac;')).replace(/^no$/, '')
                        }, t
                    },
                    _unlockAudio() {
                        const t = this || o
                        if (!t._audioUnlocked && t.ctx) {
                            t._audioUnlocked = !1, t.autoUnlock = !1, t._mobileUnloaded || t.ctx.sampleRate === 44100 || (t._mobileUnloaded = !0, t.unload()), t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050)
                            let e = function (n) {
                                for (var r = 0; r < t.html5PoolSize; r++) { try {
                                    let i = new Audio()
                                    i._unlocked = !0, t._releaseHtml5Audio(i)
                                } catch (n) {
                                    t.noAudio = !0
                                }
                                }
                                for (r = 0; r < t._howls.length; r++) {
                                    if (!t._howls[r]._webAudio) {
                                        for (let o = t._howls[r]._getSoundIds(), a = 0; a < o.length; a++) {
                                            var s = t._howls[r]._soundById(o[a])
                                                s && s._node && !s._node._unlocked && (s._node._unlocked = !0, s._node.load())
                                        }
                                    }
                                }
                                t._autoResume()
                                let u = t.ctx.createBufferSource()
                                u.buffer = t._scratchBuffer, u.connect(t.ctx.destination), void 0 === u.start ? u.noteOn(0) : u.start(0), typeof t.ctx.resume == 'function' && t.ctx.resume(), u.onended = function () {
                                    u.disconnect(0), t._audioUnlocked = !0, document.removeEventListener('touchstart', e, !0), document.removeEventListener('touchend', e, !0), document.removeEventListener('click', e, !0)
                                    for (let n = 0; n < t._howls.length; n++) t._howls[n]._emit('unlock')
                                }
                            }
                            return document.addEventListener('touchstart', e, !0), document.addEventListener('touchend', e, !0), document.addEventListener('click', e, !0), t
                        }
                    },
                    _obtainHtml5Audio() {
                        const t = this || o
                        if (t._html5AudioPool.length) return t._html5AudioPool.pop()
                        let e = (new Audio()).play()
                        return e && typeof Promise != 'undefined' && (e instanceof Promise || typeof e.then == 'function') && e.catch(() => {
                            console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.')
                        }), new Audio()
                    },
                    _releaseHtml5Audio(t) {
                        const e = this || o
                        return t._unlocked && e._html5AudioPool.push(t), e
                    },
                    _autoSuspend() {
                        const t = this
                        if (t.autoSuspend && t.ctx && void 0 !== t.ctx.suspend && o.usingWebAudio) {
                            for (let e = 0; e < t._howls.length; e++) {
                                if (t._howls[e]._webAudio) {
                                    for (let n = 0; n < t._howls[e]._sounds.length; n++) {
                                            if (!t._howls[e]._sounds[n]._paused) return t;
}
                                }
                            }
                            return t._suspendTimer && clearTimeout(t._suspendTimer), t._suspendTimer = setTimeout(() => {
                                t.autoSuspend && (t._suspendTimer = null, t.state = 'suspending', t.ctx.suspend().then(() => {
                                    t.state = 'suspended', t._resumeAfterSuspend && (delete t._resumeAfterSuspend, t._autoResume())
                                }))
                            }, 3e4), t
                        }
                    },
                    _autoResume() {
                        const t = this
                        if (t.ctx && void 0 !== t.ctx.resume && o.usingWebAudio) { return t.state === 'running' && t._suspendTimer
                            ? (clearTimeout(t._suspendTimer), t._suspendTimer = null)
                            : t.state === 'suspended'
                                ? (t.ctx.resume().then(() => {
                                        t.state = 'running';
                                        for (let e = 0; e < t._howls.length; e++) t._howls[e]._emit('resume')
                                    }), t._suspendTimer && (clearTimeout(t._suspendTimer), t._suspendTimer = null))
                                : t.state === 'suspending' && (t._resumeAfterSuspend = !0), t
                        }
                    }
                }
                var o = new i()
                var a = function (t) {
                    t.src && t.src.length !== 0 ? this.init(t) : console.error('An array of source files must be passed with any new Howl.')
                }
                a.prototype = {
                    init(t) {
                        const e = this
                        return o.ctx || d(), e._autoplay = t.autoplay || !1, e._format = typeof t.format != 'string' ? t.format : [t.format], e._html5 = t.html5 || !1, e._muted = t.mute || !1, e._loop = t.loop || !1, e._pool = t.pool || 5, e._preload = typeof t.preload != 'boolean' || t.preload, e._rate = t.rate || 1, e._sprite = t.sprite || {}, e._src = typeof t.src != 'string' ? t.src : [t.src], e._volume = void 0 !== t.volume ? t.volume : 1, e._xhrWithCredentials = t.xhrWithCredentials || !1, e._duration = 0, e._state = 'unloaded', e._sounds = [], e._endTimers = {}, e._queue = [], e._playLock = !1, e._onend = t.onend
                            ? [{
                                    fn: t.onend
                                }]
                            : [], e._onfade = t.onfade
                            ? [{
                                    fn: t.onfade
                                }]
                            : [], e._onload = t.onload
                            ? [{
                                    fn: t.onload
                                }]
                            : [], e._onloaderror = t.onloaderror
                            ? [{
                                    fn: t.onloaderror
                                }]
                            : [], e._onplayerror = t.onplayerror
                            ? [{
                                    fn: t.onplayerror
                                }]
                            : [], e._onpause = t.onpause
                            ? [{
                                    fn: t.onpause
                                }]
                            : [], e._onplay = t.onplay
                            ? [{
                                    fn: t.onplay
                                }]
                            : [], e._onstop = t.onstop
                            ? [{
                                    fn: t.onstop
                                }]
                            : [], e._onmute = t.onmute
                            ? [{
                                    fn: t.onmute
                                }]
                            : [], e._onvolume = t.onvolume
                            ? [{
                                    fn: t.onvolume
                                }]
                            : [], e._onrate = t.onrate
                            ? [{
                                    fn: t.onrate
                                }]
                            : [], e._onseek = t.onseek
                            ? [{
                                    fn: t.onseek
                                }]
                            : [], e._onunlock = t.onunlock
                            ? [{
                                    fn: t.onunlock
                                }]
                            : [], e._onresume = [], e._webAudio = o.usingWebAudio && !e._html5, void 0 !== o.ctx && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(e), e._autoplay && e._queue.push({
                            event: 'play',
                            action() {
                                e.play()
                            }
                        }), e._preload && e.load(), e
                    },
                    load() {
                        let t = null
                        if (o.noAudio) { this._emit('loaderror', null, 'No audio support.')
                        }
                        else {
                            typeof this._src == 'string' && (this._src = [this._src])
                            for (let e = 0; e < this._src.length; e++) {
                                var n, r
                                if (this._format && this._format[e]) { n = this._format[e]
                                }
                                else {
                                    if (typeof (r = this._src[e]) != 'string') {
                                        this._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.')
                                        continue
                                    }(n = /^data:audio\/([^;,]+);/i.exec(r)) || (n = /\.([^.]+)$/.exec(r.split('?', 1)[0])), n && (n = n[1].toLowerCase())
                                }
                                if (n || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n && o.codecs(n)) {
                                    t = this._src[e]
                                    break
                                }
                            }
                            if (t) return this._src = t, this._state = 'loading', window.location.protocol === 'https:' && t.slice(0, 5) === 'http:' && (this._html5 = !0, this._webAudio = !1), new s(this), this._webAudio && c(this), this
                            this._emit('loaderror', null, 'No codec support for selected audio sources.')
                        }
                    },
                    play(t, e) {
                        const n = this
                        var r = null
                        if (typeof t == 'number') { r = t, t = null
                        }
                        else {
                            if (typeof t == 'string' && n._state === 'loaded' && !n._sprite[t]) return null
                            if (void 0 === t && (t = '__default', !n._playLock)) {
                                for (var i = 0, a = 0; a < n._sounds.length; a++) n._sounds[a]._paused && !n._sounds[a]._ended && (i++, r = n._sounds[a]._id)
                                i === 1 ? t = null : r = null
                            }
                        }
                        const s = r ? n._soundById(r) : n._inactiveSound()
                        if (!s) return null
                        if (r && !t && (t = s._sprite || '__default'), n._state !== 'loaded') {
                            s._sprite = t, s._ended = !1
                            let u = s._id
                            return n._queue.push({
                                event: 'play',
                                action() {
                                    n.play(u)
                                }
                            }), u
                        }
                        if (r && !s._paused) return e || n._loadQueue('play'), s._id
                        n._webAudio && o._autoResume()
                        let c = Math.max(0, s._seek > 0 ? s._seek : n._sprite[t][0] / 1e3)
                        var l = Math.max(0, (n._sprite[t][0] + n._sprite[t][1]) / 1e3 - c)
                        var h = 1e3 * l / Math.abs(s._rate)
                        var f = n._sprite[t][0] / 1e3
                        var d = (n._sprite[t][0] + n._sprite[t][1]) / 1e3
                        s._sprite = t, s._ended = !1
                        let p = function () {
                            s._paused = !1, s._seek = c, s._start = f, s._stop = d, s._loop = !(!s._loop && !n._sprite[t][2])
                        }
                        if (!(c >= d)) {
                            const m = s._node
                            if (n._webAudio) {
                                const y = function () {
                                    n._playLock = !1, p(), n._refreshBuffer(s)
                                    var t = s._muted || n._muted ? 0 : s._volume
                                    m.gain.setValueAtTime(t, o.ctx.currentTime), s._playStart = o.ctx.currentTime, void 0 === m.bufferSource.start ? s._loop ? m.bufferSource.noteGrainOn(0, c, 86400) : m.bufferSource.noteGrainOn(0, c, l) : s._loop ? m.bufferSource.start(0, c, 86400) : m.bufferSource.start(0, c, l), h !== 1 / 0 && (n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), h)), e || setTimeout(() => {
                                        n._emit('play', s._id), n._loadQueue()
                                    }, 0)
                                }
                                'running' === o.state ? y() : (n._playLock = !0, n.once('resume', y), n._clearTimer(s._id))
                            } else {
                                const v = function () {
                                    m.currentTime = c, m.muted = s._muted || n._muted || o._muted || m.muted, m.volume = s._volume * o.volume(), m.playbackRate = s._rate
                                    try {
                                        let r = m.play()
                                        if (r && typeof Promise != 'undefined' && (r instanceof Promise || typeof r.then == 'function')
                                            ? (n._playLock = !0, p(), r.then(() => {
                                                    n._playLock = !1, m._unlocked = !0, e || (n._emit('play', s._id), n._loadQueue())
                                                }).catch(() => {
                                                    n._playLock = !1, n._emit('playerror', s._id, 'Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.'), s._ended = !0, s._paused = !0
                                                }))
                                            : e || (n._playLock = !1, p(), n._emit('play', s._id), n._loadQueue()), m.playbackRate = s._rate, m.paused) { return void n._emit('playerror', s._id, 'Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.');
                                        }
                                        '__default' !== t || s._loop
                                            ? n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), h)
                                            : (n._endTimers[s._id] = function () {
                                                    n._ended(s), m.removeEventListener('ended', n._endTimers[s._id], !1)
                                                }, m.addEventListener('ended', n._endTimers[s._id], !1))
                                    } catch (t) {
                                        n._emit('playerror', s._id, t)
                                    }
                                }
                                'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA' === m.src && (m.src = n._src, m.load())
                                let _ = window && window.ejecta || !m.readyState && o._navigator.isCocoonJS
                                if (m.readyState >= 3 || _) { v()
                                }
                                else {
                                    n._playLock = !0
                                    let g = function () {
                                        v(), m.removeEventListener(o._canPlayEvent, g, !1)
                                    }
                                    m.addEventListener(o._canPlayEvent, g, !1), n._clearTimer(s._id)
                                }
                            }
                            return s._id
                        }
                        n._ended(s)
                    },
                    pause(t) {
                        const e = this
                        if (e._state !== 'loaded' || e._playLock) { return e._queue.push({
                            event: 'pause',
                            action () {
                                e.pause(t)
                            }
                        }), e
                        }
                        for (let n = e._getSoundIds(t), r = 0; r < n.length; r++) {
                            e._clearTimer(n[r])
                            let i = e._soundById(n[r])
                            if (i && !i._paused && (i._seek = e.seek(n[r]), i._rateSeek = 0, i._paused = !0, e._stopFade(n[r]), i._node)) {
                                if (e._webAudio) {
                                    if (!i._node.bufferSource) continue
                                    void 0 === i._node.bufferSource.stop ? i._node.bufferSource.noteOff(0) : i._node.bufferSource.stop(0), e._cleanBuffer(i._node)
                                } else { isNaN(i._node.duration) && i._node.duration !== 1 / 0 || i._node.pause()
}
                            }
                            arguments[1] || e._emit('pause', i ? i._id : null)
                        }
                        return e
                    },
                    stop(t, e) {
                        const n = this
                        if (n._state !== 'loaded' || n._playLock) { return n._queue.push({
                            event: 'stop',
                            action () {
                                n.stop(t)
                            }
                        }), n
                        }
                        for (let r = n._getSoundIds(t), i = 0; i < r.length; i++) {
                            n._clearTimer(r[i])
                            let o = n._soundById(r[i])
                            o && (o._seek = o._start || 0, o._rateSeek = 0, o._paused = !0, o._ended = !0, n._stopFade(r[i]), o._node && (n._webAudio ? o._node.bufferSource && (void 0 === o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0), n._cleanBuffer(o._node)) : isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0, o._node.pause(), o._node.duration === 1 / 0 && n._clearSound(o._node))), e || n._emit('stop', o._id))
                        }
                        return n
                    },
                    mute(t, e) {
                        const n = this
                        if (n._state !== 'loaded' || n._playLock) { return n._queue.push({
                            event: 'mute',
                            action () {
                                n.mute(t, e)
                            }
                        }), n
                        }
                        if (void 0 === e) {
                            if (typeof t != 'boolean') return n._muted
                            n._muted = t
                        }
                        for (let r = n._getSoundIds(e), i = 0; i < r.length; i++) {
                            const a = n._soundById(r[i])
                            a && (a._muted = t, a._interval && n._stopFade(a._id), n._webAudio && a._node ? a._node.gain.setValueAtTime(t ? 0 : a._volume, o.ctx.currentTime) : a._node && (a._node.muted = !!o._muted || t), n._emit('mute', a._id))
                        }
                        return n
                    },
                    volume() {
                        let t; let e; let n; const r = this
                        var i = arguments
                        if (i.length === 0) return r._volume
                        if (i.length === 1 || i.length === 2 && void 0 === i[1]) {
                            const a = r._getSoundIds()
                            var s = a.indexOf(i[0])
                            s >= 0 ? e = Number.parseInt(i[0], 10) : t = Number.parseFloat(i[0])
                        } else { i.length >= 2 && (t = Number.parseFloat(i[0]), e = Number.parseInt(i[1], 10))
                        }
                        if (!(void 0 !== t && t >= 0 && t <= 1)) return (n = e ? r._soundById(e) : r._sounds[0]) ? n._volume : 0
                        if (r._state !== 'loaded' || r._playLock) { return r._queue.push({
                            event: 'volume',
                            action () {
                                r.volume.apply(r, i)
                            }
                        }), r
                        }
                        void 0 === e && (r._volume = t), e = r._getSoundIds(e)
                        for (let u = 0; u < e.length; u++)(n = r._soundById(e[u])) && (n._volume = t, i[2] || r._stopFade(e[u]), r._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(t, o.ctx.currentTime) : n._node && !n._muted && (n._node.volume = t * o.volume()), r._emit('volume', n._id))
                        return r
                    },
                    fade(t, e, n, r) {
                        const i = this
                        if (i._state !== 'loaded' || i._playLock) { return i._queue.push({
                            event: 'fade',
                            action () {
                                i.fade(t, e, n, r)
                            }
                        }), i
                        }
                        t = Number.parseFloat(t), e = Number.parseFloat(e), n = Number.parseFloat(n), i.volume(t, r)
                        for (let a = i._getSoundIds(r), s = 0; s < a.length; s++) {
                            const u = i._soundById(a[s])
                            if (u) {
                                if (r || i._stopFade(a[s]), i._webAudio && !u._muted) {
                                    const c = o.ctx.currentTime
                                    var l = c + n / 1e3
                                    u._volume = t, u._node.gain.setValueAtTime(t, c), u._node.gain.linearRampToValueAtTime(e, l)
                                }
                                i._startFadeInterval(u, t, e, n, a[s], void 0 === r)
                            }
                        }
                        return i
                    },
                    _startFadeInterval(t, e, n, r, i, o) {
                        const a = this
                        var s = e
                        var u = n - e
                        var c = Math.abs(u / 0.01)
                        var l = Math.max(4, c > 0 ? r / c : r)
                        var h = Date.now()
                        t._fadeTo = n, t._interval = setInterval(() => {
                            let i = (Date.now() - h) / r
                            h = Date.now(), s += u * i, s = Math.max(0, s), s = Math.min(1, s), s = Math.round(100 * s) / 100, a._webAudio ? t._volume = s : a.volume(s, t._id, !0), o && (a._volume = s), (n < e && s <= n || n > e && s >= n) && (clearInterval(t._interval), t._interval = null, t._fadeTo = null, a.volume(n, t._id), a._emit('fade', t._id))
                        }, l)
                    },
                    _stopFade(t) {
                        const e = this._soundById(t)
                        return e && e._interval && (this._webAudio && e._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(e._interval), e._interval = null, this.volume(e._fadeTo, t), e._fadeTo = null, this._emit('fade', t)), this
                    },
                    loop() {
                        let t; let e; let n; const r = this
                        var i = arguments
                        if (i.length === 0) return r._loop
                        if (i.length === 1) {
                            if (typeof i[0] != 'boolean') return !!(n = r._soundById(Number.parseInt(i[0], 10))) && n._loop
                            t = i[0], r._loop = t
                        } else { i.length === 2 && (t = i[0], e = Number.parseInt(i[1], 10))
                        }
                        for (let o = r._getSoundIds(e), a = 0; a < o.length; a++)(n = r._soundById(o[a])) && (n._loop = t, r._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = t, t && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop)))
                        return r
                    },
                    rate() {
                        let t; let e; let n; const r = this
                        var i = arguments
                        if (i.length === 0) { e = r._sounds[0]._id
                        }
                        else if (i.length === 1) {
                            const a = r._getSoundIds()
                            var s = a.indexOf(i[0])
                            s >= 0 ? e = Number.parseInt(i[0], 10) : t = Number.parseFloat(i[0])
                        } else { i.length === 2 && (t = Number.parseFloat(i[0]), e = Number.parseInt(i[1], 10))
                        }
                        if (typeof t != 'number') return (n = r._soundById(e)) ? n._rate : r._rate
                        if (r._state !== 'loaded' || r._playLock) { return r._queue.push({
                            event: 'rate',
                            action () {
                                r.rate.apply(r, i)
                            }
                        }), r
                        }
                        void 0 === e && (r._rate = t), e = r._getSoundIds(e)
                        for (let u = 0; u < e.length; u++) {
                            if (n = r._soundById(e[u])) {
                                r.playing(e[u]) && (n._rateSeek = r.seek(e[u]), n._playStart = r._webAudio ? o.ctx.currentTime : n._playStart), n._rate = t, r._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(t, o.ctx.currentTime) : n._node && (n._node.playbackRate = t)
                                var c = r.seek(e[u])
                                        var l = (r._sprite[n._sprite][0] + r._sprite[n._sprite][1]) / 1e3 - c
                                        var h = 1e3 * l / Math.abs(n._rate)
                                !r._endTimers[e[u]] && n._paused || (r._clearTimer(e[u]), r._endTimers[e[u]] = setTimeout(r._ended.bind(r, n), h)), r._emit('rate', n._id)
                            }
                        }
                        return r
                    },
                    seek() {
                        let t; let e; const n = this
                        var r = arguments
                        if (r.length === 0) { e = n._sounds[0]._id
                        }
                        else if (r.length === 1) {
                            const i = n._getSoundIds()
                            var a = i.indexOf(r[0])
                            a >= 0 ? e = Number.parseInt(r[0], 10) : n._sounds.length && (e = n._sounds[0]._id, t = Number.parseFloat(r[0]))
                        } else { r.length === 2 && (t = Number.parseFloat(r[0]), e = Number.parseInt(r[1], 10))
                        }
                        if (void 0 === e) return n
                        if (n._state !== 'loaded' || n._playLock) { return n._queue.push({
                            event: 'seek',
                            action () {
                                n.seek.apply(n, r)
                            }
                        }), n
                        }
                        const s = n._soundById(e)
                        if (s) {
                            if (!(typeof t == 'number' && t >= 0)) {
                                if (n._webAudio) {
                                    const u = n.playing(e) ? o.ctx.currentTime - s._playStart : 0
                                    var c = s._rateSeek ? s._rateSeek - s._seek : 0
                                    return s._seek + (c + u * Math.abs(s._rate))
                                }
                                return s._node.currentTime
                            }
                            const l = n.playing(e)
                            l && n.pause(e, !0), s._seek = t, s._ended = !1, n._clearTimer(e), n._webAudio || !s._node || isNaN(s._node.duration) || (s._node.currentTime = t)
                            let h = function () {
                                n._emit('seek', e), l && n.play(e, !0)
                            }
                            if (l && !n._webAudio) {
                                const f = function () {
                                    n._playLock ? setTimeout(f, 0) : h()
                                }
                                setTimeout(f, 0)
                            } else { h()
                            }
                        }
                        return n
                    },
                    playing(t) {
                        if (typeof t == 'number') {
                            const e = this._soundById(t)
                            return !!e && !e._paused
                        }
                        for (let n = 0; n < this._sounds.length; n++) {
                            if (!this._sounds[n]._paused) return !0
                        }
                        return !1
                    },
                    duration(t) {
                        let e = this._duration
                        var n = this._soundById(t)
                        return n && (e = this._sprite[n._sprite][1] / 1e3), e
                    },
                    state() {
                        return this._state
                    },
                    unload() {
                        for (var t = this, e = t._sounds, n = 0; n < e.length; n++) e[n]._paused || t.stop(e[n]._id), t._webAudio || (t._clearSound(e[n]._node), e[n]._node.removeEventListener('error', e[n]._errorFn, !1), e[n]._node.removeEventListener(o._canPlayEvent, e[n]._loadFn, !1), o._releaseHtml5Audio(e[n]._node)), delete e[n]._node, t._clearTimer(e[n]._id)
                        let r = o._howls.indexOf(t)
                        r >= 0 && o._howls.splice(r, 1)
                        let i = !0
                        for (n = 0; n < o._howls.length; n++) {
                            if (o._howls[n]._src === t._src || t._src.includes(o._howls[n]._src)) {
                                i = !1
                                break
                            }
                        }
                        return u && i && delete u[t._src], o.noAudio = !1, t._state = 'unloaded', t._sounds = [], t = null, null
                    },
                    on(t, e, n, r) {
                        const i = this[`_on${  t}`]
                        return typeof e == 'function' && i.push(r
                            ? {
                                    id: n,
                                    fn: e,
                                    once: r
                                }
                            : {
                                    id: n,
                                    fn: e
                                }), this
                    },
                    off(t, e, n) {
                        const r = this[`_on${  t}`];
                        let i = 0
                        if (typeof e == 'number' && (n = e, e = null), e || n) {
                            for (i = 0; i < r.length; i++) {
                                let o = n === r[i].id
                                if (e === r[i].fn && o || !e && o) {
                                    r.splice(i, 1)
                                    break
                                }
                            }
                        } else if (t) { this[`_on${  t}`] = []
                        }
                        else {
                            const a = Object.keys(this)
                            for (i = 0; i < a.length; i++) a[i].indexOf('_on') === 0 && Array.isArray(this[a[i]]) && (this[a[i]] = [])
                        }
                        return this
                    },
                    once(t, e, n) {
                        return this.on(t, e, n, 1), this
                    },
                    _emit(t, e, n) {
                        for (let r = this[`_on${ t}`], i = r.length - 1; i >= 0; i--) { r[i].id && r[i].id !== e && t !== 'load' || (setTimeout(function (t) {
                            t.call(this, e, n)
                        }.bind(this, r[i].fn), 0), r[i].once && this.off(t, r[i].fn, r[i].id))
                        }
                        return this._loadQueue(t), this
                    },
                    _loadQueue(t) {
                        if (this._queue.length > 0) {
                            const e = this._queue[0]
                            e.event === t && (this._queue.shift(), this._loadQueue()), t || e.action()
                        }
                        return this
                    },
                    _ended(t) {
                        const e = t._sprite
                        if (!this._webAudio && t._node && !t._node.paused && !t._node.ended && t._node.currentTime < t._stop) return setTimeout(this._ended.bind(this, t), 100), this
                        let n = !(!t._loop && !this._sprite[e][2])
                        if (this._emit('end', t._id), !this._webAudio && n && this.stop(t._id, !0).play(t._id), this._webAudio && n) {
                            this._emit('play', t._id), t._seek = t._start || 0, t._rateSeek = 0, t._playStart = o.ctx.currentTime
                            let r = 1e3 * (t._stop - t._start) / Math.abs(t._rate)
                            this._endTimers[t._id] = setTimeout(this._ended.bind(this, t), r)
                        }
                        return this._webAudio && !n && (t._paused = !0, t._ended = !0, t._seek = t._start || 0, t._rateSeek = 0, this._clearTimer(t._id), this._cleanBuffer(t._node), o._autoSuspend()), this._webAudio || n || this.stop(t._id, !0), this
                    },
                    _clearTimer(t) {
                        if (this._endTimers[t]) {
                            if (typeof this._endTimers[t] != 'function') { clearTimeout(this._endTimers[t])
                            }
                            else {
                                const e = this._soundById(t)
                                e && e._node && e._node.removeEventListener('ended', this._endTimers[t], !1)
                            }
                            delete this._endTimers[t]
                        }
                        return this
                    },
                    _soundById(t) {
                        for (let e = 0; e < this._sounds.length; e++) {
                            if (t === this._sounds[e]._id) return this._sounds[e]
                        }
                        return null
                    },
                    _inactiveSound() {
                        this._drain()
                        for (let t = 0; t < this._sounds.length; t++) {
                            if (this._sounds[t]._ended) return this._sounds[t].reset()
                        }
                        return new s(this)
                    },
                    _drain() {
                        const t = this._pool
                        var e = 0
                        var n = 0
                        if (!(this._sounds.length < t)) {
                            for (n = 0; n < this._sounds.length; n++) this._sounds[n]._ended && e++
                            for (n = this._sounds.length - 1; n >= 0; n--) {
                                if (e <= t) return
                                this._sounds[n]._ended && (this._webAudio && this._sounds[n]._node && this._sounds[n]._node.disconnect(0), this._sounds.splice(n, 1), e--)
                            }
                        }
                    },
                    _getSoundIds(t) {
                        if (void 0 === t) {
                            for (var e = [], n = 0; n < this._sounds.length; n++) e.push(this._sounds[n]._id)
                            return e
                        }
                        return [t]
                    },
                    _refreshBuffer(t) {
                        return t._node.bufferSource = o.ctx.createBufferSource(), t._node.bufferSource.buffer = u[this._src], t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node), t._node.bufferSource.loop = t._loop, t._loop && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop || 0), t._node.bufferSource.playbackRate.setValueAtTime(t._rate, o.ctx.currentTime), this
                    },
                    _cleanBuffer(t) {
                        const e = o._navigator && o._navigator.vendor.includes('Apple');
                        if (o._scratchBuffer && t.bufferSource && (t.bufferSource.onended = null, t.bufferSource.disconnect(0), e)) { try {
                            t.bufferSource.buffer = o._scratchBuffer
                        } catch (t) {}
                        }
                        return t.bufferSource = null, this
                    },
                    _clearSound(t) {
                        /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (t.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA')
                    }
                }
                var s = function (t) {
                    this._parent = t, this.init()
                }
                s.prototype = {
                    init() {
                        const t = this._parent
                        return this._muted = t._muted, this._loop = t._loop, this._volume = t._volume, this._rate = t._rate, this._seek = 0, this._paused = !0, this._ended = !0, this._sprite = '__default', this._id = ++o._counter, t._sounds.push(this), this.create(), this
                    },
                    create() {
                        const t = this._parent
                        var e = o._muted || this._muted || this._parent._muted ? 0 : this._volume
                        return t._webAudio ? (this._node = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), this._node.gain.setValueAtTime(e, o.ctx.currentTime), this._node.paused = !0, this._node.connect(o.masterGain)) : o.noAudio || (this._node = o._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener('error', this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(o._canPlayEvent, this._loadFn, !1), this._node.src = t._src, this._node.preload = 'auto', this._node.volume = e * o.volume(), this._node.load()), this
                    },
                    reset() {
                        const t = this._parent
                        return this._muted = t._muted, this._loop = t._loop, this._volume = t._volume, this._rate = t._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = '__default', this._id = ++o._counter, this
                    },
                    _errorListener() {
                        this._parent._emit('loaderror', this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener('error', this._errorFn, !1)
                    },
                    _loadListener() {
                        const t = this._parent
                        t._duration = Math.ceil(10 * this._node.duration) / 10, Object.keys(t._sprite).length === 0 && (t._sprite = {
                            __default: [0, 1e3 * t._duration]
                        }), t._state !== 'loaded' && (t._state = 'loaded', t._emit('load'), t._loadQueue()), this._node.removeEventListener(o._canPlayEvent, this._loadFn, !1)
                    }
                }
                var u = {}
                var c = function (t) {
                    const e = t._src
                    if (u[e]) return t._duration = u[e].duration, void f(t)
                    if (/^data:[^;]+;base64,/.test(e)) {
                        for (var n = atob(e.split(',')[1]), r = new Uint8Array(n.length), i = 0; i < n.length; ++i) r[i] = n.charCodeAt(i)
                        h(r.buffer, t)
                    } else {
                        const o = new XMLHttpRequest()
                        o.open('GET', e, !0), o.withCredentials = t._xhrWithCredentials, o.responseType = 'arraybuffer', o.onload = function () {
                            const e = (`${o.status }`)[0]
                            '0' === e || e === '2' || e === '3' ? h(o.response, t) : t._emit('loaderror', null, `Failed loading audio file with status: ${ o.status }.`)
                        }, o.onerror = function () {
                            t._webAudio && (t._html5 = !0, t._webAudio = !1, t._sounds = [], delete u[e], t.load())
                        }, l(o)
                    }
                }
                var l = function (t) {
                    try {
                        t.send()
                    } catch (e) {
                        t.onerror()
                    }
                }
                var h = function (t, e) {
                    const n = function () {
                        e._emit('loaderror', null, 'Decoding audio data failed.')
                    };
                    let r = function (t) {
                        t && e._sounds.length > 0 ? (u[e._src] = t, f(e, t)) : n()
                    }
                    'undefined' != typeof Promise && o.ctx.decodeAudioData.length === 1 ? o.ctx.decodeAudioData(t).then(r).catch(n) : o.ctx.decodeAudioData(t, r, n)
                }
                var f = function (t, e) {
                    e && !t._duration && (t._duration = e.duration), Object.keys(t._sprite).length === 0 && (t._sprite = {
                        __default: [0, 1e3 * t._duration]
                    }), t._state !== 'loaded' && (t._state = 'loaded', t._emit('load'), t._loadQueue())
                }
                var d = function () {
                    if (o.usingWebAudio) {
                        try {
                            typeof AudioContext != 'undefined' ? o.ctx = new AudioContext() : typeof webkitAudioContext != 'undefined' ? o.ctx = new webkitAudioContext() : o.usingWebAudio = !1
                        } catch (t) {
                            o.usingWebAudio = !1
                        }
                        o.ctx || (o.usingWebAudio = !1)
                        const t = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform)
                        let e = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
                        let n = e ? Number.parseInt(e[1], 10) : null
                        if (t && n && n < 9) {
                            const r = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
                            (o._navigator && o._navigator.standalone && !r || o._navigator && !o._navigator.standalone && !r) && (o.usingWebAudio = !1)
                        }
                        o.usingWebAudio && (o.masterGain = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : o._volume, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup()
                    }
                }
                void 0 === (r = (function () {
                    return {
                        Howler: o,
                        Howl: a
                    }
                }.apply(e, []))) || (t.exports = r), e.Howler = o, e.Howl = a, typeof window != 'undefined' ? (window.HowlerGlobal = i, window.Howler = o, window.Howl = a, window.Sound = s) : void 0 !== n && (n.HowlerGlobal = i, n.Howler = o, n.Howl = a, n.Sound = s)
            }()),
            /*!
                 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
                 *
                 *  howler.js v2.1.3
                 *  howlerjs.com
                 *
                 *  (c) 2013-2019, James Simpson of GoldFire Studios
                 *  goldfirestudios.com
                 *
                 *  MIT License
                 */
            (function () {
                'use strict'
                let t
                HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (t) {
                    if (!this.ctx || !this.ctx.listener) return this
                    for (let e = this._howls.length - 1; e >= 0; e--) this._howls[e].stereo(t)
                    return this
                }, HowlerGlobal.prototype.pos = function (t, e, n) {
                    return this.ctx && this.ctx.listener ? (e = typeof e != 'number' ? this._pos[1] : e, n = typeof n != 'number' ? this._pos[2] : n, typeof t != 'number' ? this._pos : (this._pos = [t, e, n], void 0 !== this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this
                }, HowlerGlobal.prototype.orientation = function (t, e, n, r, i, o) {
                    if (!this.ctx || !this.ctx.listener) return this
                    const a = this._orientation
                    return e = typeof e != 'number' ? a[1] : e, n = typeof n != 'number' ? a[2] : n, r = typeof r != 'number' ? a[3] : r, i = typeof i != 'number' ? a[4] : i, o = typeof o != 'number' ? a[5] : o, typeof t != 'number' ? a : (this._orientation = [t, e, n, r, i, o], void 0 !== this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, 0.1), this.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, 0.1), this.ctx.listener.upY.setTargetAtTime(i, Howler.ctx.currentTime, 0.1), this.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setOrientation(t, e, n, r, i, o), this)
                }, Howl.prototype.init = (t = Howl.prototype.init, function (e) {
                    return this._orientation = e.orientation || [1, 0, 0], this._stereo = e.stereo || null, this._pos = e.pos || null, this._pannerAttr = {
                        coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : 360,
                        coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : 360,
                        coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : 0,
                        distanceModel: void 0 !== e.distanceModel ? e.distanceModel : 'inverse',
                        maxDistance: void 0 !== e.maxDistance ? e.maxDistance : 1e4,
                        panningModel: void 0 !== e.panningModel ? e.panningModel : 'HRTF',
                        refDistance: void 0 !== e.refDistance ? e.refDistance : 1,
                        rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : 1
                    }, this._onstereo = e.onstereo
                        ? [{
                                fn: e.onstereo
                            }]
                        : [], this._onpos = e.onpos
                        ? [{
                                fn: e.onpos
                            }]
                        : [], this._onorientation = e.onorientation
                        ? [{
                                fn: e.onorientation
                            }]
                        : [], t.call(this, e)
                }), Howl.prototype.stereo = function (t, n) {
                    const r = this
                    if (!r._webAudio) return r
                    if (r._state !== 'loaded') { return r._queue.push({
                        event: 'stereo',
                        action() {
                            r.stereo(t, n)
                        }
                    }), r
                    }
                    const i = void 0 === Howler.ctx.createStereoPanner ? 'spatial' : 'stereo'
                    if (void 0 === n) {
                        if (typeof t != 'number') return r._stereo
                        r._stereo = t, r._pos = [t, 0, 0]
                    }
                    for (let o = r._getSoundIds(n), a = 0; a < o.length; a++) {
                        const s = r._soundById(o[a])
                        if (s) {
                            if (typeof t != 'number') return s._stereo
                            s._stereo = t, s._pos = [t, 0, 0], s._node && (s._pannerAttr.panningModel = 'equalpower', s._panner && s._panner.pan || e(s, i), i === 'spatial' ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(t, 0, 0) : s._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)), r._emit('stereo', s._id)
                        }
                    }
                    return r
                }, Howl.prototype.pos = function (t, n, r, i) {
                    const o = this
                    if (!o._webAudio) return o
                    if (o._state !== 'loaded') { return o._queue.push({
                        event: 'pos',
                        action() {
                            o.pos(t, n, r, i)
                        }
                    }), o
                    }
                    if (n = typeof n != 'number' ? 0 : n, r = typeof r != 'number' ? -0.5 : r, void 0 === i) {
                        if (typeof t != 'number') return o._pos
                        o._pos = [t, n, r]
                    }
                    for (let a = o._getSoundIds(i), s = 0; s < a.length; s++) {
                        const u = o._soundById(a[s])
                        if (u) {
                            if (typeof t != 'number') return u._pos
                            u._pos = [t, n, r], u._node && (u._panner && !u._panner.pan || e(u, 'spatial'), void 0 !== u._panner.positionX ? (u._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), u._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), u._panner.positionZ.setValueAtTime(r, Howler.ctx.currentTime)) : u._panner.setPosition(t, n, r)), o._emit('pos', u._id)
                        }
                    }
                    return o
                }, Howl.prototype.orientation = function (t, n, r, i) {
                    const o = this
                    if (!o._webAudio) return o
                    if (o._state !== 'loaded') { return o._queue.push({
                        event: 'orientation',
                        action() {
                            o.orientation(t, n, r, i)
                        }
                    }), o
                    }
                    if (n = typeof n != 'number' ? o._orientation[1] : n, r = typeof r != 'number' ? o._orientation[2] : r, void 0 === i) {
                        if (typeof t != 'number') return o._orientation
                        o._orientation = [t, n, r]
                    }
                    for (let a = o._getSoundIds(i), s = 0; s < a.length; s++) {
                        const u = o._soundById(a[s])
                        if (u) {
                            if (typeof t != 'number') return u._orientation
                            u._orientation = [t, n, r], u._node && (u._panner || (u._pos || (u._pos = o._pos || [0, 0, -0.5]), e(u, 'spatial')), void 0 !== u._panner.orientationX ? (u._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime), u._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), u._panner.orientationZ.setValueAtTime(r, Howler.ctx.currentTime)) : u._panner.setOrientation(t, n, r)), o._emit('orientation', u._id)
                        }
                    }
                    return o
                }, Howl.prototype.pannerAttr = function () {
                    let t; let n; let r; const i = this
                    let o = arguments
                    if (!i._webAudio) return i
                    if (o.length === 0) return i._pannerAttr
                    if (o.length === 1) {
                        if (typeof o[0] != 'object') return (r = i._soundById(Number.parseInt(o[0], 10))) ? r._pannerAttr : i._pannerAttr
                        t = o[0], void 0 === n && (t.pannerAttr || (t.pannerAttr = {
                            coneInnerAngle: t.coneInnerAngle,
                            coneOuterAngle: t.coneOuterAngle,
                            coneOuterGain: t.coneOuterGain,
                            distanceModel: t.distanceModel,
                            maxDistance: t.maxDistance,
                            refDistance: t.refDistance,
                            rolloffFactor: t.rolloffFactor,
                            panningModel: t.panningModel
                        }), i._pannerAttr = {
                            coneInnerAngle: void 0 !== t.pannerAttr.coneInnerAngle ? t.pannerAttr.coneInnerAngle : i._coneInnerAngle,
                            coneOuterAngle: void 0 !== t.pannerAttr.coneOuterAngle ? t.pannerAttr.coneOuterAngle : i._coneOuterAngle,
                            coneOuterGain: void 0 !== t.pannerAttr.coneOuterGain ? t.pannerAttr.coneOuterGain : i._coneOuterGain,
                            distanceModel: void 0 !== t.pannerAttr.distanceModel ? t.pannerAttr.distanceModel : i._distanceModel,
                            maxDistance: void 0 !== t.pannerAttr.maxDistance ? t.pannerAttr.maxDistance : i._maxDistance,
                            refDistance: void 0 !== t.pannerAttr.refDistance ? t.pannerAttr.refDistance : i._refDistance,
                            rolloffFactor: void 0 !== t.pannerAttr.rolloffFactor ? t.pannerAttr.rolloffFactor : i._rolloffFactor,
                            panningModel: void 0 !== t.pannerAttr.panningModel ? t.pannerAttr.panningModel : i._panningModel
                        })
                    } else { o.length === 2 && (t = o[0], n = Number.parseInt(o[1], 10))
                    }
                    for (let a = i._getSoundIds(n), s = 0; s < a.length; s++) {
                        if (r = i._soundById(a[s])) {
                            let u = r._pannerAttr
                            u = {
                                coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : u.coneInnerAngle,
                                coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : u.coneOuterAngle,
                                coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : u.coneOuterGain,
                                distanceModel: void 0 !== t.distanceModel ? t.distanceModel : u.distanceModel,
                                maxDistance: void 0 !== t.maxDistance ? t.maxDistance : u.maxDistance,
                                refDistance: void 0 !== t.refDistance ? t.refDistance : u.refDistance,
                                rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : u.rolloffFactor,
                                panningModel: void 0 !== t.panningModel ? t.panningModel : u.panningModel
                            }
                            let c = r._panner
                            c ? (c.coneInnerAngle = u.coneInnerAngle, c.coneOuterAngle = u.coneOuterAngle, c.coneOuterGain = u.coneOuterGain, c.distanceModel = u.distanceModel, c.maxDistance = u.maxDistance, c.refDistance = u.refDistance, c.rolloffFactor = u.rolloffFactor, c.panningModel = u.panningModel) : (r._pos || (r._pos = i._pos || [0, 0, -0.5]), e(r, 'spatial'))
                        }
                    }
                    return i
                }, Sound.prototype.init = (function (t) {
                    return function () {
                        const e = this._parent
                        this._orientation = e._orientation, this._stereo = e._stereo, this._pos = e._pos, this._pannerAttr = e._pannerAttr, t.call(this), this._stereo ? e.stereo(this._stereo) : this._pos && e.pos(this._pos[0], this._pos[1], this._pos[2], this._id)
                    }
                }(Sound.prototype.init)), Sound.prototype.reset = (function (t) {
                    return function () {
                        const e = this._parent
                        return this._orientation = e._orientation, this._stereo = e._stereo, this._pos = e._pos, this._pannerAttr = e._pannerAttr, this._stereo ? e.stereo(this._stereo) : this._pos ? e.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, e._refreshBuffer(this)), t.call(this)
                    }
                }(Sound.prototype.reset))
                var e = function (t, e) {
                    (e = e || 'spatial') === 'spatial' ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, void 0 !== t._panner.positionX ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), void 0 !== t._panner.orientationX ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0)
                }
            }())
        }).call(this, n('./node_modules/webpack/buildin/global.js'))
    },
    './node_modules/node-libs-browser/node_modules/timers-browserify/main.js': function (t, e, n) {
        (function (t) {
            const r = void 0 !== t && t || typeof self != 'undefined' && self || window
            const i = Function.prototype.apply

            function o(t, e) {
                this._id = t, this._clearFn = e
            }
            e.setTimeout = function () {
                return new o(i.call(setTimeout, r, arguments), clearTimeout)
            }, e.setInterval = function () {
                return new o(i.call(setInterval, r, arguments), clearInterval)
            }, e.clearTimeout = e.clearInterval = function (t) {
                t && t.close()
            }, o.prototype.unref = o.prototype.ref = function () {}, o.prototype.close = function () {
                this._clearFn.call(r, this._id)
            }, e.enroll = function (t, e) {
                clearTimeout(t._idleTimeoutId), t._idleTimeout = e
            }, e.unenroll = function (t) {
                clearTimeout(t._idleTimeoutId), t._idleTimeout = -1
            }, e._unrefActive = e.active = function (t) {
                clearTimeout(t._idleTimeoutId)
                const e = t._idleTimeout
                e >= 0 && (t._idleTimeoutId = setTimeout(() => {
                    t._onTimeout && t._onTimeout()
                }, e))
            }, n('./node_modules/setimmediate/setImmediate.js'), e.setImmediate = typeof self != 'undefined' && self.setImmediate || void 0 !== t && t.setImmediate || this && this.setImmediate, e.clearImmediate = typeof self != 'undefined' && self.clearImmediate || void 0 !== t && t.clearImmediate || this && this.clearImmediate
        }).call(this, n('./node_modules/webpack/buildin/global.js'))
    },
    './node_modules/object-assign/index.js': function (t, e, n) {
        'use strict'
        /*
            object-assign
            (c) Sindre Sorhus
            @license MIT
            */
        const r = Object.getOwnPropertySymbols
        const i = Object.prototype.hasOwnProperty
        const o = Object.prototype.propertyIsEnumerable

        function a(t) {
            if (t == null) throw new TypeError('Object.assign cannot be called with null or undefined')
            return new Object(t)
        }
        t.exports = (function () {
            try {
                if (!Object.assign) return !1
                const t = new String('abc')
                if (t[5] = 'de', Object.getOwnPropertyNames(t)[0] === '5') return !1
                for (var e = {}, n = 0; n < 10; n++) e[`_${String.fromCharCode(n)}`] = n
                if (Object.getOwnPropertyNames(e).map((t) => {
                    return e[t]
                }).join('') !== '0123456789') { return !1
                }
                const r = {}
                return 'abcdefghijklmnopqrst'.split('').forEach((t) => {
                    r[t] = t
                }), Object.keys(Object.assign({}, r)).join('') === 'abcdefghijklmnopqrst'
            } catch (t) {
                return !1
            }
        }())
            ? Object.assign
            : function (t, e) {
                for (var n, s, u = a(t), c = 1; c < arguments.length; c++) {
                    for (const l in n = new Object(arguments[c])) i.call(n, l) && (u[l] = n[l])
                    if (r) {
                        s = r(n)
                        for (let h = 0; h < s.length; h++) o.call(n, s[h]) && (u[s[h]] = n[s[h]])
                    }
                }
                return u
            }
    },
    './node_modules/pixi-heaven/lib/pixi-heaven.es.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return dt
        })
        const r = n('./node_modules/@pixi/spritesheet/dist/esm/spritesheet.js')
        const i = n('./node_modules/@pixi/math/dist/esm/math.js')
        const o = n('./node_modules/@pixi/core/dist/esm/core.js')
        const a = (n('./node_modules/@pixi/ticker/dist/esm/ticker.js'), n('./node_modules/@pixi/utils/dist/esm/utils.js'))
        const s = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const u = n('./node_modules/@pixi/mesh/dist/esm/mesh.js')
        const c = n('./node_modules/@pixi/display/dist/esm/display.js')
        const l = n('./node_modules/@pixi/sprite/dist/esm/sprite.js')
        const h = n('./node_modules/@pixi/text-bitmap/dist/esm/text-bitmap.js')
        n('./node_modules/@pixi/graphics/dist/esm/graphics.js')
        /*!
             * pixi-heaven - v0.3.1
             * Compiled Tue, 27 Jul 2021 11:04:46 UTC
             *
             * pixi-heaven is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             *
             * Copyright 2019-2020, Ivan Popelyshev, All Rights Reserved
             */
        class f {
            constructor(t, e, n) {
                this.vertices = t, this.uvs = e, this.indices = n
            }
        }
        class d {
            __init() {
                this.programCache = {}
            }

            __init2() {
                this.defaultGroupCache = {}
            }

            constructor(t, e, n) {
                if (this.vertexSrc = t, this.fragTemplate = e, this.loops = n, d.prototype.__init.call(this), d.prototype.__init2.call(this), !e.includes('%count%')) throw new Error('Fragment template must contain "%count%".')
                for (let t = 0; t < n.length; t++) {
                    if (!e.includes(n[t].loopLabel)) throw new Error(`Fragment template must contain "${n[t].loopLabel}".`)
                }
            }

            generateShader(t) {
                if (!this.programCache[t]) {
                    const e = new Int32Array(t)
                    const {
                        loops: n
                    } = this
                    for (let n = 0; n < t; n++) e[n] = n
                    this.defaultGroupCache[t] = new o.ib({
                        uSamplers: e
                    }, !0)
                    let r = this.fragTemplate
                    for (let e = 0; e < n.length; e++) r = r.replace(/%count%/gi, `${t}`), r = r.replace(new RegExp(n[e].loopLabel, 'gi'), this.generateSampleSrc(t, n[e]))
                    this.programCache[t] = new o.L(this.vertexSrc, r)
                }
                const e = {
                    tint: new Float32Array([1, 1, 1, 1]),
                    translationMatrix: new i.d(),
                    default: this.defaultGroupCache[t]
                }
                return new o.W(this.programCache[t], e)
            }

            generateSampleSrc(t, e) {
                let n = ''
                n += '\n', n += '\n'
                for (let r = 0; r < t; r++) r > 0 && (n += '\nelse '), r < t - 1 && (n += `if(${e.inTex} < ${r}.5)`), n += '\n{', n += `\n\t${e.outColor} = texture2D(uSamplers[${r}], ${e.inCoord});`, n += '\n}'
                return n += '\n', n += '\n', n
            }
        }
        const p = o.db.WHITE.baseTexture
        const m = new Float32Array([0, 0, 0, 0])
        class y extends o.C {
            constructor(t = !1) {
                super(), this._buffer = new o.p(null, t, !1), this._indexBuffer = new o.p(null, t, !0), this.addAttribute('aVertexPosition', this._buffer, 2, !1, s.r.FLOAT).addAttribute('aTextureCoord', this._buffer, 2, !1, s.r.FLOAT).addAttribute('aLight', this._buffer, 4, !0, s.r.UNSIGNED_BYTE).addAttribute('aDark', this._buffer, 4, !0, s.r.UNSIGNED_BYTE).addAttribute('aTextureId', this._buffer, 1, !0, s.r.FLOAT).addAttribute('aMaskCoord', this._buffer, 2, !1, s.r.FLOAT).addAttribute('aMaskClamp', this._buffer, 4, !1, s.r.FLOAT).addIndex(this._indexBuffer)
            }
        }
        const v = [null, null]
        class _ {
            static __initStatic() {
                this.MAX_TEXTURES = 8
            }

            static create(t) {
                const {
                    vertex: e,
                    fragment: n,
                    vertexSize: r,
                    geometryClass: i
                } = Object.assign({
                    vertex: 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aLight, aDark;\nattribute float aTextureId;\nattribute vec2 aMaskCoord;\nattribute vec4 aMaskClamp;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vLight, vDark;\nvarying float vTextureId;\nvarying vec2 vMaskCoord;\nvarying vec4 vMaskClamp;\n\nvoid main(void){\ngl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\nvTextureCoord = aTextureCoord;\nvTextureId = aTextureId;\nvLight = aLight * tint;\nvDark = vec4(aDark.rgb * tint.rgb, aDark.a);\nvMaskCoord = aMaskCoord;\nvMaskClamp = aMaskClamp;\n}\n',
                    fragment: '\nvarying vec2 vTextureCoord;\nvarying vec2 vMaskCoord;\nvarying vec4 vMaskClamp;\nvarying vec4 vLight, vDark;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void) {\nvec4 texColor, maskColor, fragColor;\n\nfloat maskBits = floor((vTextureId + 0.5) / 64.0);\nfloat textureId = floor(0.5 + vTextureId - maskBits * 64.0);\nfloat maskId = floor((maskBits + 0.5) / 16.0);\nmaskBits = maskBits - maskId * 16.0;\n\nfloat clipEnable = step(0.5, maskBits);\n\nfloat clip = step(3.5,\n    step(vMaskClamp.x, vMaskCoord.x) +\n    step(vMaskClamp.y, vMaskCoord.y) +\n    step(vMaskCoord.x, vMaskClamp.z) +\n    step(vMaskCoord.y, vMaskClamp.w));\n%loopTex%\n%loopMask%\nfragColor.a = texColor.a * vLight.a;\nfragColor.rgb = ((texColor.a - 1.0) * vDark.a + 1.0 - texColor.rgb) * vDark.rgb + texColor.rgb * vLight.rgb;\ngl_FragColor = fragColor * maskColor.r * (clipEnable * clip + 1.0 - clipEnable);\n}',
                    geometryClass: y,
                    vertexSize: 13
                }, t)
                return class extends o.a {
                    constructor(t) {
                        super(t), this.shaderGenerator = new d(e, n, [{
                            loopLabel: '%loopTex%',
                            inCoord: 'vTextureCoord',
                            outColor: 'texColor',
                            inTex: 'textureId'
                        }, {
                            loopLabel: '%loopMask%',
                            inCoord: 'vMaskCoord',
                            outColor: 'maskColor',
                            inTex: 'maskId'
                        }]), this.geometryClass = i, this.vertexSize = r
                    }

                    contextChange() {
                        const t = this
                        const e = 2 * t.renderer.plugins.batch.MAX_TEXTURES
                        t.MAX_TEXTURES = Math.max(2, Math.min(_.MAX_TEXTURES, e)), this._shader = t.shaderGenerator.generateShader(this.MAX_TEXTURES)
                        for (let e = 0; e < t._packedGeometryPoolSize; e++) t._packedGeometries[e] = new this.geometryClass()
                        this.initFlushBuffers()
                    }

                    buildTexturesAndDrawCalls() {
                        const t = this._bufferedTextures
                        const e = this._bufferedElements
                        const n = this._bufferSize
                        const {
                            MAX_TEXTURES: r
                        } = this
                        const i = o.a._textureArrayPool
                        const a = this.renderer.batch
                        const s = this._tempBoundTextures
                        const u = this.renderer.textureGC.count
                        let c = ++o.h._globalBatch
                        let l = 0
                        let h = i[0]
                        let f = 0
                        a.copyBoundTextures(s, r)
                        for (let o = 0; o < n; ++o) {
                            const n = e[o].maskSprite ? e[o].maskSprite.texture.baseTexture : null
                            v[0] = n && n.valid ? n : p, v[1] = t[o], t[o] = null
                            const d = (v[0]._batchEnabled !== c ? 1 : 0) + (v[1]._batchEnabled !== c ? 1 : 0)
                            h.count + d > r && (a.boundArray(h, s, c, r), this.buildDrawCalls(h, f, o), f = o, h = i[++l], ++c)
                            for (let t = 0; t < 2; t++) {
                                const e = v[t]
                                e._batchEnabled !== c && (e._batchEnabled = c, e.touched = u, h.elements[h.count++] = e)
                            }
                        }
                        h.count > 0 && (a.boundArray(h, s, c, r), this.buildDrawCalls(h, f, n), ++l, ++c)
                        for (let t = 0; t < s.length; t++) s[t] = null
                        o.h._globalBatch = c
                    }

                    packInterleavedGeometry(t, e, n, r, i) {
                        const {
                            uint32View: o,
                            float32View: s
                        } = e
                        let u = -1
                        let c = 0
                        if (t.color) { u = t.color.lightRgba, c = t.color.darkRgba
                        }
                        else {
                            const e = Math.min(t.worldAlpha, 1)
                            u = e < 1 && t._texture.baseTexture.premultiplyAlpha ? new Object(a.premultiplyTint)(t._tintRGB, e) : t._tintRGB + (255 * e << 24)
                        }
                        const l = r / this.vertexSize
                        const h = t.uvs
                        const f = t.indices
                        const d = t.vertexData
                        const y = t._texture.baseTexture._batchLocation
                        let v = p
                        const _ = t.maskSprite
                        let g = m
                        let b = m
                        let E = 0
                        _ && (t.calculateMaskVertices(), g = _._texture.uvMatrix.uClampFrame, b = t.maskVertexData, _.texture.valid && (v = _.texture.baseTexture, E = 1))
                        for (let t = 0; t < d.length; t += 2) s[r++] = d[t], s[r++] = d[t + 1], s[r++] = h[t], s[r++] = h[t + 1], o[r++] = u, o[r++] = c, s[r++] = 64 * (16 * v._batchLocation + E) + y, s[r++] = b[t], s[r++] = b[t + 1], s[r++] = g[0], s[r++] = g[1], s[r++] = g[2], s[r++] = g[3]
                        for (let t = 0; t < f.length; t++) n[i++] = l + f[t]
                    }
                }
            }
        }
        _.__initStatic()
        const g = [1, 1, 1, 1]
        const b = [0, 0, 0, 1]
        class E {
            constructor() {
                E.prototype.__init.call(this), E.prototype.__init2.call(this), E.prototype.__init3.call(this), E.prototype.__init4.call(this), E.prototype.__init5.call(this), E.prototype.__init6.call(this), E.prototype.__init7.call(this)
            }

            __init() {
                this.dark = new Float32Array(b)
            }

            __init2() {
                this.light = new Float32Array(g)
            }

            __init3() {
                this._updateID = 0
            }

            __init4() {
                this._currentUpdateID = -1
            }

            __init5() {
                this.darkRgba = 0
            }

            __init6() {
                this.lightRgba = -1
            }

            __init7() {
                this.hasNoTint = !0
            }

            get darkR() {
                return this.dark[0]
            }

            set darkR(t) {
                this.dark[0] !== t && (this.dark[0] = t, this._updateID++)
            }

            get darkG() {
                return this.dark[1]
            }

            set darkG(t) {
                this.dark[1] !== t && (this.dark[1] = t, this._updateID++)
            }

            get darkB() {
                return this.dark[2]
            }

            set darkB(t) {
                this.dark[2] !== t && (this.dark[2] = t, this._updateID++)
            }

            get lightR() {
                return this.light[0]
            }

            set lightR(t) {
                this.light[0] !== t && (this.light[0] = t, this._updateID++)
            }

            get lightG() {
                return this.light[1]
            }

            set lightG(t) {
                this.light[1] !== t && (this.light[1] = t, this._updateID++)
            }

            get lightB() {
                return this.light[2]
            }

            set lightB(t) {
                this.light[2] !== t && (this.light[2] = t, this._updateID++)
            }

            get alpha() {
                return this.light[3]
            }

            set alpha(t) {
                this.light[3] !== t && (this.light[3] = t, this._updateID++)
            }

            get pma() {
                return this.dark[3] !== 0
            }

            set pma(t) {
                this.dark[3] !== 0 === t && (this.dark[3] = t ? 1 : 0, this._updateID++)
            }

            get tintBGR() {
                const t = this.light
                return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0)
            }

            set tintBGR(t) {
                this.setLight((t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255)
            }

            setLight(t, e, n) {
                const r = this.light
                r[0] === t && r[1] === e && r[2] === n || (r[0] = t, r[1] = e, r[2] = n, this._updateID++)
            }

            setDark(t, e, n) {
                const r = this.dark
                r[0] === t && r[1] === e && r[2] === n || (r[0] = t, r[1] = e, r[2] = n, this._updateID++)
            }

            clear() {
                this.dark[0] = 0, this.dark[1] = 0, this.dark[2] = 0, this.light[0] = 1, this.light[1] = 1, this.light[2] = 1
            }

            invalidate() {
                this._updateID++
            }

            updateTransformLocal() {
                const t = this.dark
                const e = this.light
                const n = 255 * (1 + (e[3] - 1) * t[3])
                this.hasNoTint = t[0] === 0 && t[1] === 0 && t[2] === 0 && e[0] === 1 && e[1] === 1 && e[2] === 1, this.darkRgba = (t[0] * n | 0) + (t[1] * n << 8) + (t[2] * n << 16) + (255 * t[3] << 24), this.lightRgba = (e[0] * n | 0) + (e[1] * n << 8) + (e[2] * n << 16) + (255 * e[3] << 24), this._currentUpdateID = this._updateID
            }

            updateTransform() {
                this._currentUpdateID !== this._updateID && this.updateTransformLocal()
            }
        }
        let x
        !(function (t) {
            t[t.NEVER = 0] = 'NEVER'
            t[t.AUTO = 1] = 'AUTO'
            t[t.ALWAYS = 2] = 'ALWAYS'
        }(x || (x = {})))
        x.AUTO
        const T = !1
        o.W
        u.a
        const S = /iPhone/i
        const w = /iPod/i
        const O = /iPad/i
        const P = /\biOS-universal.+Mac\b/i
        const R = /\bAndroid.+Mobile\b/i
        const A = /Android/i
        const I = /(?:SD4930UR|\bSilk.+Mobile\b)/i
        const C = /Silk/i
        const k = /Windows Phone/i
        const N = /\bWindows.+ARM\b/i
        const M = /BlackBerry/i
        const j = /BB10/i
        const D = /Opera Mini/i
        const L = /\b(CriOS|Chrome).+Mobile/i
        const F = /Mobile.+Firefox\b/i
        const B = function (t) {
            return void 0 !== t && t.platform === 'MacIntel' && typeof t.maxTouchPoints == 'number' && t.maxTouchPoints > 1 && typeof MSStream == 'undefined'
        }
        /*!
             * @pixi/settings - v6.0.4
             * Compiled Tue, 11 May 2021 18:00:23 UTC
             *
             * @pixi/settings is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        let U; let G; let X; let H; let V; let W; let Y; let z; let q; let K; let Z; let $; let J; let Q; let tt; let et; let nt; let rt; const it = (function (t) {
            let e = {
                userAgent: '',
                platform: '',
                maxTouchPoints: 0
            }
            t || typeof navigator == 'undefined'
                ? typeof t == 'string'
                    ? e.userAgent = t
                    : t && t.userAgent && (e = {
                        userAgent: t.userAgent,
                        platform: t.platform,
                        maxTouchPoints: t.maxTouchPoints || 0
                    })
                : e = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    maxTouchPoints: navigator.maxTouchPoints || 0
                }
            let n = e.userAgent
            var r = n.split('[FBAN')
            void 0 !== r[1] && (n = r[0]), void 0 !== (r = n.split('Twitter'))[1] && (n = r[0])
            let i = (function (t) {
                return function (e) {
                    return e.test(t)
                }
            }(n))
                var o = {
                apple: {
                    phone: i(S) && !i(k),
                    ipod: i(w),
                    tablet: !i(S) && (i(O) || B(e)) && !i(k),
                    universal: i(P),
                    device: (i(S) || i(w) || i(O) || i(P) || B(e)) && !i(k)
                },
                amazon: {
                    phone: i(I),
                    tablet: !i(I) && i(C),
                    device: i(I) || i(C)
                },
                android: {
                    phone: !i(k) && i(I) || !i(k) && i(R),
                    tablet: !i(k) && !i(I) && !i(R) && (i(C) || i(A)),
                    device: !i(k) && (i(I) || i(C) || i(R) || i(A)) || i(/\bokhttp\b/i)
                },
                windows: {
                    phone: i(k),
                    tablet: i(N),
                    device: i(k) || i(N)
                },
                other: {
                    blackberry: i(M),
                    blackberry10: i(j),
                    opera: i(D),
                    firefox: i(F),
                    chrome: i(L),
                    device: i(M) || i(j) || i(D) || i(F) || i(L)
                },
                any: !1,
                phone: !1,
                tablet: !1
            }
            return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o
        }(self.navigator))
        !(function (t) {
            t[t.WEBGL_LEGACY = 0] = 'WEBGL_LEGACY', t[t.WEBGL = 1] = 'WEBGL', t[t.WEBGL2 = 2] = 'WEBGL2'
        }(U || (U = {}))),
        (function (t) {
            t[t.UNKNOWN = 0] = 'UNKNOWN', t[t.WEBGL = 1] = 'WEBGL', t[t.CANVAS = 2] = 'CANVAS'
        }(G || (G = {}))),
        (function (t) {
            t[t.COLOR = 16384] = 'COLOR', t[t.DEPTH = 256] = 'DEPTH', t[t.STENCIL = 1024] = 'STENCIL'
        }(X || (X = {}))),
        (function (t) {
            t[t.NORMAL = 0] = 'NORMAL', t[t.ADD = 1] = 'ADD', t[t.MULTIPLY = 2] = 'MULTIPLY', t[t.SCREEN = 3] = 'SCREEN', t[t.OVERLAY = 4] = 'OVERLAY', t[t.DARKEN = 5] = 'DARKEN', t[t.LIGHTEN = 6] = 'LIGHTEN', t[t.COLOR_DODGE = 7] = 'COLOR_DODGE', t[t.COLOR_BURN = 8] = 'COLOR_BURN', t[t.HARD_LIGHT = 9] = 'HARD_LIGHT', t[t.SOFT_LIGHT = 10] = 'SOFT_LIGHT', t[t.DIFFERENCE = 11] = 'DIFFERENCE', t[t.EXCLUSION = 12] = 'EXCLUSION', t[t.HUE = 13] = 'HUE', t[t.SATURATION = 14] = 'SATURATION', t[t.COLOR = 15] = 'COLOR', t[t.LUMINOSITY = 16] = 'LUMINOSITY', t[t.NORMAL_NPM = 17] = 'NORMAL_NPM', t[t.ADD_NPM = 18] = 'ADD_NPM', t[t.SCREEN_NPM = 19] = 'SCREEN_NPM', t[t.NONE = 20] = 'NONE', t[t.SRC_OVER = 0] = 'SRC_OVER', t[t.SRC_IN = 21] = 'SRC_IN', t[t.SRC_OUT = 22] = 'SRC_OUT', t[t.SRC_ATOP = 23] = 'SRC_ATOP', t[t.DST_OVER = 24] = 'DST_OVER', t[t.DST_IN = 25] = 'DST_IN', t[t.DST_OUT = 26] = 'DST_OUT', t[t.DST_ATOP = 27] = 'DST_ATOP', t[t.ERASE = 26] = 'ERASE', t[t.SUBTRACT = 28] = 'SUBTRACT', t[t.XOR = 29] = 'XOR'
        }(H || (H = {}))),
        (function (t) {
            t[t.POINTS = 0] = 'POINTS', t[t.LINES = 1] = 'LINES', t[t.LINE_LOOP = 2] = 'LINE_LOOP', t[t.LINE_STRIP = 3] = 'LINE_STRIP', t[t.TRIANGLES = 4] = 'TRIANGLES', t[t.TRIANGLE_STRIP = 5] = 'TRIANGLE_STRIP', t[t.TRIANGLE_FAN = 6] = 'TRIANGLE_FAN'
        }(V || (V = {}))),
        (function (t) {
            t[t.RGBA = 6408] = 'RGBA', t[t.RGB = 6407] = 'RGB', t[t.ALPHA = 6406] = 'ALPHA', t[t.LUMINANCE = 6409] = 'LUMINANCE', t[t.LUMINANCE_ALPHA = 6410] = 'LUMINANCE_ALPHA', t[t.DEPTH_COMPONENT = 6402] = 'DEPTH_COMPONENT', t[t.DEPTH_STENCIL = 34041] = 'DEPTH_STENCIL'
        }(W || (W = {}))),
        (function (t) {
            t[t.TEXTURE_2D = 3553] = 'TEXTURE_2D', t[t.TEXTURE_CUBE_MAP = 34067] = 'TEXTURE_CUBE_MAP', t[t.TEXTURE_2D_ARRAY = 35866] = 'TEXTURE_2D_ARRAY', t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = 'TEXTURE_CUBE_MAP_POSITIVE_X', t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = 'TEXTURE_CUBE_MAP_NEGATIVE_X', t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = 'TEXTURE_CUBE_MAP_POSITIVE_Y', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = 'TEXTURE_CUBE_MAP_NEGATIVE_Y', t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = 'TEXTURE_CUBE_MAP_POSITIVE_Z', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = 'TEXTURE_CUBE_MAP_NEGATIVE_Z'
        }(Y || (Y = {}))),
        (function (t) {
            t[t.UNSIGNED_BYTE = 5121] = 'UNSIGNED_BYTE', t[t.UNSIGNED_SHORT = 5123] = 'UNSIGNED_SHORT', t[t.UNSIGNED_SHORT_5_6_5 = 33635] = 'UNSIGNED_SHORT_5_6_5', t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = 'UNSIGNED_SHORT_4_4_4_4', t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = 'UNSIGNED_SHORT_5_5_5_1', t[t.FLOAT = 5126] = 'FLOAT', t[t.HALF_FLOAT = 36193] = 'HALF_FLOAT'
        }(z || (z = {}))),
        (function (t) {
            t[t.FLOAT = 0] = 'FLOAT', t[t.INT = 1] = 'INT', t[t.UINT = 2] = 'UINT'
        }(q || (q = {}))),
        (function (t) {
            t[t.NEAREST = 0] = 'NEAREST', t[t.LINEAR = 1] = 'LINEAR'
        }(K || (K = {}))),
        (function (t) {
            t[t.CLAMP = 33071] = 'CLAMP', t[t.REPEAT = 10497] = 'REPEAT', t[t.MIRRORED_REPEAT = 33648] = 'MIRRORED_REPEAT'
        }(Z || (Z = {}))),
        (function (t) {
            t[t.OFF = 0] = 'OFF', t[t.POW2 = 1] = 'POW2', t[t.ON = 2] = 'ON', t[t.ON_MANUAL = 3] = 'ON_MANUAL'
        }($ || ($ = {}))),
        (function (t) {
            t[t.NPM = 0] = 'NPM', t[t.UNPACK = 1] = 'UNPACK', t[t.PMA = 2] = 'PMA', t[t.NO_PREMULTIPLIED_ALPHA = 0] = 'NO_PREMULTIPLIED_ALPHA', t[t.PREMULTIPLY_ON_UPLOAD = 1] = 'PREMULTIPLY_ON_UPLOAD', t[t.PREMULTIPLY_ALPHA = 2] = 'PREMULTIPLY_ALPHA'
        }(J || (J = {}))),
        (function (t) {
            t[t.NO = 0] = 'NO', t[t.YES = 1] = 'YES', t[t.AUTO = 2] = 'AUTO', t[t.BLEND = 0] = 'BLEND', t[t.CLEAR = 1] = 'CLEAR', t[t.BLIT = 2] = 'BLIT'
        }(Q || (Q = {}))),
        (function (t) {
            t[t.AUTO = 0] = 'AUTO', t[t.MANUAL = 1] = 'MANUAL'
        }(tt || (tt = {}))),
        (function (t) {
            t.LOW = 'lowp', t.MEDIUM = 'mediump', t.HIGH = 'highp'
        }(et || (et = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.SCISSOR = 1] = 'SCISSOR', t[t.STENCIL = 2] = 'STENCIL', t[t.SPRITE = 3] = 'SPRITE'
        }(nt || (nt = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.LOW = 2] = 'LOW', t[t.MEDIUM = 4] = 'MEDIUM', t[t.HIGH = 8] = 'HIGH'
        }(rt || (rt = {})))
        $.POW2
        /*!
             * @pixi/sprite - v6.0.4
             * Compiled Tue, 11 May 2021 18:00:23 UTC
             *
             * @pixi/sprite is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0

            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.

            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
            ***************************************************************************** */
        const ot = 1
        const at = ((function (t) {
            let e = !0
            if (it.tablet || it.phone) {
                let n
                if (it.apple.device) {
                    if (n = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) Number.parseInt(n[1], 10) < 11 && (e = !1)
}
                if (it.android.device) {
                    if (n = navigator.userAgent.match(/Android\s([0-9.]*)/)) Number.parseInt(n[1], 10) < 7 && (e = !1)
                }
            }
        }(32)), tt.AUTO, Z.CLAMP, K.LINEAR, et.HIGH, it.apple.device ? et.HIGH : et.MEDIUM, it.apple.device, !1)
        let st = function (t, e) {
            return (st = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        const ut = new i.g()
        let ct = new Uint16Array([0, 1, 2, 0, 2, 3])
        let lt = (function (t) {
            function e(e) {
                const n = t.call(this) || this
                return n._anchor = new i.e(n._onAnchorUpdate, n, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), n._texture = null, n._width = 0, n._height = 0, n._tint = null, n._tintRGB = null, n.tint = 16777215, n.blendMode = s.b.NORMAL, n._cachedTint = 16777215, n.uvs = null, n.texture = e || o.db.EMPTY, n.vertexData = new Float32Array(8), n.vertexTrimmedData = null, n._transformID = -1, n._textureID = -1, n._transformTrimmedID = -1, n._textureTrimmedID = -1, n.indices = ct, n.pluginName = 'batch', n.isSprite = !0, n._roundPixels = at, n
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                st(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype._onTextureUpdate = function () {
                this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = new Object(a.sign)(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = new Object(a.sign)(this.scale.y) * this._height / this._texture.orig.height)
            }, e.prototype._onAnchorUpdate = function () {
                this._transformID = -1, this._transformTrimmedID = -1
            }, e.prototype.calculateVertices = function () {
                const t = this._texture
                if (this._transformID !== this.transform._worldID || this._textureID !== t._updateID) {
                    this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID
                    const e = this.transform.worldTransform
                    let n = e.a
                    let r = e.b
                    let i = e.c
                    let o = e.d
                    let a = e.tx
                    let s = e.ty
                    let u = this.vertexData
                    let c = t.trim
                    let l = t.orig
                    let h = this._anchor
                    let f = 0
                    let d = 0
                    let p = 0
                    let m = 0
                    if (c ? (f = (d = c.x - h._x * l.width) + c.width, p = (m = c.y - h._y * l.height) + c.height) : (f = (d = -h._x * l.width) + l.width, p = (m = -h._y * l.height) + l.height), u[0] = n * d + i * m + a, u[1] = o * m + r * d + s, u[2] = n * f + i * m + a, u[3] = o * m + r * f + s, u[4] = n * f + i * p + a, u[5] = o * p + r * f + s, u[6] = n * d + i * p + a, u[7] = o * p + r * d + s, this._roundPixels) {
                        for (let y = ot, v = 0; v < u.length; ++v) u[v] = Math.round((u[v] * y | 0) / y)
                    }
                }
            }, e.prototype.calculateTrimmedVertices = function () {
                if (this.vertexTrimmedData) {
                    if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return
                } else { this.vertexTrimmedData = new Float32Array(8)
                }
                this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID
                const t = this._texture
                let e = this.vertexTrimmedData
                let n = t.orig
                let r = this._anchor
                let i = this.transform.worldTransform
                let o = i.a
                let a = i.b
                let s = i.c
                let u = i.d
                let c = i.tx
                let l = i.ty
                let h = -r._x * n.width
                let f = h + n.width
                let d = -r._y * n.height
                let p = d + n.height
                e[0] = o * h + s * d + c, e[1] = u * d + a * h + l, e[2] = o * f + s * d + c, e[3] = u * d + a * f + l, e[4] = o * f + s * p + c, e[5] = u * p + a * f + l, e[6] = o * h + s * p + c, e[7] = u * p + a * h + l
            }, e.prototype._render = function (t) {
                this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
            }, e.prototype._calculateBounds = function () {
                const t = this._texture.trim
                let e = this._texture.orig
                !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
            }, e.prototype.getLocalBounds = function (e) {
                return this.children.length === 0 ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new i.j()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
            }, e.prototype.containsPoint = function (t) {
                this.worldTransform.applyInverse(t, ut)
                const e = this._texture.orig.width
                let n = this._texture.orig.height
                let r = -e * this.anchor.x
                let i = 0
                return ut.x >= r && ut.x < r + e && (i = -n * this.anchor.y, ut.y >= i && ut.y < i + n)
            }, e.prototype.destroy = function (e) {
                if (t.prototype.destroy.call(this, e), this._texture.off('update', this._onTextureUpdate, this), this._anchor = null, typeof e == 'boolean' ? e : e && e.texture) {
                    const n = typeof e == 'boolean' ? e : e && e.baseTexture
                    this._texture.destroy(!!n)
                }
                this._texture = null
            }, e.from = function (t, n) {
                return new e(t instanceof o.db ? t : o.db.from(t, n))
            }, Object.defineProperty(e.prototype, 'roundPixels', {
                get() {
                    return this._roundPixels
                },
                set(t) {
                    this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'width', {
                get() {
                    return Math.abs(this.scale.x) * this._texture.orig.width
                },
                set(t) {
                    let e = new Object(a.sign)(this.scale.x) || 1
                    this.scale.x = e * t / this._texture.orig.width, this._width = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'height', {
                get() {
                    return Math.abs(this.scale.y) * this._texture.orig.height
                },
                set(t) {
                    let e = new Object(a.sign)(this.scale.y) || 1
                    this.scale.y = e * t / this._texture.orig.height, this._height = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'anchor', {
                get() {
                    return this._anchor
                },
                set(t) {
                    this._anchor.copyFrom(t)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'tint', {
                get() {
                    return this._tint
                },
                set(t) {
                    this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'texture', {
                get() {
                    return this._texture
                },
                set(t) {
                    this._texture !== t && (this._texture && this._texture.off('update', this._onTextureUpdate, this), this._texture = t || o.db.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once('update', this._onTextureUpdate, this)))
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(c.b))
        const ht = new i.d()
        const ft = new Uint16Array([0, 1, 2, 0, 2, 3])
        class dt extends lt {
            __init() {
                this.color = new E()
            }

            __init2() {
                this.maskSprite = null
            }

            __init3() {
                this.maskVertexData = null
            }

            __init4() {
                this.uvs = null
            }

            __init5() {
                this.indices = ft
            }

            __init6() {
                this.animState = null
            }

            __init7() {
                this.blendAddUnity = !1
            }

            constructor(t) {
                super(t), dt.prototype.__init.call(this), dt.prototype.__init2.call(this), dt.prototype.__init3.call(this), dt.prototype.__init4.call(this), dt.prototype.__init5.call(this), dt.prototype.__init6.call(this), dt.prototype.__init7.call(this), this.pluginName = 'batchHeaven', this.texture.valid && this._onTextureUpdate()
            }

            get _tintRGB() {
                return this.color.updateTransform(), 16777215 & this.color.lightRgba
            }

            set _tintRGB(t) {}
            get tint() {
                return this.color ? this.color.tintBGR : 16777215
            }

            set tint(t) {
                this.color && (this.color.tintBGR = t)
            }

            _onTextureUpdate() {
                const t = this
                t._textureID = -1, t._textureTrimmedID = -1
                const e = t._texture
                e.polygon ? (this.uvs = e.polygon.uvs, this.indices = e.polygon.indices) : (this.uvs = e._uvs.uvsFloat32, this.indices = ft), this._cachedTint = 16777215, this.color && (this.color.pma = t._texture.baseTexture.premultipliedAlpha), t._width && (this.scale.x = new Object(a.sign)(this.scale.x) * t._width / t._texture.orig.width), t._height && (this.scale.y = new Object(a.sign)(this.scale.y) * t._height / t._texture.orig.height)
            }

            _render(t) {
                this.color.alpha = this.worldAlpha, this.color.updateTransform(), super._render(t)
            }

            _calculateBounds() {
                const t = this
                const e = t.polygon
                const n = t.trim
                const r = t.orig
                e || n && (n.width !== r.width || n.height !== r.height) ? (this.calculateTrimmedVertices(), this._bounds.addQuad(t.vertexTrimmedData)) : (this.calculateVertices(), this._bounds.addQuad(t.vertexData))
            }

            calculateVertices() {
                const t = this
                const e = this.transform
                const n = t._texture
                if (t._transformID === e._worldID && t._textureID === n._updateID) return
                t._transformID = e._worldID, t._textureID = n._updateID
                const r = this.transform.worldTransform
                const i = r.a
                const o = r.b
                const a = r.c
                const s = r.d
                const u = r.tx
                const c = r.ty
                const l = t._anchor
                const h = n.orig
                if (n.polygon) {
                    const e = n.polygon.vertices
                    const r = e.length
                    t.vertexData.length !== r && (t.vertexData = new Float32Array(r))
                    const f = t.vertexData
                    const d = -l._x * h.width
                    const p = -l._y * h.height
                    for (let t = 0; t < r; t += 2) {
                        const n = e[t] + d
                        const r = e[t + 1] + p
                        f[t] = n * i + r * a + u, f[t + 1] = n * o + r * s + c
                    }
                } else {
                    const e = t.vertexData
                    const r = n.trim
                    let f = 0
                    let d = 0
                    let p = 0
                    let m = 0
                    r ? (d = r.x - l._x * h.width, f = d + r.width, m = r.y - l._y * h.height, p = m + r.height) : (d = -l._x * h.width, f = d + h.width, m = -l._y * h.height, p = m + h.height), e[0] = i * d + a * m + u, e[1] = s * m + o * d + c, e[2] = i * f + a * m + u, e[3] = s * m + o * f + c, e[4] = i * f + a * p + u, e[5] = s * p + o * f + c, e[6] = i * d + a * p + u, e[7] = s * p + o * d + c
                }
            }

            calculateMaskVertices() {
                const t = this.maskSprite
                const e = t.texture
                const n = e.orig
                const r = t.anchor
                if (!e.valid) return
                e.uvMatrix || (e.uvMatrix = new o.fb(e, 0)), e.uvMatrix.update(), t.transform.worldTransform.copyTo(ht), ht.invert(), ht.scale(1 / n.width, 1 / n.height), ht.translate(r.x, r.y), ht.prepend(e.uvMatrix.mapCoord)
                const i = this.vertexData
                const a = i.length
                this.maskVertexData && this.maskVertexData.length === a || (this.maskVertexData = new Float32Array(a))
                const s = this.maskVertexData
                for (let t = 0; t < a; t += 2) s[t] = i[t] * ht.a + i[t + 1] * ht.c + ht.tx, s[t + 1] = i[t] * ht.b + i[t + 1] * ht.d + ht.ty
            }

            destroy(t) {
                this.animState && (this.animState.stop(), this.animState = null), super.destroy(t)
            }
        }
        class pt extends o.C {
            constructor(t = !1) {
                super(), this._buffer = new o.p(null, t, !1), this._indexBuffer = new o.p(null, t, !0), this.addAttribute('aVertexPosition', this._buffer, 2, !1, s.r.FLOAT).addAttribute('aTextureCoord', this._buffer, 2, !1, s.r.FLOAT).addAttribute('aLight', this._buffer, 4, !0, s.r.UNSIGNED_BYTE).addAttribute('aDark', this._buffer, 4, !0, s.r.UNSIGNED_BYTE).addAttribute('aTextureId', this._buffer, 1, !0, s.r.FLOAT).addIndex(this._indexBuffer)
            }
        }
        h.d
        o.S.registerPlugin('batchHeaven', class {
            static create(t) {
                const {
                    vertex: e,
                    fragment: n,
                    vertexSize: r,
                    geometryClass: i
                } = Object.assign({
                    vertex: 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aLight, aDark;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vLight, vDark;\nvarying float vTextureId;\n\nvoid main(void){\ngl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\nvTextureCoord = aTextureCoord;\nvTextureId = aTextureId;\nvLight = aLight * tint;\nvDark = vec4(aDark.rgb * tint.rgb, aDark.a);\n}\n',
                    fragment: '\nvarying vec2 vTextureCoord;\nvarying vec4 vLight, vDark;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void) {\nvec4 color;\nfloat textureId = floor(vTextureId+0.5);\n%forloop%\ngl_FragColor.a = color.a * vLight.a;\ngl_FragColor.rgb = ((color.a - 1.0) * vDark.a + 1.0 - color.rgb) * vDark.rgb + color.rgb * vLight.rgb;\n}',
                    geometryClass: pt,
                    vertexSize: 7
                }, t)
                return class extends o.a {
                    constructor(t) {
                        super(t), this.shaderGenerator = new o.m(e, n), this.geometryClass = i, this.vertexSize = r
                    }

                    packInterleavedGeometry(t, e, n, r, i) {
                        const {
                            uint32View: o,
                            float32View: s
                        } = e
                        let u = -1
                        let c = 0
                        if (t.color) { u = t.color.lightRgba, c = t.color.darkRgba
                        }
                        else {
                            const e = Math.min(t.worldAlpha, 1)
                            u = e < 1 && t._texture.baseTexture.premultiplyAlpha ? new Object(a.premultiplyTint)(t._tintRGB, e) : t._tintRGB + (255 * e << 24)
                        }
                        T && t.blendAddUnity && (u &= 16777215)
                        const l = r / this.vertexSize
                        const h = t.uvs
                        const f = t.indices
                        const d = t.vertexData
                        const p = t._texture.baseTexture._batchLocation
                        for (let t = 0; t < d.length; t += 2) s[r++] = d[t], s[r++] = d[t + 1], s[r++] = h[t], s[r++] = h[t + 1], o[r++] = u, o[r++] = c, s[r++] = p
                        for (let t = 0; t < f.length; t++) n[i++] = l + f[t]
                    }

                    buildDrawCalls(t, e, n) {
                        const {
                            _bufferedElements: r,
                            _attributeBuffer: i,
                            _indexBuffer: u,
                            vertexSize: c
                        } = this; const l = o.a._drawCallPool
                        let h = this._dcIndex
                        let f = this._aIndex
                        let d = this._iIndex
                        let p = l[h]
                        p.start = this._iIndex, p.texArray = t
                        for (let o = e; o < n; ++o) {
                            const n = r[o]
                            const m = n._texture.baseTexture
                            let y = a.premultiplyBlendMode[m.alphaMode ? 1 : 0][n.blendMode]
                            T && (n.blendAddUnity = y === s.b.ADD && m.alphaMode, n.blendAddUnity && (y = s.b.NORMAL)), r[o] = null, e < o && p.blend !== y && (p.size = d - p.start, e = o, p = l[++h], p.texArray = t, p.start = d), this.packInterleavedGeometry(n, i, u, f, d), f += n.vertexData.length / 2 * c, d += n.indices.length, p.blend = y
                        }
                        e < n && (p.size = d - p.start, ++h), this._dcIndex = h, this._aIndex = f, this._iIndex = d
                    }
                }
            }
        }.create({})), o.S.registerPlugin('batchMasked', _.create({})),
        (function () {
            function t() {
                return this.color.tintBGR
            }

            function e(t) {
                this.color.tintBGR = t
            }

            function n() {
                return this.color.updateTransform(), 16777215 & this.color.lightRgba
            }
            c.b.prototype.convertToHeaven = function () {}
            const r = dt.prototype
            l.a.prototype.convertToHeaven = function () {
                if (!this.color) { return Object.defineProperty(this, 'tint', {
                    get: t,
                    set: e,
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(this, '_tintRGB', {
                    get: n,
                    enumerable: !0,
                    configurable: !0
                }), this._onTextureUpdate = r._onTextureUpdate, this._render = r._render, this._calculateBounds = r._calculateBounds, this.calculateVertices = r.calculateVertices, this._onTextureUpdate = r._onTextureUpdate, this.calculateMaskVertices = r.calculateMaskVertices, this.destroy = dt.prototype.destroy, this.color = new E(), this.pluginName = 'batchHeaven', this._texture.valid ? this._onTextureUpdate() : (this._texture.off('update', this._onTextureUpdate), this._texture.on('update', this._onTextureUpdate, this)), this
                }
            }, c.b.prototype.convertSubtreeToHeaven = function () {
                this.convertToHeaven && this.convertToHeaven()
                for (let t = 0; t < this.children.length; t++) this.children[t].convertSubtreeToHeaven()
            }
        }())
        r.a.prototype._processFrames = function (t) {
            const e = this.data.meta
            let n = t
            const a = r.a.BATCH_SIZE
            for (; n - t < a && n < this._frameKeys.length;) {
                const t = this._frameKeys[n]
                const r = this._frames[t]
                const a = r.frame
                if (a) {
                    let n = null
                    let s = null
                    const u = !1 !== r.trimmed && r.sourceSize ? r.sourceSize : r.frame
                    const c = new i.j(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution)
                    if (n = r.rotated ? new i.j(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.h) / this.resolution, Math.floor(a.w) / this.resolution) : new i.j(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution), !1 !== r.trimmed && r.spriteSourceSize && (s = new i.j(Math.floor(r.spriteSourceSize.x) / this.resolution, Math.floor(r.spriteSourceSize.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution)), this.textures[t] = new o.db(this.baseTexture, n, c, s, r.rotated ? 2 : 0, r.anchor), r.vertices) {
                        const n = new Float32Array(2 * r.vertices.length)
                        for (let t = 0; t < r.vertices.length; t++) n[2 * t] = Math.floor(r.vertices[t][0]) / this.resolution, n[2 * t + 1] = Math.floor(r.vertices[t][1]) / this.resolution
                        const i = new Float32Array(2 * r.verticesUV.length)
                        for (let t = 0; t < r.verticesUV.length; t++) i[2 * t] = r.verticesUV[t][0] / e.size.w, i[2 * t + 1] = r.verticesUV[t][1] / e.size.h
                        const o = new Uint16Array(3 * r.triangles.length)
                        for (let t = 0; t < r.triangles.length; t++) o[3 * t] = r.triangles[t][0], o[3 * t + 1] = r.triangles[t][1], o[3 * t + 2] = r.triangles[t][2]
                        this.textures[t].polygon = new f(n, i, o)
                    }
                    o.db.addToCache(this.textures[t], t)
                }
                n++
            }
        }
    },
    './node_modules/pixi-spine/lib/all.es.js': function (t, e, n) {
        'use strict'
        n.d(e, 'd', () => {
            return Gi
        }), n.d(e, 'a', () => {
            return Ft
        }), n.d(e, 'b', () => {
            return st
        }), n.d(e, 'c', () => {
            return lt
        }), n.d(e, 'e', () => {
            return I
        })
        const r = {}
        n.r(r), n.d(r, 'Animation', () => {
            return dt
        }), n.d(r, 'AnimationState', () => {
            return kt
        }), n.d(r, 'AnimationStateAdapter', () => {
            return Dt
        }), n.d(r, 'AnimationStateData', () => {
            return Lt
        }), n.d(r, 'AtlasAttachmentLoader', () => {
            return Ft
        }), n.d(r, 'Attachment', () => {
            return rt
        }), n.d(r, 'AttachmentTimeline', () => {
            return xt
        }), n.d(r, 'Bone', () => {
            return Bt
        }), n.d(r, 'BoneData', () => {
            return Ut
        }), n.d(r, 'BoundingBoxAttachment', () => {
            return ot
        }), n.d(r, 'ClippingAttachment', () => {
            return at
        }), n.d(r, 'ColorTimeline', () => {
            return bt
        }), n.d(r, 'ConstraintData', () => {
            return Gt
        }), n.d(r, 'CurveTimeline', () => {
            return mt
        }), n.d(r, 'DeformTimeline', () => {
            return St
        }), n.d(r, 'DrawOrderTimeline', () => {
            return Ot
        }), n.d(r, 'Event', () => {
            return Xt
        }), n.d(r, 'EventData', () => {
            return Ht
        }), n.d(r, 'EventQueue', () => {
            return Mt
        }), n.d(r, 'EventTimeline', () => {
            return wt
        }), n.d(r, 'EventType', () => {
            return pt
        }), n.d(r, 'IkConstraint', () => {
            return Vt
        }), n.d(r, 'IkConstraintData', () => {
            return Wt
        }), n.d(r, 'IkConstraintTimeline', () => {
            return Pt
        }), n.d(r, 'JitterEffect', () => {
            return ht
        }), n.d(r, 'MeshAttachment', () => {
            return st
        }), n.d(r, 'PathAttachment', () => {
            return ut
        }), n.d(r, 'PathConstraint', () => {
            return zt
        }), n.d(r, 'PathConstraintData', () => {
            return Yt
        }), n.d(r, 'PathConstraintMixTimeline', () => {
            return Ct
        }), n.d(r, 'PathConstraintPositionTimeline', () => {
            return At
        }), n.d(r, 'PathConstraintSpacingTimeline', () => {
            return It
        }), n.d(r, 'PointAttachment', () => {
            return ct
        }), n.d(r, 'RegionAttachment', () => {
            return lt
        }), n.d(r, 'RotateTimeline', () => {
            return yt
        }), n.d(r, 'ScaleTimeline', () => {
            return _t
        }), n.d(r, 'ShearTimeline', () => {
            return gt
        }), n.d(r, 'Skeleton', () => {
            return Zt
        }), n.d(r, 'SkeletonBinary', () => {
            return ne
        }), n.d(r, 'SkeletonBounds', () => {
            return oe
        }), n.d(r, 'SkeletonData', () => {
            return $t
        }), n.d(r, 'SkeletonJson', () => {
            return ae
        }), n.d(r, 'Skin', () => {
            return ee
        }), n.d(r, 'SkinEntry', () => {
            return te
        }), n.d(r, 'Slot', () => {
            return qt
        }), n.d(r, 'SlotData', () => {
            return Jt
        }), n.d(r, 'SpacingMode', () => {
            return jt
        }), n.d(r, 'Spine', () => {
            return ue
        }), n.d(r, 'SwirlEffect', () => {
            return ft
        }), n.d(r, 'TimelineType', () => {
            return nt
        }), n.d(r, 'TrackEntry', () => {
            return Nt
        }), n.d(r, 'TransformConstraint', () => {
            return Kt
        }), n.d(r, 'TransformConstraintData', () => {
            return Qt
        }), n.d(r, 'TransformConstraintTimeline', () => {
            return Rt
        }), n.d(r, 'TranslateTimeline', () => {
            return vt
        }), n.d(r, 'TwoColorTimeline', () => {
            return Et
        }), n.d(r, 'VertexAttachment', () => {
            return it
        })
        const i = {}
        n.r(i), n.d(i, 'Animation', () => {
            return xe
        }), n.d(i, 'AnimationState', () => {
            return Ge
        }), n.d(i, 'AnimationStateAdapter2', () => {
            return We
        }), n.d(i, 'AnimationStateData', () => {
            return Ye
        }), n.d(i, 'AtlasAttachmentLoader', () => {
            return ze
        }), n.d(i, 'Attachment', () => {
            return fe
        }), n.d(i, 'AttachmentTimeline', () => {
            return Ce
        }), n.d(i, 'Bone', () => {
            return qe
        }), n.d(i, 'BoneData', () => {
            return Ke
        }), n.d(i, 'BoundingBoxAttachment', () => {
            return pe
        }), n.d(i, 'ClippingAttachment', () => {
            return me
        }), n.d(i, 'ColorTimeline', () => {
            return Ae
        }), n.d(i, 'CurveTimeline', () => {
            return Se
        }), n.d(i, 'DeformTimeline', () => {
            return Ne
        }), n.d(i, 'DrawOrderTimeline', () => {
            return je
        }), n.d(i, 'Event', () => {
            return Ze
        }), n.d(i, 'EventData', () => {
            return $e
        }), n.d(i, 'EventQueue', () => {
            return He
        }), n.d(i, 'EventTimeline', () => {
            return Me
        }), n.d(i, 'EventType', () => {
            return Te
        }), n.d(i, 'IkConstraint', () => {
            return Je
        }), n.d(i, 'IkConstraintData', () => {
            return Qe
        }), n.d(i, 'IkConstraintTimeline', () => {
            return De
        }), n.d(i, 'JitterEffect', () => {
            return be
        }), n.d(i, 'MeshAttachment', () => {
            return ye
        }), n.d(i, 'PathAttachment', () => {
            return ve
        }), n.d(i, 'PathConstraint', () => {
            return en
        }), n.d(i, 'PathConstraintData', () => {
            return tn
        }), n.d(i, 'PathConstraintMixTimeline', () => {
            return Ue
        }), n.d(i, 'PathConstraintPositionTimeline', () => {
            return Fe
        }), n.d(i, 'PathConstraintSpacingTimeline', () => {
            return Be
        }), n.d(i, 'PointAttachment', () => {
            return _e
        }), n.d(i, 'RegionAttachment', () => {
            return ge
        }), n.d(i, 'RotateTimeline', () => {
            return we
        }), n.d(i, 'ScaleTimeline', () => {
            return Pe
        }), n.d(i, 'ShearTimeline', () => {
            return Re
        }), n.d(i, 'Skeleton', () => {
            return on
        }), n.d(i, 'SkeletonBounds', () => {
            return an
        }), n.d(i, 'SkeletonData', () => {
            return sn
        }), n.d(i, 'SkeletonJson', () => {
            return hn
        }), n.d(i, 'Skin', () => {
            return ln
        }), n.d(i, 'Slot', () => {
            return nn
        }), n.d(i, 'SlotData', () => {
            return un
        }), n.d(i, 'SpacingMode', () => {
            return Ve
        }), n.d(i, 'Spine', () => {
            return dn
        }), n.d(i, 'SwirlEffect', () => {
            return Ee
        }), n.d(i, 'TimelineType', () => {
            return he
        }), n.d(i, 'TrackEntry', () => {
            return Xe
        }), n.d(i, 'TransformConstraint', () => {
            return rn
        }), n.d(i, 'TransformConstraintData', () => {
            return cn
        }), n.d(i, 'TransformConstraintTimeline', () => {
            return Le
        }), n.d(i, 'TranslateTimeline', () => {
            return Oe
        }), n.d(i, 'TwoColorTimeline', () => {
            return Ie
        }), n.d(i, 'VertexAttachment', () => {
            return de
        })
        const o = {}
        n.r(o), n.d(o, 'AlphaTimeline', () => {
            return cr
        }), n.d(o, 'Animation', () => {
            return Pn
        }), n.d(o, 'AnimationState', () => {
            return Er
        }), n.d(o, 'AnimationStateAdapter', () => {
            return wr
        }), n.d(o, 'AnimationStateData', () => {
            return Mr
        }), n.d(o, 'AtlasAttachmentLoader', () => {
            return jr
        }), n.d(o, 'Attachment', () => {
            return vn
        }), n.d(o, 'AttachmentTimeline', () => {
            return fr
        }), n.d(o, 'Bone', () => {
            return Dr
        }), n.d(o, 'BoneData', () => {
            return Lr
        }), n.d(o, 'BoundingBoxAttachment', () => {
            return gn
        }), n.d(o, 'ClippingAttachment', () => {
            return bn
        }), n.d(o, 'ConstraintData', () => {
            return Fr
        }), n.d(o, 'CurveTimeline', () => {
            return qn
        }), n.d(o, 'CurveTimeline1', () => {
            return Kn
        }), n.d(o, 'CurveTimeline2', () => {
            return Zn
        }), n.d(o, 'DeformTimeline', () => {
            return dr
        }), n.d(o, 'DrawOrderTimeline', () => {
            return mr
        }), n.d(o, 'Event', () => {
            return Br
        }), n.d(o, 'EventData', () => {
            return Ur
        }), n.d(o, 'EventQueue', () => {
            return Tr
        }), n.d(o, 'EventTimeline', () => {
            return pr
        }), n.d(o, 'EventType', () => {
            return yn
        }), n.d(o, 'IkConstraint', () => {
            return Gr
        }), n.d(o, 'IkConstraintData', () => {
            return Xr
        }), n.d(o, 'IkConstraintTimeline', () => {
            return yr
        }), n.d(o, 'JitterEffect', () => {
            return wn
        }), n.d(o, 'MeshAttachment', () => {
            return En
        }), n.d(o, 'PathAttachment', () => {
            return xn
        }), n.d(o, 'PathConstraint', () => {
            return Vr
        }), n.d(o, 'PathConstraintData', () => {
            return Hr
        }), n.d(o, 'PathConstraintMixTimeline', () => {
            return br
        }), n.d(o, 'PathConstraintPositionTimeline', () => {
            return _r
        }), n.d(o, 'PathConstraintSpacingTimeline', () => {
            return gr
        }), n.d(o, 'PointAttachment', () => {
            return Tn
        }), n.d(o, 'RGB2Timeline', () => {
            return hr
        }), n.d(o, 'RGBA2Timeline', () => {
            return lr
        }), n.d(o, 'RGBATimeline', () => {
            return sr
        }), n.d(o, 'RGBTimeline', () => {
            return ur
        }), n.d(o, 'RegionAttachment', () => {
            return Sn
        }), n.d(o, 'RotateTimeline', () => {
            return $n
        }), n.d(o, 'ScaleTimeline', () => {
            return er
        }), n.d(o, 'ScaleXTimeline', () => {
            return nr
        }), n.d(o, 'ScaleYTimeline', () => {
            return rr
        }), n.d(o, 'ShearTimeline', () => {
            return ir
        }), n.d(o, 'ShearXTimeline', () => {
            return or
        }), n.d(o, 'ShearYTimeline', () => {
            return ar
        }), n.d(o, 'Skeleton', () => {
            return zr
        }), n.d(o, 'SkeletonBinary', () => {
            return Qr
        }), n.d(o, 'SkeletonBounds', () => {
            return Oi
        }), n.d(o, 'SkeletonData', () => {
            return qr
        }), n.d(o, 'SkeletonJson', () => {
            return Pi
        }), n.d(o, 'Skin', () => {
            return Jr
        }), n.d(o, 'SkinEntry', () => {
            return $r
        }), n.d(o, 'Slot', () => {
            return Wr
        }), n.d(o, 'SlotData', () => {
            return Kr
        }), n.d(o, 'SpacingMode', () => {
            return Sr
        }), n.d(o, 'Spine', () => {
            return Mi
        }), n.d(o, 'SwirlEffect', () => {
            return On
        }), n.d(o, 'Timeline', () => {
            return zn
        }), n.d(o, 'TrackEntry', () => {
            return xr
        }), n.d(o, 'TransformConstraint', () => {
            return Yr
        }), n.d(o, 'TransformConstraintData', () => {
            return Zr
        }), n.d(o, 'TransformConstraintTimeline', () => {
            return vr
        }), n.d(o, 'TranslateTimeline', () => {
            return Jn
        }), n.d(o, 'TranslateXTimeline', () => {
            return Qn
        }), n.d(o, 'TranslateYTimeline', () => {
            return tr
        }), n.d(o, 'VertexAttachment', () => {
            return _n
        })
        let a; const s = n('./node_modules/@pixi/loaders/dist/esm/loaders.js')
        const u = n('./node_modules/@pixi/core/dist/esm/core.js')
        const c = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const l = n('./node_modules/@pixi/math/dist/esm/math.js')
        const h = n('./node_modules/@pixi/display/dist/esm/display.js')
        const f = n('./node_modules/@pixi/sprite/dist/esm/sprite.js')
        const d = n('./node_modules/@pixi/mesh-extras/dist/esm/mesh-extras.js')
        const p = n('./node_modules/@pixi/graphics/dist/esm/graphics.js')
        const m = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        !(function (t) {
            t[t.Region = 0] = 'Region', t[t.BoundingBox = 1] = 'BoundingBox', t[t.Mesh = 2] = 'Mesh', t[t.LinkedMesh = 3] = 'LinkedMesh', t[t.Path = 4] = 'Path', t[t.Point = 5] = 'Point', t[t.Clipping = 6] = 'Clipping'
        }(a || (a = {})))
        let y; let v; let _; let g; let b; const E = (function () {
            function t(t, e, n, r) {
                void 0 === e && (e = []), void 0 === n && (n = 0), void 0 === r && (r = new DataView(t.buffer)), this.strings = e, this.index = n, this.buffer = r
            }
            return t.prototype.readByte = function () {
                return this.buffer.getInt8(this.index++)
            }, t.prototype.readUnsignedByte = function () {
                return this.buffer.getUint8(this.index++)
            }, t.prototype.readShort = function () {
                const t = this.buffer.getInt16(this.index)
                return this.index += 2, t
            }, t.prototype.readInt32 = function () {
                const t = this.buffer.getInt32(this.index)
                return this.index += 4, t
            }, t.prototype.readInt = function (t) {
                let e = this.readByte()
                var n = 127 & e
                return (128 & e) != 0 && (n |= (127 & (e = this.readByte())) << 7, (128 & e) != 0 && (n |= (127 & (e = this.readByte())) << 14, (128 & e) != 0 && (n |= (127 & (e = this.readByte())) << 21, (128 & e) != 0 && (n |= (127 & (e = this.readByte())) << 28)))), t ? n : n >>> 1 ^ -(1 & n)
            }, t.prototype.readStringRef = function () {
                const t = this.readInt(!0)
                return t == 0 ? null : this.strings[t - 1]
            }, t.prototype.readString = function () {
                let t = this.readInt(!0)
                switch (t) {
                    case 0:
                        return null
                    case 1:
                        return ''
                }
                t--
                for (var e = '', n = 0; n < t;) {
                    const r = this.readByte()
                    switch (r >> 4) {
                        case 12:
                        case 13:
                            e += String.fromCharCode((31 & r) << 6 | 63 & this.readByte()), n += 2
                            break
                        case 14:
                            e += String.fromCharCode((15 & r) << 12 | (63 & this.readByte()) << 6 | 63 & this.readByte()), n += 3
                            break
                        default:
                            e += String.fromCharCode(r), n++
                    }
                }
                return e
            }, t.prototype.readFloat = function () {
                const t = this.buffer.getFloat32(this.index)
                return this.index += 4, t
            }, t.prototype.readBoolean = function () {
                return this.readByte() != 0
            }, t
        }())
        !(function (t) {
            t[t.setup = 0] = 'setup', t[t.first = 1] = 'first', t[t.replace = 2] = 'replace', t[t.add = 3] = 'add'
        }(y || (y = {}))),
        (function (t) {
            t[t.mixIn = 0] = 'mixIn', t[t.mixOut = 1] = 'mixOut'
        }(v || (v = {}))),
        (function (t) {
            t[t.Fixed = 0] = 'Fixed', t[t.Percent = 1] = 'Percent'
        }(_ || (_ = {}))),
        (function (t) {
            t[t.Tangent = 0] = 'Tangent', t[t.Chain = 1] = 'Chain', t[t.ChainScale = 2] = 'ChainScale'
        }(g || (g = {}))),
        (function (t) {
            t[t.Normal = 0] = 'Normal', t[t.OnlyTranslation = 1] = 'OnlyTranslation', t[t.NoRotationOrReflection = 2] = 'NoRotationOrReflection', t[t.NoScale = 3] = 'NoScale', t[t.NoScaleOrReflection = 4] = 'NoScaleOrReflection'
        }(b || (b = {})))
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
        let x; let T; let S = function (t, e) {
            return (S = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            })(t, e)
        }

        function w(t, e) {
            if (typeof e != 'function' && e !== null) throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`)

            function n() {
                this.constructor = t
            }
            S(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }

        function O(t) {
            switch (t.toLowerCase()) {
                case 'nearest':
                    return x.Nearest
                case 'linear':
                    return x.Linear
                case 'mipmap':
                    return x.MipMap
                case 'mipmapnearestnearest':
                    return x.MipMapNearestNearest
                case 'mipmaplinearnearest':
                    return x.MipMapLinearNearest
                case 'mipmapnearestlinear':
                    return x.MipMapNearestLinear
                case 'mipmaplinearlinear':
                    return x.MipMapLinearLinear
                default:
                    throw new Error(`Unknown texture filter ${t}`)
            }
        }!(function (t) {
            t[t.Nearest = 9728] = 'Nearest', t[t.Linear = 9729] = 'Linear', t[t.MipMap = 9987] = 'MipMap', t[t.MipMapNearestNearest = 9984] = 'MipMapNearestNearest', t[t.MipMapLinearNearest = 9985] = 'MipMapLinearNearest', t[t.MipMapNearestLinear = 9986] = 'MipMapNearestLinear', t[t.MipMapLinearLinear = 9987] = 'MipMapLinearLinear'
        }(x || (x = {}))),
        (function (t) {
            t[t.MirroredRepeat = 33648] = 'MirroredRepeat', t[t.ClampToEdge = 33071] = 'ClampToEdge', t[t.Repeat = 10497] = 'Repeat'
        }(T || (T = {})))
        let P; const R = (function () {
            function t() {
                this.size = null, this.names = null, this.values = null
            }
            return Object.defineProperty(t.prototype, 'width', {
                get () {
                    var t = this.texture
                            return t.trim ? t.trim.width : t.orig.width
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'height', {
                get () {
                    var t = this.texture
                            return t.trim ? t.trim.height : t.orig.height
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'u', {
                get () {
                    return this.texture._uvs.x0
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'v', {
                get () {
                    return this.texture._uvs.y0
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'u2', {
                get () {
                    return this.texture._uvs.x2
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'v2', {
                get () {
                    return this.texture._uvs.y2
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'offsetX', {
                get () {
                    var t = this.texture
                            return t.trim ? t.trim.x : 0
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'offsetY', {
                get () {
                    return this.spineOffsetY
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'pixiOffsetY', {
                get () {
                    var t = this.texture
                            return t.trim ? t.trim.y : 0
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'spineOffsetY', {
                get () {
                    var t = this.texture
                            return this.originalHeight - this.height - (t.trim ? t.trim.y : 0)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'originalWidth', {
                get () {
                    return this.texture.orig.width
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'originalHeight', {
                get () {
                    return this.texture.orig.height
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'x', {
                get () {
                    return this.texture.frame.x
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'y', {
                get () {
                    return this.texture.frame.y
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'rotate', {
                get () {
                    return this.texture.rotate !== 0
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'degrees', {
                get () {
                    return (360 - 45 * this.texture.rotate) % 360
                },
                enumerable: !1,
                configurable: !0
            }), t
        }())
        const A = function () {
            this.x = 0, this.y = 0, this.width = 0, this.height = 0, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0, this.rotate = 0, this.index = 0
        }
        var I = (function () {
            function t(t, e, n) {
                this.pages = [], this.regions = [], t && this.addSpineAtlas(t, e, n)
            }
            return t.prototype.addTexture = function (t, e) {
                for (var n = this.pages, r = null, i = 0; i < n.length; i++) {
                    if (n[i].baseTexture === e.baseTexture) {
                        r = n[i]
                        break
                    }
                }
                if (r === null) {
                    (r = new k()).name = 'texturePage'
                    let o = e.baseTexture
                    r.width = o.realWidth, r.height = o.realHeight, r.baseTexture = o, r.minFilter = r.magFilter = x.Nearest, r.uWrap = T.ClampToEdge, r.vWrap = T.ClampToEdge, n.push(r)
                }
                const a = new N()
                return a.name = t, a.page = r, a.texture = e, a.index = -1, this.regions.push(a), a
            }, t.prototype.addTextureHash = function (t, e) {
                for (const n in t) t.hasOwnProperty(n) && this.addTexture(e && n.includes('.') ? n.substr(0, n.lastIndexOf('.')) : n, t[n])
            }, t.prototype.addSpineAtlas = function (t, e, n) {
                return this.load(t, e, n)
            }, t.prototype.load = function (t, e, n) {
                const r = this
                if (e == null) throw new Error('textureLoader cannot be null.')
                let i = new C(t)
                var o = Array.from({ length: 4 })
                var a = null
                var s = {}
                var h = null
                s.size = function () {
                    a.width = Number.parseInt(o[1]), a.height = Number.parseInt(o[2])
                }, s.format = function () {}, s.filter = function () {
                    a.minFilter = O(o[1]), a.magFilter = O(o[2])
                }, s.repeat = function () {
                    o[1].includes('x') && (a.uWrap = T.Repeat), o[1].includes('y') && (a.vWrap = T.Repeat)
                }, s.pma = function () {
                    a.pma = o[1] == 'true'
                }
                for (var f = {
                        xy() {
                            h.x = Number.parseInt(o[1]), h.y = Number.parseInt(o[2])
                        },
                        size() {
                            h.width = Number.parseInt(o[1]), h.height = Number.parseInt(o[2])
                        },
                        bounds() {
                            h.x = Number.parseInt(o[1]), h.y = Number.parseInt(o[2]), h.width = Number.parseInt(o[3]), h.height = Number.parseInt(o[4])
                        },
                        offset() {
                            h.offsetX = Number.parseInt(o[1]), h.offsetY = Number.parseInt(o[2])
                        },
                        orig() {
                            h.originalWidth = Number.parseInt(o[1]), h.originalHeight = Number.parseInt(o[2])
                        },
                        offsets() {
                            h.offsetX = Number.parseInt(o[1]), h.offsetY = Number.parseInt(o[2]), h.originalWidth = Number.parseInt(o[3]), h.originalHeight = Number.parseInt(o[4])
                        },
                        rotate() {
                            let t = o[1]
                                        var e = 0
                            e = t.toLocaleLowerCase() == 'true' ? 6 : t.toLocaleLowerCase() == 'false' ? 0 : (720 - Number.parseFloat(t)) % 360 / 45, h.rotate = e
                        },
                        index() {
                            h.index = Number.parseInt(o[1])
                        }
                    }, d = i.readLine(); d != null && d.trim().length == 0;) d = i.readLine()
                for (; d != null && d.trim().length != 0 && i.readEntry(o, d) != 0;) d = i.readLine()
                let p = function () {
                    for (;;) {
                        if (d == null) return n && n(r)
                        if (d.trim().length == 0) { a = null, d = i.readLine()
                        }
                        else {
                            if (a === null) {
                                for ((a = new k()).name = d.trim(); i.readEntry(o, d = i.readLine()) != 0;) {
                                    (v = s[o[0]]) && v()
                                }
                                r.pages.push(a), e(a.name, (t) => {
                                    if (t === null) return r.pages.splice(r.pages.indexOf(a), 1), n && n(null)
                                    a.baseTexture = t, a.pma && (t.alphaMode = c.a.PMA), t.valid || t.setSize(a.width, a.height), r.pages.push(a), a.setFilters(), a.width && a.height || (a.width = t.realWidth, a.height = t.realHeight, a.width && a.height || console.log(`ERROR spine atlas page ${  a.name  }: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)), p()
                                }), r.pages.push(a)
                                break
                            }
                            h = new A()
                            let t = new N()
                            t.name = d, t.page = a
                            for (let m = null, y = null; ;) {
                                var v; const _ = i.readEntry(o, d = i.readLine())
                                if (_ == 0) break
                                if (v = f[o[0]]) { v()
                                }
                                else {
                                    m == null && (m = [], y = []), m.push(o[0])
                                    for (var g = [], b = 0; b < _; b++) g.push(Number.parseInt(o[b + 1]))
                                    y.push(g)
                                }
                            }
                            h.originalWidth == 0 && h.originalHeight == 0 && (h.originalWidth = h.width, h.originalHeight = h.height)
                            let E = a.baseTexture.resolution
                            h.x /= E, h.y /= E, h.width /= E, h.height /= E, h.originalWidth /= E, h.originalHeight /= E, h.offsetX /= E, h.offsetY /= E
                            let x = h.rotate % 4 != 0
                            var T = new l.j(h.x, h.y, x ? h.height : h.width, x ? h.width : h.height)
                            var S = new l.j(0, 0, h.originalWidth, h.originalHeight)
                            var w = new l.j(h.offsetX, h.originalHeight - h.height - h.offsetY, h.width, h.height)
                            t.texture = new u.db(t.page.baseTexture, T, S, w, h.rotate), t.index = h.index, t.texture.updateUvs(), r.regions.push(t)
                        }
                    }
                }
                p()
            }, t.prototype.findRegion = function (t) {
                for (let e = 0; e < this.regions.length; e++) {
                    if (this.regions[e].name == t) return this.regions[e]
                }
                return null
            }, t.prototype.dispose = function () {
                for (let t = 0; t < this.pages.length; t++) this.pages[t].baseTexture.dispose()
            }, t
        }())
        var C = (function () {
            function t(t) {
                this.index = 0, this.lines = t.split(/\r\n|\r|\n/)
            }
            return t.prototype.readLine = function () {
                return this.index >= this.lines.length ? null : this.lines[this.index++]
            }, t.prototype.readEntry = function (t, e) {
                if (e == null) return 0
                if ((e = e.trim()).length == 0) return 0
                let n = e.indexOf(':')
                if (n == -1) return 0
                t[0] = e.substr(0, n).trim()
                for (let r = 1, i = n + 1; ; r++) {
                    const o = e.indexOf(',', i)
                    if (o == -1) return t[r] = e.substr(i).trim(), r
                    if (t[r] = e.substr(i, o - i).trim(), i = o + 1, r == 4) return 4
                }
            }, t
        }())
        var k = (function () {
            function t() {
                this.minFilter = x.Nearest, this.magFilter = x.Nearest, this.uWrap = T.ClampToEdge, this.vWrap = T.ClampToEdge
            }
            return t.prototype.setFilters = function () {
                const t = this.baseTexture
                var e = this.minFilter
                e == x.Linear ? t.scaleMode = c.p.LINEAR : this.minFilter == x.Nearest ? t.scaleMode = c.p.NEAREST : (t.mipmap = c.k.POW2, e == x.MipMapNearestNearest ? t.scaleMode = c.p.NEAREST : t.scaleMode = c.p.LINEAR)
            }, t
        }())
        var N = (function (t) {
            function e() {
                return t !== null && t.apply(this, arguments) || this
            }
            return w(e, t), e
        }(R))
        const M = (P = new Float32Array(1), function (t) {
            return P[0] = t, P[0]
        })
        const j = Math.fround || M
        const D = (function () {
            function t() {
                this.array = []
            }
            return t.prototype.add = function (t) {
                let e = this.contains(t)
                return this.array[0 | t] = 0 | t, !e
            }, t.prototype.contains = function (t) {
                return this.array[0 | t] != null
            }, t.prototype.remove = function (t) {
                this.array[0 | t] = void 0
            }, t.prototype.clear = function () {
                this.array.length = 0
            }, t
        }())
        const L = (function () {
            function t() {
                this.entries = {}, this.size = 0
            }
            return t.prototype.add = function (t) {
                let e = this.entries[t]
                return this.entries[t] = !0, !e && (this.size++, !0)
            }, t.prototype.addAll = function (t) {
                for (var e = this.size, n = 0, r = t.length; n < r; n++) this.add(t[n])
                return e != this.size
            }, t.prototype.contains = function (t) {
                return this.entries[t]
            }, t.prototype.clear = function () {
                this.entries = {}, this.size = 0
            }, t
        }())
        const F = (function () {
            function t(t, e, n, r) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), this.r = t, this.g = e, this.b = n, this.a = r
            }
            return t.prototype.set = function (t, e, n, r) {
                return this.r = t, this.g = e, this.b = n, this.a = r, this.clamp()
            }, t.prototype.setFromColor = function (t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this
            }, t.prototype.setFromString = function (t) {
                return t = t.charAt(0) == '#' ? t.substr(1) : t, this.r = Number.parseInt(t.substr(0, 2), 16) / 255, this.g = Number.parseInt(t.substr(2, 2), 16) / 255, this.b = Number.parseInt(t.substr(4, 2), 16) / 255, this.a = t.length != 8 ? 1 : Number.parseInt(t.substr(6, 2), 16) / 255, this
            }, t.prototype.add = function (t, e, n, r) {
                return this.r += t, this.g += e, this.b += n, this.a += r, this.clamp()
            }, t.prototype.clamp = function () {
                return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this
            }, t.rgba8888ToColor = function (t, e) {
                t.r = ((4278190080 & e) >>> 24) / 255, t.g = ((16711680 & e) >>> 16) / 255, t.b = ((65280 & e) >>> 8) / 255, t.a = (255 & e) / 255
            }, t.rgb888ToColor = function (t, e) {
                t.r = ((16711680 & e) >>> 16) / 255, t.g = ((65280 & e) >>> 8) / 255, t.b = (255 & e) / 255
            }, t.fromString = function (e) {
                return (new t()).setFromString(e)
            }, t.WHITE = new t(1, 1, 1, 1), t.RED = new t(1, 0, 0, 1), t.GREEN = new t(0, 1, 0, 1), t.BLUE = new t(0, 0, 1, 1), t.MAGENTA = new t(1, 0, 1, 1), t
        }())
        const B = (function () {
            function t() {}
            return t.clamp = function (t, e, n) {
                return t < e ? e : t > n ? n : t
            }, t.cosDeg = function (e) {
                return Math.cos(e * t.degRad)
            }, t.sinDeg = function (e) {
                return Math.sin(e * t.degRad)
            }, t.signum = function (t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }, t.toInt = function (t) {
                return t > 0 ? Math.floor(t) : Math.ceil(t)
            }, t.cbrt = function (t) {
                let e = Math.abs(t) ** (1 / 3)
                return t < 0 ? -e : e
            }, t.randomTriangular = function (e, n) {
                return t.randomTriangularWith(e, n, 0.5 * (e + n))
            }, t.randomTriangularWith = function (t, e, n) {
                let r = Math.random()
                            var i = e - t
                return r <= (n - t) / i ? t + Math.sqrt(r * i * (n - t)) : e - Math.sqrt((1 - r) * i * (e - n))
            }, t.PI = 3.1415927, t.PI2 = 2 * t.PI, t.radiansToDegrees = 180 / t.PI, t.radDeg = t.radiansToDegrees, t.degreesToRadians = t.PI / 180, t.degRad = t.degreesToRadians, t
        }())
        const U = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return w(e, t), e.prototype.applyInternal = function (t) {
                return (t - 1) ** this.power * (this.power % 2 == 0 ? -1 : 1) + 1
            }, e
        }(function (t) {
            function e(e) {
                let n = t.call(this) || this
                return n.power = 2, n.power = e, n
            }
            return w(e, t), e.prototype.applyInternal = function (t) {
                return t <= 0.5 ? (2 * t) ** this.power / 2 : (2 * (t - 1)) ** this.power / (this.power % 2 == 0 ? -2 : 2) + 1
            }, e
        }(function () {
            function t() {}
            return t.prototype.apply = function (t, e, n) {
                return t + (e - t) * this.applyInternal(n)
            }, t
        }())))
        const G = (function () {
            function t() {}
            return t.arrayCopy = function (t, e, n, r, i) {
                for (let o = e, a = r; o < e + i; o++, a++) n[a] = t[o]
            }, t.arrayFill = function (t, e, n, r) {
                for (let i = e; i < n; i++) t[i] = r
            }, t.setArraySize = function (t, e, n) {
                void 0 === n && (n = 0)
                var r = t.length
                if (r == e) return t
                if (t.length = e, r < e) {
                    for (let i = r; i < e; i++) t[i] = n
}
                return t
            }, t.ensureArrayCapacity = function (e, n, r) {
                return void 0 === r && (r = 0), e.length >= n ? e : t.setArraySize(e, n, r)
            }, t.newArray = function (t, e) {
                for (var n = new Array(t), r = 0; r < t; r++) n[r] = e
                return n
            }, t.newFloatArray = function (e) {
                if (t.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e)
                for (var n = new Array(e), r = 0; r < n.length; r++) n[r] = 0
                return n
            }, t.newShortArray = function (e) {
                if (t.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e)
                for (var n = new Array(e), r = 0; r < n.length; r++) n[r] = 0
                return n
            }, t.toFloatArray = function (e) {
                return t.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e
            }, t.toSinglePrecision = function (e) {
                return t.SUPPORTS_TYPED_ARRAYS ? j(e) : e
            }, t.webkit602BugfixHelper = function (t, e) {}, t.contains = function (t, e, n) {
                for (let r = 0; r < t.length; r++) {
                    if (t[r] == e) return !0
}
                return !1
            }, t.enumValue = function (t, e) {
                return t[e[0].toUpperCase() + e.slice(1)]
            }, t.SUPPORTS_TYPED_ARRAYS = typeof Float32Array != 'undefined', t
        }())
        const X = ((function () {
            function t() {}
            t.logBones = function (t) {
                for (let e = 0; e < t.bones.length; e++) {
                    let n = t.bones[e]
                                var r = n.matrix
                    console.log(`${n.data.name }, ${ r.a }, ${ r.b }, ${ r.c }, ${ r.d }, ${ r.tx }, ${ r.ty}`)
                }
            }
        }()), (function () {
            function t(t) {
                this.items = [], this.instantiator = t
            }
            return t.prototype.obtain = function () {
                return this.items.length > 0 ? this.items.pop() : this.instantiator()
            }, t.prototype.free = function (t) {
                t.reset && t.reset(), this.items.push(t)
            }, t.prototype.freeAll = function (t) {
                for (let e = 0; e < t.length; e++) this.free(t[e])
            }, t.prototype.clear = function () {
                this.items.length = 0
            }, t
        }()))
        const H = (function () {
            function t(t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e
            }
            return t.prototype.set = function (t, e) {
                return this.x = t, this.y = e, this
            }, t.prototype.length = function () {
                let t = this.x
                            var e = this.y
                return Math.sqrt(t * t + e * e)
            }, t.prototype.normalize = function () {
                let t = this.length()
                return t != 0 && (this.x /= t, this.y /= t), this
            }, t
        }())
        const V = ((function () {
            function t() {
                this.maxDelta = 0.064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0
            }
            t.prototype.update = function () {
                let t = Date.now() / 1e3
                this.delta = t - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = t, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0)
            }
        }()), (function () {
            function t(t) {
                void 0 === t && (t = 32), this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = !0, this.values = new Array(t)
            }
            t.prototype.hasEnoughData = function () {
                return this.addedValues >= this.values.length
            }, t.prototype.addValue = function (t) {
                this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = t, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = !0
            }, t.prototype.getMean = function () {
                if (this.hasEnoughData()) {
                    if (this.dirty) {
                        for (var t = 0, e = 0; e < this.values.length; e++) t += this.values[e]
                        this.mean = t / this.values.length, this.dirty = !1
                    }
                    return this.mean
                }
                return 0
            }
        }()), !0)
        const W = !1
        const Y = !0
        const z = 0
        const q = [0, 0, 0]
        const K = (function (t) {
            function e() {
                let e = t !== null && t.apply(this, arguments) || this
                return e.region = null, e.attachment = null, e
            }
            return w(e, t), e
        }(f.a))
        const Z = (function (t) {
            function e(e, n, r, i, o) {
                let a = t.call(this, e, n, r, i, o) || this
                return a.region = null, a.attachment = null, a
            }
            return w(e, t), e
        }(d.d))
        const $ = (function (t) {
            function e(e) {
                const n = t.call(this) || this
                if (!e) throw new Error('The spineData param is required.')
                if (typeof e == 'string') throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.')
                n.spineData = e, n.createSkeleton(e), n.slotContainers = [], n.tempClipContainers = []
                for (let r = 0, i = n.skeleton.slots.length; r < i; r++) {
                    const o = n.skeleton.slots[r]
                    var s = o.getAttachment()
                    var u = n.newContainer()
                    if (n.slotContainers.push(u), n.addChild(u), n.tempClipContainers.push(null), s) {
                        if (s.type === a.Region) {
                            let c = s.region.name
                                        var l = n.createSprite(o, s, c)
                            o.currentSprite = l, o.currentSpriteName = c, u.addChild(l)
                        } else if (s.type === a.Mesh) {
                            let h = n.createMesh(o, s)
                            o.currentMesh = h, o.currentMeshId = s.id, o.currentMeshName = s.name, u.addChild(h)
                        } else { s.type === a.Clipping && (n.createGraphics(o, s), u.addChild(o.clippingContainer), u.addChild(o.currentGraphics))
                        }
                    }
                }
                return n.tintRgb = new Float32Array([1, 1, 1]), n.autoUpdate = !0, n.visible = !0, n
            }
            return w(e, t), Object.defineProperty(e.prototype, 'autoUpdate', {
                get() {
                    return this._autoUpdate
                },
                set(t) {
                    t !== this._autoUpdate && (this._autoUpdate = t, this.updateTransform = t ? e.prototype.autoUpdateTransform : h.b.prototype.updateTransform)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'tint', {
                get() {
                    return new Object(m.rgb2hex)(this.tintRgb)
                },
                set(t) {
                    this.tintRgb = new Object(m.hex2rgb)(t, this.tintRgb)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'delayLimit', {
                get() {
                    return (void 0 !== this.localDelayLimit ? this.localDelayLimit : z) || Number.MAX_VALUE
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.update = function (t) {
                const e = this.delayLimit
                if (t > e && (t = e), this.state.update(t), this.state.apply(this.skeleton), this.skeleton) {
                    this.skeleton.updateWorldTransform()
                    let n = this.skeleton.slots
                    var r = this.color
                    var i = null
                    var o = null
                    r ? (i = r.light, o = r.dark) : i = this.tintRgb
                    for (var s = 0, u = n.length; s < u; s++) {
                        const c = (A = n[s]).getAttachment()
                        var h = this.slotContainers[s]
                        if (c) {
                            let f = null
                            var d = c.color
                            switch (c.type) {
                                case a.Region:
                                    var p = c.region
                                    if (p) {
                                        A.currentMesh && (A.currentMesh.visible = !1, A.currentMesh = null, A.currentMeshId = void 0, A.currentMeshName = void 0)
                                        let y = p
                                        if (A.currentSpriteName && A.currentSpriteName === y.name) { A.currentSpriteName !== y.name || A.hackRegion || this.setSpriteRegion(c, A.currentSprite, p)
                                        }
                                        else {
                                            const v = y.name
                                            if (A.currentSprite && (A.currentSprite.visible = !1), A.sprites = A.sprites || {}, void 0 !== A.sprites[v]) { A.sprites[v].visible = !0
                                            }
                                            else {
                                                const _ = this.createSprite(A, c, v)
                                                h.addChild(_)
                                            }
                                            A.currentSprite = A.sprites[v], A.currentSpriteName = v
                                        }
                                    }
                                    h.transform.setFromMatrix(A.bone.matrix), A.currentSprite.color ? f = A.currentSprite.color : (q[0] = i[0] * A.color.r * d.r, q[1] = i[1] * A.color.g * d.g, q[2] = i[2] * A.color.b * d.b, A.currentSprite.tint = new Object(m.rgb2hex)(q)), A.currentSprite.blendMode = A.blendMode
                                    break
                                case a.Mesh:
                                    if (A.currentSprite) {
                                        A.currentSprite.visible = !1, A.currentSprite = null, A.currentSpriteName = void 0
                                        let g = new l.m()
                                        g._parentID = -1, g._worldID = h.transform._worldID, h.transform = g
                                    }
                                    var b = c.id
                                    if (!A.currentMeshId || A.currentMeshId !== b) {
                                        const E = b
                                        if (A.currentMesh && (A.currentMesh.visible = !1), A.meshes = A.meshes || {}, void 0 !== A.meshes[E]) { A.meshes[E].visible = !0
                                        }
                                        else {
                                            const x = this.createMesh(A, c)
                                            h.addChild(x)
                                        }
                                        A.currentMesh = A.meshes[E], A.currentMeshName = c.name, A.currentMeshId = E
                                    }
                                    c.computeWorldVerticesOld(A, A.currentMesh.vertices), A.currentMesh.color ? f = A.currentMesh.color : (q[0] = i[0] * A.color.r * d.r, q[1] = i[1] * A.color.g * d.g, q[2] = i[2] * A.color.b * d.b, A.currentMesh.tint = new Object(m.rgb2hex)(q)), A.currentMesh.blendMode = A.blendMode
                                    break
                                case a.Clipping:
                                    A.currentGraphics || (this.createGraphics(A, c), h.addChild(A.clippingContainer), h.addChild(A.currentGraphics)), this.updateGraphics(A, c), h.alpha = 1, h.visible = !0
                                    continue
                                default:
                                    h.visible = !1
                                    continue
                            }
                            if (h.visible = !0, f) {
                                let T = A.color.r * d.r
                                var S = A.color.g * d.g
                                var w = A.color.b * d.b
                                f.setLight(i[0] * T + o[0] * (1 - T), i[1] * S + o[1] * (1 - S), i[2] * w + o[2] * (1 - w)), A.darkColor ? (T = A.darkColor.r, S = A.darkColor.g, w = A.darkColor.b) : (T = 0, S = 0, w = 0), f.setDark(i[0] * T + o[0] * (1 - T), i[1] * S + o[1] * (1 - S), i[2] * w + o[2] * (1 - w))
                            }
                            h.alpha = A.color.a
                        } else { h.visible = !1
                        }
                    }
                    const O = this.skeleton.drawOrder
                    var P = null
                    var R = null
                    for (s = 0, u = O.length; s < u; s++) {
                        var A = n[O[s].data.index]
                        h = this.slotContainers[O[s].data.index]
                        if (R || h.parent !== null && h.parent !== this && (h.parent.removeChild(h), h.parent = this), A.currentGraphics && A.getAttachment()) { R = A.clippingContainer, P = A.getAttachment(), R.children.length = 0, this.children[s] = h, P.endSlot === A.data && (P.endSlot = null)
                        }
                        else if (R) {
                            let I = this.tempClipContainers[s]
                            I || ((I = this.tempClipContainers[s] = this.newContainer()).visible = !1), this.children[s] = I, h.parent = null, R.addChild(h), P.endSlot == A.data && (R.renderable = !0, R = null, P = null)
                        } else { this.children[s] = h
                        }
                    }
                }
            }, e.prototype.setSpriteRegion = function (t, e, n) {
                e.attachment === t && e.region === n || (e.region = n, e.attachment = t, e.texture = n.texture, e.rotation = t.rotation * B.degRad, e.position.x = t.x, e.position.y = t.y, e.alpha = t.color.a, n.size ? (e.scale.x = n.size.width / n.originalWidth, e.scale.y = -n.size.height / n.originalHeight) : (e.scale.x = t.scaleX * t.width / n.originalWidth, e.scale.y = -t.scaleY * t.height / n.originalHeight))
            }, e.prototype.setMeshRegion = function (t, e, n) {
                e.attachment === t && e.region === n || (e.region = n, e.attachment = t, e.texture = n.texture, n.texture.updateUvs(), e.uvBuffer.update(t.regionUVs))
            }, e.prototype.autoUpdateTransform = function () {
                if (Y) {
                    this.lastTime = this.lastTime || Date.now()
                    let t = 0.001 * (Date.now() - this.lastTime)
                    this.lastTime = Date.now(), this.update(t)
                } else { this.lastTime = 0
                }
                h.b.prototype.updateTransform.call(this)
            }, e.prototype.createSprite = function (t, e, n) {
                let r = e.region
                t.hackAttachment === e && (r = t.hackRegion)
                let i = r.texture
                var o = this.newSprite(i)
                return o.anchor.set(0.5), this.setSpriteRegion(e, o, e.region), t.sprites = t.sprites || {}, t.sprites[n] = o, o
            }, e.prototype.createMesh = function (t, e) {
                let n = e.region
                t.hackAttachment === e && (n = t.hackRegion, t.hackAttachment = null, t.hackRegion = null)
                let r = this.newMesh(n.texture, new Float32Array(e.regionUVs.length), e.regionUVs, new Uint16Array(e.triangles), c.f.TRIANGLES)
                return void 0 !== r._canvasPadding && (r._canvasPadding = 1.5), r.alpha = e.color.a, r.region = e.region, this.setMeshRegion(e, r, n), t.meshes = t.meshes || {}, t.meshes[e.id] = r, r
            }, e.prototype.createGraphics = function (t, e) {
                const n = this.newGraphics()
                var r = new l.h([])
                return n.clear(), n.beginFill(16777215, 1), n.drawPolygon(r), n.renderable = !1, t.currentGraphics = n, t.clippingContainer = this.newContainer(), t.clippingContainer.mask = t.currentGraphics, n
            }, e.prototype.updateGraphics = function (t, e) {
                const n = t.currentGraphics.geometry
                var r = n.graphicsData[0].shape.points
                var i = e.worldVerticesLength
                r.length = i, e.computeWorldVertices(t, 0, i, r, 0, 2), n.invalidate()
            }, e.prototype.hackTextureBySlotIndex = function (t, e, n) {
                void 0 === e && (e = null), void 0 === n && (n = null)
                let r = this.skeleton.slots[t]
                if (!r) return !1
                let i = r.getAttachment()
                var o = i.region
                return e ? ((o = new R()).texture = e, o.size = n, r.hackRegion = o, r.hackAttachment = i) : (r.hackRegion = null, r.hackAttachment = null), r.currentSprite && r.currentSprite.region != o ? (this.setSpriteRegion(i, r.currentSprite, o), r.currentSprite.region = o) : r.currentMesh && r.currentMesh.region != o && this.setMeshRegion(i, r.currentMesh, o), !0
            }, e.prototype.hackTextureBySlotName = function (t, e, n) {
                void 0 === e && (e = null), void 0 === n && (n = null)
                let r = this.skeleton.findSlotIndex(t)
                return r != -1 && this.hackTextureBySlotIndex(r, e, n)
            }, e.prototype.hackTextureAttachment = function (t, e, n, r) {
                void 0 === r && (r = null)
                let i = this.skeleton.findSlotIndex(t)
                var o = this.skeleton.getAttachmentByName(t, e)
                o.region.texture = n
                let a = this.skeleton.slots[i]
                if (!a) return !1
                let s = a.getAttachment()
                if (e === s.name) {
                    let u = o.region
                    return n ? ((u = new R()).texture = n, u.size = r, a.hackRegion = u, a.hackAttachment = s) : (a.hackRegion = null, a.hackAttachment = null), a.currentSprite && a.currentSprite.region != u ? (this.setSpriteRegion(s, a.currentSprite, u), a.currentSprite.region = u) : a.currentMesh && a.currentMesh.region != u && this.setMeshRegion(s, a.currentMesh, u), !0
                }
                return !1
            }, e.prototype.newContainer = function () {
                return new h.b()
            }, e.prototype.newSprite = function (t) {
                return new K(t)
            }, e.prototype.newGraphics = function () {
                return new p.c()
            }, e.prototype.newMesh = function (t, e, n, r, i) {
                return new Z(t, e, n, r, i)
            }, e.prototype.transformHack = function () {
                return 1
            }, e.prototype.hackAttachmentGroups = function (t, e, n) {
                if (t) {
                    for (var r = [], i = [], o = 0, a = this.skeleton.slots.length; o < a; o++) {
                        const s = this.skeleton.slots[o]
                        var u = s.currentSpriteName || s.currentMeshName || ''
                        var c = s.currentSprite || s.currentMesh
                        u.endsWith(t) ? (c.parentGroup = e, i.push(c)) : n && c && (c.parentGroup = n, r.push(c))
                    }
                    return [r, i]
                }
            }, e.prototype.destroy = function (e) {
                for (var n = 0, r = this.skeleton.slots.length; n < r; n++) {
                    const i = this.skeleton.slots[n]
                    for (const o in i.meshes) i.meshes[o].destroy(e)
                    for (const a in i.meshes = null, i.sprites) i.sprites[a].destroy(e)
                    i.sprites = null
                }
                for (n = 0, r = this.slotContainers.length; n < r; n++) this.slotContainers[n].destroy(e)
                this.spineData = null, this.skeleton = null, this.slotContainers = null, this.stateData = null, this.state = null, this.tempClipContainers = null, t.prototype.destroy.call(this, e)
            }, e.clippingPolygon = [], e
        }(h.b))
        Object.defineProperty($.prototype, 'visible', {
            get() {
                return this._visible
            },
            set(t) {
                t !== this._visible && (this._visible = t, t && (this.lastTime = 0))
            }
        }), s.c.setExtensionXhrType('skel', s.c.XHR_RESPONSE_TYPE.BUFFER)
        const J = (function () {
            function t() {}
            return t.prototype.genMiddleware = function () {
                const t = this
                return {
                    use(e, n) {
                        if (!e.data) return n()
                        var r =
                                /*!
                                 * @pixi-spine/loader-base - v3.0.13
                                 * Compiled Mon, 13 Sep 2021 16:46:34 UTC
                                 *
                                 * @pixi-spine/loader-base is licensed under the MIT License.
                                 * http://www.opensource.org/licenses/mit-license
                                 *
                                 * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
                                 */
                                (function (t) {
                                    return t.type === s.c.TYPE.JSON
                                }(e)) && e.data.bones
                                var i = (function (t) {
                            return t.xhrType === s.c.XHR_RESPONSE_TYPE.BUFFER
                        }(e)) && (e.extension === 'skel' || e.metadata && e.metadata.spineMetadata)
                        if (!r && !i) return n()
                        var o = null
                                var a = e.data
                        r ? o = t.createJsonParser() : (o = t.createBinaryParser(), e.data instanceof ArrayBuffer && (a = new Uint8Array(e.data)))
                        var u = e.metadata || {}
                                var l = u ? u.spineSkeletonScale : null
                        l && (o.scale = l)
                        var h = u.spineAtlas
                        if (!1 === h) return n()
                        if (h && h.pages) return t.parseData(e, o, h, a), n()
                        var f = u.spineAtlasSuffix || '.atlas';
                            var d = e.url;
                            var p = d.indexOf('?')
                        p > 0 && (d = d.substr(0, p)), d = d.substr(0, d.lastIndexOf('.')) + f, u.spineAtlasFile && (d = u.spineAtlasFile), d = d.replace(this.baseUrl, '')
                        var m = {
                            crossOrigin: e.crossOrigin,
                            xhrType: s.c.XHR_RESPONSE_TYPE.TEXT,
                            metadata: u.spineMetadata || null,
                            parentResource: e
                        };
                        var y = {
                            crossOrigin: e.crossOrigin,
                            metadata: u.imageMetadata || null,
                            parentResource: e
                        };
                        var v = e.url.substr(0, e.url.lastIndexOf('/') + 1)
                        v = v.replace(this.baseUrl, '')
                        var _ = u.imageNamePrefix || `${e.name }_atlas_page_`;
                            var g = u.images
                                ? Q(u.images)
                                : u.image
                                    ? Q({
                                            default: u.image
                                        })
                                    : u.imageLoader
                                        ? u.imageLoader(this, _, v, y)
                                        : (function (t, e, n, r) {
                                                n && n.lastIndexOf('/') !== n.length - 1 && (n += '/');
                                                return function (i, o) {
                                                    var a = e + i;
                                            var s = n + i;
                                            var u = t.resources[a]
                                        if (u) {
                                                        var l = function () {
                                                            o(u.texture.baseTexture)
                                                        };
                                                        u.texture ? l() : u.onAfterMiddleware.add(l)
                                                    } else { t.add(a, s, r, (function(t) {
                                            t.error ? o(null) : (i.indexOf("-pma.") >= 0 && (t.texture.baseTexture.alphaMode = c.a.PMA), o(t.texture.baseTexture))
                                        }))
}
                                                }
                                            }(this, _, v, y))

                        function b(r) {
                            new I(r, g, ((r) => {
                                    r && t.parseData(e, o, r, a), n()
                                }))
                        }
                        u.atlasRawData
                            ? b(u.atlasRawData)
                            : this.add(`${e.name }_atlas`, d, m, (t) => {
                                    t.error ? n() : b(t.data)
                                })
                    }
                }
            }, t
        }())

        function Q(t) {
            return function (e, n) {
                const r = t[e] || t.default
                r && r.baseTexture ? n(r.baseTexture) : n(r)
            }
        }
        /*!
             * @pixi-spine/runtime-3.8 - v3.0.13
             * Compiled Mon, 13 Sep 2021 16:46:34 UTC
             *
             * @pixi-spine/runtime-3.8 is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             *
             * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
             */
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
        let tt = function (t, e) {
            return (tt = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            })(t, e)
        }

        function et(t, e) {
            if (typeof e != 'function' && e !== null) throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`)

            function n() {
                this.constructor = t
            }
            tt(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        let nt; var rt = function (t) {
            if (t == null) throw new Error('name cannot be null.')
            this.name = t
        }
        var it = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.id = (65535 & e.nextID++) << 11, r.worldVerticesLength = 0, r.deformAttachment = r, r
            }
            return et(e, t), e.prototype.computeWorldVerticesOld = function (t, e) {
                this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
            }, e.prototype.computeWorldVertices = function (t, e, n, r, i, o) {
                n = i + (n >> 1) * o
                let a = t.bone.skeleton
                var s = t.deform
                var u = this.vertices
                var c = this.bones
                if (c != null) {
                    for (var l = 0, h = 0, f = 0; f < e; f += 2) {
                        l += (y = c[l]) + 1, h += y
                    }
                    const d = a.bones
                    if (s.length == 0) {
                        for (R = i, S = 3 * h; R < n; R += o) {
                            var p = 0
                                        var m = 0
                                        var y = c[l++]
                            for (y += l; l < y; l++, S += 3) {
                                b = d[c[l]].matrix, A = u[S], I = u[S + 1]
                                var v = u[S + 2]
                                p += (A * b.a + I * b.c + b.tx) * v, m += (A * b.b + I * b.d + b.ty) * v
                            }
                            r[R] = p, r[R + 1] = m
                        }
                    } else {
                        for (let _ = s, g = (R = i, S = 3 * h, h << 1); R < n; R += o) {
                            p = 0, m = 0, y = c[l++]
                            for (y += l; l < y; l++, S += 3, g += 2) {
                                b = d[c[l]].matrix, A = u[S] + _[g], I = u[S + 1] + _[g + 1], v = u[S + 2]
                                p += (A * b.a + I * b.c + b.tx) * v, m += (A * b.b + I * b.d + b.ty) * v
                            }
                            r[R] = p, r[R + 1] = m
                        }
                    }
                } else {
                    s.length > 0 && (u = s)
                    for (var b, E = (b = t.bone.matrix).tx, x = b.ty, T = b.a, S = b.c, w = b.b, O = b.d, P = e, R = i; R < n; P += 2, R += o) {
                        var A = u[P]
                        var I = u[P + 1]
                        r[R] = A * T + I * S + E, r[R + 1] = A * w + I * O + x
                    }
                }
            }, e.prototype.copyTo = function (t) {
                this.bones != null ? (t.bones = Array.from({ length: this.bones.length }), G.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length)) : t.bones = null, this.vertices != null ? (t.vertices = G.newFloatArray(this.vertices.length), G.arrayCopy(this.vertices, 0, t.vertices, 0, this.vertices.length)) : t.vertices = null, t.worldVerticesLength = this.worldVerticesLength, t.deformAttachment = this.deformAttachment
            }, e.nextID = 0, e
        }(rt))
        var ot = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.BoundingBox, n.color = new F(1, 1, 1, 1), n
            }
            return et(e, t), e.prototype.copy = function () {
                const t = new e(this.name)
                return this.copyTo(t), t.color.setFromColor(this.color), t
            }, e
        }(it))
        var at = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Clipping, n.color = new F(0.2275, 0.2275, 0.8078, 1), n
            }
            return et(e, t), e.prototype.copy = function () {
                const t = new e(this.name)
                return this.copyTo(t), t.endSlot = this.endSlot, t.color.setFromColor(this.color), t
            }, e
        }(it))
        var st = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Mesh, n.color = new F(1, 1, 1, 1), n.tempColor = new F(0, 0, 0, 0), n
            }
            return et(e, t), e.prototype.getParentMesh = function () {
                return this.parentMesh
            }, e.prototype.setParentMesh = function (t) {
                this.parentMesh = t, t != null && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength)
            }, e.prototype.copy = function () {
                if (this.parentMesh != null) return this.newLinkedMesh()
                let t = new e(this.name)
                return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), this.copyTo(t), t.regionUVs = new Float32Array(this.regionUVs.length), G.arrayCopy(this.regionUVs, 0, t.regionUVs, 0, this.regionUVs.length), t.triangles = Array.from({ length: this.triangles.length }), G.arrayCopy(this.triangles, 0, t.triangles, 0, this.triangles.length), t.hullLength = this.hullLength, this.edges != null && (t.edges = Array.from({ length: this.edges.length }), G.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)), t.width = this.width, t.height = this.height, t
            }, e.prototype.newLinkedMesh = function () {
                const t = new e(this.name)
                return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), t.deformAttachment = this.deformAttachment, t.setParentMesh(this.parentMesh != null ? this.parentMesh : this), t
            }, e
        }(it))
        var ut = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Path, n.closed = !1, n.constantSpeed = !1, n.color = new F(1, 1, 1, 1), n
            }
            return et(e, t), e.prototype.copy = function () {
                const t = new e(this.name)
                return this.copyTo(t), t.lengths = Array.from({ length: this.lengths.length }), G.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length), t.closed = closed, t.constantSpeed = this.constantSpeed, t.color.setFromColor(this.color), t
            }, e
        }(it))
        var ct = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Point, n.color = new F(0.38, 0.94, 0, 1), n
            }
            return et(e, t), e.prototype.computeWorldPosition = function (t, e) {
                const n = t.matrix
                return e.x = this.x * n.a + this.y * n.c + t.worldX, e.y = this.x * n.b + this.y * n.d + t.worldY, e
            }, e.prototype.computeWorldRotation = function (t) {
                const e = t.matrix
                var n = B.cosDeg(this.rotation)
                var r = B.sinDeg(this.rotation)
                var i = n * e.a + r * e.c
                var o = n * e.b + r * e.d
                return Math.atan2(o, i) * B.radDeg
            }, e.prototype.copy = function () {
                const t = new e(this.name)
                return t.x = this.x, t.y = this.y, t.rotation = this.rotation, t.color.setFromColor(this.color), t
            }, e
        }(it))
        var lt = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Region, n.x = 0, n.y = 0, n.scaleX = 1, n.scaleY = 1, n.rotation = 0, n.width = 0, n.height = 0, n.color = new F(1, 1, 1, 1), n.offset = G.newFloatArray(8), n.uvs = G.newFloatArray(8), n.tempColor = new F(1, 1, 1, 1), n
            }
            return et(e, t), e.prototype.updateOffset = function () {
                const t = this.width / this.region.originalWidth * this.scaleX
                var n = this.height / this.region.originalHeight * this.scaleY
                var r = -this.width / 2 * this.scaleX + this.region.offsetX * t
                var i = -this.height / 2 * this.scaleY + this.region.offsetY * n
                var o = r + this.region.width * t
                var a = i + this.region.height * n
                var s = this.rotation * Math.PI / 180
                var u = Math.cos(s)
                var c = Math.sin(s)
                var l = r * u + this.x
                var h = r * c
                var f = i * u + this.y
                var d = i * c
                var p = o * u + this.x
                var m = o * c
                var y = a * u + this.y
                var v = a * c
                var _ = this.offset
                _[e.OX1] = l - d, _[e.OY1] = f + h, _[e.OX2] = l - v, _[e.OY2] = y + h, _[e.OX3] = p - v, _[e.OY3] = y + m, _[e.OX4] = p - d, _[e.OY4] = f + m
            }, e.prototype.setRegion = function (t) {
                this.region = t
                let e = this.uvs
                t.rotate ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2)
            }, e.prototype.computeWorldVertices = function (t, n, r, i) {
                const o = this.offset
                var a = t.matrix
                var s = a.tx
                var u = a.ty
                var c = a.a
                var l = a.c
                var h = a.b
                var f = a.d
                var d = 0
                var p = 0
                d = o[e.OX1], p = o[e.OY1], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX2], p = o[e.OY2], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX3], p = o[e.OY3], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX4], p = o[e.OY4], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u
            }, e.prototype.copy = function () {
                const t = new e(this.name)
                return t.region = this.region, t.rendererObject = this.rendererObject, t.path = this.path, t.x = this.x, t.y = this.y, t.scaleX = this.scaleX, t.scaleY = this.scaleY, t.rotation = this.rotation, t.width = this.width, t.height = this.height, G.arrayCopy(this.uvs, 0, t.uvs, 0, 8), G.arrayCopy(this.offset, 0, t.offset, 0, 8), t.color.setFromColor(this.color), t
            }, e.OX1 = 0, e.OY1 = 1, e.OX2 = 2, e.OY2 = 3, e.OX3 = 4, e.OY3 = 5, e.OX4 = 6, e.OY4 = 7, e.X1 = 0, e.Y1 = 1, e.C1R = 2, e.C1G = 3, e.C1B = 4, e.C1A = 5, e.U1 = 6, e.V1 = 7, e.X2 = 8, e.Y2 = 9, e.C2R = 10, e.C2G = 11, e.C2B = 12, e.C2A = 13, e.U2 = 14, e.V2 = 15, e.X3 = 16, e.Y3 = 17, e.C3R = 18, e.C3G = 19, e.C3B = 20, e.C3A = 21, e.U3 = 22, e.V3 = 23, e.X4 = 24, e.Y4 = 25, e.C4R = 26, e.C4G = 27, e.C4B = 28, e.C4A = 29, e.U4 = 30, e.V4 = 31, e
        }(rt))
        var ht = (function () {
            function t(t, e) {
                this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e
            }
            return t.prototype.begin = function (t) {}, t.prototype.transform = function (t, e, n, r) {
                t.x += B.randomTriangular(-this.jitterX, this.jitterY), t.y += B.randomTriangular(-this.jitterX, this.jitterY)
            }, t.prototype.end = function () {}, t
        }())
        var ft = (function () {
            function t(t) {
                this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t
            }
            return t.prototype.begin = function (t) {
                this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY
            }, t.prototype.transform = function (e, n, r, i) {
                const o = this.angle * B.degreesToRadians
                var a = e.x - this.worldX
                var s = e.y - this.worldY
                var u = Math.sqrt(a * a + s * s)
                if (u < this.radius) {
                    const c = t.interpolation.apply(0, o, (this.radius - u) / this.radius)
                    var l = Math.cos(c)
                    var h = Math.sin(c)
                    e.x = l * a - h * s + this.worldX, e.y = h * a + l * s + this.worldY
                }
            }, t.prototype.end = function () {}, t.interpolation = new U(2), t
        }())
        var dt = (function () {
            function t(t, e, n) {
                if (t == null) throw new Error('name cannot be null.')
                if (e == null) throw new Error('timelines cannot be null.')
                this.name = t, this.timelines = e, this.timelineIds = []
                for (let r = 0; r < e.length; r++) this.timelineIds[e[r].getPropertyId()] = !0
                this.duration = n
            }
            return t.prototype.hasTimeline = function (t) {
                return this.timelineIds[t] == 1
            }, t.prototype.apply = function (t, e, n, r, i, o, a, s) {
                if (t == null) throw new Error('skeleton cannot be null.')
                r && this.duration != 0 && (n %= this.duration, e > 0 && (e %= this.duration))
                for (let u = this.timelines, c = 0, l = u.length; c < l; c++) u[c].apply(t, e, n, i, o, a, s)
            }, t.binarySearch = function (t, e, n) {
                void 0 === n && (n = 1)
                let r = 0
                let i = t.length / n - 2
                if (i == 0) return n
                for (let o = i >>> 1; ;) {
                    if (t[(o + 1) * n] <= e ? r = o + 1 : i = o, r == i) return (r + 1) * n
                    o = r + i >>> 1
                }
            }, t.linearSearch = function (t, e, n) {
                for (let r = 0, i = t.length - n; r <= i; r += n) {
                    if (t[r] > e) return r
                }
                return -1
            }, t
        }())
        !(function (t) {
            t[t.rotate = 0] = 'rotate', t[t.translate = 1] = 'translate', t[t.scale = 2] = 'scale', t[t.shear = 3] = 'shear', t[t.attachment = 4] = 'attachment', t[t.color = 5] = 'color', t[t.deform = 6] = 'deform', t[t.event = 7] = 'event', t[t.drawOrder = 8] = 'drawOrder', t[t.ikConstraint = 9] = 'ikConstraint', t[t.transformConstraint = 10] = 'transformConstraint', t[t.pathConstraintPosition = 11] = 'pathConstraintPosition', t[t.pathConstraintSpacing = 12] = 'pathConstraintSpacing', t[t.pathConstraintMix = 13] = 'pathConstraintMix', t[t.twoColor = 14] = 'twoColor'
        }(nt || (nt = {})))
        let pt; var mt = (function () {
            function t(e) {
                if (e <= 0) throw new Error(`frameCount must be > 0: ${ e}`)
                this.curves = G.newFloatArray((e - 1) * t.BEZIER_SIZE)
            }
            return t.prototype.getFrameCount = function () {
                return this.curves.length / t.BEZIER_SIZE + 1
            }, t.prototype.setLinear = function (e) {
                this.curves[e * t.BEZIER_SIZE] = t.LINEAR
            }, t.prototype.setStepped = function (e) {
                this.curves[e * t.BEZIER_SIZE] = t.STEPPED
            }, t.prototype.getCurveType = function (e) {
                const n = e * t.BEZIER_SIZE
                if (n == this.curves.length) return t.LINEAR
                let r = this.curves[n]
                return r == t.LINEAR ? t.LINEAR : r == t.STEPPED ? t.STEPPED : t.BEZIER
            }, t.prototype.setCurve = function (e, n, r, i, o) {
                const a = 0.03 * (2 * -n + i)
                var s = 0.03 * (2 * -r + o)
                var u = 0.006 * (3 * (n - i) + 1)
                var c = 0.006 * (3 * (r - o) + 1)
                var l = 2 * a + u
                var h = 2 * s + c
                var f = 0.3 * n + a + 0.16666667 * u
                var d = 0.3 * r + s + 0.16666667 * c
                var p = e * t.BEZIER_SIZE
                var m = this.curves
                m[p++] = t.BEZIER
                for (let y = f, v = d, _ = p + t.BEZIER_SIZE - 1; p < _; p += 2) m[p] = y, m[p + 1] = v, f += l, d += h, l += u, h += c, y += f, v += d
            }, t.prototype.getCurvePercent = function (e, n) {
                n = B.clamp(n, 0, 1)
                let r = this.curves
                var i = e * t.BEZIER_SIZE
                var o = r[i]
                if (o == t.LINEAR) return n
                if (o == t.STEPPED) return 0
                for (var a = 0, s = ++i, u = i + t.BEZIER_SIZE - 1; i < u; i += 2) {
                    if ((a = r[i]) >= n) {
                        let c = void 0
                                    var l = void 0
                        return i == s ? (c = 0, l = 0) : (c = r[i - 2], l = r[i - 1]), l + (r[i + 1] - l) * (n - c) / (a - c)
                    }
                }
                const h = r[i - 1]
                return h + (1 - h) * (n - a) / (1 - a)
            }, t.LINEAR = 0, t.STEPPED = 1, t.BEZIER = 2, t.BEZIER_SIZE = 19, t
        }())
        var yt = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.frames = G.newFloatArray(e << 1), n
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.rotate << 24) + this.boneIndex
            }, e.prototype.setFrame = function (t, n, r) {
                t <<= 1, this.frames[t] = n, this.frames[t + e.ROTATION] = r
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.bones[this.boneIndex]
                if (c.active) {
                    if (r < u[0]) { switch (a) {
                        case y.setup:
                            return void (c.rotation = c.data.rotation)
                                case y.first:
                            var l = c.data.rotation - c.rotation
                                    c.rotation += (l - 360 * (16384 - (16384.499999999996 - l / 360 | 0))) * o
                    }
                    } else if (r >= u[u.length - e.ENTRIES]) {
                        let h = u[u.length + e.PREV_ROTATION]
                        switch (a) {
                            case y.setup:
                                c.rotation = c.data.rotation + h * o
                                break;
                            case y.first:
                            case y.replace:
                                h += c.data.rotation - c.rotation, h -= 360 * (16384 - (16384.499999999996 - h / 360 | 0))
                            case y.add:
                                c.rotation += h * o
                        }
                    } else {
                        let f = dt.binarySearch(u, r, e.ENTRIES)
                                    var d = u[f + e.PREV_ROTATION]
                                    var p = u[f]
                                    var m = this.getCurvePercent((f >> 1) - 1, 1 - (r - p) / (u[f + e.PREV_TIME] - p))
                                    var v = u[f + e.ROTATION] - d
                        switch (v = d + (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * m, a) {
                            case y.setup:
                                c.rotation = c.data.rotation + (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * o
                                break;
                            case y.first:
                            case y.replace:
                                v += c.data.rotation - c.rotation
                            case y.add:
                                c.rotation += (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * o
                        }
                    }
                }
            }, e.ENTRIES = 2, e.PREV_TIME = -2, e.PREV_ROTATION = -1, e.ROTATION = 1, e
        }(mt))
        var vt = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.translate << 24) + this.boneIndex
            }, e.prototype.setFrame = function (t, n, r, i) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.X] = r, this.frames[t + e.Y] = i
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.bones[this.boneIndex]
                if (c.active) {
                    if (r < u[0]) { switch (a) {
                        case y.setup:
                            return c.x = c.data.x, void (c.y = c.data.y)
                                case y.first:
                            c.x += (c.data.x - c.x) * o, c.y += (c.data.y - c.y) * o
                    }
                    } else {
                        let l = 0
                                    var h = 0
                        if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_X], h = u[u.length + e.PREV_Y]
}
                        else {
                            let f = dt.binarySearch(u, r, e.ENTRIES)
                            l = u[f + e.PREV_X], h = u[f + e.PREV_Y]
                            var d = u[f]
                                        var p = this.getCurvePercent(f / e.ENTRIES - 1, 1 - (r - d) / (u[f + e.PREV_TIME] - d))
                            l += (u[f + e.X] - l) * p, h += (u[f + e.Y] - h) * p
                        }
                        switch (a) {
                            case y.setup:
                                c.x = c.data.x + l * o, c.y = c.data.y + h * o
                                break;
                            case y.first:
                            case y.replace:
                                c.x += (c.data.x + l - c.x) * o, c.y += (c.data.y + h - c.y) * o
                                break;
                            case y.add:
                                c.x += l * o, c.y += h * o
                        }
                    }
                }
            }, e.ENTRIES = 3, e.PREV_TIME = -3, e.PREV_X = -2, e.PREV_Y = -1, e.X = 1, e.Y = 2, e
        }(mt))
        var _t = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.scale << 24) + this.boneIndex
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.bones[this.boneIndex]
                if (c.active) {
                    if (r < u[0]) { switch (a) {
                        case y.setup:
                            return c.scaleX = c.data.scaleX, void (c.scaleY = c.data.scaleY)
                                case y.first:
                            c.scaleX += (c.data.scaleX - c.scaleX) * o, c.scaleY += (c.data.scaleY - c.scaleY) * o
                    }
                    } else {
                        let l = 0
                                    var h = 0
                        if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_X] * c.data.scaleX, h = u[u.length + e.PREV_Y] * c.data.scaleY
}
                        else {
                            let f = dt.binarySearch(u, r, e.ENTRIES)
                            l = u[f + e.PREV_X], h = u[f + e.PREV_Y]
                            var d = u[f]
                                        var p = this.getCurvePercent(f / e.ENTRIES - 1, 1 - (r - d) / (u[f + e.PREV_TIME] - d))
                            l = (l + (u[f + e.X] - l) * p) * c.data.scaleX, h = (h + (u[f + e.Y] - h) * p) * c.data.scaleY
                        }
                        if (o == 1) { a == y.add ? (c.scaleX += l - c.data.scaleX, c.scaleY += h - c.data.scaleY) : (c.scaleX = l, c.scaleY = h)
}
                        else {
                            let m = 0
                                        var _ = 0
                            if (s == v.mixOut) { switch (a) {
                                case y.setup:
                                    m = c.data.scaleX, _ = c.data.scaleY, c.scaleX = m + (Math.abs(l) * B.signum(m) - m) * o, c.scaleY = _ + (Math.abs(h) * B.signum(_) - _) * o
                                            break;
                                case y.first:
                                case y.replace:
                                    m = c.scaleX, _ = c.scaleY, c.scaleX = m + (Math.abs(l) * B.signum(m) - m) * o, c.scaleY = _ + (Math.abs(h) * B.signum(_) - _) * o
                                            break;
                                case y.add:
                                    m = c.scaleX, _ = c.scaleY, c.scaleX = m + (Math.abs(l) * B.signum(m) - c.data.scaleX) * o, c.scaleY = _ + (Math.abs(h) * B.signum(_) - c.data.scaleY) * o
                            }
                            } else { switch (a) {
                                case y.setup:
                                    m = Math.abs(c.data.scaleX) * B.signum(l), _ = Math.abs(c.data.scaleY) * B.signum(h), c.scaleX = m + (l - m) * o, c.scaleY = _ + (h - _) * o
                                            break;
                                case y.first:
                                case y.replace:
                                    m = Math.abs(c.scaleX) * B.signum(l), _ = Math.abs(c.scaleY) * B.signum(h), c.scaleX = m + (l - m) * o, c.scaleY = _ + (h - _) * o
                                            break;
                                case y.add:
                                    m = B.signum(l), _ = B.signum(h), c.scaleX = Math.abs(c.scaleX) * m + (l - Math.abs(c.data.scaleX) * m) * o, c.scaleY = Math.abs(c.scaleY) * _ + (h - Math.abs(c.data.scaleY) * _) * o
                            }
                            }
                        }
                    }
                }
            }, e
        }(vt))
        var gt = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.shear << 24) + this.boneIndex
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.bones[this.boneIndex]
                if (c.active) {
                    if (r < u[0]) { switch (a) {
                        case y.setup:
                            return c.shearX = c.data.shearX, void (c.shearY = c.data.shearY)
                                case y.first:
                            c.shearX += (c.data.shearX - c.shearX) * o, c.shearY += (c.data.shearY - c.shearY) * o
                    }
                    } else {
                        let l = 0
                                    var h = 0
                        if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_X], h = u[u.length + e.PREV_Y]
}
                        else {
                            let f = dt.binarySearch(u, r, e.ENTRIES)
                            l = u[f + e.PREV_X], h = u[f + e.PREV_Y]
                            var d = u[f]
                                        var p = this.getCurvePercent(f / e.ENTRIES - 1, 1 - (r - d) / (u[f + e.PREV_TIME] - d))
                            l += (u[f + e.X] - l) * p, h += (u[f + e.Y] - h) * p
                        }
                        switch (a) {
                            case y.setup:
                                c.shearX = c.data.shearX + l * o, c.shearY = c.data.shearY + h * o
                                break;
                            case y.first:
                            case y.replace:
                                c.shearX += (c.data.shearX + l - c.shearX) * o, c.shearY += (c.data.shearY + h - c.shearY) * o
                                break;
                            case y.add:
                                c.shearX += l * o, c.shearY += h * o
                        }
                    }
                }
            }, e
        }(vt))
        var bt = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.color << 24) + this.slotIndex
            }, e.prototype.setFrame = function (t, n, r, i, o, a) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.R] = r, this.frames[t + e.G] = i, this.frames[t + e.B] = o, this.frames[t + e.A] = a
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = t.slots[this.slotIndex]
                if (u.bone.active) {
                    const c = this.frames
                    if (r < c[0]) { switch (a) {
                        case y.setup:
                            return void u.color.setFromColor(u.data.color)
                        case y.first:
                            var l = u.color
                                        var h = u.data.color
                            l.add((h.r - l.r) * o, (h.g - l.g) * o, (h.b - l.b) * o, (h.a - l.a) * o)
                    }
                    } else {
                        let f = 0
                        var d = 0
                        var p = 0
                        var m = 0
                        if (r >= c[c.length - e.ENTRIES]) {
                            const v = c.length
                            f = c[v + e.PREV_R], d = c[v + e.PREV_G], p = c[v + e.PREV_B], m = c[v + e.PREV_A]
                        } else {
                            const _ = dt.binarySearch(c, r, e.ENTRIES)
                            f = c[_ + e.PREV_R], d = c[_ + e.PREV_G], p = c[_ + e.PREV_B], m = c[_ + e.PREV_A]
                            let g = c[_]
                            var b = this.getCurvePercent(_ / e.ENTRIES - 1, 1 - (r - g) / (c[_ + e.PREV_TIME] - g))
                            f += (c[_ + e.R] - f) * b, d += (c[_ + e.G] - d) * b, p += (c[_ + e.B] - p) * b, m += (c[_ + e.A] - m) * b
                        }
                        if (o == 1) { u.color.set(f, d, p, m)
                        }
                        else {
                            l = u.color
                            a == y.setup && l.setFromColor(u.data.color), l.add((f - l.r) * o, (d - l.g) * o, (p - l.b) * o, (m - l.a) * o)
                        }
                    }
                }
            }, e.ENTRIES = 5, e.PREV_TIME = -5, e.PREV_R = -4, e.PREV_G = -3, e.PREV_B = -2, e.PREV_A = -1, e.R = 1, e.G = 2, e.B = 3, e.A = 4, e
        }(mt))
        var Et = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.twoColor << 24) + this.slotIndex
            }, e.prototype.setFrame = function (t, n, r, i, o, a, s, u, c) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.R] = r, this.frames[t + e.G] = i, this.frames[t + e.B] = o, this.frames[t + e.A] = a, this.frames[t + e.R2] = s, this.frames[t + e.G2] = u, this.frames[t + e.B2] = c
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = t.slots[this.slotIndex]
                if (u.bone.active) {
                    const c = this.frames
                    if (r < c[0]) { switch (a) {
                        case y.setup:
                            return u.color.setFromColor(u.data.color), void u.darkColor.setFromColor(u.data.darkColor)
                        case y.first:
                            var l = u.color
                                        var h = u.darkColor
                                        var f = u.data.color
                                        var d = u.data.darkColor
                            l.add((f.r - l.r) * o, (f.g - l.g) * o, (f.b - l.b) * o, (f.a - l.a) * o), h.add((d.r - h.r) * o, (d.g - h.g) * o, (d.b - h.b) * o, 0)
                    }
                    } else {
                        let p = 0
                        var m = 0
                        var v = 0
                        var _ = 0
                        var g = 0
                        var b = 0
                        var E = 0
                        if (r >= c[c.length - e.ENTRIES]) {
                            const x = c.length
                            p = c[x + e.PREV_R], m = c[x + e.PREV_G], v = c[x + e.PREV_B], _ = c[x + e.PREV_A], g = c[x + e.PREV_R2], b = c[x + e.PREV_G2], E = c[x + e.PREV_B2]
                        } else {
                            const T = dt.binarySearch(c, r, e.ENTRIES)
                            p = c[T + e.PREV_R], m = c[T + e.PREV_G], v = c[T + e.PREV_B], _ = c[T + e.PREV_A], g = c[T + e.PREV_R2], b = c[T + e.PREV_G2], E = c[T + e.PREV_B2]
                            let S = c[T]
                            var w = this.getCurvePercent(T / e.ENTRIES - 1, 1 - (r - S) / (c[T + e.PREV_TIME] - S))
                            p += (c[T + e.R] - p) * w, m += (c[T + e.G] - m) * w, v += (c[T + e.B] - v) * w, _ += (c[T + e.A] - _) * w, g += (c[T + e.R2] - g) * w, b += (c[T + e.G2] - b) * w, E += (c[T + e.B2] - E) * w
                        }
                        if (o == 1) { u.color.set(p, m, v, _), u.darkColor.set(g, b, E, 1)
                        }
                        else {
                            l = u.color, h = u.darkColor
                            a == y.setup && (l.setFromColor(u.data.color), h.setFromColor(u.data.darkColor)), l.add((p - l.r) * o, (m - l.g) * o, (v - l.b) * o, (_ - l.a) * o), h.add((g - h.r) * o, (b - h.g) * o, (E - h.b) * o, 0)
                        }
                    }
                }
            }, e.ENTRIES = 8, e.PREV_TIME = -8, e.PREV_R = -7, e.PREV_G = -6, e.PREV_B = -5, e.PREV_A = -4, e.PREV_R2 = -3, e.PREV_G2 = -2, e.PREV_B2 = -1, e.R = 1, e.G = 2, e.B = 3, e.A = 4, e.R2 = 5, e.G2 = 6, e.B2 = 7, e
        }(mt))
        var xt = (function () {
            function t(t) {
                this.frames = G.newFloatArray(t), this.attachmentNames = new Array(t)
            }
            return t.prototype.getPropertyId = function () {
                return (nt.attachment << 24) + this.slotIndex
            }, t.prototype.getFrameCount = function () {
                return this.frames.length
            }, t.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.attachmentNames[t] = n
            }, t.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (s.bone.active) {
                    if (a != v.mixOut) {
                        let u = this.frames
                        if (n < u[0]) { o != y.setup && o != y.first || this.setAttachment(t, s, s.data.attachmentName)
}
                        else {
                            let c = 0
                            c = n >= u[u.length - 1] ? u.length - 1 : dt.binarySearch(u, n, 1) - 1
                            var l = this.attachmentNames[c]
                            t.slots[this.slotIndex].setAttachment(l == null ? null : t.getAttachment(this.slotIndex, l))
                        }
                    } else { o == y.setup && this.setAttachment(t, s, s.data.attachmentName)
                    }
                }
            }, t.prototype.setAttachment = function (t, e, n) {
                e.setAttachment(n == null ? null : t.getAttachment(this.slotIndex, n))
            }, t
        }())
        let Tt = null
        var St = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.frames = G.newFloatArray(e), n.frameVertices = new Array(e), Tt == null && (Tt = G.newFloatArray(64)), n
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.deform << 27) + +this.attachment.id + this.slotIndex
            }, e.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.frameVertices[t] = n
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (s.bone.active) {
                    const u = s.getAttachment()
                    if (u instanceof it && u.deformAttachment == this.attachment) {
                        const c = s.deform
                        c.length == 0 && (o = y.setup)
                        let l = this.frameVertices
                        var h = l[0].length
                        var f = this.frames
                        if (n < f[0]) {
                            var d = u
                            switch (o) {
                                case y.setup:
                                    return void (c.length = 0)
                                case y.first:
                                    if (i == 1) {
                                        c.length = 0
                                        break
                                    }
                                    var p = G.setArraySize(c, h)
                                    if (d.bones == null) {
                                        for (var m = d.vertices, v = 0; v < h; v++) p[v] += (m[v] - p[v]) * i
                                    }
                                    else {
                                        i = 1 - i
                                        for (v = 0; v < h; v++) p[v] *= i
                                    }
                            }
                        } else {
                            const _ = G.setArraySize(c, h)
                            if (n >= f[f.length - 1]) {
                                const g = l[f.length - 1]
                                if (i == 1) {
                                    if (o == y.add) {
                                        if ((d = u).bones == null) {
                                            m = d.vertices
                                                    for (let b = 0; b < h; b++) _[b] += g[b] - m[b]
                                        } else {
                                                    for (var E = 0; E < h; E++) _[E] += g[E];
}
                                    }
                                    else { G.arrayCopy(g, 0, _, 0, h)
}
                                }
                                else { switch (o) {
                                    case y.setup:
                                        var x = u
                                        if (x.bones == null) {
                                            m = x.vertices
                                            for (let T = 0; T < h; T++) {
                                                var S = m[T]
                                                _[T] = S + (g[T] - S) * i
                                            }
                                        } else {
                                            for (let w = 0; w < h; w++) _[w] = g[w] * i
}
                                        break
                                    case y.first:
                                    case y.replace:
                                        for (let O = 0; O < h; O++) _[O] += (g[O] - _[O]) * i
                                        break;
                                    case y.add:
                                        if ((d = u).bones == null) {
                                            m = d.vertices
                                            for (let P = 0; P < h; P++) _[P] += (g[P] - m[P]) * i
                                        } else {
                                            for (let R = 0; R < h; R++) _[R] += g[R] * i
                                        }
                                }
                                }
                            } else {
                                const A = dt.binarySearch(f, n)
                                var I = l[A - 1]
                                var C = l[A]
                                var k = f[A]
                                var N = this.getCurvePercent(A - 1, 1 - (n - k) / (f[A - 1] - k))
                                if (i == 1) {
                                    if (o == y.add) {
                                        if ((d = u).bones == null) {
                                            m = d.vertices
                                                    for (let M = 0; M < h; M++) {
                                                var j = I[M]
                                                        _[M] += j + (C[M] - j) * N - m[M]
                                            }
                                        } else {
                                                    for (var D = 0; D < h; D++) {
                                                        j = I[D];
                                                        _[D] += j + (C[D] - j) * N
                                                    }
}
                                    } else {
                                        for (let L = 0; L < h; L++) {
                                            j = I[L]
                                                            _[L] = j + (C[L] - j) * N
                                        }
                                    }
                                } else { switch (o) {
                                    case y.setup:
                                        var F = u
                                        if (F.bones == null) {
                                            m = F.vertices
                                            for (let B = 0; B < h; B++) {
                                                j = I[B], S = m[B]
                                                _[B] = S + (j + (C[B] - j) * N - S) * i
                                            }
                                        } else {
                                            for (let U = 0; U < h; U++) {
                                                j = I[U]
                                                                        _[U] = (j + (C[U] - j) * N) * i
                                            }
                                        }
                                        break
                                    case y.first:
                                    case y.replace:
                                        for (let X = 0; X < h; X++) {
                                            j = I[X]
                                            _[X] += (j + (C[X] - j) * N - _[X]) * i
                                        }
                                        break
                                    case y.add:
                                        if ((d = u).bones == null) {
                                            m = d.vertices
                                            for (let H = 0; H < h; H++) {
                                                j = I[H]
                                                _[H] += (j + (C[H] - j) * N - m[H]) * i
                                            }
                                        } else {
                                            for (let V = 0; V < h; V++) {
                                                j = I[V]
                                                                        _[V] += (j + (C[V] - j) * N) * i
                                            }
                                        }
                                }
                                }
                            }
                        }
                    }
                }
            }, e
        }(mt))
        var wt = (function () {
            function t(t) {
                this.frames = G.newFloatArray(t), this.events = new Array(t)
            }
            return t.prototype.getPropertyId = function () {
                return nt.event << 24
            }, t.prototype.getFrameCount = function () {
                return this.frames.length
            }, t.prototype.setFrame = function (t, e) {
                this.frames[t] = e.time, this.events[t] = e
            }, t.prototype.apply = function (t, e, n, r, i, o, a) {
                if (r != null) {
                    const s = this.frames
                    var u = this.frames.length
                    if (e > n) this.apply(t, e, Number.MAX_VALUE, r, i, o, a), e = -1
                    else if (e >= s[u - 1]) return
                    if (!(n < s[0])) {
                        let c = 0
                        if (e < s[0]) { c = 0
                        }
                        else {
                            for (let l = s[c = dt.binarySearch(s, e)]; c > 0 && s[c - 1] == l;) c--
                        }
                        for (; c < u && n >= s[c]; c++) r.push(this.events[c])
                    }
                }
            }, t
        }())
        var Ot = (function () {
            function t(t) {
                this.frames = G.newFloatArray(t), this.drawOrders = new Array(t)
            }
            return t.prototype.getPropertyId = function () {
                return nt.drawOrder << 24
            }, t.prototype.getFrameCount = function () {
                return this.frames.length
            }, t.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.drawOrders[t] = n
            }, t.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.drawOrder
                var u = t.slots
                if (a != v.mixOut || o != y.setup) {
                    const c = this.frames
                    if (n < c[0]) { o != y.setup && o != y.first || G.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length)
                    }
                    else {
                        let l = 0
                        l = n >= c[c.length - 1] ? c.length - 1 : dt.binarySearch(c, n) - 1
                        let h = this.drawOrders[l]
                        if (h == null) { G.arrayCopy(u, 0, s, 0, u.length)
                        }
                        else {
                            for (let f = 0, d = h.length; f < d; f++) s[f] = u[h[f]]
                        }
                    }
                } else { G.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length)
                }
            }, t
        }())
        var Pt = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.ikConstraint << 24) + this.ikConstraintIndex
            }, e.prototype.setFrame = function (t, n, r, i, o, a, s) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.MIX] = r, this.frames[t + e.SOFTNESS] = i, this.frames[t + e.BEND_DIRECTION] = o, this.frames[t + e.COMPRESS] = a ? 1 : 0, this.frames[t + e.STRETCH] = s ? 1 : 0
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.ikConstraints[this.ikConstraintIndex]
                if (c.active) {
                    if (r < u[0]) { switch (a) {
                        case y.setup:
                            return c.mix = c.data.mix, c.softness = c.data.softness, c.bendDirection = c.data.bendDirection, c.compress = c.data.compress, void (c.stretch = c.data.stretch)
                                    case y.first:
                            c.mix += (c.data.mix - c.mix) * o, c.softness += (c.data.softness - c.softness) * o, c.bendDirection = c.data.bendDirection, c.compress = c.data.compress, c.stretch = c.data.stretch
                    }
                    } else if (r >= u[u.length - e.ENTRIES]) { a == y.setup ? (c.mix = c.data.mix + (u[u.length + e.PREV_MIX] - c.data.mix) * o, c.softness = c.data.softness + (u[u.length + e.PREV_SOFTNESS] - c.data.softness) * o, s == v.mixOut ? (c.bendDirection = c.data.bendDirection, c.compress = c.data.compress, c.stretch = c.data.stretch) : (c.bendDirection = u[u.length + e.PREV_BEND_DIRECTION], c.compress = u[u.length + e.PREV_COMPRESS] != 0, c.stretch = u[u.length + e.PREV_STRETCH] != 0)) : (c.mix += (u[u.length + e.PREV_MIX] - c.mix) * o, c.softness += (u[u.length + e.PREV_SOFTNESS] - c.softness) * o, s == v.mixIn && (c.bendDirection = u[u.length + e.PREV_BEND_DIRECTION], c.compress = u[u.length + e.PREV_COMPRESS] != 0, c.stretch = u[u.length + e.PREV_STRETCH] != 0))
}
                    else {
                        let l = dt.binarySearch(u, r, e.ENTRIES)
                                        var h = u[l + e.PREV_MIX]
                                        var f = u[l + e.PREV_SOFTNESS]
                                        var d = u[l]
                                        var p = this.getCurvePercent(l / e.ENTRIES - 1, 1 - (r - d) / (u[l + e.PREV_TIME] - d))
                        a == y.setup ? (c.mix = c.data.mix + (h + (u[l + e.MIX] - h) * p - c.data.mix) * o, c.softness = c.data.softness + (f + (u[l + e.SOFTNESS] - f) * p - c.data.softness) * o, s == v.mixOut ? (c.bendDirection = c.data.bendDirection, c.compress = c.data.compress, c.stretch = c.data.stretch) : (c.bendDirection = u[l + e.PREV_BEND_DIRECTION], c.compress = u[l + e.PREV_COMPRESS] != 0, c.stretch = u[l + e.PREV_STRETCH] != 0)) : (c.mix += (h + (u[l + e.MIX] - h) * p - c.mix) * o, c.softness += (f + (u[l + e.SOFTNESS] - f) * p - c.softness) * o, s == v.mixIn && (c.bendDirection = u[l + e.PREV_BEND_DIRECTION], c.compress = u[l + e.PREV_COMPRESS] != 0, c.stretch = u[l + e.PREV_STRETCH] != 0))
                    }
                }
            }, e.ENTRIES = 6, e.PREV_TIME = -6, e.PREV_MIX = -5, e.PREV_SOFTNESS = -4, e.PREV_BEND_DIRECTION = -3, e.PREV_COMPRESS = -2, e.PREV_STRETCH = -1, e.MIX = 1, e.SOFTNESS = 2, e.BEND_DIRECTION = 3, e.COMPRESS = 4, e.STRETCH = 5, e
        }(mt))
        var Rt = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.transformConstraint << 24) + this.transformConstraintIndex
            }, e.prototype.setFrame = function (t, n, r, i, o, a) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.ROTATE] = r, this.frames[t + e.TRANSLATE] = i, this.frames[t + e.SCALE] = o, this.frames[t + e.SHEAR] = a
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.transformConstraints[this.transformConstraintIndex]
                if (c.active) {
                    if (r < u[0]) {
                        var l = c.data
                        switch (a) {
                            case y.setup:
                                return c.rotateMix = l.rotateMix, c.translateMix = l.translateMix, c.scaleMix = l.scaleMix, void (c.shearMix = l.shearMix)
                            case y.first:
                                c.rotateMix += (l.rotateMix - c.rotateMix) * o, c.translateMix += (l.translateMix - c.translateMix) * o, c.scaleMix += (l.scaleMix - c.scaleMix) * o, c.shearMix += (l.shearMix - c.shearMix) * o
                        }
                    } else {
                        let h = 0
                                    var f = 0
                                    var d = 0
                                    var p = 0
                        if (r >= u[u.length - e.ENTRIES]) {
                            let m = u.length
                            h = u[m + e.PREV_ROTATE], f = u[m + e.PREV_TRANSLATE], d = u[m + e.PREV_SCALE], p = u[m + e.PREV_SHEAR]
                        } else {
                            let v = dt.binarySearch(u, r, e.ENTRIES)
                            h = u[v + e.PREV_ROTATE], f = u[v + e.PREV_TRANSLATE], d = u[v + e.PREV_SCALE], p = u[v + e.PREV_SHEAR]
                            var _ = u[v]
                                        var g = this.getCurvePercent(v / e.ENTRIES - 1, 1 - (r - _) / (u[v + e.PREV_TIME] - _))
                            h += (u[v + e.ROTATE] - h) * g, f += (u[v + e.TRANSLATE] - f) * g, d += (u[v + e.SCALE] - d) * g, p += (u[v + e.SHEAR] - p) * g
                        }
                        if (a == y.setup) {
                            l = c.data
                            c.rotateMix = l.rotateMix + (h - l.rotateMix) * o, c.translateMix = l.translateMix + (f - l.translateMix) * o, c.scaleMix = l.scaleMix + (d - l.scaleMix) * o, c.shearMix = l.shearMix + (p - l.shearMix) * o
                        } else { c.rotateMix += (h - c.rotateMix) * o, c.translateMix += (f - c.translateMix) * o, c.scaleMix += (d - c.scaleMix) * o, c.shearMix += (p - c.shearMix) * o
                        }
                    }
                }
            }, e.ENTRIES = 5, e.PREV_TIME = -5, e.PREV_ROTATE = -4, e.PREV_TRANSLATE = -3, e.PREV_SCALE = -2, e.PREV_SHEAR = -1, e.ROTATE = 1, e.TRANSLATE = 2, e.SCALE = 3, e.SHEAR = 4, e
        }(mt))
        var At = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.pathConstraintPosition << 24) + this.pathConstraintIndex
            }, e.prototype.setFrame = function (t, n, r) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.VALUE] = r
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.pathConstraints[this.pathConstraintIndex]
                if (c.active) {
                    if (r < u[0]) { switch (a) {
                        case y.setup:
                            return void (c.position = c.data.position)
                                case y.first:
                            c.position += (c.data.position - c.position) * o
                    }
                    } else {
                        let l = 0
                        if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_VALUE]
}
                        else {
                            let h = dt.binarySearch(u, r, e.ENTRIES)
                            l = u[h + e.PREV_VALUE]
                            var f = u[h]
                                        var d = this.getCurvePercent(h / e.ENTRIES - 1, 1 - (r - f) / (u[h + e.PREV_TIME] - f))
                            l += (u[h + e.VALUE] - l) * d
                        }
                        a == y.setup ? c.position = c.data.position + (l - c.data.position) * o : c.position += (l - c.position) * o
                    }
                }
            }, e.ENTRIES = 2, e.PREV_TIME = -2, e.PREV_VALUE = -1, e.VALUE = 1, e
        }(mt))
        var It = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.pathConstraintSpacing << 24) + this.pathConstraintIndex
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.pathConstraints[this.pathConstraintIndex]
                if (c.active) {
                    if (r < u[0]) { switch (a) {
                        case y.setup:
                            return void (c.spacing = c.data.spacing)
                                case y.first:
                            c.spacing += (c.data.spacing - c.spacing) * o
                    }
                    } else {
                        let l = 0
                        if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_VALUE]
}
                        else {
                            let h = dt.binarySearch(u, r, e.ENTRIES)
                            l = u[h + e.PREV_VALUE]
                            var f = u[h]
                                        var d = this.getCurvePercent(h / e.ENTRIES - 1, 1 - (r - f) / (u[h + e.PREV_TIME] - f))
                            l += (u[h + e.VALUE] - l) * d
                        }
                        a == y.setup ? c.spacing = c.data.spacing + (l - c.data.spacing) * o : c.spacing += (l - c.spacing) * o
                    }
                }
            }, e
        }(At))
        var Ct = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return et(e, t), e.prototype.getPropertyId = function () {
                return (nt.pathConstraintMix << 24) + this.pathConstraintIndex
            }, e.prototype.setFrame = function (t, n, r, i) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.ROTATE] = r, this.frames[t + e.TRANSLATE] = i
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.pathConstraints[this.pathConstraintIndex]
                if (c.active) {
                    if (r < u[0]) { switch (a) {
                        case y.setup:
                            return c.rotateMix = c.data.rotateMix, void (c.translateMix = c.data.translateMix)
                                case y.first:
                            c.rotateMix += (c.data.rotateMix - c.rotateMix) * o, c.translateMix += (c.data.translateMix - c.translateMix) * o
                    }
                    } else {
                        let l = 0
                                    var h = 0
                        if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_ROTATE], h = u[u.length + e.PREV_TRANSLATE]
}
                        else {
                            let f = dt.binarySearch(u, r, e.ENTRIES)
                            l = u[f + e.PREV_ROTATE], h = u[f + e.PREV_TRANSLATE]
                            var d = u[f]
                                        var p = this.getCurvePercent(f / e.ENTRIES - 1, 1 - (r - d) / (u[f + e.PREV_TIME] - d))
                            l += (u[f + e.ROTATE] - l) * p, h += (u[f + e.TRANSLATE] - h) * p
                        }
                        a == y.setup ? (c.rotateMix = c.data.rotateMix + (l - c.data.rotateMix) * o, c.translateMix = c.data.translateMix + (h - c.data.translateMix) * o) : (c.rotateMix += (l - c.rotateMix) * o, c.translateMix += (h - c.translateMix) * o)
                    }
                }
            }, e.ENTRIES = 3, e.PREV_TIME = -3, e.PREV_ROTATE = -2, e.PREV_TRANSLATE = -1, e.ROTATE = 1, e.TRANSLATE = 2, e
        }(mt))
        var kt = (function () {
            function t(t) {
                this.tracks = [], this.timeScale = 1, this.unkeyedState = 0, this.events = [], this.listeners = [], this.queue = new Mt(this), this.propertyIDs = new D(), this.animationsChanged = !1, this.trackEntryPool = new X(() => {
                    return new Nt()
                }), this.data = t
            }
            return t.prototype.update = function (t) {
                t *= this.timeScale
                for (let e = this.tracks, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i != null) {
                        i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast
                        let o = t * i.timeScale
                        if (i.delay > 0) {
                            if (i.delay -= o, i.delay > 0) continue
                            o = -i.delay, i.delay = 0
                        }
                        let a = i.next
                        if (a != null) {
                            const s = i.trackLast - a.delay
                            if (s >= 0) {
                                for (a.delay = 0, a.trackTime += i.timeScale == 0 ? 0 : (s / i.timeScale + t) * a.timeScale, i.trackTime += o, this.setCurrent(n, a, !0); a.mixingFrom != null;) a.mixTime += t, a = a.mixingFrom
                                continue
                            }
                        } else if (i.trackLast >= i.trackEnd && i.mixingFrom == null) {
                            e[n] = null, this.queue.end(i), this.disposeNext(i)
                            continue
                        }
                        if (i.mixingFrom != null && this.updateMixingFrom(i, t)) {
                            let u = i.mixingFrom
                            for (i.mixingFrom = null, u != null && (u.mixingTo = null); u != null;) this.queue.end(u), u = u.mixingFrom
                        }
                        i.trackTime += o
                    }
                }
                this.queue.drain()
            }, t.prototype.updateMixingFrom = function (t, e) {
                const n = t.mixingFrom
                if (n == null) return !0
                let r = this.updateMixingFrom(n, e)
                return n.animationLast = n.nextAnimationLast, n.trackLast = n.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? (n.totalAlpha != 0 && t.mixDuration != 0 || (t.mixingFrom = n.mixingFrom, n.mixingFrom != null && (n.mixingFrom.mixingTo = t), t.interruptAlpha = n.interruptAlpha, this.queue.end(n)), r) : (n.trackTime += e * n.timeScale, t.mixTime += e, !1)
            }, t.prototype.apply = function (e) {
                if (e == null) throw new Error('skeleton cannot be null.')
                this.animationsChanged && this._animationsChanged()
                for (var n = this.events, r = this.tracks, i = !1, o = 0, a = r.length; o < a; o++) {
                    const s = r[o]
                    if (!(s == null || s.delay > 0)) {
                        i = !0
                        let u = o == 0 ? y.first : s.mixBlend
                        var c = s.alpha
                        s.mixingFrom != null ? c *= this.applyMixingFrom(s, e, u) : s.trackTime >= s.trackEnd && s.next == null && (c = 0)
                        let l = s.animationLast
                        var h = s.getAnimationTime()
                        var f = s.animation.timelines.length
                        var d = s.animation.timelines
                        if (o == 0 && c == 1 || u == y.add) {
                            for (var p = 0; p < f; p++) {
                                G.webkit602BugfixHelper(c, u)
                                var m = d[p]
                                m instanceof xt ? this.applyAttachmentTimeline(m, e, h, u, !0) : m.apply(e, l, h, n, c, u, v.mixIn)
                            }
                        } else {
                            const _ = s.timelineMode
                            var g = s.timelinesRotation.length == 0
                            g && G.setArraySize(s.timelinesRotation, f << 1, null)
                            let b = s.timelinesRotation
                            for (p = 0; p < f; p++) {
                                const E = d[p]
                                var x = _[p] == t.SUBSEQUENT ? u : y.setup
                                E instanceof yt ? this.applyRotateTimeline(E, e, h, c, x, b, p << 1, g) : E instanceof xt ? this.applyAttachmentTimeline(E, e, h, u, !0) : (G.webkit602BugfixHelper(c, u), E.apply(e, l, h, n, c, x, v.mixIn))
                            }
                        }
                        this.queueEvents(s, h), n.length = 0, s.nextAnimationLast = h, s.nextTrackLast = s.trackTime
                    }
                }
                for (let T = this.unkeyedState + t.SETUP, S = e.slots, w = 0, O = e.slots.length; w < O; w++) {
                    const P = S[w]
                    if (P.attachmentState == T) {
                        const R = P.data.attachmentName
                        P.setAttachment(R == null ? null : e.getAttachment(P.data.index, R))
                    }
                }
                return this.unkeyedState += 2, this.queue.drain(), i
            }, t.prototype.applyMixingFrom = function (e, n, r) {
                const i = e.mixingFrom
                i.mixingFrom != null && this.applyMixingFrom(i, n, r)
                let o = 0
                e.mixDuration == 0 ? (o = 1, r == y.first && (r = y.setup)) : ((o = e.mixTime / e.mixDuration) > 1 && (o = 1), r != y.first && (r = i.mixBlend))
                let a = o < i.eventThreshold ? this.events : null
                var s = o < i.attachmentThreshold
                var u = o < i.drawOrderThreshold
                var c = i.animationLast
                var l = i.getAnimationTime()
                var h = i.animation.timelines.length
                var f = i.animation.timelines
                var d = i.alpha * e.interruptAlpha
                var p = d * (1 - o)
                if (r == y.add) {
                    for (var m = 0; m < h; m++) f[m].apply(n, c, l, a, p, r, v.mixOut)
                }
                else {
                    const _ = i.timelineMode
                    var g = i.timelineHoldMix
                    var b = i.timelinesRotation.length == 0
                    b && G.setArraySize(i.timelinesRotation, h << 1, null)
                    let E = i.timelinesRotation
                    i.totalAlpha = 0
                    for (m = 0; m < h; m++) {
                        const x = f[m]
                        var T = v.mixOut
                        var S = void 0
                        var w = 0
                        switch (_[m]) {
                            case t.SUBSEQUENT:
                                if (!u && x instanceof Ot) continue
                                S = r, w = p
                                break
                            case t.FIRST:
                                S = y.setup, w = p
                                break
                            case t.HOLD_SUBSEQUENT:
                                S = r, w = d
                                break
                            case t.HOLD_FIRST:
                                S = y.setup, w = d
                                break
                            default:
                                S = y.setup
                                var O = g[m]
                                w = d * Math.max(0, 1 - O.mixTime / O.mixDuration)
                        }
                        i.totalAlpha += w, x instanceof yt ? this.applyRotateTimeline(x, n, l, w, S, E, m << 1, b) : x instanceof xt ? this.applyAttachmentTimeline(x, n, l, S, s) : (G.webkit602BugfixHelper(w, r), u && x instanceof Ot && S == y.setup && (T = v.mixIn), x.apply(n, c, l, a, w, S, T))
                    }
                }
                return e.mixDuration > 0 && this.queueEvents(i, l), this.events.length = 0, i.nextAnimationLast = l, i.nextTrackLast = i.trackTime, o
            }, t.prototype.applyAttachmentTimeline = function (e, n, r, i, o) {
                const a = n.slots[e.slotIndex]
                if (a.bone.active) {
                    let s; const u = e.frames
                    if (r < u[0]) i != y.setup && i != y.first || this.setAttachment(n, a, a.data.attachmentName, o)
                    else s = r >= u[u.length - 1] ? u.length - 1 : dt.binarySearch(u, r) - 1, this.setAttachment(n, a, e.attachmentNames[s], o)
                    a.attachmentState <= this.unkeyedState && (a.attachmentState = this.unkeyedState + t.SETUP)
                }
            }, t.prototype.setAttachment = function (e, n, r, i) {
                n.setAttachment(r == null ? null : e.getAttachment(n.data.index, r)), i && (n.attachmentState = this.unkeyedState + t.CURRENT)
            }, t.prototype.applyRotateTimeline = function (t, e, n, r, i, o, a, s) {
                if (s && (o[a] = 0), r != 1) {
                    const u = t
                    var c = u.frames
                    var l = e.bones[u.boneIndex]
                    if (l.active) {
                        let h = 0
                        var f = 0
                        if (n < c[0]) { switch (i) {
                            case y.setup:
                                l.rotation = l.data.rotation
                            default:
                                return
                            case y.first:
                                h = l.rotation, f = l.data.rotation
                        }
                        } else if (h = i == y.setup ? l.data.rotation : l.rotation, n >= c[c.length - yt.ENTRIES]) { f = l.data.rotation + c[c.length + yt.PREV_ROTATION]
                        }
                        else {
                            const d = dt.binarySearch(c, n, yt.ENTRIES)
                            var p = c[d + yt.PREV_ROTATION]
                            var m = c[d]
                            var _ = u.getCurvePercent((d >> 1) - 1, 1 - (n - m) / (c[d + yt.PREV_TIME] - m))
                            f = c[d + yt.ROTATION] - p, f = p + (f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * _ + l.data.rotation, f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))
                        }
                        let g = 0
                        var b = f - h
                        if ((b -= 360 * (16384 - (16384.499999999996 - b / 360 | 0))) == 0) { g = o[a]
                        }
                        else {
                            let E = 0
                            var x = 0
                            s ? (E = 0, x = b) : (E = o[a], x = o[a + 1])
                            let T = b > 0
                            var S = E >= 0
                            B.signum(x) != B.signum(b) && Math.abs(x) <= 90 && (Math.abs(E) > 180 && (E += 360 * B.signum(E)), S = T), g = b + E - E % 360, S != T && (g += 360 * B.signum(E)), o[a] = g
                        }
                        o[a + 1] = b, h += g * r, l.rotation = h - 360 * (16384 - (16384.499999999996 - h / 360 | 0))
                    }
                } else { t.apply(e, 0, n, null, 1, i, v.mixIn)
                }
            }, t.prototype.queueEvents = function (t, e) {
                for (var n = t.animationStart, r = t.animationEnd, i = r - n, o = t.trackLast % i, a = this.events, s = 0, u = a.length; s < u; s++) {
                    const c = a[s]
                    if (c.time < o) break
                    c.time > r || this.queue.event(t, c)
                }
                for ((t.loop ? i == 0 || o > t.trackTime % i : e >= r && t.animationLast < r) && this.queue.complete(t); s < u; s++) {
                    a[s].time < n || this.queue.event(t, a[s])
                }
            }, t.prototype.clearTracks = function () {
                const t = this.queue.drainDisabled
                this.queue.drainDisabled = !0
                for (let e = 0, n = this.tracks.length; e < n; e++) this.clearTrack(e)
                this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain()
            }, t.prototype.clearTrack = function (t) {
                if (!(t >= this.tracks.length)) {
                    const e = this.tracks[t]
                    if (e != null) {
                        this.queue.end(e), this.disposeNext(e)
                        for (let n = e; ;) {
                            const r = n.mixingFrom
                            if (r == null) break
                            this.queue.end(r), n.mixingFrom = null, n.mixingTo = null, n = r
                        }
                        this.tracks[e.trackIndex] = null, this.queue.drain()
                    }
                }
            }, t.prototype.setCurrent = function (t, e, n) {
                const r = this.expandToIndex(t)
                this.tracks[t] = e, r != null && (n && this.queue.interrupt(r), e.mixingFrom = r, r.mixingTo = e, e.mixTime = 0, r.mixingFrom != null && r.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)), r.timelinesRotation.length = 0), this.queue.start(e)
            }, t.prototype.setAnimation = function (t, e, n) {
                const r = this.data.skeletonData.findAnimation(e)
                if (r == null) throw new Error(`Animation not found: ${ e}`)
                return this.setAnimationWith(t, r, n)
            }, t.prototype.setAnimationWith = function (t, e, n) {
                if (e == null) throw new Error('animation cannot be null.')
                let r = !0
                var i = this.expandToIndex(t)
                i != null && (i.nextTrackLast == -1 ? (this.tracks[t] = i.mixingFrom, this.queue.interrupt(i), this.queue.end(i), this.disposeNext(i), i = i.mixingFrom, r = !1) : this.disposeNext(i))
                let o = this.trackEntry(t, e, n, i)
                return this.setCurrent(t, o, r), this.queue.drain(), o
            }, t.prototype.addAnimation = function (t, e, n, r) {
                const i = this.data.skeletonData.findAnimation(e)
                if (i == null) throw new Error(`Animation not found: ${ e}`)
                return this.addAnimationWith(t, i, n, r)
            }, t.prototype.addAnimationWith = function (t, e, n, r) {
                if (e == null) throw new Error('animation cannot be null.')
                let i = this.expandToIndex(t)
                if (i != null) {
                    for (; i.next != null;) i = i.next
                }
                const o = this.trackEntry(t, e, n, i)
                if (i == null) { this.setCurrent(t, o, !0), this.queue.drain()
                }
                else if (i.next = o, r <= 0) {
                    const a = i.animationEnd - i.animationStart
                    a != 0 ? (i.loop ? r += a * (1 + (i.trackTime / a | 0)) : r += Math.max(a, i.trackTime), r -= this.data.getMix(i.animation, e)) : r = i.trackTime
                }
                return o.delay = r, o
            }, t.prototype.setEmptyAnimation = function (e, n) {
                const r = this.setAnimationWith(e, t.emptyAnimation, !1)
                return r.mixDuration = n, r.trackEnd = n, r
            }, t.prototype.addEmptyAnimation = function (e, n, r) {
                r <= 0 && (r -= n)
                let i = this.addAnimationWith(e, t.emptyAnimation, !1, r)
                return i.mixDuration = n, i.trackEnd = n, i
            }, t.prototype.setEmptyAnimations = function (t) {
                const e = this.queue.drainDisabled
                this.queue.drainDisabled = !0
                for (let n = 0, r = this.tracks.length; n < r; n++) {
                    const i = this.tracks[n]
                    i != null && this.setEmptyAnimation(i.trackIndex, t)
                }
                this.queue.drainDisabled = e, this.queue.drain()
            }, t.prototype.expandToIndex = function (t) {
                return t < this.tracks.length ? this.tracks[t] : (G.ensureArrayCapacity(this.tracks, t + 1, null), this.tracks.length = t + 1, null)
            }, t.prototype.trackEntry = function (t, e, n, r) {
                const i = this.trackEntryPool.obtain()
                return i.trackIndex = t, i.animation = e, i.loop = n, i.holdPrevious = !1, i.eventThreshold = 0, i.attachmentThreshold = 0, i.drawOrderThreshold = 0, i.animationStart = 0, i.animationEnd = e.duration, i.animationLast = -1, i.nextAnimationLast = -1, i.delay = 0, i.trackTime = 0, i.trackLast = -1, i.nextTrackLast = -1, i.trackEnd = Number.MAX_VALUE, i.timeScale = 1, i.alpha = 1, i.interruptAlpha = 1, i.mixTime = 0, i.mixDuration = r == null ? 0 : this.data.getMix(r.animation, e), i.mixBlend = y.replace, i
            }, t.prototype.disposeNext = function (t) {
                for (let e = t.next; e != null;) this.queue.dispose(e), e = e.next
                t.next = null
            }, t.prototype._animationsChanged = function () {
                this.animationsChanged = !1, this.propertyIDs.clear()
                for (let t = 0, e = this.tracks.length; t < e; t++) {
                    let n = this.tracks[t]
                    if (n != null) {
                        for (; n.mixingFrom != null;) n = n.mixingFrom
                        do {
                            n.mixingFrom != null && n.mixBlend == y.add || this.computeHold(n), n = n.mixingTo
                        } while (n != null)
                    }
                }
            }, t.prototype.computeHold = function (e) {
                const n = e.mixingTo
                var r = e.animation.timelines
                var i = e.animation.timelines.length
                var o = G.setArraySize(e.timelineMode, i)
                e.timelineHoldMix.length = 0
                let a = G.setArraySize(e.timelineHoldMix, i)
                var s = this.propertyIDs
                if (n != null && n.holdPrevious) {
                    for (var u = 0; u < i; u++) o[u] = s.add(r[u].getPropertyId()) ? t.HOLD_FIRST : t.HOLD_SUBSEQUENT
                }
                else { t: for (u = 0; u < i; u++) {
                    let c = r[u]
                                var l = c.getPropertyId()
                    if (s.add(l)) {
                        if (n == null || c instanceof xt || c instanceof Ot || c instanceof wt || !n.animation.hasTimeline(l)) { o[u] = t.FIRST;
}
                        else {
                            for (let h = n.mixingTo; h != null; h = h.mixingTo) {
                                        if (!h.animation.hasTimeline(l)) {
                                            if (e.mixDuration > 0) {
                                                o[u] = t.HOLD_MIX, a[u] = h;
                                                continue t
                                            }
                                            break
                                        }
}
                            o[u] = t.HOLD_FIRST
                        }
                    }
                    else { o[u] = t.SUBSEQUENT
                    }
                }
                }
            }, t.prototype.getCurrent = function (t) {
                return t >= this.tracks.length ? null : this.tracks[t]
            }, t.prototype.addListener = function (t) {
                if (t == null) throw new Error('listener cannot be null.')
                this.listeners.push(t)
            }, t.prototype.removeListener = function (t) {
                const e = this.listeners.indexOf(t)
                e >= 0 && this.listeners.splice(e, 1)
            }, t.prototype.clearListeners = function () {
                this.listeners.length = 0
            }, t.prototype.clearListenerNotifications = function () {
                this.queue.clear()
            }, t.prototype.setAnimationByName = function (e, n, r) {
                t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.')), this.setAnimation(e, n, r)
            }, t.prototype.addAnimationByName = function (e, n, r, i) {
                t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.')), this.addAnimation(e, n, r, i)
            }, t.prototype.hasAnimation = function (t) {
                return this.data.skeletonData.findAnimation(t) !== null
            }, t.prototype.hasAnimationByName = function (e) {
                return t.deprecatedWarning3 || (t.deprecatedWarning3 = !0, console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.')), this.hasAnimation(e)
            }, t.emptyAnimation = new dt('<empty>', [], 0), t.SUBSEQUENT = 0, t.FIRST = 1, t.HOLD_SUBSEQUENT = 2, t.HOLD_FIRST = 3, t.HOLD_MIX = 4, t.SETUP = 1, t.CURRENT = 2, t.deprecatedWarning1 = !1, t.deprecatedWarning2 = !1, t.deprecatedWarning3 = !1, t
        }())
        var Nt = (function () {
            function t() {
                this.mixBlend = y.replace, this.timelineMode = [], this.timelineHoldMix = [], this.timelinesRotation = []
            }
            return t.prototype.reset = function () {
                this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0
            }, t.prototype.getAnimationTime = function () {
                if (this.loop) {
                    const t = this.animationEnd - this.animationStart
                    return t == 0 ? this.animationStart : this.trackTime % t + this.animationStart
                }
                return Math.min(this.trackTime + this.animationStart, this.animationEnd)
            }, t.prototype.setAnimationLast = function (t) {
                this.animationLast = t, this.nextAnimationLast = t
            }, t.prototype.isComplete = function () {
                return this.trackTime >= this.animationEnd - this.animationStart
            }, t.prototype.resetRotationDirections = function () {
                this.timelinesRotation.length = 0
            }, Object.defineProperty(t.prototype, 'time', {
                get() {
                    return t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.')), this.trackTime
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.')), this.trackTime = e
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'endTime', {
                get() {
                    return t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.')), this.trackTime
                },
                set(e) {
                    t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.')), this.trackTime = e
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.loopsCount = function () {
                return Math.floor(this.trackTime / this.trackEnd)
            }, t.deprecatedWarning1 = !1, t.deprecatedWarning2 = !1, t
        }())
        var Mt = (function () {
            function t(t) {
                this.objects = [], this.drainDisabled = !1, this.animState = t
            }
            return t.prototype.start = function (t) {
                this.objects.push(pt.start), this.objects.push(t), this.animState.animationsChanged = !0
            }, t.prototype.interrupt = function (t) {
                this.objects.push(pt.interrupt), this.objects.push(t)
            }, t.prototype.end = function (t) {
                this.objects.push(pt.end), this.objects.push(t), this.animState.animationsChanged = !0
            }, t.prototype.dispose = function (t) {
                this.objects.push(pt.dispose), this.objects.push(t)
            }, t.prototype.complete = function (t) {
                this.objects.push(pt.complete), this.objects.push(t)
            }, t.prototype.event = function (t, e) {
                this.objects.push(pt.event), this.objects.push(t), this.objects.push(e)
            }, t.prototype.deprecateStuff = function () {
                return t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. \'state.addListener({ complete: function(track, event) { } })\'')), !0
            }, t.prototype.drain = function () {
                if (!this.drainDisabled) {
                    this.drainDisabled = !0
                    for (let t = this.objects, e = this.animState.listeners, n = 0; n < t.length; n += 2) {
                        const r = t[n]
                        let i = t[n + 1]
                        switch (r) {
                            case pt.start:
                                i.listener != null && i.listener.start && i.listener.start(i)
                                for (var o = 0; o < e.length; o++) e[o].start && e[o].start(i)
                                i.onStart && this.deprecateStuff() && i.onStart(i.trackIndex), this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(i.trackIndex)
                                break
                            case pt.interrupt:
                                i.listener != null && i.listener.interrupt && i.listener.interrupt(i)
                                for (o = 0; o < e.length; o++) e[o].interrupt && e[o].interrupt(i)
                                break
                            case pt.end:
                                i.listener != null && i.listener.end && i.listener.end(i)
                                for (o = 0; o < e.length; o++) e[o].end && e[o].end(i)
                                i.onEnd && this.deprecateStuff() && i.onEnd(i.trackIndex), this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(i.trackIndex)
                            case pt.dispose:
                                i.listener != null && i.listener.dispose && i.listener.dispose(i)
                                for (o = 0; o < e.length; o++) e[o].dispose && e[o].dispose(i)
                                this.animState.trackEntryPool.free(i)
                                break
                            case pt.complete:
                                i.listener != null && i.listener.complete && i.listener.complete(i)
                                for (o = 0; o < e.length; o++) e[o].complete && e[o].complete(i)
                                var a = B.toInt(i.loopsCount())
                                i.onComplete && this.deprecateStuff() && i.onComplete(i.trackIndex, a), this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(i.trackIndex, a)
                                break
                            case pt.event:
                                var s = t[2 + n++]
                                i.listener != null && i.listener.event && i.listener.event(i, s)
                                for (o = 0; o < e.length; o++) e[o].event && e[o].event(i, s)
                                i.onEvent && this.deprecateStuff() && i.onEvent(i.trackIndex, s), this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(i.trackIndex, s)
                        }
                    }
                    this.clear(), this.drainDisabled = !1
                }
            }, t.prototype.clear = function () {
                this.objects.length = 0
            }, t.deprecatedWarning1 = !1, t
        }())
        !(function (t) {
            t[t.start = 0] = 'start', t[t.interrupt = 1] = 'interrupt', t[t.end = 2] = 'end', t[t.dispose = 3] = 'dispose', t[t.complete = 4] = 'complete', t[t.event = 5] = 'event'
        }(pt || (pt = {})))
        let jt; var Dt = (function () {
            function t() {}
            return t.prototype.start = function (t) {}, t.prototype.interrupt = function (t) {}, t.prototype.end = function (t) {}, t.prototype.dispose = function (t) {}, t.prototype.complete = function (t) {}, t.prototype.event = function (t, e) {}, t
        }())
        var Lt = (function () {
            function t(t) {
                if (this.animationToMixTime = {}, this.defaultMix = 0, t == null) throw new Error('skeletonData cannot be null.')
                this.skeletonData = t
            }
            return t.prototype.setMix = function (t, e, n) {
                const r = this.skeletonData.findAnimation(t)
                if (r == null) throw new Error(`Animation not found: ${ t}`)
                let i = this.skeletonData.findAnimation(e)
                if (i == null) throw new Error(`Animation not found: ${ e}`)
                this.setMixWith(r, i, n)
            }, t.prototype.setMixByName = function (e, n, r) {
                t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.')), this.setMix(e, n, r)
            }, t.prototype.setMixWith = function (t, e, n) {
                if (t == null) throw new Error('from cannot be null.')
                if (e == null) throw new Error('to cannot be null.')
                let r = `${t.name}.${e.name}`
                this.animationToMixTime[r] = n
            }, t.prototype.getMix = function (t, e) {
                const n = `${t.name }.${ e.name}`;
                var r = this.animationToMixTime[n]
                return void 0 === r ? this.defaultMix : r
            }, t.deprecatedWarning1 = !1, t
        }())
        var Ft = (function () {
            function t(t) {
                this.atlas = t
            }
            return t.prototype.newRegionAttachment = function (t, e, n) {
                const r = this.atlas.findRegion(n)
                if (r == null) throw new Error(`Region not found in atlas: ${ n } (region attachment: ${ e })`)
                let i = new lt(e)
                return i.region = r, i
            }, t.prototype.newMeshAttachment = function (t, e, n) {
                const r = this.atlas.findRegion(n)
                if (r == null) throw new Error(`Region not found in atlas: ${ n } (mesh attachment: ${ e })`)
                let i = new st(e)
                return i.region = r, i
            }, t.prototype.newBoundingBoxAttachment = function (t, e) {
                return new ot(e)
            }, t.prototype.newPathAttachment = function (t, e) {
                return new ut(e)
            }, t.prototype.newPointAttachment = function (t, e) {
                return new ct(e)
            }, t.prototype.newClippingAttachment = function (t, e) {
                return new at(e)
            }, t
        }())
        var Bt = (function () {
            function t(t, e, n) {
                if (this.matrix = new l.d(), this.children = [], this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = !1, this.sorted = !1, this.active = !1, t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.skeleton = e, this.parent = n, this.setToSetupPose()
            }
            return Object.defineProperty(t.prototype, 'worldX', {
                get() {
                    return this.matrix.tx
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'worldY', {
                get() {
                    return this.matrix.ty
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.isActive = function () {
                return this.active
            }, t.prototype.update = function () {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            }, t.prototype.updateWorldTransform = function () {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            }, t.prototype.updateWorldTransformWith = function (t, e, n, r, i, o, a) {
                this.ax = t, this.ay = e, this.arotation = n, this.ascaleX = r, this.ascaleY = i, this.ashearX = o, this.ashearY = a, this.appliedValid = !0
                let s = this.parent
                var u = this.matrix
                var c = this.skeleton.scaleX
                var l = V ? -this.skeleton.scaleY : this.skeleton.scaleY
                if (s == null) {
                    const h = this.skeleton
                    var f = n + 90 + a
                    return u.a = B.cosDeg(n + o) * r * c, u.c = B.cosDeg(f) * i * c, u.b = B.sinDeg(n + o) * r * l, u.d = B.sinDeg(f) * i * l, u.tx = t * c + h.x, void (u.ty = e * l + h.y)
                }
                let d = s.matrix.a
                var p = s.matrix.c
                var m = s.matrix.b
                var y = s.matrix.d
                switch (u.tx = d * t + p * e + s.matrix.tx, u.ty = m * t + y * e + s.matrix.ty, this.data.transformMode) {
                    case b.Normal:
                        f = n + 90 + a
                        var v = B.cosDeg(n + o) * r
                        var _ = B.cosDeg(f) * i
                        var g = B.sinDeg(n + o) * r
                        var E = B.sinDeg(f) * i
                        return u.a = d * v + p * g, u.c = d * _ + p * E, u.b = m * v + y * g, void (u.d = m * _ + y * E)
                    case b.OnlyTranslation:
                        f = n + 90 + a
                        u.a = B.cosDeg(n + o) * r, u.c = B.cosDeg(f) * i, u.b = B.sinDeg(n + o) * r, u.d = B.sinDeg(f) * i
                        break
                    case b.NoRotationOrReflection:
                        var x = 0;
                        (w = d * d + m * m) > 1e-4 ? (w = Math.abs(d * y - p * m) / w, d /= this.skeleton.scaleX, p = (m /= this.skeleton.scaleY) * w, y = d * w, x = Math.atan2(m, d) * B.radDeg) : (d = 0, m = 0, x = 90 - Math.atan2(y, p) * B.radDeg)
                        var T = n + o - x
                        var S = n + a - x + 90
                        v = B.cosDeg(T) * r, _ = B.cosDeg(S) * i, g = B.sinDeg(T) * r, E = B.sinDeg(S) * i
                        u.a = d * v - p * g, u.c = d * _ - p * E, u.b = m * v + y * g, u.d = m * _ + y * E
                        break
                    case b.NoScale:
                    case b.NoScaleOrReflection:
                        var w; var O = B.cosDeg(n)
                        var P = B.sinDeg(n)
                        var R = (d * O + p * P) / c
                        var A = (m * O + y * P) / l;
                        (w = Math.sqrt(R * R + A * A)) > 1e-5 && (w = 1 / w), R *= w, A *= w, w = Math.sqrt(R * R + A * A), this.data.transformMode == b.NoScale && d * y - p * m < 0 != (V ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (w = -w)
                        var I = Math.PI / 2 + Math.atan2(A, R)
                        var C = Math.cos(I) * w
                        var k = Math.sin(I) * w
                        v = B.cosDeg(o) * r, _ = B.cosDeg(90 + a) * i, g = B.sinDeg(o) * r, E = B.sinDeg(90 + a) * i
                        u.a = R * v + C * g, u.c = R * _ + C * E, u.b = A * v + k * g, u.d = A * _ + k * E
                }
                u.a *= c, u.c *= c, u.b *= l, u.d *= l
            }, t.prototype.setToSetupPose = function () {
                const t = this.data
                this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY
            }, t.prototype.getWorldRotationX = function () {
                return Math.atan2(this.matrix.b, this.matrix.a) * B.radDeg
            }, t.prototype.getWorldRotationY = function () {
                return Math.atan2(this.matrix.d, this.matrix.c) * B.radDeg
            }, t.prototype.getWorldScaleX = function () {
                const t = this.matrix
                return Math.sqrt(t.a * t.a + t.c * t.c)
            }, t.prototype.getWorldScaleY = function () {
                const t = this.matrix
                return Math.sqrt(t.b * t.b + t.d * t.d)
            }, t.prototype.updateAppliedTransform = function () {
                this.appliedValid = !0
                let t = this.parent
                var e = this.matrix
                if (t == null) return this.ax = e.tx, this.ay = e.ty, this.arotation = Math.atan2(e.b, e.a) * B.radDeg, this.ascaleX = Math.sqrt(e.a * e.a + e.b * e.b), this.ascaleY = Math.sqrt(e.c * e.c + e.d * e.d), this.ashearX = 0, void (this.ashearY = Math.atan2(e.a * e.c + e.b * e.d, e.a * e.d - e.b * e.c) * B.radDeg)
                let n = t.matrix
                var r = 1 / (n.a * n.d - n.b * n.c)
                var i = e.tx - n.tx
                var o = e.ty - n.ty
                this.ax = i * n.d * r - o * n.c * r, this.ay = o * n.a * r - i * n.b * r
                let a = r * n.d
                var s = r * n.a
                var u = r * n.c
                var c = r * n.b
                var l = a * e.a - u * e.b
                var h = a * e.c - u * e.d
                var f = s * e.b - c * e.a
                var d = s * e.d - c * e.c
                if (this.ashearX = 0, this.ascaleX = Math.sqrt(l * l + f * f), this.ascaleX > 1e-4) {
                    const p = l * d - h * f
                    this.ascaleY = p / this.ascaleX, this.ashearY = Math.atan2(l * h + f * d, p) * B.radDeg, this.arotation = Math.atan2(f, l) * B.radDeg
                } else { this.ascaleX = 0, this.ascaleY = Math.sqrt(h * h + d * d), this.ashearY = 0, this.arotation = 90 - Math.atan2(d, h) * B.radDeg
                }
            }, t.prototype.worldToLocal = function (t) {
                const e = this.matrix
                var n = e.a
                var r = e.c
                var i = e.b
                var o = e.d
                var a = 1 / (n * o - r * i)
                var s = t.x - e.tx
                var u = t.y - e.ty
                return t.x = s * o * a - u * r * a, t.y = u * n * a - s * i * a, t
            }, t.prototype.localToWorld = function (t) {
                const e = this.matrix
                var n = t.x
                var r = t.y
                return t.x = n * e.a + r * e.c + e.tx, t.y = n * e.b + r * e.d + e.ty, t
            }, t.prototype.worldToLocalRotation = function (t) {
                const e = B.sinDeg(t)
                var n = B.cosDeg(t)
                var r = this.matrix
                return Math.atan2(r.a * e - r.b * n, r.d * n - r.c * e) * B.radDeg
            }, t.prototype.localToWorldRotation = function (t) {
                const e = B.sinDeg(t)
                var n = B.cosDeg(t)
                var r = this.matrix
                return Math.atan2(n * r.b + e * r.d, n * r.a + e * r.c) * B.radDeg
            }, t.prototype.rotateWorld = function (t) {
                const e = this.matrix
                var n = e.a
                var r = e.c
                var i = e.b
                var o = e.d
                var a = B.cosDeg(t)
                var s = B.sinDeg(t)
                e.a = a * n - s * i, e.c = a * r - s * o, e.b = s * n + a * i, e.d = s * r + a * o, this.appliedValid = !1
            }, t
        }())
        var Ut = function (t, e, n) {
            if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = b.Normal, this.skinRequired = !1, this.color = new F(), t < 0) throw new Error('index must be >= 0.')
            if (e == null) throw new Error('name cannot be null.')
            this.index = t, this.name = e, this.parent = n
        }
        var Gt = function (t, e, n) {
            this.name = t, this.order = e, this.skinRequired = n
        }
        var Xt = function (t, e) {
            if (e == null) throw new Error('data cannot be null.')
            this.time = t, this.data = e
        }
        var Ht = function (t) {
            this.name = t
        }
        var Vt = (function () {
            function t(t, e) {
                if (this.bendDirection = 0, this.compress = !1, this.stretch = !1, this.mix = 1, this.softness = 0, this.active = !1, t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.mix = t.mix, this.softness = t.softness, this.bendDirection = t.bendDirection, this.compress = t.compress, this.stretch = t.stretch, this.bones = []
                for (let n = 0; n < t.bones.length; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findBone(t.target.name)
            }
            return t.prototype.isActive = function () {
                return this.active
            }, t.prototype.apply = function () {
                this.update()
            }, t.prototype.update = function () {
                const t = this.target
                var e = this.bones
                switch (e.length) {
                    case 1:
                        this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix)
                        break
                    case 2:
                        this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.softness, this.mix)
                }
            }, t.prototype.apply1 = function (t, e, n, r, i, o, a) {
                t.appliedValid || t.updateAppliedTransform()
                let s = t.parent.matrix
                var u = s.a
                var c = s.c
                var l = s.b
                var h = s.d
                var f = -t.ashearX - t.arotation
                var d = 0
                var p = 0
                switch (t.data.transformMode) {
                    case b.OnlyTranslation:
                        d = e - t.worldX, p = n - t.worldY
                        break
                    case b.NoRotationOrReflection:
                        var m = Math.abs(u * h - c * l) / (u * u + l * l)
                        var y = u / t.skeleton.scaleX
                        var v = l / t.skeleton.scaleY
                        c = -v * m * t.skeleton.scaleX, h = y * m * t.skeleton.scaleY, f += Math.atan2(v, y) * B.radDeg
                    default:
                        var _ = e - s.tx
                        var g = n - s.ty
                        var E = u * h - c * l
                        d = (_ * h - g * c) / E - t.ax, p = (g * u - _ * l) / E - t.ay
                }
                f += Math.atan2(p, d) * B.radDeg, t.ascaleX < 0 && (f += 180), f > 180 ? f -= 360 : f < -180 && (f += 360)
                let x = t.ascaleX
                var T = t.ascaleY
                if (r || i) {
                    switch (t.data.transformMode) {
                        case b.NoScale:
                        case b.NoScaleOrReflection:
                            d = e - t.worldX, p = n - t.worldY
                    }
                    const S = t.data.length * x
                    var w = Math.sqrt(d * d + p * p)
                    if (r && w < S || i && w > S && S > 1e-4) x *= m = (w / S - 1) * a + 1, o && (T *= m)
                }
                t.updateWorldTransformWith(t.ax, t.ay, t.arotation + f * a, x, T, t.ashearX, t.ashearY)
            }, t.prototype.apply2 = function (t, e, n, r, i, o, a, s) {
                if (s != 0) {
                    t.appliedValid || t.updateAppliedTransform(), e.appliedValid || e.updateAppliedTransform()
                    let u = t.ax
                    var c = t.ay
                    var l = t.ascaleX
                    var h = l
                    var f = t.ascaleY
                    var d = e.ascaleX
                    var p = t.matrix
                    var m = 0
                    var y = 0
                    var v = 0
                    l < 0 ? (l = -l, m = 180, v = -1) : (m = 0, v = 1), f < 0 && (f = -f, v = -v), d < 0 ? (d = -d, y = 180) : y = 0
                    let _ = e.ax
                    var g = 0
                    var b = 0
                    var E = 0
                    var x = p.a
                    var T = p.c
                    var S = p.b
                    var w = p.d
                    var O = Math.abs(l - f) <= 1e-4
                    O ? (b = x * _ + T * (g = e.ay) + p.tx, E = S * _ + w * g + p.ty) : (g = 0, b = x * _ + p.tx, E = S * _ + p.ty)
                    let P = t.parent.matrix
                    x = P.a, T = P.c, S = P.b
                    let R; let A; const I = 1 / (x * (w = P.d) - T * S)
                    var C = b - P.tx
                    var k = E - P.ty
                    var N = (C * w - k * T) * I - u
                    var M = (k * x - C * S) * I - c
                    var j = Math.sqrt(N * N + M * M)
                    var D = e.data.length * d
                    if (j < 1e-4) return this.apply1(t, n, r, !1, o, !1, s), void e.updateWorldTransformWith(_, g, 0, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY)
                    let L = ((C = n - P.tx) * w - (k = r - P.ty) * T) * I - u
                    var F = (k * x - C * S) * I - c
                    var U = L * L + F * F
                    if (a != 0) {
                        a *= l * (d + 1) / 2
                        let G = Math.sqrt(U)
                        var X = G - j - D * l + a
                        if (X > 0) {
                            let H = Math.min(1, X / (2 * a)) - 1
                            U = (L -= (H = (X - a * (1 - H * H)) / G) * L) * L + (F -= H * F) * F
                        }
                    }
                    t: if (O) {
                        let V = (U - j * j - (D *= l) * D) / (2 * j * D)
                        V < -1 ? V = -1 : V > 1 && (V = 1, o && (h *= (Math.sqrt(U) / (j + D) - 1) * s + 1)), A = Math.acos(V) * i, x = j + D * V, T = D * Math.sin(A), R = Math.atan2(F * x - L * T, L * x + F * T)
                    } else {
                        const W = (x = l * D) * x
                        var Y = (T = f * D) * T
                        var z = Math.atan2(F, L)
                        var q = -2 * Y * j
                        var K = Y - W
                        if ((w = q * q - 4 * K * (S = Y * j * j + W * U - W * Y)) >= 0) {
                            let Z = Math.sqrt(w)
                            q < 0 && (Z = -Z)
                            let $ = (Z = -(q + Z) / 2) / K
                            var J = S / Z
                            var Q = Math.abs($) < Math.abs(J) ? $ : J
                            if (Q * Q <= U) {
                                k = Math.sqrt(U - Q * Q) * i, R = z - Math.atan2(k, Q), A = Math.atan2(k / f, (Q - j) / l)
                                break t
                            }
                        }
                        let tt = B.PI
                        var et = j - x
                        var nt = et * et
                        var rt = 0
                        var it = 0
                        var ot = j + x
                        var at = ot * ot
                        var st = 0;
                        (S = -x * j / (W - Y)) >= -1 && S <= 1 && (S = Math.acos(S), (w = (C = x * Math.cos(S) + j) * C + (k = T * Math.sin(S)) * k) < nt && (tt = S, nt = w, et = C, rt = k), w > at && (it = S, at = w, ot = C, st = k)), U <= (nt + at) / 2 ? (R = z - Math.atan2(rt * i, et), A = tt * i) : (R = z - Math.atan2(st * i, ot), A = it * i)
                    }
                    const ut = Math.atan2(g, _) * v
                    var ct = t.arotation;
                    (R = (R - ut) * B.radDeg + m - ct) > 180 ? R -= 360 : R < -180 && (R += 360), t.updateWorldTransformWith(u, c, ct + R * s, h, t.ascaleY, 0, 0), ct = e.arotation, (A = ((A + ut) * B.radDeg - e.ashearX) * v + y - ct) > 180 ? A -= 360 : A < -180 && (A += 360), e.updateWorldTransformWith(_, g, ct + A * s, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY)
                } else { e.updateWorldTransform()
                }
            }, t
        }())
        var Wt = (function (t) {
            function e(e) {
                const n = t.call(this, e, 0, !1) || this
                return n.bones = [], n.bendDirection = 1, n.compress = !1, n.stretch = !1, n.uniform = !1, n.mix = 1, n.softness = 0, n
            }
            return et(e, t), e
        }(Gt))
        var Yt = (function (t) {
            function e(e) {
                const n = t.call(this, e, 0, !1) || this
                return n.bones = [], n
            }
            return et(e, t), e
        }(Gt))
        !(function (t) {
            t[t.Length = 0] = 'Length', t[t.Fixed = 1] = 'Fixed', t[t.Percent = 2] = 'Percent'
        }(jt || (jt = {})))
        var zt = (function () {
            function t(t, e) {
                if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = [], this.positions = [], this.world = [], this.curves = [], this.lengths = [], this.segments = [], this.active = !1, t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.bones = []
                for (let n = 0, r = t.bones.length; n < r; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix
            }
            return t.prototype.isActive = function () {
                return this.active
            }, t.prototype.apply = function () {
                this.update()
            }, t.prototype.update = function () {
                const e = this.target.getAttachment()
                if (e instanceof ut) {
                    const n = this.rotateMix
                    let r = this.translateMix
                    let i = n > 0
                    if (r > 0 || i) {
                        const o = this.data
                        let a = o.spacingMode
                        let s = a == jt.Length
                        let u = o.rotateMode
                        let c = u == g.Tangent
                        let l = u == g.ChainScale
                        let h = this.bones.length
                        let f = c ? h : h + 1
                        let d = this.bones
                        let p = G.setArraySize(this.spaces, f)
                        let m = null
                        let y = this.spacing
                        if (l || s) {
                            l && (m = G.setArraySize(this.lengths, h))
                            for (var v = 0, b = f - 1; v < b;) {
                                const E = (C = d[v]).data.length
                                if (E < t.epsilon) { l && (m[v] = 0), p[++v] = 0
                                }
                                else {
                                    var x = E * C.matrix.a
                                    var T = E * C.matrix.b
                                    let S = Math.sqrt(x * x + T * T)
                                    l && (m[v] = S), p[++v] = (s ? E + y : y) * S / E
                                }
                            }
                        } else {
                            for (v = 1; v < f; v++) p[v] = y
                        }
                        const w = this.computeWorldPositions(e, f, c, o.positionMode == _.Percent, a == jt.Percent)
                        let O = w[0]
                        let P = w[1]
                        let R = o.offsetRotation
                        let A = !1
                        if (R == 0) A = u == g.Chain
                        else A = !1, R *= (I = this.target.bone.matrix).a * I.d - I.b * I.c > 0 ? B.degRad : -B.degRad
                        v = 0
                        for (var I = 3; v < h; v++, I += 3) {
                            var C; const k = (C = d[v]).matrix
                            k.tx += (O - k.tx) * r, k.ty += (P - k.ty) * r
                            const N = (x = w[I]) - O
                            let M = (T = w[I + 1]) - P
                            if (l) {
                                const j = m[v]
                                if (j != 0) {
                                    const D = (Math.sqrt(N * N + M * M) / j - 1) * n + 1
                                    k.a *= D, k.b *= D
                                }
                            }
                            if (O = x, P = T, i) {
                                const L = k.a
                                let F = k.c
                                let U = k.b
                                let X = k.d
                                let H = 0
                                let V = 0
                                let W = 0
                                if (H = c ? w[I - 1] : p[v + 1] == 0 ? w[I + 2] : Math.atan2(M, N), H -= Math.atan2(U, L), A) {
                                    V = Math.cos(H), W = Math.sin(H)
                                    const Y = C.data.length
                                    O += (Y * (V * L - W * U) - N) * n, P += (Y * (W * L + V * U) - M) * n
                                } else { H += R
                                }
                                H > B.PI ? H -= B.PI2 : H < -B.PI && (H += B.PI2), H *= n, V = Math.cos(H), W = Math.sin(H), k.a = V * L - W * U, k.c = V * F - W * X, k.b = W * L + V * U, k.d = W * F + V * X
                            }
                            C.appliedValid = !1
                        }
                    }
                }
            }, t.prototype.computeWorldPositions = function (e, n, r, i, o) {
                const a = this.target
                let s = this.position
                let u = this.spaces
                let c = G.setArraySize(this.positions, 3 * n + 2)
                let l = null
                let h = e.closed
                let f = e.worldVerticesLength
                let d = f / 6
                let p = t.NONE
                if (!e.constantSpeed) {
                    const m = e.lengths
                    let y = m[d -= h ? 1 : 2]
                    if (i && (s *= y), o) {
                        for (var v = 0; v < n; v++) u[v] *= y
                    }
                    l = G.setArraySize(this.world, 8)
                    v = 0
                    for (var _ = 0, g = 0; v < n; v++, _ += 3) {
                        var b = s += W = u[v]
                        if (h) { (b %= y) < 0 && (b += y), g = 0
                        }
                        else {
                            if (b < 0) {
                                p != t.BEFORE && (p = t.BEFORE, e.computeWorldVertices(a, 2, 4, l, 0, 2)), this.addBeforePosition(b, l, 0, c, _)
                                continue
                            }
                            if (b > y) {
                                p != t.AFTER && (p = t.AFTER, e.computeWorldVertices(a, f - 6, 4, l, 0, 2)), this.addAfterPosition(b - y, l, 0, c, _)
                                continue
                            }
                        }
                        for (;; g++) {
                            const E = m[g]
                            if (!(b > E)) {
                                if (g == 0) b /= E
                                else b = (b - (K = m[g - 1])) / (E - K)
                                break
                            }
                        }
                        g != p && (p = g, h && g == d ? (e.computeWorldVertices(a, f - 4, 4, l, 0, 2), e.computeWorldVertices(a, 0, 4, l, 4, 2)) : e.computeWorldVertices(a, 6 * g + 2, 8, l, 0, 2)), this.addCurvePosition(b, l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], c, _, r || v > 0 && W == 0)
                    }
                    return c
                }
                h ? (f += 2, l = G.setArraySize(this.world, f), e.computeWorldVertices(a, 2, f - 4, l, 0, 2), e.computeWorldVertices(a, 0, 2, l, f - 4, 2), l[f - 2] = l[0], l[f - 1] = l[1]) : (d--, f -= 4, l = G.setArraySize(this.world, f), e.computeWorldVertices(a, 2, f, l, 0, 2))
                for (var x = G.setArraySize(this.curves, d), T = 0, S = l[0], w = l[1], O = 0, P = 0, R = 0, A = 0, I = 0, C = 0, k = 0, N = 0, M = 0, j = 0, D = 0, L = 0, F = 0, B = 0, U = (v = 0, 2); v < d; v++, U += 6) O = l[U], P = l[U + 1], R = l[U + 2], A = l[U + 3], D = 2 * (k = 0.1875 * (S - 2 * O + R)) + (M = 0.09375 * (3 * (O - R) - S + (I = l[U + 4]))), L = 2 * (N = 0.1875 * (w - 2 * P + A)) + (j = 0.09375 * (3 * (P - A) - w + (C = l[U + 5]))), F = 0.75 * (O - S) + k + 0.16666667 * M, B = 0.75 * (P - w) + N + 0.16666667 * j, T += Math.sqrt(F * F + B * B), F += D, B += L, D += M, L += j, T += Math.sqrt(F * F + B * B), F += D, B += L, T += Math.sqrt(F * F + B * B), F += D + M, B += L + j, T += Math.sqrt(F * F + B * B), x[v] = T, S = I, w = C
                if (i && (s *= T), o) {
                    for (v = 0; v < n; v++) u[v] *= T
                }
                for (let X = this.segments, H = 0, V = (v = 0, _ = 0, g = 0, 0); v < n; v++, _ += 3) {
                    var W
                    b = s += W = u[v]
                    if (h) { (b %= T) < 0 && (b += T), g = 0
                    }
                    else {
                        if (b < 0) {
                            this.addBeforePosition(b, l, 0, c, _)
                            continue
                        }
                        if (b > T) {
                            this.addAfterPosition(b - T, l, f - 4, c, _)
                            continue
                        }
                    }
                    for (;; g++) {
                        const Y = x[g]
                        if (!(b > Y)) {
                            if (g == 0) b /= Y
                            else b = (b - (K = x[g - 1])) / (Y - K)
                            break
                        }
                    }
                    if (g != p) {
                        p = g
                        let z = 6 * g
                        for (S = l[z], w = l[z + 1], O = l[z + 2], P = l[z + 3], R = l[z + 4], A = l[z + 5], D = 2 * (k = 0.03 * (S - 2 * O + R)) + (M = 0.006 * (3 * (O - R) - S + (I = l[z + 6]))), L = 2 * (N = 0.03 * (w - 2 * P + A)) + (j = 0.006 * (3 * (P - A) - w + (C = l[z + 7]))), F = 0.3 * (O - S) + k + 0.16666667 * M, B = 0.3 * (P - w) + N + 0.16666667 * j, H = Math.sqrt(F * F + B * B), X[0] = H, z = 1; z < 8; z++) F += D, B += L, D += M, L += j, H += Math.sqrt(F * F + B * B), X[z] = H
                        F += D, B += L, H += Math.sqrt(F * F + B * B), X[8] = H, F += D + M, B += L + j, H += Math.sqrt(F * F + B * B), X[9] = H, V = 0
                    }
                    for (b *= H; ; V++) {
                        const q = X[V]
                        if (!(b > q)) {
                            var K
                            if (V == 0) b /= q
                            else b = V + (b - (K = X[V - 1])) / (q - K)
                            break
                        }
                    }
                    this.addCurvePosition(0.1 * b, S, w, O, P, R, A, I, C, c, _, r || v > 0 && W == 0)
                }
                return c
            }, t.prototype.addBeforePosition = function (t, e, n, r, i) {
                const o = e[n]
                let a = e[n + 1]
                let s = e[n + 2] - o
                let u = e[n + 3] - a
                let c = Math.atan2(u, s)
                r[i] = o + t * Math.cos(c), r[i + 1] = a + t * Math.sin(c), r[i + 2] = c
            }, t.prototype.addAfterPosition = function (t, e, n, r, i) {
                const o = e[n + 2]
                let a = e[n + 3]
                let s = o - e[n]
                let u = a - e[n + 1]
                let c = Math.atan2(u, s)
                r[i] = o + t * Math.cos(c), r[i + 1] = a + t * Math.sin(c), r[i + 2] = c
            }, t.prototype.addCurvePosition = function (t, e, n, r, i, o, a, s, u, c, l, h) {
                (t == 0 || isNaN(t)) && (t = 1e-4)
                const f = t * t
                let d = f * t
                let p = 1 - t
                let m = p * p
                let y = m * p
                let v = p * t
                let _ = 3 * v
                let g = p * _
                let b = _ * t
                let E = e * y + r * g + o * b + s * d
                let x = n * y + i * g + a * b + u * d
                c[l] = E, c[l + 1] = x, h && (c[l + 2] = Math.atan2(x - (n * m + i * v * 2 + a * f), E - (e * m + r * v * 2 + o * f)))
            }, t.NONE = -1, t.BEFORE = -2, t.AFTER = -3, t.epsilon = 1e-5, t
        }())
        var qt = (function () {
            function t(t, e) {
                if (this.deform = [], t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('bone cannot be null.')
                this.data = t, this.bone = e, this.color = new F(), this.darkColor = t.darkColor == null ? null : new F(), this.setToSetupPose(), this.blendMode = this.data.blendMode
            }
            return t.prototype.getAttachment = function () {
                return this.attachment
            }, t.prototype.setAttachment = function (t) {
                this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, this.deform.length = 0)
            }, t.prototype.setAttachmentTime = function (t) {
                this.attachmentTime = this.bone.skeleton.time - t
            }, t.prototype.getAttachmentTime = function () {
                return this.bone.skeleton.time - this.attachmentTime
            }, t.prototype.setToSetupPose = function () {
                this.color.setFromColor(this.data.color), this.darkColor != null && this.darkColor.setFromColor(this.data.darkColor), this.data.attachmentName == null ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
            }, t
        }())
        var Kt = (function () {
            function t(t, e) {
                if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new H(), this.active = !1, t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix, this.scaleMix = t.scaleMix, this.shearMix = t.shearMix, this.bones = []
                for (let n = 0; n < t.bones.length; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findBone(t.target.name)
            }
            return t.prototype.isActive = function () {
                return this.active
            }, t.prototype.apply = function () {
                this.update()
            }, t.prototype.update = function () {
                this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
            }, t.prototype.applyAbsoluteWorld = function () {
                for (let t = this.rotateMix, e = this.translateMix, n = this.scaleMix, r = this.shearMix, i = this.target, o = i.matrix, a = o.a, s = o.c, u = o.b, c = o.d, l = a * c - s * u > 0 ? B.degRad : -B.degRad, h = this.data.offsetRotation * l, f = this.data.offsetShearY * l, d = this.bones, p = 0, m = d.length; p < m; p++) {
                    const y = d[p]
                    var v = !1
                    var _ = y.matrix
                    if (t != 0) {
                        const g = _.a
                        var b = _.c
                        var E = _.b
                        var x = _.d;
                        (R = Math.atan2(u, a) - Math.atan2(E, g) + h) > B.PI ? R -= B.PI2 : R < -B.PI && (R += B.PI2), R *= t
                        let T = Math.cos(R)
                        var S = Math.sin(R)
                        _.a = T * g - S * E, _.c = T * b - S * x, _.b = S * g + T * E, _.d = S * b + T * x, v = !0
                    }
                    if (e != 0) {
                        const w = this.temp
                        i.localToWorld(w.set(this.data.offsetX, this.data.offsetY)), _.tx += (w.x - _.tx) * e, _.ty += (w.y - _.ty) * e, v = !0
                    }
                    if (n > 0) {
                        var O = Math.sqrt(_.a * _.a + _.b * _.b)
                        var P = Math.sqrt(a * a + u * u)
                        O > 1e-5 && (O = (O + (P - O + this.data.offsetScaleX) * n) / O), _.a *= O, _.b *= O, O = Math.sqrt(_.c * _.c + _.d * _.d), P = Math.sqrt(s * s + c * c), O > 1e-5 && (O = (O + (P - O + this.data.offsetScaleY) * n) / O), _.c *= O, _.d *= O, v = !0
                    }
                    if (r > 0) {
                        b = _.c, x = _.d
                        var R; const A = Math.atan2(x, b);
                        (R = Math.atan2(c, s) - Math.atan2(u, a) - (A - Math.atan2(_.b, _.a))) > B.PI ? R -= B.PI2 : R < -B.PI && (R += B.PI2), R = A + (R + f) * r
                        O = Math.sqrt(b * b + x * x)
                        _.c = Math.cos(R) * O, _.d = Math.sin(R) * O, v = !0
                    }
                    v && (y.appliedValid = !1)
                }
            }, t.prototype.applyRelativeWorld = function () {
                for (let t = this.rotateMix, e = this.translateMix, n = this.scaleMix, r = this.shearMix, i = this.target, o = i.matrix, a = o.a, s = o.c, u = o.b, c = o.d, l = a * c - s * u > 0 ? B.degRad : -B.degRad, h = this.data.offsetRotation * l, f = this.data.offsetShearY * l, d = this.bones, p = 0, m = d.length; p < m; p++) {
                    const y = d[p]
                    var v = !1
                    var _ = y.matrix
                    if (t != 0) {
                        const g = _.a
                        var b = _.c
                        var E = _.b
                        var x = _.d;
                        (P = Math.atan2(u, a) + h) > B.PI ? P -= B.PI2 : P < -B.PI && (P += B.PI2), P *= t
                        let T = Math.cos(P)
                        var S = Math.sin(P)
                        _.a = T * g - S * E, _.c = T * b - S * x, _.b = S * g + T * E, _.d = S * b + T * x, v = !0
                    }
                    if (e != 0) {
                        const w = this.temp
                        i.localToWorld(w.set(this.data.offsetX, this.data.offsetY)), _.tx += w.x * e, _.ty += w.y * e, v = !0
                    }
                    if (n > 0) {
                        var O = (Math.sqrt(a * a + u * u) - 1 + this.data.offsetScaleX) * n + 1
                        _.a *= O, _.b *= O, O = (Math.sqrt(s * s + c * c) - 1 + this.data.offsetScaleY) * n + 1, _.c *= O, _.d *= O, v = !0
                    }
                    if (r > 0) {
                        var P;
                        (P = Math.atan2(c, s) - Math.atan2(u, a)) > B.PI ? P -= B.PI2 : P < -B.PI && (P += B.PI2)
                        b = _.c, x = _.d
                        P = Math.atan2(x, b) + (P - B.PI / 2 + f) * r
                        O = Math.sqrt(b * b + x * x)
                        _.c = Math.cos(P) * O, _.d = Math.sin(P) * O, v = !0
                    }
                    v && (y.appliedValid = !1)
                }
            }, t.prototype.applyAbsoluteLocal = function () {
                const t = this.rotateMix
                var e = this.translateMix
                var n = this.scaleMix
                var r = this.shearMix
                var i = this.target
                i.appliedValid || i.updateAppliedTransform()
                for (let o = this.bones, a = 0, s = o.length; a < s; a++) {
                    const u = o[a]
                    u.appliedValid || u.updateAppliedTransform()
                    let c = u.arotation
                    if (t != 0) {
                        var l = i.arotation - c + this.data.offsetRotation
                        c += (l -= 360 * (16384 - (16384.499999999996 - l / 360 | 0))) * t
                    }
                    let h = u.ax
                    var f = u.ay
                    e != 0 && (h += (i.ax - h + this.data.offsetX) * e, f += (i.ay - f + this.data.offsetY) * e)
                    let d = u.ascaleX
                    var p = u.ascaleY
                    n > 0 && (d > 1e-5 && (d = (d + (i.ascaleX - d + this.data.offsetScaleX) * n) / d), p > 1e-5 && (p = (p + (i.ascaleY - p + this.data.offsetScaleY) * n) / p))
                    let m = u.ashearY
                    if (r > 0) {
                        l = i.ashearY - m + this.data.offsetShearY
                        l -= 360 * (16384 - (16384.499999999996 - l / 360 | 0)), u.shearY += l * r
                    }
                    u.updateWorldTransformWith(h, f, c, d, p, u.ashearX, m)
                }
            }, t.prototype.applyRelativeLocal = function () {
                const t = this.rotateMix
                var e = this.translateMix
                var n = this.scaleMix
                var r = this.shearMix
                var i = this.target
                i.appliedValid || i.updateAppliedTransform()
                for (let o = this.bones, a = 0, s = o.length; a < s; a++) {
                    const u = o[a]
                    u.appliedValid || u.updateAppliedTransform()
                    let c = u.arotation
                    t != 0 && (c += (i.arotation + this.data.offsetRotation) * t)
                    let l = u.ax
                    var h = u.ay
                    e != 0 && (l += (i.ax + this.data.offsetX) * e, h += (i.ay + this.data.offsetY) * e)
                    let f = u.ascaleX
                    var d = u.ascaleY
                    n > 0 && (f > 1e-5 && (f *= (i.ascaleX - 1 + this.data.offsetScaleX) * n + 1), d > 1e-5 && (d *= (i.ascaleY - 1 + this.data.offsetScaleY) * n + 1))
                    let p = u.ashearY
                    r > 0 && (p += (i.ashearY + this.data.offsetShearY) * r), u.updateWorldTransformWith(l, h, c, f, d, u.ashearX, p)
                }
            }, t
        }())
        var Zt = (function () {
            function t(t) {
                if (this._updateCache = [], this.updateCacheReset = [], this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, t == null) throw new Error('data cannot be null.')
                this.data = t, this.bones = []
                for (var e = 0; e < t.bones.length; e++) {
                    const n = t.bones[e]
                    var r = void 0
                    if (n.parent == null) { r = new Bt(n, this, null)
                    }
                    else {
                        const i = this.bones[n.parent.index]
                        r = new Bt(n, this, i), i.children.push(r)
                    }
                    this.bones.push(r)
                }
                this.slots = [], this.drawOrder = []
                for (e = 0; e < t.slots.length; e++) {
                    const o = t.slots[e]
                    var a = (r = this.bones[o.boneData.index], new qt(o, r))
                    this.slots.push(a), this.drawOrder.push(a)
                }
                this.ikConstraints = []
                for (e = 0; e < t.ikConstraints.length; e++) {
                    const s = t.ikConstraints[e]
                    this.ikConstraints.push(new Vt(s, this))
                }
                this.transformConstraints = []
                for (e = 0; e < t.transformConstraints.length; e++) {
                    const u = t.transformConstraints[e]
                    this.transformConstraints.push(new Kt(u, this))
                }
                this.pathConstraints = []
                for (e = 0; e < t.pathConstraints.length; e++) {
                    const c = t.pathConstraints[e]
                    this.pathConstraints.push(new zt(c, this))
                }
                this.color = new F(1, 1, 1, 1), this.updateCache()
            }
            return t.prototype.updateCache = function () {
                this._updateCache.length = 0, this.updateCacheReset.length = 0
                for (var t = this.bones, e = 0, n = t.length; e < n; e++) {
                    (i = t[e]).sorted = i.data.skinRequired, i.active = !i.sorted
                }
                if (this.skin != null) {
                    const r = this.skin.bones
                    for (e = 0, n = this.skin.bones.length; e < n; e++) {
                        var i = this.bones[r[e].index]
                        do {
                            i.sorted = !1, i.active = !0, i = i.parent
                        } while (i != null)
                    }
                }
                const o = this.ikConstraints
                var a = this.transformConstraints
                var s = this.pathConstraints
                var u = o.length
                var c = a.length
                var l = s.length
                var h = u + c + l
                t: for (e = 0; e < h; e++) {
                    for (var f = 0; f < u; f++) {
                        if ((d = o[f]).data.order == e) {
                            this.sortIkConstraint(d)
                            continue t
                        }
                    }
                    for (f = 0; f < c; f++) {
                        if ((d = a[f]).data.order == e) {
                            this.sortTransformConstraint(d)
                            continue t
                        }
                    }
                    for (f = 0; f < l; f++) {
                        var d
                        if ((d = s[f]).data.order == e) {
                            this.sortPathConstraint(d)
                            continue t
                        }
                    }
                }
                for (e = 0, n = t.length; e < n; e++) this.sortBone(t[e])
            }, t.prototype.sortIkConstraint = function (t) {
                if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin != null && G.contains(this.skin.constraints, t.data, !0)), t.active) {
                    const e = t.target
                    this.sortBone(e)
                    let n = t.bones
                    var r = n[0]
                    if (this.sortBone(r), n.length > 1) {
                        const i = n[n.length - 1]
                        this._updateCache.includes(i) || this.updateCacheReset.push(i)
                    }
                    this._updateCache.push(t), this.sortReset(r.children), n[n.length - 1].sorted = !0
                }
            }, t.prototype.sortPathConstraint = function (t) {
                if (t.active = t.target.bone.isActive() && (!t.data.skinRequired || this.skin != null && G.contains(this.skin.constraints, t.data, !0)), t.active) {
                    const e = t.target
                    var n = e.data.index
                    var r = e.bone
                    this.skin != null && this.sortPathConstraintAttachment(this.skin, n, r), this.data.defaultSkin != null && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, r)
                    for (var i = 0, o = this.data.skins.length; i < o; i++) this.sortPathConstraintAttachment(this.data.skins[i], n, r)
                    let a = e.getAttachment()
                    a instanceof ut && this.sortPathConstraintAttachmentWith(a, r)
                    let s = t.bones
                    var u = s.length
                    for (i = 0; i < u; i++) this.sortBone(s[i])
                    this._updateCache.push(t)
                    for (i = 0; i < u; i++) this.sortReset(s[i].children)
                    for (i = 0; i < u; i++) s[i].sorted = !0
                }
            }, t.prototype.sortTransformConstraint = function (t) {
                if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin != null && G.contains(this.skin.constraints, t.data, !0)), t.active) {
                    this.sortBone(t.target)
                    let e = t.bones
                    var n = e.length
                    if (t.data.local) {
                        for (var r = 0; r < n; r++) {
                            let i = e[r]
                            this.sortBone(i.parent), this._updateCache.includes(i) || this.updateCacheReset.push(i)
                        }
                    } else {
                        for (r = 0; r < n; r++) this.sortBone(e[r])
                    }
                    this._updateCache.push(t)
                    for (var o = 0; o < n; o++) this.sortReset(e[o].children)
                    for (o = 0; o < n; o++) e[o].sorted = !0
                }
            }, t.prototype.sortPathConstraintAttachment = function (t, e, n) {
                const r = t.attachments[e]
                if (r) {
                    for (const i in r) this.sortPathConstraintAttachmentWith(r[i], n)
                }
            }, t.prototype.sortPathConstraintAttachmentWith = function (t, e) {
                if (t instanceof ut) {
                    const n = t.bones
                    if (n == null) { this.sortBone(e)
                    }
                    else {
                        for (let r = this.bones, i = 0; i < n.length;) {
                            for (let o = n[i++], a = i + o; i < a; i++) {
                                var s = n[i]
                                        this.sortBone(r[s])
                            }
                        }
                    }
                }
            }, t.prototype.sortBone = function (t) {
                if (!t.sorted) {
                    const e = t.parent
                    e != null && this.sortBone(e), t.sorted = !0, this._updateCache.push(t)
                }
            }, t.prototype.sortReset = function (t) {
                for (let e = 0, n = t.length; e < n; e++) {
                    const r = t[e]
                    r.active && (r.sorted && this.sortReset(r.children), r.sorted = !1)
                }
            }, t.prototype.updateWorldTransform = function () {
                for (var t = this.updateCacheReset, e = 0, n = t.length; e < n; e++) {
                    const r = t[e]
                    r.ax = r.x, r.ay = r.y, r.arotation = r.rotation, r.ascaleX = r.scaleX, r.ascaleY = r.scaleY, r.ashearX = r.shearX, r.ashearY = r.shearY, r.appliedValid = !0
                }
                const i = this._updateCache
                for (e = 0, n = i.length; e < n; e++) i[e].update()
            }, t.prototype.setToSetupPose = function () {
                this.setBonesToSetupPose(), this.setSlotsToSetupPose()
            }, t.prototype.setBonesToSetupPose = function () {
                for (var t = this.bones, e = 0, n = t.length; e < n; e++) t[e].setToSetupPose()
                let r = this.ikConstraints
                for (e = 0, n = r.length; e < n; e++) {
                    (s = r[e]).mix = s.data.mix, s.softness = s.data.softness, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch
                }
                const i = this.transformConstraints
                for (e = 0, n = i.length; e < n; e++) {
                    var o = (s = i[e]).data
                    s.rotateMix = o.rotateMix, s.translateMix = o.translateMix, s.scaleMix = o.scaleMix, s.shearMix = o.shearMix
                }
                const a = this.pathConstraints
                for (e = 0, n = a.length; e < n; e++) {
                    var s
                    o = (s = a[e]).data
                    s.position = o.position, s.spacing = o.spacing, s.rotateMix = o.rotateMix, s.translateMix = o.translateMix
                }
            }, t.prototype.setSlotsToSetupPose = function () {
                const t = this.slots
                G.arrayCopy(t, 0, this.drawOrder, 0, t.length)
                for (let e = 0, n = t.length; e < n; e++) t[e].setToSetupPose()
            }, t.prototype.getRootBone = function () {
                return this.bones.length == 0 ? null : this.bones[0]
            }, t.prototype.findBone = function (t) {
                if (t == null) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findBoneIndex = function (t) {
                if (t == null) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    if (e[n].data.name == t) return n
                }
                return -1
            }, t.prototype.findSlot = function (t) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findSlotIndex = function (t) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    if (e[n].data.name == t) return n
                }
                return -1
            }, t.prototype.setSkinByName = function (t) {
                const e = this.data.findSkin(t)
                if (e == null) throw new Error(`Skin not found: ${ t}`)
                this.setSkin(e)
            }, t.prototype.setSkin = function (t) {
                if (t != this.skin) {
                    if (t != null) {
                        if (this.skin != null) { t.attachAll(this, this.skin)
}
                        else {
                            for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                            var o = i.data.attachmentName
                                        if (o != null) {
                                    var a = t.getAttachment(n, o)
                                            null != a && i.setAttachment(a)
                                }
                            }
                        }
                    }
                    this.skin = t, this.updateCache()
                }
            }, t.prototype.getAttachmentByName = function (t, e) {
                return this.getAttachment(this.data.findSlotIndex(t), e)
            }, t.prototype.getAttachment = function (t, e) {
                if (e == null) throw new Error('attachmentName cannot be null.')
                if (this.skin != null) {
                    const n = this.skin.getAttachment(t, e)
                    if (n != null) return n
                }
                return this.data.defaultSkin != null ? this.data.defaultSkin.getAttachment(t, e) : null
            }, t.prototype.setAttachment = function (t, e) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let n = this.slots, r = 0, i = n.length; r < i; r++) {
                    const o = n[r]
                    if (o.data.name == t) {
                        let a = null
                        if (e != null && (a = this.getAttachment(r, e)) == null) throw new Error(`Attachment not found: ${ e }, for slot: ${ t}`)
                        return void o.setAttachment(a)
                    }
                }
                throw new Error(`Slot not found: ${ t}`)
            }, t.prototype.findIkConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.ikConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findTransformConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.transformConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.getBounds = function (t, e, n) {
                if (void 0 === n && (n = Array.from({ length: 2 })), t == null) throw new Error('offset cannot be null.')
                if (e == null) throw new Error('size cannot be null.')
                for (var r = this.drawOrder, i = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY, u = 0, c = r.length; u < c; u++) {
                    const l = r[u]
                    if (l.bone.active) {
                        let h = 0
                        var f = null
                        var d = l.getAttachment()
                        if (d instanceof lt) { h = 8, f = G.setArraySize(n, h, 0), d.computeWorldVertices(l.bone, f, 0, 2)
                        }
                        else if (d instanceof st) {
                            const p = d
                            h = p.worldVerticesLength, f = G.setArraySize(n, h, 0), p.computeWorldVertices(l, 0, h, f, 0, 2)
                        }
                        if (f != null) {
                            for (let m = 0, y = f.length; m < y; m += 2) {
                                let v = f[m]
                                            var _ = f[m + 1]
                                i = Math.min(i, v), o = Math.min(o, _), a = Math.max(a, v), s = Math.max(s, _)
                            }
                        }
                    }
                }
                t.set(i, o), e.set(a - i, s - o)
            }, t.prototype.update = function (t) {
                this.time += t
            }, Object.defineProperty(t.prototype, 'flipX', {
                get() {
                    return this.scaleX == -1
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY')), this.scaleX = e ? 1 : -1
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'flipY', {
                get() {
                    return this.scaleY == -1
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY')), this.scaleY = e ? 1 : -1
                },
                enumerable: !1,
                configurable: !0
            }), t.deprecatedWarning1 = !1, t
        }())
        var $t = (function () {
            function t() {
                this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], this.ikConstraints = [], this.transformConstraints = [], this.pathConstraints = [], this.fps = 0
            }
            return t.prototype.findBone = function (t) {
                if (t == null) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findBoneIndex = function (t) {
                if (t == null) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t.prototype.findSlot = function (t) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findSlotIndex = function (t) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t.prototype.findSkin = function (t) {
                if (t == null) throw new Error('skinName cannot be null.')
                for (let e = this.skins, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findEvent = function (t) {
                if (t == null) throw new Error('eventDataName cannot be null.')
                for (let e = this.events, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findAnimation = function (t) {
                if (t == null) throw new Error('animationName cannot be null.')
                for (let e = this.animations, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findIkConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.ikConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findTransformConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.transformConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraintIndex = function (t) {
                if (t == null) throw new Error('pathConstraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t
        }())
        var Jt = function (t, e, n) {
            if (this.color = new F(1, 1, 1, 1), t < 0) throw new Error('index must be >= 0.')
            if (e == null) throw new Error('name cannot be null.')
            if (n == null) throw new Error('boneData cannot be null.')
            this.index = t, this.name = e, this.boneData = n
        }
        var Qt = (function (t) {
            function e(e) {
                const n = t.call(this, e, 0, !1) || this
                return n.bones = [], n.rotateMix = 0, n.translateMix = 0, n.scaleMix = 0, n.shearMix = 0, n.offsetRotation = 0, n.offsetX = 0, n.offsetY = 0, n.offsetScaleX = 0, n.offsetScaleY = 0, n.offsetShearY = 0, n.relative = !1, n.local = !1, n
            }
            return et(e, t), e
        }(Gt))
        var te = function (t, e, n) {
            this.slotIndex = t, this.name = e, this.attachment = n
        }
        var ee = (function () {
            function t(t) {
                if (this.attachments = [], this.bones = [], this.constraints = [], t == null) throw new Error('name cannot be null.')
                this.name = t
            }
            return t.prototype.setAttachment = function (t, e, n) {
                if (n == null) throw new Error('attachment cannot be null.')
                let r = this.attachments
                t >= r.length && (r.length = t + 1), r[t] || (r[t] = {}), r[t][e] = n
            }, t.prototype.addSkin = function (t) {
                for (var e = 0; e < t.bones.length; e++) {
                    for (var n = t.bones[e], r = !1, i = 0; i < this.bones.length; i++) {
                        if (this.bones[i] == n) {
                            r = !0
                            break
                        }
                    }
                    r || this.bones.push(n)
                }
                for (e = 0; e < t.constraints.length; e++) {
                    const o = t.constraints[e]
                    for (r = !1, i = 0; i < this.constraints.length; i++) {
                        if (this.constraints[i] == o) {
                            r = !0
                            break
                        }
                    }
                    r || this.constraints.push(o)
                }
                const a = t.getAttachments()
                for (e = 0; e < a.length; e++) {
                    const s = a[e]
                    this.setAttachment(s.slotIndex, s.name, s.attachment)
                }
            }, t.prototype.copySkin = function (t) {
                for (var e = 0; e < t.bones.length; e++) {
                    for (var n = t.bones[e], r = !1, i = 0; i < this.bones.length; i++) {
                        if (this.bones[i] == n) {
                            r = !0
                            break
                        }
                    }
                    r || this.bones.push(n)
                }
                for (e = 0; e < t.constraints.length; e++) {
                    const o = t.constraints[e]
                    for (r = !1, i = 0; i < this.constraints.length; i++) {
                        if (this.constraints[i] == o) {
                            r = !0
                            break
                        }
                    }
                    r || this.constraints.push(o)
                }
                const a = t.getAttachments()
                for (e = 0; e < a.length; e++) {
                    const s = a[e]
                    s.attachment != null && (s.attachment instanceof st ? (s.attachment = s.attachment.newLinkedMesh(), this.setAttachment(s.slotIndex, s.name, s.attachment)) : (s.attachment = s.attachment.copy(), this.setAttachment(s.slotIndex, s.name, s.attachment)))
                }
            }, t.prototype.getAttachment = function (t, e) {
                const n = this.attachments[t]
                return n ? n[e] : null
            }, t.prototype.removeAttachment = function (t, e) {
                const n = this.attachments[t]
                n && (n[e] = null)
            }, t.prototype.getAttachments = function () {
                for (var t = [], e = 0; e < this.attachments.length; e++) {
                    const n = this.attachments[e]
                    if (n) {
                        for (const r in n) {
                            let i = n[r]
                            i && t.push(new te(e, r, i))
                        }
                    }
                }
                return t
            }, t.prototype.getAttachmentsForSlot = function (t, e) {
                const n = this.attachments[t]
                if (n) {
                    for (const r in n) {
                        let i = n[r]
                        i && e.push(new te(t, r, i))
                    }
                }
            }, t.prototype.clear = function () {
                this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0
            }, t.prototype.attachAll = function (t, e) {
                for (let n = 0, r = 0; r < t.slots.length; r++) {
                    const i = t.slots[r]
                    var o = i.getAttachment()
                    if (o && n < e.attachments.length) {
                        const a = e.attachments[n]
                        for (const s in a) {
                            if (o == a[s]) {
                                const u = this.getAttachment(n, s)
                                u != null && i.setAttachment(u)
                                break
                            }
                        }
                    }
                    n++
                }
            }, t
        }())
        var ne = (function () {
            function t(t) {
                this.scale = 1, this.linkedMeshes = [], this.attachmentLoader = t
            }
            return t.prototype.readSkeletonData = function (e) {
                const n = this.scale
                var r = new $t()
                r.name = ''
                let i = new E(e)
                if (r.hash = i.readString(), r.version = i.readString(), r.version === '3.8.75') {
                    console.error('Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.')
                }
                r.x = i.readFloat(), r.y = i.readFloat(), r.width = i.readFloat(), r.height = i.readFloat()
                let o = i.readBoolean()
                o && (r.fps = i.readFloat(), r.imagesPath = i.readString(), r.audioPath = i.readString())
                let a = 0
                a = i.readInt(!0)
                for (var s = 0; s < a; s++) i.strings.push(i.readString())
                a = i.readInt(!0)
                for (s = 0; s < a; s++) {
                    const u = i.readString()
                    var c = s == 0 ? null : r.bones[i.readInt(!0)];
                    (f = new Ut(s, u, c)).rotation = i.readFloat(), f.x = i.readFloat() * n, f.y = i.readFloat() * n, f.scaleX = i.readFloat(), f.scaleY = i.readFloat(), f.shearX = i.readFloat(), f.shearY = i.readFloat(), f.length = i.readFloat() * n, f.transformMode = t.TransformModeValues[i.readInt(!0)], f.skinRequired = i.readBoolean(), o && F.rgba8888ToColor(f.color, i.readInt32()), r.bones.push(f)
                }
                a = i.readInt(!0)
                for (s = 0; s < a; s++) {
                    const l = i.readString()
                    var h = r.bones[i.readInt(!0)]
                    var f = new Jt(s, l, h)
                    F.rgba8888ToColor(f.color, i.readInt32())
                    let d = i.readInt32(); d != -1 && F.rgb888ToColor(f.darkColor = new F(), d), f.attachmentName = i.readStringRef(), f.blendMode = t.BlendModeValues[i.readInt(!0)], r.slots.push(f)
                }
                a = i.readInt(!0)
                s = 0
                for (var p = void 0; s < a; s++) {
                    (f = new Wt(i.readString())).order = i.readInt(!0), f.skinRequired = i.readBoolean(), p = i.readInt(!0)
                    for (var m = 0; m < p; m++) f.bones.push(r.bones[i.readInt(!0)])
                    f.target = r.bones[i.readInt(!0)], f.mix = i.readFloat(), f.softness = i.readFloat() * n, f.bendDirection = i.readByte(), f.compress = i.readBoolean(), f.stretch = i.readBoolean(), f.uniform = i.readBoolean(), r.ikConstraints.push(f)
                }
                a = i.readInt(!0)
                for (s = 0, p = void 0; s < a; s++) {
                    (f = new Qt(i.readString())).order = i.readInt(!0), f.skinRequired = i.readBoolean(), p = i.readInt(!0)
                    for (m = 0; m < p; m++) f.bones.push(r.bones[i.readInt(!0)])
                    f.target = r.bones[i.readInt(!0)], f.local = i.readBoolean(), f.relative = i.readBoolean(), f.offsetRotation = i.readFloat(), f.offsetX = i.readFloat() * n, f.offsetY = i.readFloat() * n, f.offsetScaleX = i.readFloat(), f.offsetScaleY = i.readFloat(), f.offsetShearY = i.readFloat(), f.rotateMix = i.readFloat(), f.translateMix = i.readFloat(), f.scaleMix = i.readFloat(), f.shearMix = i.readFloat(), r.transformConstraints.push(f)
                }
                a = i.readInt(!0)
                for (s = 0, p = void 0; s < a; s++) {
                    (f = new Yt(i.readString())).order = i.readInt(!0), f.skinRequired = i.readBoolean(), p = i.readInt(!0)
                    for (m = 0; m < p; m++) f.bones.push(r.bones[i.readInt(!0)])
                    f.target = r.slots[i.readInt(!0)], f.positionMode = t.PositionModeValues[i.readInt(!0)], f.spacingMode = t.SpacingModeValues[i.readInt(!0)], f.rotateMode = t.RotateModeValues[i.readInt(!0)], f.offsetRotation = i.readFloat(), f.position = i.readFloat(), f.positionMode == _.Fixed && (f.position *= n), f.spacing = i.readFloat(), f.spacingMode != jt.Length && f.spacingMode != jt.Fixed || (f.spacing *= n), f.rotateMix = i.readFloat(), f.translateMix = i.readFloat(), r.pathConstraints.push(f)
                }
                const y = this.readSkin(i, r, !0, o)
                y != null && (r.defaultSkin = y, r.skins.push(y))
                s = r.skins.length
                for (G.setArraySize(r.skins, a = s + i.readInt(!0)); s < a; s++) r.skins[s] = this.readSkin(i, r, !1, o)
                a = this.linkedMeshes.length
                for (s = 0; s < a; s++) {
                    const v = this.linkedMeshes[s]
                    var g = v.skin == null ? r.defaultSkin : r.findSkin(v.skin)
                    if (g == null) throw new Error(`Skin not found: ${ v.skin}`)
                    let b = g.getAttachment(v.slotIndex, v.parent)
                    if (b == null) throw new Error(`Parent mesh not found: ${ v.parent}`)
                    v.mesh.deformAttachment = v.inheritDeform ? b : v.mesh, v.mesh.setParentMesh(b)
                }
                this.linkedMeshes.length = 0, a = i.readInt(!0)
                for (s = 0; s < a; s++) {
                    (f = new Ht(i.readStringRef())).intValue = i.readInt(!1), f.floatValue = i.readFloat(), f.stringValue = i.readString(), f.audioPath = i.readString(), f.audioPath != null && (f.volume = i.readFloat(), f.balance = i.readFloat()), r.events.push(f)
                }
                a = i.readInt(!0)
                for (s = 0; s < a; s++) r.animations.push(this.readAnimation(i, i.readString(), r))
                return r
            }, t.prototype.readSkin = function (t, e, n, r) {
                let i = null
                var o = 0
                if (n) {
                    if ((o = t.readInt(!0)) == 0) return null
                    i = new ee('default')
                } else {
                    (i = new ee(t.readStringRef())).bones.length = t.readInt(!0)
                    for (var a = 0, s = i.bones.length; a < s; a++) i.bones[a] = e.bones[t.readInt(!0)]
                    for (a = 0, s = t.readInt(!0); a < s; a++) i.constraints.push(e.ikConstraints[t.readInt(!0)])
                    for (a = 0, s = t.readInt(!0); a < s; a++) i.constraints.push(e.transformConstraints[t.readInt(!0)])
                    for (a = 0, s = t.readInt(!0); a < s; a++) i.constraints.push(e.pathConstraints[t.readInt(!0)])
                    o = t.readInt(!0)
                }
                for (a = 0; a < o; a++) {
                    for (let u = t.readInt(!0), c = 0, l = t.readInt(!0); c < l; c++) {
                        let h = t.readStringRef()
                                    var f = this.readAttachment(t, e, i, u, h, r)
                        null != f && i.setAttachment(u, h, f)
                    }
                }
                return i
            }, t.prototype.readAttachment = function (e, n, r, i, o, s) {
                const u = this.scale
                var c = e.readStringRef()
                c == null && (c = o)
                let l = e.readByte()
                switch (t.AttachmentTypeValues[l]) {
                    case a.Region:
                        var h = e.readStringRef()
                        var f = e.readFloat()
                        var d = e.readFloat()
                        var p = e.readFloat()
                        var m = e.readFloat()
                        var y = e.readFloat()
                        var v = e.readFloat()
                        var _ = e.readFloat()
                        var g = e.readInt32()
                        h == null && (h = c)
                        var b = this.attachmentLoader.newRegionAttachment(r, c, h)
                        return b == null ? null : (b.path = h, b.x = d * u, b.y = p * u, b.scaleX = m, b.scaleY = y, b.rotation = f, b.width = v * u, b.height = _ * u, F.rgba8888ToColor(b.color, g), b)
                    case a.BoundingBox:
                        var E = e.readInt(!0)
                        var x = this.readVertices(e, E)
                        var T = (g = s ? e.readInt32() : 0, this.attachmentLoader.newBoundingBoxAttachment(r, c))
                        return T == null ? null : (T.worldVerticesLength = E << 1, T.vertices = x.vertices, T.bones = x.bones, s && F.rgba8888ToColor(T.color, g), T)
                    case a.Mesh:
                        h = e.readStringRef(), g = e.readInt32(), E = e.readInt(!0)
                        var S = this.readFloatArray(e, E << 1, 1)
                        var w = this.readShortArray(e)
                        var O = (x = this.readVertices(e, E), e.readInt(!0))
                        var P = null
                        v = 0, _ = 0
                        return s && (P = this.readShortArray(e), v = e.readFloat(), _ = e.readFloat()), h == null && (h = c), (R = this.attachmentLoader.newMeshAttachment(r, c, h)) == null ? null : (R.path = h, F.rgba8888ToColor(R.color, g), R.bones = x.bones, R.vertices = x.vertices, R.worldVerticesLength = E << 1, R.triangles = w, R.regionUVs = new Float32Array(S), R.hullLength = O << 1, s && (R.edges = P, R.width = v * u, R.height = _ * u), R)
                    case a.LinkedMesh:
                        h = e.readStringRef(), g = e.readInt32()
                        var R; var A = e.readStringRef()
                        var I = e.readStringRef()
                        var C = e.readBoolean()
                        v = 0, _ = 0
                        return s && (v = e.readFloat(), _ = e.readFloat()), h == null && (h = c), (R = this.attachmentLoader.newMeshAttachment(r, c, h)) == null ? null : (R.path = h, F.rgba8888ToColor(R.color, g), s && (R.width = v * u, R.height = _ * u), this.linkedMeshes.push(new re(R, A, i, I, C)), R)
                    case a.Path:
                        for (var k = e.readBoolean(), N = e.readBoolean(), M = (E = e.readInt(!0), x = this.readVertices(e, E), G.newArray(E / 3, 0)), j = 0, D = M.length; j < D; j++) M[j] = e.readFloat() * u
                        g = s ? e.readInt32() : 0
                        return (h = this.attachmentLoader.newPathAttachment(r, c)) == null ? null : (h.closed = k, h.constantSpeed = N, h.worldVerticesLength = E << 1, h.vertices = x.vertices, h.bones = x.bones, h.lengths = M, s && F.rgba8888ToColor(h.color, g), h)
                    case a.Point:
                        f = e.readFloat(), d = e.readFloat(), p = e.readFloat(), g = s ? e.readInt32() : 0
                        var L = this.attachmentLoader.newPointAttachment(r, c)
                        return L == null ? null : (L.x = d * u, L.y = p * u, L.rotation = f, s && F.rgba8888ToColor(L.color, g), L)
                    case a.Clipping:
                        var B = e.readInt(!0)
                        var U = (E = e.readInt(!0), x = this.readVertices(e, E), g = s ? e.readInt32() : 0, this.attachmentLoader.newClippingAttachment(r, c))
                        return U == null ? null : (U.endSlot = n.slots[B], U.worldVerticesLength = E << 1, U.vertices = x.vertices, U.bones = x.bones, s && F.rgba8888ToColor(U.color, g), U)
                }
                return null
            }, t.prototype.readVertices = function (t, e) {
                const n = e << 1
                var r = new ie()
                var i = this.scale
                if (!t.readBoolean()) return r.vertices = this.readFloatArray(t, n, i), r
                for (var o = [], a = [], s = 0; s < e; s++) {
                    const u = t.readInt(!0)
                    a.push(u)
                    for (let c = 0; c < u; c++) a.push(t.readInt(!0)), o.push(t.readFloat() * i), o.push(t.readFloat() * i), o.push(t.readFloat())
                }
                return r.vertices = G.toFloatArray(o), r.bones = a, r
            }, t.prototype.readFloatArray = function (t, e, n) {
                const r = new Array(e)
                if (n == 1) {
                    for (var i = 0; i < e; i++) r[i] = t.readFloat()
                }
                else {
                    for (i = 0; i < e; i++) r[i] = t.readFloat() * n
                }
                return r
            }, t.prototype.readShortArray = function (t) {
                for (var e = t.readInt(!0), n = new Array(e), r = 0; r < e; r++) n[r] = t.readShort()
                return n
            }, t.prototype.readAnimation = function (e, n, r) {
                for (var i = [], o = this.scale, a = 0, s = new F(), u = new F(), c = 0, l = e.readInt(!0); c < l; c++) {
                    for (var h = e.readInt(!0), f = 0, d = e.readInt(!0); f < d; f++) {
                        var p = e.readByte()
                                    var m = e.readInt(!0)
                        switch (p) {
                            case t.SLOT_ATTACHMENT:
                                (b = new xt(m)).slotIndex = h
                                for (var y = 0; y < m; y++) b.setFrame(y, e.readFloat(), e.readStringRef())
                                i.push(b), a = Math.max(a, b.frames[m - 1])
                                break;
                            case t.SLOT_COLOR:
                                (b = new bt(m)).slotIndex = h
                                for (y = 0; y < m; y++) {
                                    var v = e.readFloat()
                                    F.rgba8888ToColor(s, e.readInt32()), b.setFrame(y, v, s.r, s.g, s.b, s.a), y < m - 1 && this.readCurve(e, y, b)
                                }
                                i.push(b), a = Math.max(a, b.frames[(m - 1) * bt.ENTRIES])
                                break;
                            case t.SLOT_TWO_COLOR:
                                (b = new Et(m)).slotIndex = h
                                for (y = 0; y < m; y++) {
                                    v = e.readFloat()
                                    F.rgba8888ToColor(s, e.readInt32()), F.rgb888ToColor(u, e.readInt32()), b.setFrame(y, v, s.r, s.g, s.b, s.a, u.r, u.g, u.b), y < m - 1 && this.readCurve(e, y, b)
                                }
                                i.push(b), a = Math.max(a, b.frames[(m - 1) * Et.ENTRIES])
                        }
                    }
                }
                for (c = 0, l = e.readInt(!0); c < l; c++) {
                    const g = e.readInt(!0)
                    for (f = 0, d = e.readInt(!0); f < d; f++) {
                        p = e.readByte(), m = e.readInt(!0)
                        switch (p) {
                            case t.BONE_ROTATE:
                                (b = new yt(m)).boneIndex = g
                                for (y = 0; y < m; y++) b.setFrame(y, e.readFloat(), e.readFloat()), y < m - 1 && this.readCurve(e, y, b)
                                i.push(b), a = Math.max(a, b.frames[(m - 1) * yt.ENTRIES])
                                break
                            case t.BONE_TRANSLATE:
                            case t.BONE_SCALE:
                            case t.BONE_SHEAR:
                                var b = void 0
                                var E = 1
                                p == t.BONE_SCALE ? b = new _t(m) : p == t.BONE_SHEAR ? b = new gt(m) : (b = new vt(m), E = o), b.boneIndex = g
                                for (y = 0; y < m; y++) b.setFrame(y, e.readFloat(), e.readFloat() * E, e.readFloat() * E), y < m - 1 && this.readCurve(e, y, b)
                                i.push(b), a = Math.max(a, b.frames[(m - 1) * vt.ENTRIES])
                        }
                    }
                }
                for (c = 0, l = e.readInt(!0); c < l; c++) {
                    var x = e.readInt(!0)
                    m = e.readInt(!0);
                    (b = new Pt(m)).ikConstraintIndex = x
                    for (y = 0; y < m; y++) b.setFrame(y, e.readFloat(), e.readFloat(), e.readFloat() * o, e.readByte(), e.readBoolean(), e.readBoolean()), y < m - 1 && this.readCurve(e, y, b)
                    i.push(b), a = Math.max(a, b.frames[(m - 1) * Pt.ENTRIES])
                }
                for (c = 0, l = e.readInt(!0); c < l; c++) {
                    x = e.readInt(!0), m = e.readInt(!0);
                    (b = new Rt(m)).transformConstraintIndex = x
                    for (y = 0; y < m; y++) b.setFrame(y, e.readFloat(), e.readFloat(), e.readFloat(), e.readFloat(), e.readFloat()), y < m - 1 && this.readCurve(e, y, b)
                    i.push(b), a = Math.max(a, b.frames[(m - 1) * Rt.ENTRIES])
                }
                for (c = 0, l = e.readInt(!0); c < l; c++) {
                    x = e.readInt(!0)
                    let T = r.pathConstraints[x]
                    for (f = 0, d = e.readInt(!0); f < d; f++) {
                        p = e.readByte(), m = e.readInt(!0)
                        switch (p) {
                            case t.PATH_POSITION:
                            case t.PATH_SPACING:
                                b = void 0, E = 1
                                p == t.PATH_SPACING ? (b = new It(m), T.spacingMode != jt.Length && T.spacingMode != jt.Fixed || (E = o)) : (b = new At(m), T.positionMode == _.Fixed && (E = o)), b.pathConstraintIndex = x
                                for (y = 0; y < m; y++) b.setFrame(y, e.readFloat(), e.readFloat() * E), y < m - 1 && this.readCurve(e, y, b)
                                i.push(b), a = Math.max(a, b.frames[(m - 1) * At.ENTRIES])
                                break
                            case t.PATH_MIX:
                                (b = new Ct(m)).pathConstraintIndex = x
                                for (y = 0; y < m; y++) b.setFrame(y, e.readFloat(), e.readFloat(), e.readFloat()), y < m - 1 && this.readCurve(e, y, b)
                                i.push(b), a = Math.max(a, b.frames[(m - 1) * Ct.ENTRIES])
                        }
                    }
                }
                for (c = 0, l = e.readInt(!0); c < l; c++) {
                    const S = r.skins[e.readInt(!0)]
                    for (f = 0, d = e.readInt(!0); f < d; f++) {
                        h = e.readInt(!0)
                        for (let w = 0, O = e.readInt(!0); w < O; w++) {
                            const P = S.getAttachment(h, e.readStringRef())
                            var R = P.bones != null
                            var A = P.vertices
                            var I = R ? A.length / 3 * 2 : A.length
                            m = e.readInt(!0);
                            (b = new St(m)).slotIndex = h, b.attachment = P
                            for (y = 0; y < m; y++) {
                                v = e.readFloat()
                                let C = void 0
                                var k = e.readInt(!0)
                                if (k == 0) { C = R ? G.newFloatArray(I) : A
                                }
                                else {
                                    C = G.newFloatArray(I)
                                    let N = e.readInt(!0)
                                    if (k += N, o == 1) {
                                        for (var M = N; M < k; M++) C[M] = e.readFloat()
                                    }
                                    else {
                                        for (M = N; M < k; M++) C[M] = e.readFloat() * o
                                    }
                                    if (!R) {
                                        M = 0
                                        for (let j = C.length; M < j; M++) C[M] += A[M]
                                    }
                                }
                                b.setFrame(y, v, C), y < m - 1 && this.readCurve(e, y, b)
                            }
                            i.push(b), a = Math.max(a, b.frames[m - 1])
                        }
                    }
                }
                const D = e.readInt(!0)
                if (D > 0) {
                    b = new Ot(D)
                    let L = r.slots.length
                    for (c = 0; c < D; c++) {
                        v = e.readFloat()
                        let B = e.readInt(!0)
                        var U = G.newArray(L, 0)
                        for (f = L - 1; f >= 0; f--) U[f] = -1
                        let X = G.newArray(L - B, 0)
                        var H = 0
                        var V = 0
                        for (f = 0; f < B; f++) {
                            for (h = e.readInt(!0); H != h;) X[V++] = H++
                            U[H + e.readInt(!0)] = H++
                        }
                        for (; H < L;) X[V++] = H++
                        for (f = L - 1; f >= 0; f--) U[f] == -1 && (U[f] = X[--V])
                        b.setFrame(c, v, U)
                    }
                    i.push(b), a = Math.max(a, b.frames[D - 1])
                }
                const W = e.readInt(!0)
                if (W > 0) {
                    for (b = new wt(W), c = 0; c < W; c++) {
                        v = e.readFloat()
                        let Y = r.events[e.readInt(!0)]
                        var z = new Xt(v, Y)
                        z.intValue = e.readInt(!1), z.floatValue = e.readFloat(), z.stringValue = e.readBoolean() ? e.readString() : Y.stringValue, z.data.audioPath != null && (z.volume = e.readFloat(), z.balance = e.readFloat()), b.setFrame(c, z)
                    }
                    i.push(b), a = Math.max(a, b.frames[W - 1])
                }
                return new dt(n, i, a)
            }, t.prototype.readCurve = function (e, n, r) {
                switch (e.readByte()) {
                    case t.CURVE_STEPPED:
                        r.setStepped(n)
                        break
                    case t.CURVE_BEZIER:
                        this.setCurve(r, n, e.readFloat(), e.readFloat(), e.readFloat(), e.readFloat())
                }
            }, t.prototype.setCurve = function (t, e, n, r, i, o) {
                t.setCurve(e, n, r, i, o)
            }, t.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6], t.TransformModeValues = [b.Normal, b.OnlyTranslation, b.NoRotationOrReflection, b.NoScale, b.NoScaleOrReflection], t.PositionModeValues = [_.Fixed, _.Percent], t.SpacingModeValues = [jt.Length, jt.Fixed, jt.Percent], t.RotateModeValues = [g.Tangent, g.Chain, g.ChainScale], t.BlendModeValues = [c.b.NORMAL, c.b.ADD, c.b.MULTIPLY, c.b.SCREEN], t.BONE_ROTATE = 0, t.BONE_TRANSLATE = 1, t.BONE_SCALE = 2, t.BONE_SHEAR = 3, t.SLOT_ATTACHMENT = 0, t.SLOT_COLOR = 1, t.SLOT_TWO_COLOR = 2, t.PATH_POSITION = 0, t.PATH_SPACING = 1, t.PATH_MIX = 2, t.CURVE_LINEAR = 0, t.CURVE_STEPPED = 1, t.CURVE_BEZIER = 2, t
        }())
        var re = function (t, e, n, r, i) {
            this.mesh = t, this.skin = e, this.slotIndex = n, this.parent = r, this.inheritDeform = i
        }
        var ie = function (t, e) {
            void 0 === t && (t = null), void 0 === e && (e = null), this.bones = t, this.vertices = e
        }
        var oe = (function () {
            function t() {
                this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = [], this.polygons = [], this.polygonPool = new X(() => {
                    return G.newFloatArray(16)
                })
            }
            return t.prototype.update = function (t, e) {
                if (t == null) throw new Error('skeleton cannot be null.')
                let n = this.boundingBoxes
                var r = this.polygons
                var i = this.polygonPool
                var o = t.slots
                var a = o.length
                n.length = 0, i.freeAll(r), r.length = 0
                for (let s = 0; s < a; s++) {
                    const u = o[s]
                    if (u.bone.active) {
                        const c = u.getAttachment()
                        if (c instanceof ot) {
                            const l = c
                            n.push(l)
                            let h = i.obtain()
                            h.length != l.worldVerticesLength && (h = G.newFloatArray(l.worldVerticesLength)), r.push(h), l.computeWorldVertices(u, 0, l.worldVerticesLength, h, 0, 2)
                        }
                    }
                }
                e ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY)
            }, t.prototype.aabbCompute = function () {
                for (var t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, r = Number.NEGATIVE_INFINITY, i = this.polygons, o = 0, a = i.length; o < a; o++) {
                    for (let s = i[o], u = s, c = 0, l = s.length; c < l; c += 2) {
                        let h = u[c]
                                    var f = u[c + 1]
                        t = Math.min(t, h), e = Math.min(e, f), n = Math.max(n, h), r = Math.max(r, f)
                    }
                }
                this.minX = t, this.minY = e, this.maxX = n, this.maxY = r
            }, t.prototype.aabbContainsPoint = function (t, e) {
                return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
            }, t.prototype.aabbIntersectsSegment = function (t, e, n, r) {
                const i = this.minX
                var o = this.minY
                var a = this.maxX
                var s = this.maxY
                if (t <= i && n <= i || e <= o && r <= o || t >= a && n >= a || e >= s && r >= s) return !1
                let u = (r - e) / (n - t)
                var c = u * (i - t) + e
                if (c > o && c < s) return !0
                if ((c = u * (a - t) + e) > o && c < s) return !0
                let l = (o - e) / u + t
                return l > i && l < a || (l = (s - e) / u + t) > i && l < a
            }, t.prototype.aabbIntersectsSkeleton = function (t) {
                return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
            }, t.prototype.containsPoint = function (t, e) {
                for (let n = this.polygons, r = 0, i = n.length; r < i; r++) {
                    if (this.containsPointPolygon(n[r], t, e)) return this.boundingBoxes[r]
                }
                return null
            }, t.prototype.containsPointPolygon = function (t, e, n) {
                for (var r = t, i = t.length, o = i - 2, a = !1, s = 0; s < i; s += 2) {
                    const u = r[s + 1]
                    var c = r[o + 1]
                    if (u < n && c >= n || c < n && u >= n) {
                        const l = r[s]
                        l + (n - u) / (c - u) * (r[o] - l) < e && (a = !a)
                    }
                    o = s
                }
                return a
            }, t.prototype.intersectsSegment = function (t, e, n, r) {
                for (let i = this.polygons, o = 0, a = i.length; o < a; o++) {
                    if (this.intersectsSegmentPolygon(i[o], t, e, n, r)) return this.boundingBoxes[o]
                }
                return null
            }, t.prototype.intersectsSegmentPolygon = function (t, e, n, r, i) {
                for (let o = t, a = t.length, s = e - r, u = n - i, c = e * i - n * r, l = o[a - 2], h = o[a - 1], f = 0; f < a; f += 2) {
                    const d = o[f]
                    var p = o[f + 1]
                    var m = l * p - h * d
                    var y = l - d
                    var v = h - p
                    var _ = s * v - u * y
                    var g = (c * y - s * m) / _
                    if ((g >= l && g <= d || g >= d && g <= l) && (g >= e && g <= r || g >= r && g <= e)) {
                        const b = (c * v - u * m) / _
                        if ((b >= h && b <= p || b >= p && b <= h) && (b >= n && b <= i || b >= i && b <= n)) return !0
                    }
                    l = d, h = p
                }
                return !1
            }, t.prototype.getPolygon = function (t) {
                if (t == null) throw new Error('boundingBox cannot be null.')
                let e = this.boundingBoxes.indexOf(t)
                return e == -1 ? null : this.polygons[e]
            }, t.prototype.getWidth = function () {
                return this.maxX - this.minX
            }, t.prototype.getHeight = function () {
                return this.maxY - this.minY
            }, t
        }())
        var ae = (function () {
            function t(t) {
                this.scale = 1, this.linkedMeshes = [], this.attachmentLoader = t
            }
            return t.prototype.readSkeletonData = function (e) {
                const n = this.scale
                var r = new $t()
                var i = typeof e == 'string' ? JSON.parse(e) : e
                var o = i.skeleton
                if (o != null) {
                    if (r.hash = o.hash, r.version = o.spine, r.version.substr(0, 3) !== '3.8') {
                        var a = `Spine 3.8 loader cant load version ${ o.spine }. Please configure your pixi-spine bundle`;
                        console.error(a)
                    }
                    if (r.version === '3.8.75') {
                        a = 'Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.'
                        console.error(a)
                    }
                    r.x = o.x, r.y = o.y, r.width = o.width, r.height = o.height, r.fps = o.fps, r.imagesPath = o.images
                }
                if (i.bones) {
                    for (var s = 0; s < i.bones.length; s++) {
                        let u = i.bones[s]
                                    var c = null
                                    var l = this.getValue(u, 'parent', null)
                        if (l != null && (c = r.findBone(l)) == null) throw new Error(`Parent bone not found: ${  l}`);
                        (p = new Ut(r.bones.length, u.name, c)).length = this.getValue(u, 'length', 0) * n, p.x = this.getValue(u, 'x', 0) * n, p.y = this.getValue(u, 'y', 0) * n, p.rotation = this.getValue(u, 'rotation', 0), p.scaleX = this.getValue(u, 'scaleX', 1), p.scaleY = this.getValue(u, 'scaleY', 1), p.shearX = this.getValue(u, 'shearX', 0), p.shearY = this.getValue(u, 'shearY', 0), p.transformMode = t.transformModeFromString(this.getValue(u, 'transform', 'normal')), p.skinRequired = this.getValue(u, 'skin', !1), r.bones.push(p)
                    }
                }
                if (i.slots) {
                    for (s = 0; s < i.slots.length; s++) {
                        var h = (P = i.slots[s]).name
                                    var f = P.bone
                                    var d = r.findBone(f)
                        if (d == null) throw new Error(`Slot bone not found: ${  f}`)
                        var p = new Jt(r.slots.length, h, d)
                                    var m = this.getValue(P, 'color', null)
                        null != m && p.color.setFromString(m)
                        var y = this.getValue(P, 'dark', null)
                        null != y && (p.darkColor = new F(1, 1, 1, 1), p.darkColor.setFromString(y)), p.attachmentName = this.getValue(P, 'attachment', null), p.blendMode = t.blendModeFromString(this.getValue(P, 'blend', 'normal')), r.slots.push(p)
                    }
                }
                if (i.ik) {
                    for (s = 0; s < i.ik.length; s++) {
                        var v = i.ik[s];
                        (p = new Wt(v.name)).order = this.getValue(v, 'order', 0), p.skinRequired = this.getValue(v, 'skin', !1)
                        for (var g = 0; g < v.bones.length; g++) {
                            f = v.bones[g]
                            if ((S = r.findBone(f)) == null) throw new Error(`IK bone not found: ${  f}`)
                            p.bones.push(S)
                        }
                        var b = v.target
                        if (p.target = r.findBone(b), p.target == null) throw new Error(`IK target bone not found: ${  b}`)
                        p.mix = this.getValue(v, 'mix', 1), p.softness = this.getValue(v, 'softness', 0) * n, p.bendDirection = this.getValue(v, 'bendPositive', !0) ? 1 : -1, p.compress = this.getValue(v, 'compress', !1), p.stretch = this.getValue(v, 'stretch', !1), p.uniform = this.getValue(v, 'uniform', !1), r.ikConstraints.push(p)
                    }
                }
                if (i.transform) {
                    for (s = 0; s < i.transform.length; s++) {
                        v = i.transform[s];
                        (p = new Qt(v.name)).order = this.getValue(v, 'order', 0), p.skinRequired = this.getValue(v, 'skin', !1)
                        for (g = 0; g < v.bones.length; g++) {
                            f = v.bones[g]
                            if ((S = r.findBone(f)) == null) throw new Error(`Transform constraint bone not found: ${  f}`)
                            p.bones.push(S)
                        }
                        b = v.target
                        if (p.target = r.findBone(b), p.target == null) throw new Error(`Transform constraint target bone not found: ${  b}`)
                        p.local = this.getValue(v, 'local', !1), p.relative = this.getValue(v, 'relative', !1), p.offsetRotation = this.getValue(v, 'rotation', 0), p.offsetX = this.getValue(v, 'x', 0) * n, p.offsetY = this.getValue(v, 'y', 0) * n, p.offsetScaleX = this.getValue(v, 'scaleX', 0), p.offsetScaleY = this.getValue(v, 'scaleY', 0), p.offsetShearY = this.getValue(v, 'shearY', 0), p.rotateMix = this.getValue(v, 'rotateMix', 1), p.translateMix = this.getValue(v, 'translateMix', 1), p.scaleMix = this.getValue(v, 'scaleMix', 1), p.shearMix = this.getValue(v, 'shearMix', 1), r.transformConstraints.push(p)
                    }
                }
                if (i.path) {
                    for (s = 0; s < i.path.length; s++) {
                        v = i.path[s];
                        (p = new Yt(v.name)).order = this.getValue(v, 'order', 0), p.skinRequired = this.getValue(v, 'skin', !1)
                        for (g = 0; g < v.bones.length; g++) {
                            f = v.bones[g]
                            if ((S = r.findBone(f)) == null) throw new Error(`Transform constraint bone not found: ${  f}`)
                            p.bones.push(S)
                        }
                        b = v.target
                        if (p.target = r.findSlot(b), p.target == null) throw new Error(`Path target slot not found: ${  b}`)
                        p.positionMode = t.positionModeFromString(this.getValue(v, 'positionMode', 'percent')), p.spacingMode = t.spacingModeFromString(this.getValue(v, 'spacingMode', 'length')), p.rotateMode = t.rotateModeFromString(this.getValue(v, 'rotateMode', 'tangent')), p.offsetRotation = this.getValue(v, 'rotation', 0), p.position = this.getValue(v, 'position', 0), p.positionMode == _.Fixed && (p.position *= n), p.spacing = this.getValue(v, 'spacing', 0), p.spacingMode != jt.Length && p.spacingMode != jt.Fixed || (p.spacing *= n), p.rotateMix = this.getValue(v, 'rotateMix', 1), p.translateMix = this.getValue(v, 'translateMix', 1), r.pathConstraints.push(p)
                    }
                }
                if (i.skins) {
                    for (s = 0; s < i.skins.length; s++) {
                        let E = i.skins[s]
                                    var x = new ee(E.name)
                        if (E.bones) {
                            for (var T = 0; T < E.bones.length; T++) {
                                var S
                                        if ((S = r.findBone(E.bones[T])) == null) throw new Error('Skin bone not found: ' + E.bones[s])
                                        x.bones.push(S)
                            }
                        }
                        if (E.ik) {
                            for (T = 0; T < E.ik.length; T++) {
                                if ((w = r.findIkConstraint(E.ik[T])) == null) throw new Error('Skin IK constraint not found: ' + E.ik[s])
                                        x.constraints.push(w)
                            }
                        }
                        if (E.transform) {
                            for (T = 0; T < E.transform.length; T++) {
                                if ((w = r.findTransformConstraint(E.transform[T])) == null) throw new Error('Skin transform constraint not found: ' + E.transform[s])
                                        x.constraints.push(w)
                            }
                        }
                        if (E.path) {
                            for (T = 0; T < E.path.length; T++) {
                                var w
                                        if ((w = r.findPathConstraint(E.path[T])) == null) throw new Error('Skin path constraint not found: ' + E.path[s])
                                        x.constraints.push(w)
                            }
                        }
                        for (var h in E.attachments) {
                            let O = r.findSlot(h)
                            if (O == null) throw new Error(`Slot not found: ${  h}`)
                            var P = E.attachments[h]
                            for (const R in P) {
                                let A = this.readAttachment(P[R], x, O.index, R, r)
                                null != A && x.setAttachment(O.index, R, A)
                            }
                        }
                        r.skins.push(x), x.name == 'default' && (r.defaultSkin = x)
                    }
                }
                s = 0
                for (let I = this.linkedMeshes.length; s < I; s++) {
                    const C = this.linkedMeshes[s]
                    if ((x = C.skin == null ? r.defaultSkin : r.findSkin(C.skin)) == null) throw new Error(`Skin not found: ${ C.skin}`)
                    let k = x.getAttachment(C.slotIndex, C.parent)
                    if (k == null) throw new Error(`Parent mesh not found: ${ C.parent}`)
                    C.mesh.deformAttachment = C.inheritDeform ? k : C.mesh, C.mesh.setParentMesh(k)
                }
                if (this.linkedMeshes.length = 0, i.events) {
                    for (const N in i.events) {
                        let M = i.events[N];
                        (p = new Ht(N)).intValue = this.getValue(M, 'int', 0), p.floatValue = this.getValue(M, 'float', 0), p.stringValue = this.getValue(M, 'string', ''), p.audioPath = this.getValue(M, 'audio', null), p.audioPath != null && (p.volume = this.getValue(M, 'volume', 1), p.balance = this.getValue(M, 'balance', 0)), r.events.push(p)
                    }
                }
                if (i.animations) {
                    for (const j in i.animations) {
                        let D = i.animations[j]
                        this.readAnimation(D, j, r)
                    }
                }
                return r
            }, t.prototype.readAttachment = function (t, e, n, r, i) {
                const o = this.scale
                switch (r = this.getValue(t, 'name', r), this.getValue(t, 'type', 'region')) {
                    case 'region':
                        var a = this.getValue(t, 'path', r)
                        var s = this.attachmentLoader.newRegionAttachment(e, r, a)
                        return s == null ? null : (s.path = a, s.x = this.getValue(t, 'x', 0) * o, s.y = this.getValue(t, 'y', 0) * o, s.scaleX = this.getValue(t, 'scaleX', 1), s.scaleY = this.getValue(t, 'scaleY', 1), s.rotation = this.getValue(t, 'rotation', 0), s.width = t.width * o, s.height = t.height * o, (g = this.getValue(t, 'color', null)) != null && s.color.setFromString(g), s)
                    case 'boundingbox':
                        var u = this.attachmentLoader.newBoundingBoxAttachment(e, r)
                        return u == null ? null : (this.readVertices(t, u, t.vertexCount << 1), (g = this.getValue(t, 'color', null)) != null && u.color.setFromString(g), u)
                    case 'mesh':
                    case 'linkedmesh':
                        a = this.getValue(t, 'path', r)
                        var c = this.attachmentLoader.newMeshAttachment(e, r, a)
                        if (c == null) return null
                        c.path = a, (g = this.getValue(t, 'color', null)) != null && c.color.setFromString(g), c.width = this.getValue(t, 'width', 0) * o, c.height = this.getValue(t, 'height', 0) * o
                        var l = this.getValue(t, 'parent', null)
                        if (l != null) return this.linkedMeshes.push(new se(c, this.getValue(t, 'skin', null), n, l, this.getValue(t, 'deform', !0))), c
                        var h = t.uvs
                        return this.readVertices(t, c, h.length), c.triangles = t.triangles, c.regionUVs = new Float32Array(h), c.edges = this.getValue(t, 'edges', null), c.hullLength = 2 * this.getValue(t, 'hull', 0), c
                    case 'path':
                        if ((a = this.attachmentLoader.newPathAttachment(e, r)) == null) return null
                        a.closed = this.getValue(t, 'closed', !1), a.constantSpeed = this.getValue(t, 'constantSpeed', !0)
                        var f = t.vertexCount
                        this.readVertices(t, a, f << 1)
                        for (var d = G.newArray(f / 3, 0), p = 0; p < t.lengths.length; p++) d[p] = t.lengths[p] * o
                        return a.lengths = d, (g = this.getValue(t, 'color', null)) != null && a.color.setFromString(g), a
                    case 'point':
                        var m = this.attachmentLoader.newPointAttachment(e, r)
                        return m == null ? null : (m.x = this.getValue(t, 'x', 0) * o, m.y = this.getValue(t, 'y', 0) * o, m.rotation = this.getValue(t, 'rotation', 0), (g = this.getValue(t, 'color', null)) != null && m.color.setFromString(g), m)
                    case 'clipping':
                        var y = this.attachmentLoader.newClippingAttachment(e, r)
                        if (y == null) return null
                        var v = this.getValue(t, 'end', null)
                        if (v != null) {
                            const _ = i.findSlot(v)
                            if (_ == null) throw new Error(`Clipping end slot not found: ${ v}`)
                            y.endSlot = _
                        }
                        var g
                        f = t.vertexCount
                        return this.readVertices(t, y, f << 1), (g = this.getValue(t, 'color', null)) != null && y.color.setFromString(g), y
                }
                return null
            }, t.prototype.readVertices = function (t, e, n) {
                const r = this.scale
                e.worldVerticesLength = n
                let i = t.vertices
                if (n != i.length) {
                    const o = [];
                    var a = []
                    for (l = 0, h = i.length; l < h;) {
                        const s = i[l++]
                        a.push(s)
                        for (let u = l + 4 * s; l < u; l += 4) a.push(i[l]), o.push(i[l + 1] * r), o.push(i[l + 2] * r), o.push(i[l + 3])
                    }
                    e.bones = a, e.vertices = G.toFloatArray(o)
                } else {
                    const c = G.toFloatArray(i)
                    if (r != 1) {
                        for (var l = 0, h = i.length; l < h; l++) c[l] *= r
                    }
                    e.vertices = c
                }
            }, t.prototype.readAnimation = function (t, e, n) {
                const r = this.scale
                var i = []
                var o = 0
                if (t.slots) {
                    for (var a in t.slots) {
                        var s = t.slots[a]
                        if ((Q = n.findSlotIndex(a)) == -1) throw new Error(`Slot not found: ${  a}`)
                        for (var u in s) {
                            var c = s[u]
                            if (u == 'attachment') {
                                (b = new xt(c.length)).slotIndex = Q
                                for (var l = 0, h = 0; h < c.length; h++) {
                                    var f = c[h]
                                    b.setFrame(l++, this.getValue(f, 'time', 0), f.name)
                                }
                                i.push(b), o = Math.max(o, b.frames[b.getFrameCount() - 1])
                            } else if (u == 'color') {
                                (b = new bt(c.length)).slotIndex = Q
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    var d = new F()
                                    d.setFromString(f.color || 'ffffffff'), b.setFrame(l, this.getValue(f, 'time', 0), d.r, d.g, d.b, d.a), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * bt.ENTRIES])
                            } else {
                                if (u != 'twoColor') throw new Error(`Invalid timeline type for a slot: ${  u  } (${  a  })`);
                                (b = new Et(c.length)).slotIndex = Q
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    var p = new F();
                                        var m = new F()
                                    p.setFromString(f.light), m.setFromString(f.dark), b.setFrame(l, this.getValue(f, 'time', 0), p.r, p.g, p.b, p.a, m.r, m.g, m.b), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Et.ENTRIES])
                            }
                        }
                    }
                }
                if (t.bones) {
                    for (const y in t.bones) {
                        let v = t.bones[y]
                                    var g = n.findBoneIndex(y)
                        if (g == -1) throw new Error(`Bone not found: ${  y}`)
                        for (var u in v) {
                            c = v[u]
                            if (u === 'rotate') {
                                (b = new yt(c.length)).boneIndex = g
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    b.setFrame(l, this.getValue(f, 'time', 0), this.getValue(f, 'angle', 0)), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * yt.ENTRIES])
                            } else {
                                if (u !== 'translate' && u !== 'scale' && u !== 'shear') throw new Error(`Invalid timeline type for a bone: ${  u  } (${  y  })`);
                                var b = null
                                            var E = 1
                                            var x = 0
                                "scale" === u ? (b = new _t(c.length), x = 1) : u === 'shear' ? b = new gt(c.length) : (b = new vt(c.length), E = r), b.boneIndex = g
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    var T = this.getValue(f, 'x', x)
                                                var S = this.getValue(f, 'y', x)
                                    b.setFrame(l, this.getValue(f, 'time', 0), T * E, S * E), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * vt.ENTRIES])
                            }
                        }
                    }
                }
                if (t.ik) {
                    for (var w in t.ik) {
                        var O = t.ik[w]
                                    var P = n.findIkConstraint(w);
                        (b = new Pt(O.length)).ikConstraintIndex = n.ikConstraints.indexOf(P)
                        for (l = 0, h = 0; h < O.length; h++) {
                            f = O[h]
                            b.setFrame(l, this.getValue(f, 'time', 0), this.getValue(f, 'mix', 1), this.getValue(f, 'softness', 0) * r, this.getValue(f, 'bendPositive', !0) ? 1 : -1, this.getValue(f, 'compress', !1), this.getValue(f, 'stretch', !1)), this.readCurve(f, b, l), l++
                        }
                        i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Pt.ENTRIES])
                    }
                }
                if (t.transform) {
                    for (var w in t.transform) {
                        O = t.transform[w], P = n.findTransformConstraint(w);
                        (b = new Rt(O.length)).transformConstraintIndex = n.transformConstraints.indexOf(P)
                        for (l = 0, h = 0; h < O.length; h++) {
                            f = O[h]
                            b.setFrame(l, this.getValue(f, 'time', 0), this.getValue(f, 'rotateMix', 1), this.getValue(f, 'translateMix', 1), this.getValue(f, 'scaleMix', 1), this.getValue(f, 'shearMix', 1)), this.readCurve(f, b, l), l++
                        }
                        i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Rt.ENTRIES])
                    }
                }
                if (t.path) {
                    for (var w in t.path) {
                        O = t.path[w]
                        var R = n.findPathConstraintIndex(w)
                        if (R == -1) throw new Error(`Path constraint not found: ${  w}`)
                        var A = n.pathConstraints[R]
                        for (var u in O) {
                            c = O[u]
                            if (u === 'position' || u === 'spacing') {
                                b = null, E = 1
                                "spacing" === u ? (b = new It(c.length), A.spacingMode != jt.Length && A.spacingMode != jt.Fixed || (E = r)) : (b = new At(c.length), A.positionMode == _.Fixed && (E = r)), b.pathConstraintIndex = R
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    b.setFrame(l, this.getValue(f, 'time', 0), this.getValue(f, u, 0) * E), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * At.ENTRIES])
                            } else if (u === 'mix') {
                                (b = new Ct(c.length)).pathConstraintIndex = R
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    b.setFrame(l, this.getValue(f, 'time', 0), this.getValue(f, 'rotateMix', 1), this.getValue(f, 'translateMix', 1)), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Ct.ENTRIES])
                            }
                        }
                    }
                }
                if (t.deform) {
                    for (const I in t.deform) {
                        let C = t.deform[I]
                                    var k = n.findSkin(I)
                        if (k != null) {
                            for (var a in C) {
                                s = C[a]
                                        if ((Q = n.findSlotIndex(a)) == -1) throw new Error('Slot not found: ' + s.name)
                                        for (var u in s) {
                                    c = s[u]
                                            var N = k.getAttachment(Q, u)
                                            if (N == null) throw new Error('Deform attachment not found: ' + c.name)
                                            var M = N.bones != null,
                                        j = N.vertices,
                                        D = M ? j.length / 3 * 2 : j.length;
                                    (b = new St(c.length)).slotIndex = Q, b.attachment = N
                                            l = 0
                                            for (var L = 0; L < c.length; L++) {
                                        f = c[L]
                                                var B = void 0;
                                                    var U = this.getValue(f, 'vertices', null)
                                                if (U == null) { B = M ? G.newFloatArray(D) : j;
}
                                        else {
                                            B = G.newFloatArray(D)
                                                    var X = this.getValue(f, 'offset', 0)
                                                    if (G.arrayCopy(U, 0, B, X, U.length), r != 1) {
                                                        for (var H = (h = X) + U.length; h < H; h++) B[h] *= r;
}
                                            if (!M) {
                                                        for (h = 0; h < D; h++) B[h] += j[h]
}
                                        }
                                        b.setFrame(l, this.getValue(f, 'time', 0), B), this.readCurve(f, b, l), l++
                                    }
                                    i.push(b), o = Math.max(o, b.frames[b.getFrameCount() - 1])
                                }
                            }
                        } else if (W) { throw new Error('Skin not found: ' + I)
                        }
                    }
                }
                let V = t.drawOrder
                if (V == null && (V = t.draworder), V != null) {
                    b = new Ot(V.length)
                    let Y = n.slots.length
                    for (l = 0, L = 0; L < V.length; L++) {
                        const z = V[L]
                        var q = null
                        var K = this.getValue(z, 'offsets', null)
                        if (K != null) {
                            q = G.newArray(Y, -1)
                            let Z = G.newArray(Y - K.length, 0)
                            var $ = 0
                            var J = 0
                            for (h = 0; h < K.length; h++) {
                                var Q; const tt = K[h]
                                if ((Q = n.findSlotIndex(tt.slot)) == -1) throw new Error(`Slot not found: ${ tt.slot}`)
                                for (; $ != Q;) Z[J++] = $++
                                q[$ + tt.offset] = $++
                            }
                            for (; $ < Y;) Z[J++] = $++
                            for (h = Y - 1; h >= 0; h--) q[h] == -1 && (q[h] = Z[--J])
                        }
                        b.setFrame(l++, this.getValue(z, 'time', 0), q)
                    }
                    i.push(b), o = Math.max(o, b.frames[b.getFrameCount() - 1])
                }
                if (t.events) {
                    for (b = new wt(t.events.length), l = 0, h = 0; h < t.events.length; h++) {
                        const et = t.events[h]
                        var nt = n.findEvent(et.name)
                        if (nt == null) throw new Error(`Event not found: ${ et.name}`)
                        let rt = new Xt(G.toSinglePrecision(this.getValue(et, 'time', 0)), nt)
                        rt.intValue = this.getValue(et, 'int', nt.intValue), rt.floatValue = this.getValue(et, 'float', nt.floatValue), rt.stringValue = this.getValue(et, 'string', nt.stringValue), rt.data.audioPath != null && (rt.volume = this.getValue(et, 'volume', 1), rt.balance = this.getValue(et, 'balance', 0)), b.setFrame(l++, rt)
                    }
                    i.push(b), o = Math.max(o, b.frames[b.getFrameCount() - 1])
                }
                if (isNaN(o)) throw new Error('Error while parsing animation, duration is NaN')
                n.animations.push(new dt(e, i, o))
            }, t.prototype.readCurve = function (t, e, n) {
                if (t.hasOwnProperty('curve')) {
                    if (t.curve === 'stepped') { e.setStepped(n)
}
                    else {
                        let r = t.curve
                        e.setCurve(n, r, this.getValue(t, 'c2', 0), this.getValue(t, 'c3', 1), this.getValue(t, 'c4', 1))
                    }
                }
            }, t.prototype.getValue = function (t, e, n) {
                return void 0 !== t[e] ? t[e] : n
            }, t.blendModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'normal') return c.b.NORMAL
                if (t == 'additive') return c.b.ADD
                if (t == 'multiply') return c.b.MULTIPLY
                if (t == 'screen') return c.b.SCREEN
                throw new Error(`Unknown blend mode: ${ t}`)
            }, t.positionModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'fixed') return _.Fixed
                if (t == 'percent') return _.Percent
                throw new Error(`Unknown position mode: ${ t}`)
            }, t.spacingModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'length') return jt.Length
                if (t == 'fixed') return jt.Fixed
                if (t == 'percent') return jt.Percent
                throw new Error(`Unknown position mode: ${ t}`)
            }, t.rotateModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'tangent') return g.Tangent
                if (t == 'chain') return g.Chain
                if (t == 'chainscale') return g.ChainScale
                throw new Error(`Unknown rotate mode: ${ t}`)
            }, t.transformModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'normal') return b.Normal
                if (t == 'onlytranslation') return b.OnlyTranslation
                if (t == 'norotationorreflection') return b.NoRotationOrReflection
                if (t == 'noscale') return b.NoScale
                if (t == 'noscaleorreflection') return b.NoScaleOrReflection
                throw new Error(`Unknown transform mode: ${ t}`)
            }, t
        }())
        var se = function (t, e, n, r, i) {
            this.mesh = t, this.skin = e, this.slotIndex = n, this.parent = r, this.inheritDeform = i
        }
        var ue = (function (t) {
            function e() {
                return t !== null && t.apply(this, arguments) || this
            }
            return et(e, t), e.prototype.createSkeleton = function (t) {
                this.skeleton = new Zt(t), this.skeleton.updateWorldTransform(), this.stateData = new Lt(t), this.state = new kt(this.stateData)
            }, e
        }($))
        let ce = function (t, e) {
            return (ce = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            })(t, e)
        }

        function le(t, e) {
            if (typeof e != 'function' && e !== null) throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`)

            function n() {
                this.constructor = t
            }
            ce(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        let he; var fe = function (t) {
            if (t == null) throw new Error('name cannot be null.')
            this.name = t
        }
        var de = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.id = (65535 & e.nextID++) << 11, r.worldVerticesLength = 0, r
            }
            return le(e, t), e.prototype.computeWorldVerticesOld = function (t, e) {
                this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
            }, e.prototype.computeWorldVertices = function (t, e, n, r, i, o) {
                n = i + (n >> 1) * o
                let a = t.bone.skeleton
                var s = t.attachmentVertices
                var u = this.vertices
                var c = this.bones
                if (c != null) {
                    for (var l = 0, h = 0, f = 0; f < e; f += 2) {
                        l += (y = c[l]) + 1, h += y
                    }
                    const d = a.bones
                    if (s.length == 0) {
                        for (R = i, S = 3 * h; R < n; R += o) {
                            var p = 0
                                        var m = 0
                                        var y = c[l++]
                            for (y += l; l < y; l++, S += 3) {
                                b = d[c[l]].matrix, A = u[S], I = u[S + 1]
                                var v = u[S + 2]
                                p += (A * b.a + I * b.c + b.tx) * v, m += (A * b.b + I * b.d + b.ty) * v
                            }
                            r[R] = p, r[R + 1] = m
                        }
                    } else {
                        for (let _ = s, g = (R = i, S = 3 * h, h << 1); R < n; R += o) {
                            p = 0, m = 0, y = c[l++]
                            for (y += l; l < y; l++, S += 3, g += 2) {
                                b = d[c[l]].matrix, A = u[S] + _[g], I = u[S + 1] + _[g + 1], v = u[S + 2]
                                p += (A * b.a + I * b.c + b.tx) * v, m += (A * b.b + I * b.d + b.ty) * v
                            }
                            r[R] = p, r[R + 1] = m
                        }
                    }
                } else {
                    s.length > 0 && (u = s)
                    for (var b, E = (b = t.bone.matrix).tx, x = b.ty, T = b.a, S = b.c, w = b.b, O = b.d, P = e, R = i; R < n; P += 2, R += o) {
                        var A = u[P]
                        var I = u[P + 1]
                        r[R] = A * T + I * S + E, r[R + 1] = A * w + I * O + x
                    }
                }
            }, e.prototype.applyDeform = function (t) {
                return this == t
            }, e.nextID = 0, e
        }(fe))
        var pe = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.BoundingBox, n.color = new F(1, 1, 1, 1), n
            }
            return le(e, t), e
        }(de))
        var me = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Clipping, n.color = new F(0.2275, 0.2275, 0.8078, 1), n
            }
            return le(e, t), e
        }(de))
        var ye = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Mesh, n.color = new F(1, 1, 1, 1), n.inheritDeform = !1, n.tempColor = new F(0, 0, 0, 0), n
            }
            return le(e, t), e.prototype.applyDeform = function (t) {
                return this == t || this.inheritDeform && this.parentMesh == t
            }, e.prototype.getParentMesh = function () {
                return this.parentMesh
            }, e.prototype.setParentMesh = function (t) {
                this.parentMesh = t, t != null && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength)
            }, e
        }(de))
        var ve = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Path, n.closed = !1, n.constantSpeed = !1, n.color = new F(1, 1, 1, 1), n
            }
            return le(e, t), e
        }(de))
        var _e = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Point, n.color = new F(0.38, 0.94, 0, 1), n
            }
            return le(e, t), e.prototype.computeWorldPosition = function (t, e) {
                const n = t.matrix
                return e.x = this.x * n.a + this.y * n.c + t.worldX, e.y = this.x * n.b + this.y * n.d + t.worldY, e
            }, e.prototype.computeWorldRotation = function (t) {
                const e = t.matrix
                var n = B.cosDeg(this.rotation)
                var r = B.sinDeg(this.rotation)
                var i = n * e.a + r * e.c
                var o = n * e.b + r * e.d
                return Math.atan2(o, i) * B.radDeg
            }, e
        }(de))
        var ge = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Region, n.x = 0, n.y = 0, n.scaleX = 1, n.scaleY = 1, n.rotation = 0, n.width = 0, n.height = 0, n.color = new F(1, 1, 1, 1), n.offset = G.newFloatArray(8), n.uvs = G.newFloatArray(8), n.tempColor = new F(1, 1, 1, 1), n
            }
            return le(e, t), e.prototype.updateOffset = function () {
                const t = this.width / this.region.originalWidth * this.scaleX
                var n = this.height / this.region.originalHeight * this.scaleY
                var r = -this.width / 2 * this.scaleX + this.region.offsetX * t
                var i = -this.height / 2 * this.scaleY + this.region.offsetY * n
                var o = r + this.region.width * t
                var a = i + this.region.height * n
                var s = this.rotation * Math.PI / 180
                var u = Math.cos(s)
                var c = Math.sin(s)
                var l = r * u + this.x
                var h = r * c
                var f = i * u + this.y
                var d = i * c
                var p = o * u + this.x
                var m = o * c
                var y = a * u + this.y
                var v = a * c
                var _ = this.offset
                _[e.OX1] = l - d, _[e.OY1] = f + h, _[e.OX2] = l - v, _[e.OY2] = y + h, _[e.OX3] = p - v, _[e.OY3] = y + m, _[e.OX4] = p - d, _[e.OY4] = f + m
            }, e.prototype.setRegion = function (t) {
                this.region = t
                let e = this.uvs
                t.rotate ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2)
            }, e.prototype.computeWorldVertices = function (t, n, r, i) {
                const o = this.offset
                var a = t.matrix
                var s = a.tx
                var u = a.ty
                var c = a.a
                var l = a.c
                var h = a.b
                var f = a.d
                var d = 0
                var p = 0
                d = o[e.OX1], p = o[e.OY1], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX2], p = o[e.OY2], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX3], p = o[e.OY3], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX4], p = o[e.OY4], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u
            }, e.OX1 = 0, e.OY1 = 1, e.OX2 = 2, e.OY2 = 3, e.OX3 = 4, e.OY3 = 5, e.OX4 = 6, e.OY4 = 7, e.X1 = 0, e.Y1 = 1, e.C1R = 2, e.C1G = 3, e.C1B = 4, e.C1A = 5, e.U1 = 6, e.V1 = 7, e.X2 = 8, e.Y2 = 9, e.C2R = 10, e.C2G = 11, e.C2B = 12, e.C2A = 13, e.U2 = 14, e.V2 = 15, e.X3 = 16, e.Y3 = 17, e.C3R = 18, e.C3G = 19, e.C3B = 20, e.C3A = 21, e.U3 = 22, e.V3 = 23, e.X4 = 24, e.Y4 = 25, e.C4R = 26, e.C4G = 27, e.C4B = 28, e.C4A = 29, e.U4 = 30, e.V4 = 31, e
        }(fe))
        var be = (function () {
            function t(t, e) {
                this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e
            }
            return t.prototype.begin = function (t) {}, t.prototype.transform = function (t, e, n, r) {
                t.x += B.randomTriangular(-this.jitterX, this.jitterY), t.y += B.randomTriangular(-this.jitterX, this.jitterY)
            }, t.prototype.end = function () {}, t
        }())
        var Ee = (function () {
            function t(t) {
                this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t
            }
            return t.prototype.begin = function (t) {
                this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY
            }, t.prototype.transform = function (e, n, r, i) {
                const o = this.angle * B.degreesToRadians
                var a = e.x - this.worldX
                var s = e.y - this.worldY
                var u = Math.sqrt(a * a + s * s)
                if (u < this.radius) {
                    const c = t.interpolation.apply(0, o, (this.radius - u) / this.radius)
                    var l = Math.cos(c)
                    var h = Math.sin(c)
                    e.x = l * a - h * s + this.worldX, e.y = h * a + l * s + this.worldY
                }
            }, t.prototype.end = function () {}, t.interpolation = new U(2), t
        }())
        var xe = (function () {
            function t(t, e, n) {
                if (t == null) throw new Error('name cannot be null.')
                if (e == null) throw new Error('timelines cannot be null.')
                this.name = t, this.timelines = e, this.duration = n
            }
            return t.prototype.apply = function (t, e, n, r, i, o, a, s) {
                if (t == null) throw new Error('skeleton cannot be null.')
                r && this.duration != 0 && (n %= this.duration, e > 0 && (e %= this.duration))
                for (let u = this.timelines, c = 0, l = u.length; c < l; c++) u[c].apply(t, e, n, i, o, a, s)
            }, t.binarySearch = function (t, e, n) {
                void 0 === n && (n = 1)
                let r = 0
                let i = t.length / n - 2
                if (i == 0) return n
                for (let o = i >>> 1; ;) {
                    if (t[(o + 1) * n] <= e ? r = o + 1 : i = o, r == i) return (r + 1) * n
                    o = r + i >>> 1
                }
            }, t.linearSearch = function (t, e, n) {
                for (let r = 0, i = t.length - n; r <= i; r += n) {
                    if (t[r] > e) return r
                }
                return -1
            }, t
        }())
        !(function (t) {
            t[t.rotate = 0] = 'rotate', t[t.translate = 1] = 'translate', t[t.scale = 2] = 'scale', t[t.shear = 3] = 'shear', t[t.attachment = 4] = 'attachment', t[t.color = 5] = 'color', t[t.deform = 6] = 'deform', t[t.event = 7] = 'event', t[t.drawOrder = 8] = 'drawOrder', t[t.ikConstraint = 9] = 'ikConstraint', t[t.transformConstraint = 10] = 'transformConstraint', t[t.pathConstraintPosition = 11] = 'pathConstraintPosition', t[t.pathConstraintSpacing = 12] = 'pathConstraintSpacing', t[t.pathConstraintMix = 13] = 'pathConstraintMix', t[t.twoColor = 14] = 'twoColor'
        }(he || (he = {})))
        let Te; var Se = (function () {
            function t(e) {
                if (e <= 0) throw new Error(`frameCount must be > 0: ${ e}`)
                this.curves = G.newFloatArray((e - 1) * t.BEZIER_SIZE)
            }
            return t.prototype.getFrameCount = function () {
                return this.curves.length / t.BEZIER_SIZE + 1
            }, t.prototype.setLinear = function (e) {
                this.curves[e * t.BEZIER_SIZE] = t.LINEAR
            }, t.prototype.setStepped = function (e) {
                this.curves[e * t.BEZIER_SIZE] = t.STEPPED
            }, t.prototype.getCurveType = function (e) {
                const n = e * t.BEZIER_SIZE
                if (n == this.curves.length) return t.LINEAR
                let r = this.curves[n]
                return r == t.LINEAR ? t.LINEAR : r == t.STEPPED ? t.STEPPED : t.BEZIER
            }, t.prototype.setCurve = function (e, n, r, i, o) {
                const a = 0.03 * (2 * -n + i)
                var s = 0.03 * (2 * -r + o)
                var u = 0.006 * (3 * (n - i) + 1)
                var c = 0.006 * (3 * (r - o) + 1)
                var l = 2 * a + u
                var h = 2 * s + c
                var f = 0.3 * n + a + 0.16666667 * u
                var d = 0.3 * r + s + 0.16666667 * c
                var p = e * t.BEZIER_SIZE
                var m = this.curves
                m[p++] = t.BEZIER
                for (let y = f, v = d, _ = p + t.BEZIER_SIZE - 1; p < _; p += 2) m[p] = y, m[p + 1] = v, f += l, d += h, l += u, h += c, y += f, v += d
            }, t.prototype.getCurvePercent = function (e, n) {
                n = B.clamp(n, 0, 1)
                let r = this.curves
                var i = e * t.BEZIER_SIZE
                var o = r[i]
                if (o == t.LINEAR) return n
                if (o == t.STEPPED) return 0
                for (var a = 0, s = ++i, u = i + t.BEZIER_SIZE - 1; i < u; i += 2) {
                    if ((a = r[i]) >= n) {
                        let c = void 0
                                    var l = void 0
                        return i == s ? (c = 0, l = 0) : (c = r[i - 2], l = r[i - 1]), l + (r[i + 1] - l) * (n - c) / (a - c)
                    }
                }
                const h = r[i - 1]
                return h + (1 - h) * (n - a) / (1 - a)
            }, t.LINEAR = 0, t.STEPPED = 1, t.BEZIER = 2, t.BEZIER_SIZE = 19, t
        }())
        var we = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.frames = G.newFloatArray(e << 1), n
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.rotate << 24) + this.boneIndex
            }, e.prototype.setFrame = function (t, n, r) {
                t <<= 1, this.frames[t] = n, this.frames[t + e.ROTATION] = r
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.bones[this.boneIndex]
                if (r < u[0]) { switch (a) {
                    case y.setup:
                        return void (c.rotation = c.data.rotation)
                    case y.first:
                        var l = c.data.rotation - c.rotation
                        c.rotation += (l - 360 * (16384 - (16384.499999999996 - l / 360 | 0))) * o
                }
                } else if (r >= u[u.length - e.ENTRIES]) {
                    let h = u[u.length + e.PREV_ROTATION]
                    switch (a) {
                        case y.setup:
                            c.rotation = c.data.rotation + h * o
                            break
                        case y.first:
                        case y.replace:
                            h += c.data.rotation - c.rotation, h -= 360 * (16384 - (16384.499999999996 - h / 360 | 0))
                        case y.add:
                            c.rotation += h * o
                    }
                } else {
                    const f = xe.binarySearch(u, r, e.ENTRIES)
                    var d = u[f + e.PREV_ROTATION]
                    var p = u[f]
                    var m = this.getCurvePercent((f >> 1) - 1, 1 - (r - p) / (u[f + e.PREV_TIME] - p))
                    var v = u[f + e.ROTATION] - d
                    switch (v = d + (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * m, a) {
                        case y.setup:
                            c.rotation = c.data.rotation + (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * o
                            break
                        case y.first:
                        case y.replace:
                            v += c.data.rotation - c.rotation
                        case y.add:
                            c.rotation += (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * o
                    }
                }
            }, e.ENTRIES = 2, e.PREV_TIME = -2, e.PREV_ROTATION = -1, e.ROTATION = 1, e
        }(Se))
        var Oe = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.translate << 24) + this.boneIndex
            }, e.prototype.setFrame = function (t, n, r, i) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.X] = r, this.frames[t + e.Y] = i
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.bones[this.boneIndex]
                if (r < u[0]) { switch (a) {
                    case y.setup:
                        return c.x = c.data.x, void (c.y = c.data.y)
                    case y.first:
                        c.x += (c.data.x - c.x) * o, c.y += (c.data.y - c.y) * o
                }
                } else {
                    let l = 0
                    var h = 0
                    if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_X], h = u[u.length + e.PREV_Y]
                    }
                    else {
                        const f = xe.binarySearch(u, r, e.ENTRIES)
                        l = u[f + e.PREV_X], h = u[f + e.PREV_Y]
                        let d = u[f]
                        var p = this.getCurvePercent(f / e.ENTRIES - 1, 1 - (r - d) / (u[f + e.PREV_TIME] - d))
                        l += (u[f + e.X] - l) * p, h += (u[f + e.Y] - h) * p
                    }
                    switch (a) {
                        case y.setup:
                            c.x = c.data.x + l * o, c.y = c.data.y + h * o
                            break
                        case y.first:
                        case y.replace:
                            c.x += (c.data.x + l - c.x) * o, c.y += (c.data.y + h - c.y) * o
                            break
                        case y.add:
                            c.x += l * o, c.y += h * o
                    }
                }
            }, e.ENTRIES = 3, e.PREV_TIME = -3, e.PREV_X = -2, e.PREV_Y = -1, e.X = 1, e.Y = 2, e
        }(Se))
        var Pe = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.scale << 24) + this.boneIndex
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.bones[this.boneIndex]
                if (r < u[0]) { switch (a) {
                    case y.setup:
                        return c.scaleX = c.data.scaleX, void (c.scaleY = c.data.scaleY)
                    case y.first:
                        c.scaleX += (c.data.scaleX - c.scaleX) * o, c.scaleY += (c.data.scaleY - c.scaleY) * o
                }
                } else {
                    let l = 0
                    var h = 0
                    if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_X] * c.data.scaleX, h = u[u.length + e.PREV_Y] * c.data.scaleY
                    }
                    else {
                        const f = xe.binarySearch(u, r, e.ENTRIES)
                        l = u[f + e.PREV_X], h = u[f + e.PREV_Y]
                        let d = u[f]
                        var p = this.getCurvePercent(f / e.ENTRIES - 1, 1 - (r - d) / (u[f + e.PREV_TIME] - d))
                        l = (l + (u[f + e.X] - l) * p) * c.data.scaleX, h = (h + (u[f + e.Y] - h) * p) * c.data.scaleY
                    }
                    if (o == 1) { a == y.add ? (c.scaleX += l - c.data.scaleX, c.scaleY += h - c.data.scaleY) : (c.scaleX = l, c.scaleY = h)
                    }
                    else {
                        let m = 0
                        var _ = 0
                        if (s == v.mixOut) { switch (a) {
                            case y.setup:
                                m = c.data.scaleX, _ = c.data.scaleY, c.scaleX = m + (Math.abs(l) * B.signum(m) - m) * o, c.scaleY = _ + (Math.abs(h) * B.signum(_) - _) * o
                                break;
                            case y.first:
                            case y.replace:
                                m = c.scaleX, _ = c.scaleY, c.scaleX = m + (Math.abs(l) * B.signum(m) - m) * o, c.scaleY = _ + (Math.abs(h) * B.signum(_) - _) * o
                                break;
                            case y.add:
                                m = c.scaleX, _ = c.scaleY, c.scaleX = m + (Math.abs(l) * B.signum(m) - c.data.scaleX) * o, c.scaleY = _ + (Math.abs(h) * B.signum(_) - c.data.scaleY) * o
                        }
                        } else { switch (a) {
                            case y.setup:
                                m = Math.abs(c.data.scaleX) * B.signum(l), _ = Math.abs(c.data.scaleY) * B.signum(h), c.scaleX = m + (l - m) * o, c.scaleY = _ + (h - _) * o
                                break;
                            case y.first:
                            case y.replace:
                                m = Math.abs(c.scaleX) * B.signum(l), _ = Math.abs(c.scaleY) * B.signum(h), c.scaleX = m + (l - m) * o, c.scaleY = _ + (h - _) * o
                                break;
                            case y.add:
                                m = B.signum(l), _ = B.signum(h), c.scaleX = Math.abs(c.scaleX) * m + (l - Math.abs(c.data.scaleX) * m) * o, c.scaleY = Math.abs(c.scaleY) * _ + (h - Math.abs(c.data.scaleY) * _) * o
                        }
                        }
                    }
                }
            }, e
        }(Oe))
        var Re = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.shear << 24) + this.boneIndex
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.bones[this.boneIndex]
                if (r < u[0]) { switch (a) {
                    case y.setup:
                        return c.shearX = c.data.shearX, void (c.shearY = c.data.shearY)
                    case y.first:
                        c.shearX += (c.data.shearX - c.shearX) * o, c.shearY += (c.data.shearY - c.shearY) * o
                }
                } else {
                    let l = 0
                    var h = 0
                    if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_X], h = u[u.length + e.PREV_Y]
                    }
                    else {
                        const f = xe.binarySearch(u, r, e.ENTRIES)
                        l = u[f + e.PREV_X], h = u[f + e.PREV_Y]
                        let d = u[f]
                        var p = this.getCurvePercent(f / e.ENTRIES - 1, 1 - (r - d) / (u[f + e.PREV_TIME] - d))
                        l += (u[f + e.X] - l) * p, h += (u[f + e.Y] - h) * p
                    }
                    switch (a) {
                        case y.setup:
                            c.shearX = c.data.shearX + l * o, c.shearY = c.data.shearY + h * o
                            break
                        case y.first:
                        case y.replace:
                            c.shearX += (c.data.shearX + l - c.shearX) * o, c.shearY += (c.data.shearY + h - c.shearY) * o
                            break
                        case y.add:
                            c.shearX += l * o, c.shearY += h * o
                    }
                }
            }, e
        }(Oe))
        var Ae = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.color << 24) + this.slotIndex
            }, e.prototype.setFrame = function (t, n, r, i, o, a) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.R] = r, this.frames[t + e.G] = i, this.frames[t + e.B] = o, this.frames[t + e.A] = a
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = t.slots[this.slotIndex]
                var c = this.frames
                if (r < c[0]) { switch (a) {
                    case y.setup:
                        return void u.color.setFromColor(u.data.color)
                    case y.first:
                        var l = u.color
                                    var h = u.data.color
                        l.add((h.r - l.r) * o, (h.g - l.g) * o, (h.b - l.b) * o, (h.a - l.a) * o)
                }
                } else {
                    let f = 0
                    var d = 0
                    var p = 0
                    var m = 0
                    if (r >= c[c.length - e.ENTRIES]) {
                        const v = c.length
                        f = c[v + e.PREV_R], d = c[v + e.PREV_G], p = c[v + e.PREV_B], m = c[v + e.PREV_A]
                    } else {
                        const _ = xe.binarySearch(c, r, e.ENTRIES)
                        f = c[_ + e.PREV_R], d = c[_ + e.PREV_G], p = c[_ + e.PREV_B], m = c[_ + e.PREV_A]
                        let g = c[_]
                        var b = this.getCurvePercent(_ / e.ENTRIES - 1, 1 - (r - g) / (c[_ + e.PREV_TIME] - g))
                        f += (c[_ + e.R] - f) * b, d += (c[_ + e.G] - d) * b, p += (c[_ + e.B] - p) * b, m += (c[_ + e.A] - m) * b
                    }
                    if (o == 1) { u.color.set(f, d, p, m)
                    }
                    else {
                        l = u.color
                        a == y.setup && l.setFromColor(u.data.color), l.add((f - l.r) * o, (d - l.g) * o, (p - l.b) * o, (m - l.a) * o)
                    }
                }
            }, e.ENTRIES = 5, e.PREV_TIME = -5, e.PREV_R = -4, e.PREV_G = -3, e.PREV_B = -2, e.PREV_A = -1, e.R = 1, e.G = 2, e.B = 3, e.A = 4, e
        }(Se))
        var Ie = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.twoColor << 24) + this.slotIndex
            }, e.prototype.setFrame = function (t, n, r, i, o, a, s, u, c) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.R] = r, this.frames[t + e.G] = i, this.frames[t + e.B] = o, this.frames[t + e.A] = a, this.frames[t + e.R2] = s, this.frames[t + e.G2] = u, this.frames[t + e.B2] = c
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = t.slots[this.slotIndex]
                var c = this.frames
                if (r < c[0]) { switch (a) {
                    case y.setup:
                        return u.color.setFromColor(u.data.color), void u.darkColor.setFromColor(u.data.darkColor)
                    case y.first:
                        var l = u.color
                                    var h = u.darkColor
                                    var f = u.data.color
                                    var d = u.data.darkColor
                        l.add((f.r - l.r) * o, (f.g - l.g) * o, (f.b - l.b) * o, (f.a - l.a) * o), h.add((d.r - h.r) * o, (d.g - h.g) * o, (d.b - h.b) * o, 0)
                }
                } else {
                    let p = 0
                    var m = 0
                    var v = 0
                    var _ = 0
                    var g = 0
                    var b = 0
                    var E = 0
                    if (r >= c[c.length - e.ENTRIES]) {
                        const x = c.length
                        p = c[x + e.PREV_R], m = c[x + e.PREV_G], v = c[x + e.PREV_B], _ = c[x + e.PREV_A], g = c[x + e.PREV_R2], b = c[x + e.PREV_G2], E = c[x + e.PREV_B2]
                    } else {
                        const T = xe.binarySearch(c, r, e.ENTRIES)
                        p = c[T + e.PREV_R], m = c[T + e.PREV_G], v = c[T + e.PREV_B], _ = c[T + e.PREV_A], g = c[T + e.PREV_R2], b = c[T + e.PREV_G2], E = c[T + e.PREV_B2]
                        let S = c[T]
                        var w = this.getCurvePercent(T / e.ENTRIES - 1, 1 - (r - S) / (c[T + e.PREV_TIME] - S))
                        p += (c[T + e.R] - p) * w, m += (c[T + e.G] - m) * w, v += (c[T + e.B] - v) * w, _ += (c[T + e.A] - _) * w, g += (c[T + e.R2] - g) * w, b += (c[T + e.G2] - b) * w, E += (c[T + e.B2] - E) * w
                    }
                    if (o == 1) { u.color.set(p, m, v, _), u.darkColor.set(g, b, E, 1)
                    }
                    else {
                        l = u.color, h = u.darkColor
                        a == y.setup && (l.setFromColor(u.data.color), h.setFromColor(u.data.darkColor)), l.add((p - l.r) * o, (m - l.g) * o, (v - l.b) * o, (_ - l.a) * o), h.add((g - h.r) * o, (b - h.g) * o, (E - h.b) * o, 0)
                    }
                }
            }, e.ENTRIES = 8, e.PREV_TIME = -8, e.PREV_R = -7, e.PREV_G = -6, e.PREV_B = -5, e.PREV_A = -4, e.PREV_R2 = -3, e.PREV_G2 = -2, e.PREV_B2 = -1, e.R = 1, e.G = 2, e.B = 3, e.A = 4, e.R2 = 5, e.G2 = 6, e.B2 = 7, e
        }(Se))
        var Ce = (function () {
            function t(t) {
                this.frames = G.newFloatArray(t), this.attachmentNames = new Array(t)
            }
            return t.prototype.getPropertyId = function () {
                return (he.attachment << 24) + this.slotIndex
            }, t.prototype.getFrameCount = function () {
                return this.frames.length
            }, t.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.attachmentNames[t] = n
            }, t.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (a != v.mixOut || o != y.setup) {
                    const u = this.frames
                    if (n < u[0]) {
                        if (o == y.setup || o == y.first) {
                            const c = s.data.attachmentName
                            s.setAttachment(c == null ? null : t.getAttachment(this.slotIndex, c))
                        }
                    } else {
                        let l = 0
                        l = n >= u[u.length - 1] ? u.length - 1 : xe.binarySearch(u, n, 1) - 1
                        let h = this.attachmentNames[l]
                        t.slots[this.slotIndex].setAttachment(h == null ? null : t.getAttachment(this.slotIndex, h))
                    }
                } else {
                    const f = s.data.attachmentName
                    s.setAttachment(f == null ? null : t.getAttachment(this.slotIndex, f))
                }
            }, t
        }())
        let ke = null
        var Ne = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.frames = G.newFloatArray(e), n.frameVertices = new Array(e), ke == null && (ke = G.newFloatArray(64)), n
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.deform << 27) + +this.attachment.id + this.slotIndex
            }, e.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.frameVertices[t] = n
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                var u = s.getAttachment()
                if (u instanceof de && u.applyDeform(this.attachment)) {
                    const c = s.attachmentVertices
                    c.length == 0 && (o = y.setup)
                    let l = this.frameVertices
                    var h = l[0].length
                    var f = this.frames
                    if (n < f[0]) {
                        var d = u
                        switch (o) {
                            case y.setup:
                                return void (c.length = 0)
                            case y.first:
                                if (i == 1) {
                                    c.length = 0
                                    break
                                }
                                var p = G.setArraySize(c, h)
                                if (d.bones == null) {
                                    for (var m = d.vertices, v = 0; v < h; v++) p[v] += (m[v] - p[v]) * i
                                }
                                else {
                                    i = 1 - i
                                    for (v = 0; v < h; v++) p[v] *= i
                                }
                        }
                    } else {
                        const _ = G.setArraySize(c, h)
                        if (n >= f[f.length - 1]) {
                            const g = l[f.length - 1]
                            if (i == 1) {
                                if (o == y.add) {
                                    if ((d = u).bones == null) {
                                                for (m = d.vertices, v = 0; v < h; v++) _[v] += g[v] - m[v];
}
                                    else {
                                                for (v = 0; v < h; v++) _[v] += g[v];
}
                                }
                                else { G.arrayCopy(g, 0, _, 0, h)
}
                            }
                            else { switch (o) {
                                case y.setup:
                                    var b = u
                                    if (b.bones == null) {
                                        for (m = b.vertices, v = 0; v < h; v++) {
                                            var E = m[v]
                                                    _[v] = E + (g[v] - E) * i
                                        }
                                    } else {
                                        for (v = 0; v < h; v++) _[v] = g[v] * i
}
                                    break
                                case y.first:
                                case y.replace:
                                    for (v = 0; v < h; v++) _[v] += (g[v] - _[v]) * i
                                case y.add:
                                    if ((d = u).bones == null) {
                                        for (m = d.vertices, v = 0; v < h; v++) _[v] += (g[v] - m[v]) * i
}
                                    else {
                                        for (v = 0; v < h; v++) _[v] += g[v] * i
                                    }
                            }
                            }
                        } else {
                            const x = xe.binarySearch(f, n)
                            var T = l[x - 1]
                            var S = l[x]
                            var w = f[x]
                            var O = this.getCurvePercent(x - 1, 1 - (n - w) / (f[x - 1] - w))
                            if (i == 1) {
                                if (o == y.add) {
                                    if ((d = u).bones == null) {
                                                for (m = d.vertices, v = 0; v < h; v++) {
                                                    var P = T[v];
                                                    _[v] += P + (S[v] - P) * O - m[v]
                                                }
} else {
                                                    for (v = 0; v < h; v++) {
                                                        P = T[v];
                                                        _[v] += P + (S[v] - P) * O
                                                    }
}
                                } else {
                                    for (v = 0; v < h; v++) {
                                        P = T[v]
                                                            _[v] = P + (S[v] - P) * O
                                    }
                                }
                            } else { switch (o) {
                                case y.setup:
                                    var R = u
                                    if (R.bones == null) {
                                        for (m = R.vertices, v = 0; v < h; v++) {
                                            P = T[v], E = m[v]
                                                                        _[v] = E + (P + (S[v] - P) * O - E) * i
                                        }
                                    } else {
                                        for (v = 0; v < h; v++) {
                                            P = T[v]
                                                                            _[v] = (P + (S[v] - P) * O) * i
                                        }
                                    }
                                    break
                                case y.first:
                                case y.replace:
                                    for (v = 0; v < h; v++) {
                                        P = T[v]
                                        _[v] += (P + (S[v] - P) * O - _[v]) * i
                                    }
                                    break
                                case y.add:
                                    if ((d = u).bones == null) {
                                        for (m = d.vertices, v = 0; v < h; v++) {
                                            P = T[v]
                                                                        _[v] += (P + (S[v] - P) * O - m[v]) * i
                                        }
                                    } else {
                                        for (v = 0; v < h; v++) {
                                            P = T[v]
                                                                            _[v] += (P + (S[v] - P) * O) * i
                                        }
                                    }
                            }
                            }
                        }
                    }
                }
            }, e
        }(Se))
        var Me = (function () {
            function t(t) {
                this.frames = G.newFloatArray(t), this.events = new Array(t)
            }
            return t.prototype.getPropertyId = function () {
                return he.event << 24
            }, t.prototype.getFrameCount = function () {
                return this.frames.length
            }, t.prototype.setFrame = function (t, e) {
                this.frames[t] = e.time, this.events[t] = e
            }, t.prototype.apply = function (t, e, n, r, i, o, a) {
                if (r != null) {
                    const s = this.frames
                    var u = this.frames.length
                    if (e > n) this.apply(t, e, Number.MAX_VALUE, r, i, o, a), e = -1
                    else if (e >= s[u - 1]) return
                    if (!(n < s[0])) {
                        let c = 0
                        if (e < s[0]) { c = 0
                        }
                        else {
                            for (let l = s[c = xe.binarySearch(s, e)]; c > 0 && s[c - 1] == l;) c--
                        }
                        for (; c < u && n >= s[c]; c++) r.push(this.events[c])
                    }
                }
            }, t
        }())
        var je = (function () {
            function t(t) {
                this.frames = G.newFloatArray(t), this.drawOrders = new Array(t)
            }
            return t.prototype.getPropertyId = function () {
                return he.drawOrder << 24
            }, t.prototype.getFrameCount = function () {
                return this.frames.length
            }, t.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.drawOrders[t] = n
            }, t.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.drawOrder
                var u = t.slots
                if (a != v.mixOut || o != y.setup) {
                    const c = this.frames
                    if (n < c[0]) { o != y.setup && o != y.first || G.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length)
                    }
                    else {
                        let l = 0
                        l = n >= c[c.length - 1] ? c.length - 1 : xe.binarySearch(c, n) - 1
                        let h = this.drawOrders[l]
                        if (h == null) { G.arrayCopy(u, 0, s, 0, u.length)
                        }
                        else {
                            for (let f = 0, d = h.length; f < d; f++) s[f] = u[h[f]]
                        }
                    }
                } else { G.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length)
                }
            }, t
        }())
        var De = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.ikConstraint << 24) + this.ikConstraintIndex
            }, e.prototype.setFrame = function (t, n, r, i, o, a) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.MIX] = r, this.frames[t + e.BEND_DIRECTION] = i, this.frames[t + e.COMPRESS] = o ? 1 : 0, this.frames[t + e.STRETCH] = a ? 1 : 0
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.ikConstraints[this.ikConstraintIndex]
                if (r < u[0]) { switch (a) {
                    case y.setup:
                        return c.mix = c.data.mix, c.bendDirection = c.data.bendDirection, c.compress = c.data.compress, void (c.stretch = c.data.stretch)
                    case y.first:
                        c.mix += (c.data.mix - c.mix) * o, c.bendDirection = c.data.bendDirection, c.compress = c.data.compress, c.stretch = c.data.stretch
                }
                } else if (r >= u[u.length - e.ENTRIES]) { a == y.setup ? (c.mix = c.data.mix + (u[u.length + e.PREV_MIX] - c.data.mix) * o, s == v.mixOut ? (c.bendDirection = c.data.bendDirection, c.compress = c.data.compress, c.stretch = c.data.stretch) : (c.bendDirection = u[u.length + e.PREV_BEND_DIRECTION], c.compress = u[u.length + e.PREV_COMPRESS] != 0, c.stretch = u[u.length + e.PREV_STRETCH] != 0)) : (c.mix += (u[u.length + e.PREV_MIX] - c.mix) * o, s == v.mixIn && (c.bendDirection = u[u.length + e.PREV_BEND_DIRECTION], c.compress = u[u.length + e.PREV_COMPRESS] != 0, c.stretch = u[u.length + e.PREV_STRETCH] != 0))
                }
                else {
                    const l = xe.binarySearch(u, r, e.ENTRIES)
                    var h = u[l + e.PREV_MIX]
                    var f = u[l]
                    var d = this.getCurvePercent(l / e.ENTRIES - 1, 1 - (r - f) / (u[l + e.PREV_TIME] - f))
                    a == y.setup ? (c.mix = c.data.mix + (h + (u[l + e.MIX] - h) * d - c.data.mix) * o, s == v.mixOut ? (c.bendDirection = c.data.bendDirection, c.compress = c.data.compress, c.stretch = c.data.stretch) : (c.bendDirection = u[l + e.PREV_BEND_DIRECTION], c.compress = u[l + e.PREV_COMPRESS] != 0, c.stretch = u[l + e.PREV_STRETCH] != 0)) : (c.mix += (h + (u[l + e.MIX] - h) * d - c.mix) * o, s == v.mixIn && (c.bendDirection = u[l + e.PREV_BEND_DIRECTION], c.compress = u[l + e.PREV_COMPRESS] != 0, c.stretch = u[l + e.PREV_STRETCH] != 0))
                }
            }, e.ENTRIES = 5, e.PREV_TIME = -5, e.PREV_MIX = -4, e.PREV_BEND_DIRECTION = -3, e.PREV_COMPRESS = -2, e.PREV_STRETCH = -1, e.MIX = 1, e.BEND_DIRECTION = 2, e.COMPRESS = 3, e.STRETCH = 4, e
        }(Se))
        var Le = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.transformConstraint << 24) + this.transformConstraintIndex
            }, e.prototype.setFrame = function (t, n, r, i, o, a) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.ROTATE] = r, this.frames[t + e.TRANSLATE] = i, this.frames[t + e.SCALE] = o, this.frames[t + e.SHEAR] = a
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.transformConstraints[this.transformConstraintIndex]
                if (r < u[0]) {
                    var l = c.data
                    switch (a) {
                        case y.setup:
                            return c.rotateMix = l.rotateMix, c.translateMix = l.translateMix, c.scaleMix = l.scaleMix, void (c.shearMix = l.shearMix)
                        case y.first:
                            c.rotateMix += (l.rotateMix - c.rotateMix) * o, c.translateMix += (l.translateMix - c.translateMix) * o, c.scaleMix += (l.scaleMix - c.scaleMix) * o, c.shearMix += (l.shearMix - c.shearMix) * o
                    }
                } else {
                    let h = 0
                    var f = 0
                    var d = 0
                    var p = 0
                    if (r >= u[u.length - e.ENTRIES]) {
                        const m = u.length
                        h = u[m + e.PREV_ROTATE], f = u[m + e.PREV_TRANSLATE], d = u[m + e.PREV_SCALE], p = u[m + e.PREV_SHEAR]
                    } else {
                        const v = xe.binarySearch(u, r, e.ENTRIES)
                        h = u[v + e.PREV_ROTATE], f = u[v + e.PREV_TRANSLATE], d = u[v + e.PREV_SCALE], p = u[v + e.PREV_SHEAR]
                        let _ = u[v]
                        var g = this.getCurvePercent(v / e.ENTRIES - 1, 1 - (r - _) / (u[v + e.PREV_TIME] - _))
                        h += (u[v + e.ROTATE] - h) * g, f += (u[v + e.TRANSLATE] - f) * g, d += (u[v + e.SCALE] - d) * g, p += (u[v + e.SHEAR] - p) * g
                    }
                    if (a == y.setup) {
                        l = c.data
                        c.rotateMix = l.rotateMix + (h - l.rotateMix) * o, c.translateMix = l.translateMix + (f - l.translateMix) * o, c.scaleMix = l.scaleMix + (d - l.scaleMix) * o, c.shearMix = l.shearMix + (p - l.shearMix) * o
                    } else { c.rotateMix += (h - c.rotateMix) * o, c.translateMix += (f - c.translateMix) * o, c.scaleMix += (d - c.scaleMix) * o, c.shearMix += (p - c.shearMix) * o
                    }
                }
            }, e.ENTRIES = 5, e.PREV_TIME = -5, e.PREV_ROTATE = -4, e.PREV_TRANSLATE = -3, e.PREV_SCALE = -2, e.PREV_SHEAR = -1, e.ROTATE = 1, e.TRANSLATE = 2, e.SCALE = 3, e.SHEAR = 4, e
        }(Se))
        var Fe = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.pathConstraintPosition << 24) + this.pathConstraintIndex
            }, e.prototype.setFrame = function (t, n, r) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.VALUE] = r
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.pathConstraints[this.pathConstraintIndex]
                if (r < u[0]) { switch (a) {
                    case y.setup:
                        return void (c.position = c.data.position)
                    case y.first:
                        c.position += (c.data.position - c.position) * o
                }
                } else {
                    let l = 0
                    if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_VALUE]
                    }
                    else {
                        const h = xe.binarySearch(u, r, e.ENTRIES)
                        l = u[h + e.PREV_VALUE]
                        let f = u[h]
                        var d = this.getCurvePercent(h / e.ENTRIES - 1, 1 - (r - f) / (u[h + e.PREV_TIME] - f))
                        l += (u[h + e.VALUE] - l) * d
                    }
                    a == y.setup ? c.position = c.data.position + (l - c.data.position) * o : c.position += (l - c.position) * o
                }
            }, e.ENTRIES = 2, e.PREV_TIME = -2, e.PREV_VALUE = -1, e.VALUE = 1, e
        }(Se))
        var Be = (function (t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.pathConstraintSpacing << 24) + this.pathConstraintIndex
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.pathConstraints[this.pathConstraintIndex]
                if (r < u[0]) { switch (a) {
                    case y.setup:
                        return void (c.spacing = c.data.spacing)
                    case y.first:
                        c.spacing += (c.data.spacing - c.spacing) * o
                }
                } else {
                    let l = 0
                    if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_VALUE]
                    }
                    else {
                        const h = xe.binarySearch(u, r, e.ENTRIES)
                        l = u[h + e.PREV_VALUE]
                        let f = u[h]
                        var d = this.getCurvePercent(h / e.ENTRIES - 1, 1 - (r - f) / (u[h + e.PREV_TIME] - f))
                        l += (u[h + e.VALUE] - l) * d
                    }
                    a == y.setup ? c.spacing = c.data.spacing + (l - c.data.spacing) * o : c.spacing += (l - c.spacing) * o
                }
            }, e
        }(Fe))
        var Ue = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.frames = G.newFloatArray(n * e.ENTRIES), r
            }
            return le(e, t), e.prototype.getPropertyId = function () {
                return (he.pathConstraintMix << 24) + this.pathConstraintIndex
            }, e.prototype.setFrame = function (t, n, r, i) {
                t *= e.ENTRIES, this.frames[t] = n, this.frames[t + e.ROTATE] = r, this.frames[t + e.TRANSLATE] = i
            }, e.prototype.apply = function (t, n, r, i, o, a, s) {
                const u = this.frames
                var c = t.pathConstraints[this.pathConstraintIndex]
                if (r < u[0]) { switch (a) {
                    case y.setup:
                        return c.rotateMix = c.data.rotateMix, void (c.translateMix = c.data.translateMix)
                    case y.first:
                        c.rotateMix += (c.data.rotateMix - c.rotateMix) * o, c.translateMix += (c.data.translateMix - c.translateMix) * o
                }
                } else {
                    let l = 0
                    var h = 0
                    if (r >= u[u.length - e.ENTRIES]) { l = u[u.length + e.PREV_ROTATE], h = u[u.length + e.PREV_TRANSLATE]
                    }
                    else {
                        const f = xe.binarySearch(u, r, e.ENTRIES)
                        l = u[f + e.PREV_ROTATE], h = u[f + e.PREV_TRANSLATE]
                        let d = u[f]
                        var p = this.getCurvePercent(f / e.ENTRIES - 1, 1 - (r - d) / (u[f + e.PREV_TIME] - d))
                        l += (u[f + e.ROTATE] - l) * p, h += (u[f + e.TRANSLATE] - h) * p
                    }
                    a == y.setup ? (c.rotateMix = c.data.rotateMix + (l - c.data.rotateMix) * o, c.translateMix = c.data.translateMix + (h - c.data.translateMix) * o) : (c.rotateMix += (l - c.rotateMix) * o, c.translateMix += (h - c.translateMix) * o)
                }
            }, e.ENTRIES = 3, e.PREV_TIME = -3, e.PREV_ROTATE = -2, e.PREV_TRANSLATE = -1, e.ROTATE = 1, e.TRANSLATE = 2, e
        }(Se))
        var Ge = (function () {
            function t(t) {
                this.tracks = [], this.events = [], this.listeners = [], this.queue = new He(this), this.propertyIDs = new D(), this.animationsChanged = !1, this.timeScale = 1, this.trackEntryPool = new X(() => {
                    return new Xe()
                }), this.data = t
            }
            return t.prototype.update = function (t) {
                t *= this.timeScale
                for (let e = this.tracks, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i != null) {
                        i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast
                        let o = t * i.timeScale
                        if (i.delay > 0) {
                            if (i.delay -= o, i.delay > 0) continue
                            o = -i.delay, i.delay = 0
                        }
                        let a = i.next
                        if (a != null) {
                            const s = i.trackLast - a.delay
                            if (s >= 0) {
                                for (a.delay = 0, a.trackTime = i.timeScale == 0 ? 0 : (s / i.timeScale + t) * a.timeScale, i.trackTime += o, this.setCurrent(n, a, !0); a.mixingFrom != null;) a.mixTime += t, a = a.mixingFrom
                                continue
                            }
                        } else if (i.trackLast >= i.trackEnd && i.mixingFrom == null) {
                            e[n] = null, this.queue.end(i), this.disposeNext(i)
                            continue
                        }
                        if (i.mixingFrom != null && this.updateMixingFrom(i, t)) {
                            let u = i.mixingFrom
                            for (i.mixingFrom = null, u != null && (u.mixingTo = null); u != null;) this.queue.end(u), u = u.mixingFrom
                        }
                        i.trackTime += o
                    }
                }
                this.queue.drain()
            }, t.prototype.updateMixingFrom = function (t, e) {
                const n = t.mixingFrom
                if (n == null) return !0
                let r = this.updateMixingFrom(n, e)
                return n.animationLast = n.nextAnimationLast, n.trackLast = n.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? (n.totalAlpha != 0 && t.mixDuration != 0 || (t.mixingFrom = n.mixingFrom, n.mixingFrom != null && (n.mixingFrom.mixingTo = t), t.interruptAlpha = n.interruptAlpha, this.queue.end(n)), r) : (n.trackTime += e * n.timeScale, t.mixTime += e, !1)
            }, t.prototype.apply = function (e) {
                if (e == null) throw new Error('skeleton cannot be null.')
                this.animationsChanged && this._animationsChanged()
                for (var n = this.events, r = this.tracks, i = !1, o = 0, a = r.length; o < a; o++) {
                    const s = r[o]
                    if (!(s == null || s.delay > 0)) {
                        i = !0
                        let u = o == 0 ? y.first : s.mixBlend
                        var c = s.alpha
                        s.mixingFrom != null ? c *= this.applyMixingFrom(s, e, u) : s.trackTime >= s.trackEnd && s.next == null && (c = 0)
                        let l = s.animationLast
                        var h = s.getAnimationTime()
                        var f = s.animation.timelines.length
                        var d = s.animation.timelines
                        if (o == 0 && c == 1 || u == y.add) {
                            for (var p = 0; p < f; p++) G.webkit602BugfixHelper(c, u), d[p].apply(e, l, h, n, c, u, v.mixIn)
                        }
                        else {
                            const m = s.timelineMode
                            var _ = s.timelinesRotation.length == 0
                            _ && G.setArraySize(s.timelinesRotation, f << 1, null)
                            let g = s.timelinesRotation
                            for (p = 0; p < f; p++) {
                                const b = d[p]
                                var E = m[p] == t.SUBSEQUENT ? u : y.setup
                                b instanceof we ? this.applyRotateTimeline(b, e, h, c, E, g, p << 1, _) : (G.webkit602BugfixHelper(c, u), b.apply(e, l, h, n, c, E, v.mixIn))
                            }
                        }
                        this.queueEvents(s, h), n.length = 0, s.nextAnimationLast = h, s.nextTrackLast = s.trackTime
                    }
                }
                return this.queue.drain(), i
            }, t.prototype.applyMixingFrom = function (e, n, r) {
                const i = e.mixingFrom
                i.mixingFrom != null && this.applyMixingFrom(i, n, r)
                let o = 0
                e.mixDuration == 0 ? (o = 1, r == y.first && (r = y.setup)) : ((o = e.mixTime / e.mixDuration) > 1 && (o = 1), r != y.first && (r = i.mixBlend))
                let a = o < i.eventThreshold ? this.events : null
                var s = o < i.attachmentThreshold
                var u = o < i.drawOrderThreshold
                var c = i.animationLast
                var l = i.getAnimationTime()
                var h = i.animation.timelines.length
                var f = i.animation.timelines
                var d = i.alpha * e.interruptAlpha
                var p = d * (1 - o)
                if (r == y.add) {
                    for (var m = 0; m < h; m++) f[m].apply(n, c, l, a, p, r, v.mixOut)
                }
                else {
                    const _ = i.timelineMode
                    var g = i.timelineHoldMix
                    var b = i.timelinesRotation.length == 0
                    b && G.setArraySize(i.timelinesRotation, h << 1, null)
                    let E = i.timelinesRotation
                    i.totalAlpha = 0
                    for (m = 0; m < h; m++) {
                        const x = f[m]
                        var T = v.mixOut
                        var S = void 0
                        var w = 0
                        switch (_[m]) {
                            case t.SUBSEQUENT:
                                if (!s && x instanceof Ce) continue
                                if (!u && x instanceof je) continue
                                S = r, w = p
                                break
                            case t.FIRST:
                                S = y.setup, w = p
                                break
                            case t.HOLD:
                                S = y.setup, w = d
                                break
                            default:
                                S = y.setup
                                var O = g[m]
                                w = d * Math.max(0, 1 - O.mixTime / O.mixDuration)
                        }
                        i.totalAlpha += w, x instanceof we ? this.applyRotateTimeline(x, n, l, w, S, E, m << 1, b) : (G.webkit602BugfixHelper(w, r), S == y.setup && (x instanceof Ce ? s && (T = v.mixOut) : x instanceof je && u && (T = v.mixOut)), x.apply(n, c, l, a, w, S, T))
                    }
                }
                return e.mixDuration > 0 && this.queueEvents(i, l), this.events.length = 0, i.nextAnimationLast = l, i.nextTrackLast = i.trackTime, o
            }, t.prototype.applyRotateTimeline = function (t, e, n, r, i, o, a, s) {
                if (s && (o[a] = 0), r != 1) {
                    const u = t
                    var c = u.frames
                    var l = e.bones[u.boneIndex]
                    var h = 0
                    var f = 0
                    if (n < c[0]) { switch (i) {
                        case y.setup:
                            l.rotation = l.data.rotation
                        default:
                            return
                        case y.first:
                            h = l.rotation, f = l.data.rotation
                    }
                    } else if (h = i == y.setup ? l.data.rotation : l.rotation, n >= c[c.length - we.ENTRIES]) { f = l.data.rotation + c[c.length + we.PREV_ROTATION]
                    }
                    else {
                        const d = xe.binarySearch(c, n, we.ENTRIES)
                        var p = c[d + we.PREV_ROTATION]
                        var m = c[d]
                        var _ = u.getCurvePercent((d >> 1) - 1, 1 - (n - m) / (c[d + we.PREV_TIME] - m))
                        f = c[d + we.ROTATION] - p, f = p + (f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * _ + l.data.rotation, f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))
                    }
                    let g = 0
                    var b = f - h
                    if ((b -= 360 * (16384 - (16384.499999999996 - b / 360 | 0))) == 0) { g = o[a]
                    }
                    else {
                        let E = 0
                        var x = 0
                        s ? (E = 0, x = b) : (E = o[a], x = o[a + 1])
                        let T = b > 0
                        var S = E >= 0
                        B.signum(x) != B.signum(b) && Math.abs(x) <= 90 && (Math.abs(E) > 180 && (E += 360 * B.signum(E)), S = T), g = b + E - E % 360, S != T && (g += 360 * B.signum(E)), o[a] = g
                    }
                    o[a + 1] = b, h += g * r, l.rotation = h - 360 * (16384 - (16384.499999999996 - h / 360 | 0))
                } else { t.apply(e, 0, n, null, 1, i, v.mixIn)
                }
            }, t.prototype.queueEvents = function (t, e) {
                for (var n = t.animationStart, r = t.animationEnd, i = r - n, o = t.trackLast % i, a = this.events, s = 0, u = a.length; s < u; s++) {
                    const c = a[s]
                    if (c.time < o) break
                    c.time > r || this.queue.event(t, c)
                }
                for ((t.loop ? i == 0 || o > t.trackTime % i : e >= r && t.animationLast < r) && this.queue.complete(t); s < u; s++) {
                    a[s].time < n || this.queue.event(t, a[s])
                }
            }, t.prototype.clearTracks = function () {
                const t = this.queue.drainDisabled
                this.queue.drainDisabled = !0
                for (let e = 0, n = this.tracks.length; e < n; e++) this.clearTrack(e)
                this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain()
            }, t.prototype.clearTrack = function (t) {
                if (!(t >= this.tracks.length)) {
                    const e = this.tracks[t]
                    if (e != null) {
                        this.queue.end(e), this.disposeNext(e)
                        for (let n = e; ;) {
                            const r = n.mixingFrom
                            if (r == null) break
                            this.queue.end(r), n.mixingFrom = null, n.mixingTo = null, n = r
                        }
                        this.tracks[e.trackIndex] = null, this.queue.drain()
                    }
                }
            }, t.prototype.setCurrent = function (t, e, n) {
                const r = this.expandToIndex(t)
                this.tracks[t] = e, r != null && (n && this.queue.interrupt(r), e.mixingFrom = r, r.mixingTo = e, e.mixTime = 0, r.mixingFrom != null && r.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)), r.timelinesRotation.length = 0), this.queue.start(e)
            }, t.prototype.setAnimation = function (t, e, n) {
                const r = this.data.skeletonData.findAnimation(e)
                if (r == null) throw new Error(`Animation not found: ${ e}`)
                return this.setAnimationWith(t, r, n)
            }, t.prototype.setAnimationWith = function (t, e, n) {
                if (e == null) throw new Error('animation cannot be null.')
                let r = !0
                var i = this.expandToIndex(t)
                i != null && (i.nextTrackLast == -1 ? (this.tracks[t] = i.mixingFrom, this.queue.interrupt(i), this.queue.end(i), this.disposeNext(i), i = i.mixingFrom, r = !1) : this.disposeNext(i))
                let o = this.trackEntry(t, e, n, i)
                return this.setCurrent(t, o, r), this.queue.drain(), o
            }, t.prototype.addAnimation = function (t, e, n, r) {
                const i = this.data.skeletonData.findAnimation(e)
                if (i == null) throw new Error(`Animation not found: ${ e}`)
                return this.addAnimationWith(t, i, n, r)
            }, t.prototype.addAnimationWith = function (t, e, n, r) {
                if (e == null) throw new Error('animation cannot be null.')
                let i = this.expandToIndex(t)
                if (i != null) {
                    for (; i.next != null;) i = i.next
                }
                const o = this.trackEntry(t, e, n, i)
                if (i == null) { this.setCurrent(t, o, !0), this.queue.drain()
                }
                else if (i.next = o, r <= 0) {
                    const a = i.animationEnd - i.animationStart
                    a != 0 ? (i.loop ? r += a * (1 + (i.trackTime / a | 0)) : r += Math.max(a, i.trackTime), r -= this.data.getMix(i.animation, e)) : r = i.trackTime
                }
                return o.delay = r, o
            }, t.prototype.setEmptyAnimation = function (e, n) {
                const r = this.setAnimationWith(e, t.emptyAnimation, !1)
                return r.mixDuration = n, r.trackEnd = n, r
            }, t.prototype.addEmptyAnimation = function (e, n, r) {
                r <= 0 && (r -= n)
                let i = this.addAnimationWith(e, t.emptyAnimation, !1, r)
                return i.mixDuration = n, i.trackEnd = n, i
            }, t.prototype.setEmptyAnimations = function (t) {
                const e = this.queue.drainDisabled
                this.queue.drainDisabled = !0
                for (let n = 0, r = this.tracks.length; n < r; n++) {
                    const i = this.tracks[n]
                    i != null && this.setEmptyAnimation(i.trackIndex, t)
                }
                this.queue.drainDisabled = e, this.queue.drain()
            }, t.prototype.expandToIndex = function (t) {
                return t < this.tracks.length ? this.tracks[t] : (G.ensureArrayCapacity(this.tracks, t - this.tracks.length + 1, null), this.tracks.length = t + 1, null)
            }, t.prototype.trackEntry = function (t, e, n, r) {
                const i = this.trackEntryPool.obtain()
                return i.trackIndex = t, i.animation = e, i.loop = n, i.holdPrevious = !1, i.eventThreshold = 0, i.attachmentThreshold = 0, i.drawOrderThreshold = 0, i.animationStart = 0, i.animationEnd = e.duration, i.animationLast = -1, i.nextAnimationLast = -1, i.delay = 0, i.trackTime = 0, i.trackLast = -1, i.nextTrackLast = -1, i.trackEnd = Number.MAX_VALUE, i.timeScale = 1, i.alpha = 1, i.interruptAlpha = 1, i.mixTime = 0, i.mixDuration = r == null ? 0 : this.data.getMix(r.animation, e), i
            }, t.prototype.disposeNext = function (t) {
                for (let e = t.next; e != null;) this.queue.dispose(e), e = e.next
                t.next = null
            }, t.prototype._animationsChanged = function () {
                this.animationsChanged = !1, this.propertyIDs.clear()
                for (let t = 0, e = this.tracks.length; t < e; t++) {
                    let n = this.tracks[t]
                    if (n != null) {
                        for (; n.mixingFrom != null;) n = n.mixingFrom
                        do {
                            n.mixingFrom != null && n.mixBlend == y.add || this.setTimelineModes(n), n = n.mixingTo
                        } while (n != null)
                    }
                }
            }, t.prototype.setTimelineModes = function (e) {
                const n = e.mixingTo
                var r = e.animation.timelines
                var i = e.animation.timelines.length
                var o = G.setArraySize(e.timelineMode, i)
                e.timelineHoldMix.length = 0
                let a = G.setArraySize(e.timelineHoldMix, i)
                var s = this.propertyIDs
                if (n != null && n.holdPrevious) {
                    for (var u = 0; u < i; u++) s.add(r[u].getPropertyId()), o[u] = t.HOLD
                }
                else { t: for (u = 0; u < i; u++) {
                    let c = r[u].getPropertyId()
                    if (s.add(c)) {
                        if (n != null && this.hasTimeline(n, c)) {
                            for (let l = n.mixingTo; l != null; l = l.mixingTo) {
                                        if (!this.hasTimeline(l, c)) {
                                            if (e.mixDuration > 0) {
                                                o[u] = t.HOLD_MIX, a[u] = l;
                                                continue t
                                            }
                                            break
                                        }
}
                            o[u] = t.HOLD
                        } else { o[u] = t.FIRST;
}
                    }
                    else { o[u] = t.SUBSEQUENT
                    }
                }
                }
            }, t.prototype.hasTimeline = function (t, e) {
                for (let n = t.animation.timelines, r = 0, i = n.length; r < i; r++) {
                    if (n[r].getPropertyId() == e) return !0
                }
                return !1
            }, t.prototype.getCurrent = function (t) {
                return t >= this.tracks.length ? null : this.tracks[t]
            }, t.prototype.addListener = function (t) {
                if (t == null) throw new Error('listener cannot be null.')
                this.listeners.push(t)
            }, t.prototype.removeListener = function (t) {
                const e = this.listeners.indexOf(t)
                e >= 0 && this.listeners.splice(e, 1)
            }, t.prototype.clearListeners = function () {
                this.listeners.length = 0
            }, t.prototype.clearListenerNotifications = function () {
                this.queue.clear()
            }, t.prototype.setAnimationByName = function (e, n, r) {
                t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.')), this.setAnimation(e, n, r)
            }, t.prototype.addAnimationByName = function (e, n, r, i) {
                t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.')), this.addAnimation(e, n, r, i)
            }, t.prototype.hasAnimation = function (t) {
                return this.data.skeletonData.findAnimation(t) !== null
            }, t.prototype.hasAnimationByName = function (e) {
                return t.deprecatedWarning3 || (t.deprecatedWarning3 = !0, console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.')), this.hasAnimation(e)
            }, t.emptyAnimation = new xe('<empty>', [], 0), t.SUBSEQUENT = 0, t.FIRST = 1, t.HOLD = 2, t.HOLD_MIX = 3, t.deprecatedWarning1 = !1, t.deprecatedWarning2 = !1, t.deprecatedWarning3 = !1, t
        }())
        var Xe = (function () {
            function t() {
                this.mixBlend = y.replace, this.timelineMode = [], this.timelineHoldMix = [], this.timelinesRotation = []
            }
            return t.prototype.reset = function () {
                this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0
            }, t.prototype.getAnimationTime = function () {
                if (this.loop) {
                    const t = this.animationEnd - this.animationStart
                    return t == 0 ? this.animationStart : this.trackTime % t + this.animationStart
                }
                return Math.min(this.trackTime + this.animationStart, this.animationEnd)
            }, t.prototype.setAnimationLast = function (t) {
                this.animationLast = t, this.nextAnimationLast = t
            }, t.prototype.isComplete = function () {
                return this.trackTime >= this.animationEnd - this.animationStart
            }, t.prototype.resetRotationDirections = function () {
                this.timelinesRotation.length = 0
            }, Object.defineProperty(t.prototype, 'time', {
                get() {
                    return t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.')), this.trackTime
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.')), this.trackTime = e
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'endTime', {
                get() {
                    return t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.')), this.trackTime
                },
                set(e) {
                    t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.')), this.trackTime = e
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.loopsCount = function () {
                return Math.floor(this.trackTime / this.trackEnd)
            }, t.deprecatedWarning1 = !1, t.deprecatedWarning2 = !1, t
        }())
        var He = (function () {
            function t(t) {
                this.objects = [], this.drainDisabled = !1, this.animState = t
            }
            return t.prototype.start = function (t) {
                this.objects.push(Te.start), this.objects.push(t), this.animState.animationsChanged = !0
            }, t.prototype.interrupt = function (t) {
                this.objects.push(Te.interrupt), this.objects.push(t)
            }, t.prototype.end = function (t) {
                this.objects.push(Te.end), this.objects.push(t), this.animState.animationsChanged = !0
            }, t.prototype.dispose = function (t) {
                this.objects.push(Te.dispose), this.objects.push(t)
            }, t.prototype.complete = function (t) {
                this.objects.push(Te.complete), this.objects.push(t)
            }, t.prototype.event = function (t, e) {
                this.objects.push(Te.event), this.objects.push(t), this.objects.push(e)
            }, t.prototype.deprecateStuff = function () {
                return t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. \'state.addListener({ complete: function(track, event) { } })\'')), !0
            }, t.prototype.drain = function () {
                if (!this.drainDisabled) {
                    this.drainDisabled = !0
                    for (let t = this.objects, e = this.animState.listeners, n = 0; n < t.length; n += 2) {
                        const r = t[n]
                        let i = t[n + 1]
                        switch (r) {
                            case Te.start:
                                i.listener != null && i.listener.start && i.listener.start(i)
                                for (var o = 0; o < e.length; o++) e[o].start && e[o].start(i)
                                i.onStart && this.deprecateStuff() && i.onStart(i.trackIndex), this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(i.trackIndex)
                                break
                            case Te.interrupt:
                                i.listener != null && i.listener.interrupt && i.listener.interrupt(i)
                                for (o = 0; o < e.length; o++) e[o].interrupt && e[o].interrupt(i)
                                break
                            case Te.end:
                                i.listener != null && i.listener.end && i.listener.end(i)
                                for (o = 0; o < e.length; o++) e[o].end && e[o].end(i)
                                i.onEnd && this.deprecateStuff() && i.onEnd(i.trackIndex), this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(i.trackIndex)
                            case Te.dispose:
                                i.listener != null && i.listener.dispose && i.listener.dispose(i)
                                for (o = 0; o < e.length; o++) e[o].dispose && e[o].dispose(i)
                                this.animState.trackEntryPool.free(i)
                                break
                            case Te.complete:
                                i.listener != null && i.listener.complete && i.listener.complete(i)
                                for (o = 0; o < e.length; o++) e[o].complete && e[o].complete(i)
                                var a = B.toInt(i.loopsCount())
                                i.onComplete && this.deprecateStuff() && i.onComplete(i.trackIndex, a), this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(i.trackIndex, a)
                                break
                            case Te.event:
                                var s = t[2 + n++]
                                i.listener != null && i.listener.event && i.listener.event(i, s)
                                for (o = 0; o < e.length; o++) e[o].event && e[o].event(i, s)
                                i.onEvent && this.deprecateStuff() && i.onEvent(i.trackIndex, s), this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(i.trackIndex, s)
                        }
                    }
                    this.clear(), this.drainDisabled = !1
                }
            }, t.prototype.clear = function () {
                this.objects.length = 0
            }, t.deprecatedWarning1 = !1, t
        }())
        !(function (t) {
            t[t.start = 0] = 'start', t[t.interrupt = 1] = 'interrupt', t[t.end = 2] = 'end', t[t.dispose = 3] = 'dispose', t[t.complete = 4] = 'complete', t[t.event = 5] = 'event'
        }(Te || (Te = {})))
        let Ve; var We = (function () {
            function t() {}
            return t.prototype.start = function (t) {}, t.prototype.interrupt = function (t) {}, t.prototype.end = function (t) {}, t.prototype.dispose = function (t) {}, t.prototype.complete = function (t) {}, t.prototype.event = function (t, e) {}, t
        }())
        var Ye = (function () {
            function t(t) {
                if (this.animationToMixTime = {}, this.defaultMix = 0, t == null) throw new Error('skeletonData cannot be null.')
                this.skeletonData = t
            }
            return t.prototype.setMix = function (t, e, n) {
                const r = this.skeletonData.findAnimation(t)
                if (r == null) throw new Error(`Animation not found: ${ t}`)
                let i = this.skeletonData.findAnimation(e)
                if (i == null) throw new Error(`Animation not found: ${ e}`)
                this.setMixWith(r, i, n)
            }, t.prototype.setMixByName = function (e, n, r) {
                t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.')), this.setMix(e, n, r)
            }, t.prototype.setMixWith = function (t, e, n) {
                if (t == null) throw new Error('from cannot be null.')
                if (e == null) throw new Error('to cannot be null.')
                let r = `${t.name}.${e.name}`
                this.animationToMixTime[r] = n
            }, t.prototype.getMix = function (t, e) {
                const n = `${t.name }.${ e.name}`;
                var r = this.animationToMixTime[n]
                return void 0 === r ? this.defaultMix : r
            }, t.deprecatedWarning1 = !1, t
        }())
        var ze = (function () {
            function t(t) {
                this.atlas = t
            }
            return t.prototype.newRegionAttachment = function (t, e, n) {
                const r = this.atlas.findRegion(n)
                if (r == null) throw new Error(`Region not found in atlas: ${ n } (region attachment: ${ e })`)
                let i = new ge(e)
                return i.region = r, i
            }, t.prototype.newMeshAttachment = function (t, e, n) {
                const r = this.atlas.findRegion(n)
                if (r == null) throw new Error(`Region not found in atlas: ${ n } (mesh attachment: ${ e })`)
                let i = new ye(e)
                return i.region = r, i
            }, t.prototype.newBoundingBoxAttachment = function (t, e) {
                return new pe(e)
            }, t.prototype.newPathAttachment = function (t, e) {
                return new ve(e)
            }, t.prototype.newPointAttachment = function (t, e) {
                return new _e(e)
            }, t.prototype.newClippingAttachment = function (t, e) {
                return new me(e)
            }, t
        }())
        var qe = (function () {
            function t(t, e, n) {
                if (this.matrix = new l.d(), this.children = [], this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = !1, this.sorted = !1, t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.skeleton = e, this.parent = n, this.setToSetupPose()
            }
            return Object.defineProperty(t.prototype, 'worldX', {
                get() {
                    return this.matrix.tx
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'worldY', {
                get() {
                    return this.matrix.ty
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.update = function () {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            }, t.prototype.updateWorldTransform = function () {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            }, t.prototype.updateWorldTransformWith = function (t, e, n, r, i, o, a) {
                this.ax = t, this.ay = e, this.arotation = n, this.ascaleX = r, this.ascaleY = i, this.ashearX = o, this.ashearY = a, this.appliedValid = !0
                let s = this.parent
                var u = this.matrix
                var c = this.skeleton.scaleX
                var l = V ? -this.skeleton.scaleY : this.skeleton.scaleY
                if (s == null) {
                    const h = this.skeleton
                    var f = n + 90 + a
                    return u.a = B.cosDeg(n + o) * r * c, u.c = B.cosDeg(f) * i * c, u.b = B.sinDeg(n + o) * r * l, u.d = B.sinDeg(f) * i * l, u.tx = t * c + h.x, void (u.ty = e * l + h.y)
                }
                let d = s.matrix.a
                var p = s.matrix.c
                var m = s.matrix.b
                var y = s.matrix.d
                switch (u.tx = d * t + p * e + s.matrix.tx, u.ty = m * t + y * e + s.matrix.ty, this.data.transformMode) {
                    case b.Normal:
                        f = n + 90 + a
                        var v = B.cosDeg(n + o) * r
                        var _ = B.cosDeg(f) * i
                        var g = B.sinDeg(n + o) * r
                        var E = B.sinDeg(f) * i
                        return u.a = d * v + p * g, u.c = d * _ + p * E, u.b = m * v + y * g, void (u.d = m * _ + y * E)
                    case b.OnlyTranslation:
                        f = n + 90 + a
                        u.a = B.cosDeg(n + o) * r, u.c = B.cosDeg(f) * i, u.b = B.sinDeg(n + o) * r, u.d = B.sinDeg(f) * i
                        break
                    case b.NoRotationOrReflection:
                        var x = 0;
                        (w = d * d + m * m) > 1e-4 ? (p = m * (w = Math.abs(d * y - p * m) / w), y = d * w, x = Math.atan2(m, d) * B.radDeg) : (d = 0, m = 0, x = 90 - Math.atan2(y, p) * B.radDeg)
                        var T = n + o - x
                        var S = n + a - x + 90
                        v = B.cosDeg(T) * r, _ = B.cosDeg(S) * i, g = B.sinDeg(T) * r, E = B.sinDeg(S) * i
                        u.a = d * v - p * g, u.c = d * _ - p * E, u.b = m * v + y * g, u.d = m * _ + y * E
                        break
                    case b.NoScale:
                    case b.NoScaleOrReflection:
                        var w; var O = B.cosDeg(n)
                        var P = B.sinDeg(n)
                        var R = (d * O + p * P) / c
                        var A = (m * O + y * P) / l;
                        (w = Math.sqrt(R * R + A * A)) > 1e-5 && (w = 1 / w), R *= w, A *= w, w = Math.sqrt(R * R + A * A), this.data.transformMode == b.NoScale && d * y - p * m < 0 != (V ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (w = -w)
                        var I = Math.PI / 2 + Math.atan2(A, R)
                        var C = Math.cos(I) * w
                        var k = Math.sin(I) * w
                        v = B.cosDeg(o) * r, _ = B.cosDeg(90 + a) * i, g = B.sinDeg(o) * r, E = B.sinDeg(90 + a) * i
                        u.a = R * v + C * g, u.c = R * _ + C * E, u.b = A * v + k * g, u.d = A * _ + k * E
                }
                u.a *= c, u.c *= c, u.b *= l, u.d *= l
            }, t.prototype.setToSetupPose = function () {
                const t = this.data
                this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY
            }, t.prototype.getWorldRotationX = function () {
                return Math.atan2(this.matrix.b, this.matrix.a) * B.radDeg
            }, t.prototype.getWorldRotationY = function () {
                return Math.atan2(this.matrix.d, this.matrix.c) * B.radDeg
            }, t.prototype.getWorldScaleX = function () {
                const t = this.matrix
                return Math.sqrt(t.a * t.a + t.c * t.c)
            }, t.prototype.getWorldScaleY = function () {
                const t = this.matrix
                return Math.sqrt(t.b * t.b + t.d * t.d)
            }, t.prototype.updateAppliedTransform = function () {
                this.appliedValid = !0
                let t = this.parent
                var e = this.matrix
                if (t == null) return this.ax = e.tx, this.ay = e.ty, this.arotation = Math.atan2(e.b, e.a) * B.radDeg, this.ascaleX = Math.sqrt(e.a * e.a + e.b * e.b), this.ascaleY = Math.sqrt(e.c * e.c + e.d * e.d), this.ashearX = 0, void (this.ashearY = Math.atan2(e.a * e.c + e.b * e.d, e.a * e.d - e.b * e.c) * B.radDeg)
                let n = t.matrix
                var r = 1 / (n.a * n.d - n.b * n.c)
                var i = e.tx - n.tx
                var o = e.ty - n.ty
                this.ax = i * n.d * r - o * n.c * r, this.ay = o * n.a * r - i * n.b * r
                let a = r * n.d
                var s = r * n.a
                var u = r * n.c
                var c = r * n.b
                var l = a * e.a - u * e.b
                var h = a * e.c - u * e.d
                var f = s * e.b - c * e.a
                var d = s * e.d - c * e.c
                if (this.ashearX = 0, this.ascaleX = Math.sqrt(l * l + f * f), this.ascaleX > 1e-4) {
                    const p = l * d - h * f
                    this.ascaleY = p / this.ascaleX, this.ashearY = Math.atan2(l * h + f * d, p) * B.radDeg, this.arotation = Math.atan2(f, l) * B.radDeg
                } else { this.ascaleX = 0, this.ascaleY = Math.sqrt(h * h + d * d), this.ashearY = 0, this.arotation = 90 - Math.atan2(d, h) * B.radDeg
                }
            }, t.prototype.worldToLocal = function (t) {
                const e = this.matrix
                var n = e.a
                var r = e.c
                var i = e.b
                var o = e.d
                var a = 1 / (n * o - r * i)
                var s = t.x - e.tx
                var u = t.y - e.ty
                return t.x = s * o * a - u * r * a, t.y = u * n * a - s * i * a, t
            }, t.prototype.localToWorld = function (t) {
                const e = this.matrix
                var n = t.x
                var r = t.y
                return t.x = n * e.a + r * e.c + e.tx, t.y = n * e.b + r * e.d + e.ty, t
            }, t.prototype.worldToLocalRotation = function (t) {
                const e = B.sinDeg(t)
                var n = B.cosDeg(t)
                var r = this.matrix
                return Math.atan2(r.a * e - r.b * n, r.d * n - r.c * e) * B.radDeg
            }, t.prototype.localToWorldRotation = function (t) {
                const e = B.sinDeg(t)
                var n = B.cosDeg(t)
                var r = this.matrix
                return Math.atan2(n * r.b + e * r.d, n * r.a + e * r.c) * B.radDeg
            }, t.prototype.rotateWorld = function (t) {
                const e = this.matrix
                var n = e.a
                var r = e.c
                var i = e.b
                var o = e.d
                var a = B.cosDeg(t)
                var s = B.sinDeg(t)
                e.a = a * n - s * i, e.c = a * r - s * o, e.b = s * n + a * i, e.d = s * r + a * o, this.appliedValid = !1
            }, t
        }())
        var Ke = function (t, e, n) {
            if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = b.Normal, t < 0) throw new Error('index must be >= 0.')
            if (e == null) throw new Error('name cannot be null.')
            this.index = t, this.name = e, this.parent = n
        }
        var Ze = function (t, e) {
            if (e == null) throw new Error('data cannot be null.')
            this.time = t, this.data = e
        }
        var $e = function (t) {
            this.name = t
        }
        var Je = (function () {
            function t(t, e) {
                if (this.bendDirection = 0, this.compress = !1, this.stretch = !1, this.mix = 1, t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.compress = t.compress, this.stretch = t.stretch, this.bones = []
                for (let n = 0; n < t.bones.length; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findBone(t.target.name)
            }
            return t.prototype.getOrder = function () {
                return this.data.order
            }, t.prototype.apply = function () {
                this.update()
            }, t.prototype.update = function () {
                const t = this.target
                var e = this.bones
                switch (e.length) {
                    case 1:
                        this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix)
                        break
                    case 2:
                        this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.mix)
                }
            }, t.prototype.apply1 = function (t, e, n, r, i, o, a) {
                t.appliedValid || t.updateAppliedTransform()
                let s = t.parent.matrix
                var u = 1 / (s.a * s.d - s.b * s.c)
                var c = e - s.tx
                var l = n - s.ty
                var h = (c * s.d - l * s.c) * u - t.ax
                var f = (l * s.a - c * s.b) * u - t.ay
                var d = Math.atan2(f, h) * B.radDeg - t.ashearX - t.arotation
                t.ascaleX < 0 && (d += 180), d > 180 ? d -= 360 : d < -180 && (d += 360)
                let p = t.ascaleX
                var m = t.ascaleY
                if (r || i) {
                    const y = t.data.length * p
                    var v = Math.sqrt(h * h + f * f)
                    if (r && v < y || i && v > y && y > 1e-4) {
                        const _ = (v / y - 1) * a + 1
                        p *= _, o && (m *= _)
                    }
                }
                t.updateWorldTransformWith(t.ax, t.ay, t.arotation + d * a, p, m, t.ashearX, t.ashearY)
            }, t.prototype.apply2 = function (t, e, n, r, i, o, a) {
                if (a != 0) {
                    t.appliedValid || t.updateAppliedTransform(), e.appliedValid || e.updateAppliedTransform()
                    let s = t.ax
                    var u = t.ay
                    var c = t.ascaleX
                    var l = c
                    var h = t.ascaleY
                    var f = e.ascaleX
                    var d = t.matrix
                    var p = 0
                    var m = 0
                    var y = 0
                    c < 0 ? (c = -c, p = 180, y = -1) : (p = 0, y = 1), h < 0 && (h = -h, y = -y), f < 0 ? (f = -f, m = 180) : m = 0
                    let v = e.ax
                    var _ = 0
                    var g = 0
                    var b = 0
                    var E = d.a
                    var x = d.c
                    var T = d.b
                    var S = d.d
                    var w = Math.abs(c - h) <= 1e-4
                    w ? (g = E * v + x * (_ = e.ay) + d.tx, b = T * v + S * _ + d.ty) : (_ = 0, g = E * v + d.tx, b = T * v + d.ty)
                    let O = t.parent.matrix
                    E = O.a, x = O.c, T = O.b
                    let P = 1 / (E * (S = O.d) - x * T)
                    var R = n - O.tx
                    var A = r - O.ty
                    var I = (R * S - A * x) * P - s
                    var C = (A * E - R * T) * P - u
                    var k = I * I + C * C
                    var N = ((R = g - O.tx) * S - (A = b - O.ty) * x) * P - s
                    var M = (A * E - R * T) * P - u
                    var j = Math.sqrt(N * N + M * M)
                    var D = e.data.length * f
                    var L = 0
                    var F = 0
                    t: if (w) {
                        let U = (k - j * j - (D *= c) * D) / (2 * j * D)
                        U < -1 ? U = -1 : U > 1 && (U = 1, o && j + D > 1e-4 && (l *= (Math.sqrt(k) / (j + D) - 1) * a + 1)), F = Math.acos(U) * i, E = j + D * U, x = D * Math.sin(F), L = Math.atan2(C * E - I * x, I * E + C * x)
                    } else {
                        const G = (E = c * D) * E
                        var X = (x = h * D) * x
                        var H = Math.atan2(C, I)
                        var V = -2 * X * j
                        var W = X - G
                        if ((S = V * V - 4 * W * (T = X * j * j + G * k - G * X)) >= 0) {
                            let Y = Math.sqrt(S)
                            V < 0 && (Y = -Y)
                            let z = (Y = -(V + Y) / 2) / W
                            var q = T / Y
                            var K = Math.abs(z) < Math.abs(q) ? z : q
                            if (K * K <= k) {
                                A = Math.sqrt(k - K * K) * i, L = H - Math.atan2(A, K), F = Math.atan2(A / h, (K - j) / c)
                                break t
                            }
                        }
                        let Z = B.PI
                        var $ = j - E
                        var J = $ * $
                        var Q = 0
                        var tt = 0
                        var et = j + E
                        var nt = et * et
                        var rt = 0;
                        (T = -E * j / (G - X)) >= -1 && T <= 1 && (T = Math.acos(T), (S = (R = E * Math.cos(T) + j) * R + (A = x * Math.sin(T)) * A) < J && (Z = T, J = S, $ = R, Q = A), S > nt && (tt = T, nt = S, et = R, rt = A)), k <= (J + nt) / 2 ? (L = H - Math.atan2(Q * i, $), F = Z * i) : (L = H - Math.atan2(rt * i, et), F = tt * i)
                    }
                    const it = Math.atan2(_, v) * y
                    var ot = t.arotation;
                    (L = (L - it) * B.radDeg + p - ot) > 180 ? L -= 360 : L < -180 && (L += 360), t.updateWorldTransformWith(s, u, ot + L * a, l, t.ascaleY, 0, 0), ot = e.arotation, (F = ((F + it) * B.radDeg - e.ashearX) * y + m - ot) > 180 ? F -= 360 : F < -180 && (F += 360), e.updateWorldTransformWith(v, _, ot + F * a, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY)
                } else { e.updateWorldTransform()
                }
            }, t
        }())
        var Qe = function (t) {
            this.order = 0, this.bones = [], this.bendDirection = 1, this.compress = !1, this.stretch = !1, this.uniform = !1, this.mix = 1, this.name = t
        }
        var tn = function (t) {
            this.order = 0, this.bones = [], this.name = t
        }
        !(function (t) {
            t[t.Length = 0] = 'Length', t[t.Fixed = 1] = 'Fixed', t[t.Percent = 2] = 'Percent'
        }(Ve || (Ve = {})))
        var en = (function () {
            function t(t, e) {
                if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = [], this.positions = [], this.world = [], this.curves = [], this.lengths = [], this.segments = [], t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.bones = []
                for (let n = 0, r = t.bones.length; n < r; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix
            }
            return t.prototype.apply = function () {
                this.update()
            }, t.prototype.update = function () {
                const e = this.target.getAttachment()
                if (e instanceof ve) {
                    const n = this.rotateMix
                    let r = this.translateMix
                    let i = n > 0
                    if (r > 0 || i) {
                        const o = this.data
                        let a = o.spacingMode
                        let s = a == Ve.Length
                        let u = o.rotateMode
                        let c = u == g.Tangent
                        let l = u == g.ChainScale
                        let h = this.bones.length
                        let f = c ? h : h + 1
                        let d = this.bones
                        let p = G.setArraySize(this.spaces, f)
                        let m = null
                        let y = this.spacing
                        if (l || s) {
                            l && (m = G.setArraySize(this.lengths, h))
                            for (var v = 0, b = f - 1; v < b;) {
                                const E = (C = d[v]).data.length
                                if (E < t.epsilon) { l && (m[v] = 0), p[++v] = 0
                                }
                                else {
                                    var x = E * C.matrix.a
                                    var T = E * C.matrix.b
                                    let S = Math.sqrt(x * x + T * T)
                                    l && (m[v] = S), p[++v] = (s ? E + y : y) * S / E
                                }
                            }
                        } else {
                            for (v = 1; v < f; v++) p[v] = y
                        }
                        const w = this.computeWorldPositions(e, f, c, o.positionMode == _.Percent, a == Ve.Percent)
                        let O = w[0]
                        let P = w[1]
                        let R = o.offsetRotation
                        let A = !1
                        if (R == 0) A = u == g.Chain
                        else A = !1, R *= (I = this.target.bone.matrix).a * I.d - I.b * I.c > 0 ? B.degRad : -B.degRad
                        v = 0
                        for (var I = 3; v < h; v++, I += 3) {
                            var C; const k = (C = d[v]).matrix
                            k.tx += (O - k.tx) * r, k.ty += (P - k.ty) * r
                            const N = (x = w[I]) - O
                            let M = (T = w[I + 1]) - P
                            if (l) {
                                const j = m[v]
                                if (j != 0) {
                                    const D = (Math.sqrt(N * N + M * M) / j - 1) * n + 1
                                    k.a *= D, k.b *= D
                                }
                            }
                            if (O = x, P = T, i) {
                                const L = k.a
                                let F = k.c
                                let U = k.b
                                let X = k.d
                                let H = 0
                                let V = 0
                                let W = 0
                                if (H = c ? w[I - 1] : p[v + 1] == 0 ? w[I + 2] : Math.atan2(M, N), H -= Math.atan2(U, L), A) {
                                    V = Math.cos(H), W = Math.sin(H)
                                    const Y = C.data.length
                                    O += (Y * (V * L - W * U) - N) * n, P += (Y * (W * L + V * U) - M) * n
                                } else { H += R
                                }
                                H > B.PI ? H -= B.PI2 : H < -B.PI && (H += B.PI2), H *= n, V = Math.cos(H), W = Math.sin(H), k.a = V * L - W * U, k.c = V * F - W * X, k.b = W * L + V * U, k.d = W * F + V * X
                            }
                            C.appliedValid = !1
                        }
                    }
                }
            }, t.prototype.computeWorldPositions = function (e, n, r, i, o) {
                const a = this.target
                let s = this.position
                let u = this.spaces
                let c = G.setArraySize(this.positions, 3 * n + 2)
                let l = null
                let h = e.closed
                let f = e.worldVerticesLength
                let d = f / 6
                let p = t.NONE
                if (!e.constantSpeed) {
                    const m = e.lengths
                    let y = m[d -= h ? 1 : 2]
                    if (i && (s *= y), o) {
                        for (var v = 0; v < n; v++) u[v] *= y
                    }
                    l = G.setArraySize(this.world, 8)
                    v = 0
                    for (var _ = 0, g = 0; v < n; v++, _ += 3) {
                        var b = s += W = u[v]
                        if (h) { (b %= y) < 0 && (b += y), g = 0
                        }
                        else {
                            if (b < 0) {
                                p != t.BEFORE && (p = t.BEFORE, e.computeWorldVertices(a, 2, 4, l, 0, 2)), this.addBeforePosition(b, l, 0, c, _)
                                continue
                            }
                            if (b > y) {
                                p != t.AFTER && (p = t.AFTER, e.computeWorldVertices(a, f - 6, 4, l, 0, 2)), this.addAfterPosition(b - y, l, 0, c, _)
                                continue
                            }
                        }
                        for (;; g++) {
                            const E = m[g]
                            if (!(b > E)) {
                                if (g == 0) b /= E
                                else b = (b - (K = m[g - 1])) / (E - K)
                                break
                            }
                        }
                        g != p && (p = g, h && g == d ? (e.computeWorldVertices(a, f - 4, 4, l, 0, 2), e.computeWorldVertices(a, 0, 4, l, 4, 2)) : e.computeWorldVertices(a, 6 * g + 2, 8, l, 0, 2)), this.addCurvePosition(b, l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], c, _, r || v > 0 && W == 0)
                    }
                    return c
                }
                h ? (f += 2, l = G.setArraySize(this.world, f), e.computeWorldVertices(a, 2, f - 4, l, 0, 2), e.computeWorldVertices(a, 0, 2, l, f - 4, 2), l[f - 2] = l[0], l[f - 1] = l[1]) : (d--, f -= 4, l = G.setArraySize(this.world, f), e.computeWorldVertices(a, 2, f, l, 0, 2))
                for (var x = G.setArraySize(this.curves, d), T = 0, S = l[0], w = l[1], O = 0, P = 0, R = 0, A = 0, I = 0, C = 0, k = 0, N = 0, M = 0, j = 0, D = 0, L = 0, F = 0, B = 0, U = (v = 0, 2); v < d; v++, U += 6) O = l[U], P = l[U + 1], R = l[U + 2], A = l[U + 3], D = 2 * (k = 0.1875 * (S - 2 * O + R)) + (M = 0.09375 * (3 * (O - R) - S + (I = l[U + 4]))), L = 2 * (N = 0.1875 * (w - 2 * P + A)) + (j = 0.09375 * (3 * (P - A) - w + (C = l[U + 5]))), F = 0.75 * (O - S) + k + 0.16666667 * M, B = 0.75 * (P - w) + N + 0.16666667 * j, T += Math.sqrt(F * F + B * B), F += D, B += L, D += M, L += j, T += Math.sqrt(F * F + B * B), F += D, B += L, T += Math.sqrt(F * F + B * B), F += D + M, B += L + j, T += Math.sqrt(F * F + B * B), x[v] = T, S = I, w = C
                if (i && (s *= T), o) {
                    for (v = 0; v < n; v++) u[v] *= T
                }
                for (let X = this.segments, H = 0, V = (v = 0, _ = 0, g = 0, 0); v < n; v++, _ += 3) {
                    var W
                    b = s += W = u[v]
                    if (h) { (b %= T) < 0 && (b += T), g = 0
                    }
                    else {
                        if (b < 0) {
                            this.addBeforePosition(b, l, 0, c, _)
                            continue
                        }
                        if (b > T) {
                            this.addAfterPosition(b - T, l, f - 4, c, _)
                            continue
                        }
                    }
                    for (;; g++) {
                        const Y = x[g]
                        if (!(b > Y)) {
                            if (g == 0) b /= Y
                            else b = (b - (K = x[g - 1])) / (Y - K)
                            break
                        }
                    }
                    if (g != p) {
                        p = g
                        let z = 6 * g
                        for (S = l[z], w = l[z + 1], O = l[z + 2], P = l[z + 3], R = l[z + 4], A = l[z + 5], D = 2 * (k = 0.03 * (S - 2 * O + R)) + (M = 0.006 * (3 * (O - R) - S + (I = l[z + 6]))), L = 2 * (N = 0.03 * (w - 2 * P + A)) + (j = 0.006 * (3 * (P - A) - w + (C = l[z + 7]))), F = 0.3 * (O - S) + k + 0.16666667 * M, B = 0.3 * (P - w) + N + 0.16666667 * j, H = Math.sqrt(F * F + B * B), X[0] = H, z = 1; z < 8; z++) F += D, B += L, D += M, L += j, H += Math.sqrt(F * F + B * B), X[z] = H
                        F += D, B += L, H += Math.sqrt(F * F + B * B), X[8] = H, F += D + M, B += L + j, H += Math.sqrt(F * F + B * B), X[9] = H, V = 0
                    }
                    for (b *= H; ; V++) {
                        const q = X[V]
                        if (!(b > q)) {
                            var K
                            if (V == 0) b /= q
                            else b = V + (b - (K = X[V - 1])) / (q - K)
                            break
                        }
                    }
                    this.addCurvePosition(0.1 * b, S, w, O, P, R, A, I, C, c, _, r || v > 0 && W == 0)
                }
                return c
            }, t.prototype.addBeforePosition = function (t, e, n, r, i) {
                const o = e[n]
                let a = e[n + 1]
                let s = e[n + 2] - o
                let u = e[n + 3] - a
                let c = Math.atan2(u, s)
                r[i] = o + t * Math.cos(c), r[i + 1] = a + t * Math.sin(c), r[i + 2] = c
            }, t.prototype.addAfterPosition = function (t, e, n, r, i) {
                const o = e[n + 2]
                let a = e[n + 3]
                let s = o - e[n]
                let u = a - e[n + 1]
                let c = Math.atan2(u, s)
                r[i] = o + t * Math.cos(c), r[i + 1] = a + t * Math.sin(c), r[i + 2] = c
            }, t.prototype.addCurvePosition = function (t, e, n, r, i, o, a, s, u, c, l, h) {
                (t == 0 || isNaN(t)) && (t = 1e-4)
                const f = t * t
                let d = f * t
                let p = 1 - t
                let m = p * p
                let y = m * p
                let v = p * t
                let _ = 3 * v
                let g = p * _
                let b = _ * t
                let E = e * y + r * g + o * b + s * d
                let x = n * y + i * g + a * b + u * d
                c[l] = E, c[l + 1] = x, h && (c[l + 2] = Math.atan2(x - (n * m + i * v * 2 + a * f), E - (e * m + r * v * 2 + o * f)))
            }, t.prototype.getOrder = function () {
                return this.data.order
            }, t.NONE = -1, t.BEFORE = -2, t.AFTER = -3, t.epsilon = 1e-5, t
        }())
        var nn = (function () {
            function t(t, e) {
                if (this.attachmentVertices = [], t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('bone cannot be null.')
                this.data = t, this.bone = e, this.color = new F(), this.darkColor = t.darkColor == null ? null : new F(), this.setToSetupPose(), this.blendMode = this.data.blendMode
            }
            return t.prototype.getAttachment = function () {
                return this.attachment
            }, t.prototype.setAttachment = function (t) {
                this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0)
            }, t.prototype.setAttachmentTime = function (t) {
                this.attachmentTime = this.bone.skeleton.time - t
            }, t.prototype.getAttachmentTime = function () {
                return this.bone.skeleton.time - this.attachmentTime
            }, t.prototype.setToSetupPose = function () {
                this.color.setFromColor(this.data.color), this.darkColor != null && this.darkColor.setFromColor(this.data.darkColor), this.data.attachmentName == null ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
            }, t
        }())
        var rn = (function () {
            function t(t, e) {
                if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new H(), t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix, this.scaleMix = t.scaleMix, this.shearMix = t.shearMix, this.bones = []
                for (let n = 0; n < t.bones.length; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findBone(t.target.name)
            }
            return t.prototype.apply = function () {
                this.update()
            }, t.prototype.update = function () {
                this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
            }, t.prototype.applyAbsoluteWorld = function () {
                for (let t = this.rotateMix, e = this.translateMix, n = this.scaleMix, r = this.shearMix, i = this.target, o = i.matrix, a = o.a, s = o.c, u = o.b, c = o.d, l = a * c - s * u > 0 ? B.degRad : -B.degRad, h = this.data.offsetRotation * l, f = this.data.offsetShearY * l, d = this.bones, p = 0, m = d.length; p < m; p++) {
                    const y = d[p]
                    var v = !1
                    var _ = y.matrix
                    if (t != 0) {
                        const g = _.a
                        var b = _.c
                        var E = _.b
                        var x = _.d;
                        (R = Math.atan2(u, a) - Math.atan2(E, g) + h) > B.PI ? R -= B.PI2 : R < -B.PI && (R += B.PI2), R *= t
                        let T = Math.cos(R)
                        var S = Math.sin(R)
                        _.a = T * g - S * E, _.c = T * b - S * x, _.b = S * g + T * E, _.d = S * b + T * x, v = !0
                    }
                    if (e != 0) {
                        const w = this.temp
                        i.localToWorld(w.set(this.data.offsetX, this.data.offsetY)), _.tx += (w.x - _.tx) * e, _.ty += (w.y - _.ty) * e, v = !0
                    }
                    if (n > 0) {
                        var O = Math.sqrt(_.a * _.a + _.b * _.b)
                        var P = Math.sqrt(a * a + u * u)
                        O > 1e-5 && (O = (O + (P - O + this.data.offsetScaleX) * n) / O), _.a *= O, _.b *= O, O = Math.sqrt(_.c * _.c + _.d * _.d), P = Math.sqrt(s * s + c * c), O > 1e-5 && (O = (O + (P - O + this.data.offsetScaleY) * n) / O), _.c *= O, _.d *= O, v = !0
                    }
                    if (r > 0) {
                        b = _.c, x = _.d
                        var R; const A = Math.atan2(x, b);
                        (R = Math.atan2(c, s) - Math.atan2(u, a) - (A - Math.atan2(_.b, _.a))) > B.PI ? R -= B.PI2 : R < -B.PI && (R += B.PI2), R = A + (R + f) * r
                        O = Math.sqrt(b * b + x * x)
                        _.c = Math.cos(R) * O, _.d = Math.sin(R) * O, v = !0
                    }
                    v && (y.appliedValid = !1)
                }
            }, t.prototype.applyRelativeWorld = function () {
                for (let t = this.rotateMix, e = this.translateMix, n = this.scaleMix, r = this.shearMix, i = this.target, o = i.matrix, a = o.a, s = o.c, u = o.b, c = o.d, l = a * c - s * u > 0 ? B.degRad : -B.degRad, h = this.data.offsetRotation * l, f = this.data.offsetShearY * l, d = this.bones, p = 0, m = d.length; p < m; p++) {
                    const y = d[p]
                    var v = !1
                    var _ = y.matrix
                    if (t != 0) {
                        const g = _.a
                        var b = _.c
                        var E = _.b
                        var x = _.d;
                        (P = Math.atan2(u, a) + h) > B.PI ? P -= B.PI2 : P < -B.PI && (P += B.PI2), P *= t
                        let T = Math.cos(P)
                        var S = Math.sin(P)
                        _.a = T * g - S * E, _.c = T * b - S * x, _.b = S * g + T * E, _.d = S * b + T * x, v = !0
                    }
                    if (e != 0) {
                        const w = this.temp
                        i.localToWorld(w.set(this.data.offsetX, this.data.offsetY)), _.tx += w.x * e, _.ty += w.y * e, v = !0
                    }
                    if (n > 0) {
                        var O = (Math.sqrt(a * a + u * u) - 1 + this.data.offsetScaleX) * n + 1
                        _.a *= O, _.b *= O, O = (Math.sqrt(s * s + c * c) - 1 + this.data.offsetScaleY) * n + 1, _.c *= O, _.d *= O, v = !0
                    }
                    if (r > 0) {
                        var P;
                        (P = Math.atan2(c, s) - Math.atan2(u, a)) > B.PI ? P -= B.PI2 : P < -B.PI && (P += B.PI2)
                        b = _.c, x = _.d
                        P = Math.atan2(x, b) + (P - B.PI / 2 + f) * r
                        O = Math.sqrt(b * b + x * x)
                        _.c = Math.cos(P) * O, _.d = Math.sin(P) * O, v = !0
                    }
                    v && (y.appliedValid = !1)
                }
            }, t.prototype.applyAbsoluteLocal = function () {
                const t = this.rotateMix
                var e = this.translateMix
                var n = this.scaleMix
                var r = this.shearMix
                var i = this.target
                i.appliedValid || i.updateAppliedTransform()
                for (let o = this.bones, a = 0, s = o.length; a < s; a++) {
                    const u = o[a]
                    u.appliedValid || u.updateAppliedTransform()
                    let c = u.arotation
                    if (t != 0) {
                        var l = i.arotation - c + this.data.offsetRotation
                        c += (l -= 360 * (16384 - (16384.499999999996 - l / 360 | 0))) * t
                    }
                    let h = u.ax
                    var f = u.ay
                    e != 0 && (h += (i.ax - h + this.data.offsetX) * e, f += (i.ay - f + this.data.offsetY) * e)
                    let d = u.ascaleX
                    var p = u.ascaleY
                    n > 0 && (d > 1e-5 && (d = (d + (i.ascaleX - d + this.data.offsetScaleX) * n) / d), p > 1e-5 && (p = (p + (i.ascaleY - p + this.data.offsetScaleY) * n) / p))
                    let m = u.ashearY
                    if (r > 0) {
                        l = i.ashearY - m + this.data.offsetShearY
                        l -= 360 * (16384 - (16384.499999999996 - l / 360 | 0)), u.shearY += l * r
                    }
                    u.updateWorldTransformWith(h, f, c, d, p, u.ashearX, m)
                }
            }, t.prototype.applyRelativeLocal = function () {
                const t = this.rotateMix
                var e = this.translateMix
                var n = this.scaleMix
                var r = this.shearMix
                var i = this.target
                i.appliedValid || i.updateAppliedTransform()
                for (let o = this.bones, a = 0, s = o.length; a < s; a++) {
                    const u = o[a]
                    u.appliedValid || u.updateAppliedTransform()
                    let c = u.arotation
                    t != 0 && (c += (i.arotation + this.data.offsetRotation) * t)
                    let l = u.ax
                    var h = u.ay
                    e != 0 && (l += (i.ax + this.data.offsetX) * e, h += (i.ay + this.data.offsetY) * e)
                    let f = u.ascaleX
                    var d = u.ascaleY
                    n > 0 && (f > 1e-5 && (f *= (i.ascaleX - 1 + this.data.offsetScaleX) * n + 1), d > 1e-5 && (d *= (i.ascaleY - 1 + this.data.offsetScaleY) * n + 1))
                    let p = u.ashearY
                    r > 0 && (p += (i.ashearY + this.data.offsetShearY) * r), u.updateWorldTransformWith(l, h, c, f, d, u.ashearX, p)
                }
            }, t.prototype.getOrder = function () {
                return this.data.order
            }, t
        }())
        var on = (function () {
            function t(t) {
                if (this._updateCache = [], this.updateCacheReset = [], this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, t == null) throw new Error('data cannot be null.')
                this.data = t, this.bones = []
                for (var e = 0; e < t.bones.length; e++) {
                    const n = t.bones[e]
                    var r = void 0
                    if (n.parent == null) { r = new qe(n, this, null)
                    }
                    else {
                        const i = this.bones[n.parent.index]
                        r = new qe(n, this, i), i.children.push(r)
                    }
                    this.bones.push(r)
                }
                this.slots = [], this.drawOrder = []
                for (e = 0; e < t.slots.length; e++) {
                    const o = t.slots[e]
                    var a = (r = this.bones[o.boneData.index], new nn(o, r))
                    this.slots.push(a), this.drawOrder.push(a)
                }
                this.ikConstraints = []
                for (e = 0; e < t.ikConstraints.length; e++) {
                    const s = t.ikConstraints[e]
                    this.ikConstraints.push(new Je(s, this))
                }
                this.transformConstraints = []
                for (e = 0; e < t.transformConstraints.length; e++) {
                    const u = t.transformConstraints[e]
                    this.transformConstraints.push(new rn(u, this))
                }
                this.pathConstraints = []
                for (e = 0; e < t.pathConstraints.length; e++) {
                    const c = t.pathConstraints[e]
                    this.pathConstraints.push(new en(c, this))
                }
                this.color = new F(1, 1, 1, 1), this.updateCache()
            }
            return t.prototype.updateCache = function () {
                this._updateCache.length = 0, this.updateCacheReset.length = 0
                for (var t = this.bones, e = 0, n = t.length; e < n; e++) t[e].sorted = !1
                let r = this.ikConstraints
                var i = this.transformConstraints
                var o = this.pathConstraints
                var a = r.length
                var s = i.length
                var u = o.length
                var c = a + s + u
                t: for (e = 0; e < c; e++) {
                    for (var l = 0; l < a; l++) {
                        if ((h = r[l]).data.order == e) {
                            this.sortIkConstraint(h)
                            continue t
                        }
                    }
                    for (l = 0; l < s; l++) {
                        if ((h = i[l]).data.order == e) {
                            this.sortTransformConstraint(h)
                            continue t
                        }
                    }
                    for (l = 0; l < u; l++) {
                        var h
                        if ((h = o[l]).data.order == e) {
                            this.sortPathConstraint(h)
                            continue t
                        }
                    }
                }
                for (e = 0, n = t.length; e < n; e++) this.sortBone(t[e])
            }, t.prototype.sortIkConstraint = function (t) {
                const e = t.target
                this.sortBone(e)
                let n = t.bones
                var r = n[0]
                if (this.sortBone(r), n.length > 1) {
                    const i = n[n.length - 1]
                    this._updateCache.includes(i) || this.updateCacheReset.push(i)
                }
                this._updateCache.push(t), this.sortReset(r.children), n[n.length - 1].sorted = !0
            }, t.prototype.sortPathConstraint = function (t) {
                const e = t.target
                var n = e.data.index
                var r = e.bone
                this.skin != null && this.sortPathConstraintAttachment(this.skin, n, r), this.data.defaultSkin != null && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, r)
                for (var i = 0, o = this.data.skins.length; i < o; i++) this.sortPathConstraintAttachment(this.data.skins[i], n, r)
                let a = e.getAttachment()
                a instanceof ve && this.sortPathConstraintAttachmentWith(a, r)
                let s = t.bones
                var u = s.length
                for (i = 0; i < u; i++) this.sortBone(s[i])
                this._updateCache.push(t)
                for (i = 0; i < u; i++) this.sortReset(s[i].children)
                for (i = 0; i < u; i++) s[i].sorted = !0
            }, t.prototype.sortTransformConstraint = function (t) {
                this.sortBone(t.target)
                let e = t.bones
                var n = e.length
                if (t.data.local) {
                    for (var r = 0; r < n; r++) {
                        let i = e[r]
                        this.sortBone(i.parent), this._updateCache.includes(i) || this.updateCacheReset.push(i)
                    }
                } else {
                    for (r = 0; r < n; r++) this.sortBone(e[r])
                }
                this._updateCache.push(t)
                for (var o = 0; o < n; o++) this.sortReset(e[o].children)
                for (o = 0; o < n; o++) e[o].sorted = !0
            }, t.prototype.sortPathConstraintAttachment = function (t, e, n) {
                const r = t.attachments[e]
                if (r) {
                    for (const i in r) this.sortPathConstraintAttachmentWith(r[i], n)
                }
            }, t.prototype.sortPathConstraintAttachmentWith = function (t, e) {
                if (t instanceof ve) {
                    const n = t.bones
                    if (n == null) { this.sortBone(e)
                    }
                    else {
                        for (let r = this.bones, i = 0; i < n.length;) {
                            for (let o = n[i++], a = i + o; i < a; i++) {
                                var s = n[i]
                                        this.sortBone(r[s])
                            }
                        }
                    }
                }
            }, t.prototype.sortBone = function (t) {
                if (!t.sorted) {
                    const e = t.parent
                    e != null && this.sortBone(e), t.sorted = !0, this._updateCache.push(t)
                }
            }, t.prototype.sortReset = function (t) {
                for (let e = 0, n = t.length; e < n; e++) {
                    const r = t[e]
                    r.sorted && this.sortReset(r.children), r.sorted = !1
                }
            }, t.prototype.updateWorldTransform = function () {
                for (var t = this.updateCacheReset, e = 0, n = t.length; e < n; e++) {
                    const r = t[e]
                    r.ax = r.x, r.ay = r.y, r.arotation = r.rotation, r.ascaleX = r.scaleX, r.ascaleY = r.scaleY, r.ashearX = r.shearX, r.ashearY = r.shearY, r.appliedValid = !0
                }
                const i = this._updateCache
                for (e = 0, n = i.length; e < n; e++) i[e].update()
            }, t.prototype.setToSetupPose = function () {
                this.setBonesToSetupPose(), this.setSlotsToSetupPose()
            }, t.prototype.setBonesToSetupPose = function () {
                for (var t = this.bones, e = 0, n = t.length; e < n; e++) t[e].setToSetupPose()
                let r = this.ikConstraints
                for (e = 0, n = r.length; e < n; e++) {
                    (s = r[e]).bendDirection = s.data.bendDirection, s.mix = s.data.mix
                }
                const i = this.transformConstraints
                for (e = 0, n = i.length; e < n; e++) {
                    var o = (s = i[e]).data
                    s.rotateMix = o.rotateMix, s.translateMix = o.translateMix, s.scaleMix = o.scaleMix, s.shearMix = o.shearMix
                }
                const a = this.pathConstraints
                for (e = 0, n = a.length; e < n; e++) {
                    var s
                    o = (s = a[e]).data
                    s.position = o.position, s.spacing = o.spacing, s.rotateMix = o.rotateMix, s.translateMix = o.translateMix
                }
            }, t.prototype.setSlotsToSetupPose = function () {
                const t = this.slots
                G.arrayCopy(t, 0, this.drawOrder, 0, t.length)
                for (let e = 0, n = t.length; e < n; e++) t[e].setToSetupPose()
            }, t.prototype.getRootBone = function () {
                return this.bones.length == 0 ? null : this.bones[0]
            }, t.prototype.findBone = function (t) {
                if (t == null) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findBoneIndex = function (t) {
                if (t == null) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    if (e[n].data.name == t) return n
                }
                return -1
            }, t.prototype.findSlot = function (t) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findSlotIndex = function (t) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    if (e[n].data.name == t) return n
                }
                return -1
            }, t.prototype.setSkinByName = function (t) {
                const e = this.data.findSkin(t)
                if (e == null) throw new Error(`Skin not found: ${ t}`)
                this.setSkin(e)
            }, t.prototype.setSkin = function (t) {
                if (t != null) {
                    if (this.skin != null) { t.attachAll(this, this.skin)
}
                    else {
                        for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                            var i = e[n];
                                        var o = i.data.attachmentName
                                    if (o != null) {
                                var a = t.getAttachment(n, o)
                                        null != a && i.setAttachment(a)
                            }
                        }
                    }
                }
                this.skin = t
            }, t.prototype.getAttachmentByName = function (t, e) {
                return this.getAttachment(this.data.findSlotIndex(t), e)
            }, t.prototype.getAttachment = function (t, e) {
                if (e == null) throw new Error('attachmentName cannot be null.')
                if (this.skin != null) {
                    const n = this.skin.getAttachment(t, e)
                    if (n != null) return n
                }
                return this.data.defaultSkin != null ? this.data.defaultSkin.getAttachment(t, e) : null
            }, t.prototype.setAttachment = function (t, e) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let n = this.slots, r = 0, i = n.length; r < i; r++) {
                    const o = n[r]
                    if (o.data.name == t) {
                        let a = null
                        if (e != null && (a = this.getAttachment(r, e)) == null) throw new Error(`Attachment not found: ${ e }, for slot: ${ t}`)
                        return void o.setAttachment(a)
                    }
                }
                throw new Error(`Slot not found: ${ t}`)
            }, t.prototype.findIkConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.ikConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findTransformConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.transformConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.getBounds = function (t, e, n) {
                if (t == null) throw new Error('offset cannot be null.')
                if (e == null) throw new Error('size cannot be null.')
                for (var r = this.drawOrder, i = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY, u = 0, c = r.length; u < c; u++) {
                    const l = r[u]
                    var h = 0
                    var f = null
                    var d = l.getAttachment()
                    if (d instanceof ge) { h = 8, f = G.setArraySize(n, h, 0), d.computeWorldVertices(l.bone, f, 0, 2)
                    }
                    else if (d instanceof ye) {
                        const p = d
                        h = p.worldVerticesLength, f = G.setArraySize(n, h, 0), p.computeWorldVertices(l, 0, h, f, 0, 2)
                    }
                    if (f != null) {
                        for (let m = 0, y = f.length; m < y; m += 2) {
                            let v = f[m]
                                        var _ = f[m + 1]
                            i = Math.min(i, v), o = Math.min(o, _), a = Math.max(a, v), s = Math.max(s, _)
                        }
                    }
                }
                t.set(i, o), e.set(a - i, s - o)
            }, t.prototype.update = function (t) {
                this.time += t
            }, Object.defineProperty(t.prototype, 'flipX', {
                get() {
                    return this.scaleX == -1
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY')), this.scaleX = e ? 1 : -1
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'flipY', {
                get() {
                    return this.scaleY == -1
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY')), this.scaleY = e ? 1 : -1
                },
                enumerable: !1,
                configurable: !0
            }), t.deprecatedWarning1 = !1, t
        }())
        var an = (function () {
            function t() {
                this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = [], this.polygons = [], this.polygonPool = new X(() => {
                    return G.newFloatArray(16)
                })
            }
            return t.prototype.update = function (t, e) {
                if (t == null) throw new Error('skeleton cannot be null.')
                let n = this.boundingBoxes
                var r = this.polygons
                var i = this.polygonPool
                var o = t.slots
                var a = o.length
                n.length = 0, i.freeAll(r), r.length = 0
                for (let s = 0; s < a; s++) {
                    const u = o[s]
                    var c = u.getAttachment()
                    if (c instanceof pe) {
                        const l = c
                        n.push(l)
                        let h = i.obtain()
                        h.length != l.worldVerticesLength && (h = G.newFloatArray(l.worldVerticesLength)), r.push(h), l.computeWorldVertices(u, 0, l.worldVerticesLength, h, 0, 2)
                    }
                }
                e ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY)
            }, t.prototype.aabbCompute = function () {
                for (var t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, r = Number.NEGATIVE_INFINITY, i = this.polygons, o = 0, a = i.length; o < a; o++) {
                    for (let s = i[o], u = s, c = 0, l = s.length; c < l; c += 2) {
                        let h = u[c]
                                    var f = u[c + 1]
                        t = Math.min(t, h), e = Math.min(e, f), n = Math.max(n, h), r = Math.max(r, f)
                    }
                }
                this.minX = t, this.minY = e, this.maxX = n, this.maxY = r
            }, t.prototype.aabbContainsPoint = function (t, e) {
                return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
            }, t.prototype.aabbIntersectsSegment = function (t, e, n, r) {
                const i = this.minX
                var o = this.minY
                var a = this.maxX
                var s = this.maxY
                if (t <= i && n <= i || e <= o && r <= o || t >= a && n >= a || e >= s && r >= s) return !1
                let u = (r - e) / (n - t)
                var c = u * (i - t) + e
                if (c > o && c < s) return !0
                if ((c = u * (a - t) + e) > o && c < s) return !0
                let l = (o - e) / u + t
                return l > i && l < a || (l = (s - e) / u + t) > i && l < a
            }, t.prototype.aabbIntersectsSkeleton = function (t) {
                return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
            }, t.prototype.containsPoint = function (t, e) {
                for (let n = this.polygons, r = 0, i = n.length; r < i; r++) {
                    if (this.containsPointPolygon(n[r], t, e)) return this.boundingBoxes[r]
                }
                return null
            }, t.prototype.containsPointPolygon = function (t, e, n) {
                for (var r = t, i = t.length, o = i - 2, a = !1, s = 0; s < i; s += 2) {
                    const u = r[s + 1]
                    var c = r[o + 1]
                    if (u < n && c >= n || c < n && u >= n) {
                        const l = r[s]
                        l + (n - u) / (c - u) * (r[o] - l) < e && (a = !a)
                    }
                    o = s
                }
                return a
            }, t.prototype.intersectsSegment = function (t, e, n, r) {
                for (let i = this.polygons, o = 0, a = i.length; o < a; o++) {
                    if (this.intersectsSegmentPolygon(i[o], t, e, n, r)) return this.boundingBoxes[o]
                }
                return null
            }, t.prototype.intersectsSegmentPolygon = function (t, e, n, r, i) {
                for (let o = t, a = t.length, s = e - r, u = n - i, c = e * i - n * r, l = o[a - 2], h = o[a - 1], f = 0; f < a; f += 2) {
                    const d = o[f]
                    var p = o[f + 1]
                    var m = l * p - h * d
                    var y = l - d
                    var v = h - p
                    var _ = s * v - u * y
                    var g = (c * y - s * m) / _
                    if ((g >= l && g <= d || g >= d && g <= l) && (g >= e && g <= r || g >= r && g <= e)) {
                        const b = (c * v - u * m) / _
                        if ((b >= h && b <= p || b >= p && b <= h) && (b >= n && b <= i || b >= i && b <= n)) return !0
                    }
                    l = d, h = p
                }
                return !1
            }, t.prototype.getPolygon = function (t) {
                if (t == null) throw new Error('boundingBox cannot be null.')
                let e = this.boundingBoxes.indexOf(t)
                return e == -1 ? null : this.polygons[e]
            }, t.prototype.getWidth = function () {
                return this.maxX - this.minX
            }, t.prototype.getHeight = function () {
                return this.maxY - this.minY
            }, t
        }())
        var sn = (function () {
            function t() {
                this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], this.ikConstraints = [], this.transformConstraints = [], this.pathConstraints = [], this.fps = 0
            }
            return t.prototype.findBone = function (t) {
                if (t == null) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findBoneIndex = function (t) {
                if (t == null) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t.prototype.findSlot = function (t) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findSlotIndex = function (t) {
                if (t == null) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t.prototype.findSkin = function (t) {
                if (t == null) throw new Error('skinName cannot be null.')
                for (let e = this.skins, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findEvent = function (t) {
                if (t == null) throw new Error('eventDataName cannot be null.')
                for (let e = this.events, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findAnimation = function (t) {
                if (t == null) throw new Error('animationName cannot be null.')
                for (let e = this.animations, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findIkConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.ikConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findTransformConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.transformConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraint = function (t) {
                if (t == null) throw new Error('constraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraintIndex = function (t) {
                if (t == null) throw new Error('pathConstraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t
        }())
        var un = function (t, e, n) {
            if (this.color = new F(1, 1, 1, 1), t < 0) throw new Error('index must be >= 0.')
            if (e == null) throw new Error('name cannot be null.')
            if (n == null) throw new Error('boneData cannot be null.')
            this.index = t, this.name = e, this.boneData = n
        }
        var cn = function (t) {
            if (this.order = 0, this.bones = [], this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.offsetRotation = 0, this.offsetX = 0, this.offsetY = 0, this.offsetScaleX = 0, this.offsetScaleY = 0, this.offsetShearY = 0, this.relative = !1, this.local = !1, t == null) throw new Error('name cannot be null.')
            this.name = t
        }
        var ln = (function () {
            function t(t) {
                if (this.attachments = [], t == null) throw new Error('name cannot be null.')
                this.name = t
            }
            return t.prototype.addAttachment = function (t, e, n) {
                if (n == null) throw new Error('attachment cannot be null.')
                let r = this.attachments
                t >= r.length && (r.length = t + 1), r[t] || (r[t] = {}), r[t][e] = n
            }, t.prototype.getAttachment = function (t, e) {
                const n = this.attachments[t]
                return n ? n[e] : null
            }, t.prototype.attachAll = function (t, e) {
                for (let n = 0, r = 0; r < t.slots.length; r++) {
                    const i = t.slots[r]
                    var o = i.getAttachment()
                    if (o && n < e.attachments.length) {
                        const a = e.attachments[n]
                        for (const s in a) {
                            if (o == a[s]) {
                                const u = this.getAttachment(n, s)
                                u != null && i.setAttachment(u)
                                break
                            }
                        }
                    }
                    n++
                }
            }, t
        }())
        var hn = (function () {
            function t(t) {
                this.scale = 1, this.linkedMeshes = [], this.attachmentLoader = t
            }
            return t.prototype.readSkeletonData = function (e) {
                const n = this.scale
                var r = new sn()
                var i = typeof e == 'string' ? JSON.parse(e) : e
                var o = i.skeleton
                if (o != null && (r.hash = o.hash, r.version = o.spine, r.width = o.width, r.height = o.height, r.fps = o.fps, r.imagesPath = o.images), i.bones) {
                    for (var a = 0; a < i.bones.length; a++) {
                        let s = i.bones[a]
                                    var u = null
                                    var c = this.getValue(s, 'parent', null)
                        if (c != null && (u = r.findBone(c)) == null) throw new Error(`Parent bone not found: ${  c}`);
                        (d = new Ke(r.bones.length, s.name, u)).length = this.getValue(s, 'length', 0) * n, d.x = this.getValue(s, 'x', 0) * n, d.y = this.getValue(s, 'y', 0) * n, d.rotation = this.getValue(s, 'rotation', 0), d.scaleX = this.getValue(s, 'scaleX', 1), d.scaleY = this.getValue(s, 'scaleY', 1), d.shearX = this.getValue(s, 'shearX', 0), d.shearY = this.getValue(s, 'shearY', 0), d.transformMode = t.transformModeFromString(this.getValue(s, 'transform', 'normal')), r.bones.push(d)
                    }
                }
                if (i.slots) {
                    for (a = 0; a < i.slots.length; a++) {
                        var l = (w = i.slots[a]).name
                                    var h = w.bone
                                    var f = r.findBone(h)
                        if (f == null) throw new Error(`Slot bone not found: ${  h}`)
                        var d = new un(r.slots.length, l, f)
                                    var p = this.getValue(w, 'color', null)
                        null != p && d.color.setFromString(p)
                        var m = this.getValue(w, 'dark', null)
                        null != m && (d.darkColor = new F(1, 1, 1, 1), d.darkColor.setFromString(m)), d.attachmentName = this.getValue(w, 'attachment', null), d.blendMode = t.blendModeFromString(this.getValue(w, 'blend', 'normal')), r.slots.push(d)
                    }
                }
                if (i.ik) {
                    for (a = 0; a < i.ik.length; a++) {
                        var y = i.ik[a];
                        (d = new Qe(y.name)).order = this.getValue(y, 'order', 0)
                        for (var v = 0; v < y.bones.length; v++) {
                            h = y.bones[v]
                            if ((b = r.findBone(h)) == null) throw new Error(`IK bone not found: ${  h}`)
                            d.bones.push(b)
                        }
                        var g = y.target
                        if (d.target = r.findBone(g), d.target == null) throw new Error(`IK target bone not found: ${  g}`)
                        d.bendDirection = this.getValue(y, 'bendPositive', !0) ? 1 : -1, d.mix = this.getValue(y, 'mix', 1), r.ikConstraints.push(d)
                    }
                }
                if (i.transform) {
                    for (a = 0; a < i.transform.length; a++) {
                        y = i.transform[a];
                        (d = new cn(y.name)).order = this.getValue(y, 'order', 0)
                        for (v = 0; v < y.bones.length; v++) {
                            h = y.bones[v]
                            if ((b = r.findBone(h)) == null) throw new Error(`Transform constraint bone not found: ${  h}`)
                            d.bones.push(b)
                        }
                        g = y.target
                        if (d.target = r.findBone(g), d.target == null) throw new Error(`Transform constraint target bone not found: ${  g}`)
                        d.local = this.getValue(y, 'local', !1), d.relative = this.getValue(y, 'relative', !1), d.offsetRotation = this.getValue(y, 'rotation', 0), d.offsetX = this.getValue(y, 'x', 0) * n, d.offsetY = this.getValue(y, 'y', 0) * n, d.offsetScaleX = this.getValue(y, 'scaleX', 0), d.offsetScaleY = this.getValue(y, 'scaleY', 0), d.offsetShearY = this.getValue(y, 'shearY', 0), d.rotateMix = this.getValue(y, 'rotateMix', 1), d.translateMix = this.getValue(y, 'translateMix', 1), d.scaleMix = this.getValue(y, 'scaleMix', 1), d.shearMix = this.getValue(y, 'shearMix', 1), r.transformConstraints.push(d)
                    }
                }
                if (i.path) {
                    for (a = 0; a < i.path.length; a++) {
                        y = i.path[a];
                        (d = new tn(y.name)).order = this.getValue(y, 'order', 0)
                        for (v = 0; v < y.bones.length; v++) {
                            var b
                            h = y.bones[v]
                            if ((b = r.findBone(h)) == null) throw new Error(`Transform constraint bone not found: ${  h}`)
                            d.bones.push(b)
                        }
                        g = y.target
                        if (d.target = r.findSlot(g), d.target == null) throw new Error(`Path target slot not found: ${  g}`)
                        d.positionMode = t.positionModeFromString(this.getValue(y, 'positionMode', 'percent')), d.spacingMode = t.spacingModeFromString(this.getValue(y, 'spacingMode', 'length')), d.rotateMode = t.rotateModeFromString(this.getValue(y, 'rotateMode', 'tangent')), d.offsetRotation = this.getValue(y, 'rotation', 0), d.position = this.getValue(y, 'position', 0), d.positionMode == _.Fixed && (d.position *= n), d.spacing = this.getValue(y, 'spacing', 0), d.spacingMode != Ve.Length && d.spacingMode != Ve.Fixed || (d.spacing *= n), d.rotateMix = this.getValue(y, 'rotateMix', 1), d.translateMix = this.getValue(y, 'translateMix', 1), r.pathConstraints.push(d)
                    }
                }
                if (i.skins) {
                    for (const E in i.skins) {
                        let x = i.skins[E]
                                    var T = new ln(E)
                        for (var l in x) {
                            let S = r.findSlotIndex(l)
                            if (S == -1) throw new Error(`Slot not found: ${  l}`)
                            var w = x[l]
                            for (const O in w) {
                                let P = this.readAttachment(w[O], T, S, O, r)
                                null != P && T.addAttachment(S, O, P)
                            }
                        }
                        r.skins.push(T), T.name == 'default' && (r.defaultSkin = T)
                    }
                }
                a = 0
                for (let R = this.linkedMeshes.length; a < R; a++) {
                    const A = this.linkedMeshes[a]
                    if ((T = A.skin == null ? r.defaultSkin : r.findSkin(A.skin)) == null) throw new Error(`Skin not found: ${ A.skin}`)
                    let I = T.getAttachment(A.slotIndex, A.parent)
                    if (I == null) throw new Error(`Parent mesh not found: ${ A.parent}`)
                    A.mesh.setParentMesh(I)
                }
                if (this.linkedMeshes.length = 0, i.events) {
                    for (const C in i.events) {
                        let k = i.events[C];
                        (d = new $e(C)).intValue = this.getValue(k, 'int', 0), d.floatValue = this.getValue(k, 'float', 0), d.stringValue = this.getValue(k, 'string', ''), d.audioPath = this.getValue(k, 'audio', null), d.audioPath != null && (d.volume = this.getValue(k, 'volume', 1), d.balance = this.getValue(k, 'balance', 0)), r.events.push(d)
                    }
                }
                if (i.animations) {
                    for (const N in i.animations) {
                        let M = i.animations[N]
                        this.readAnimation(M, N, r)
                    }
                }
                return r
            }, t.prototype.readAttachment = function (t, e, n, r, i) {
                const o = this.scale
                switch (r = this.getValue(t, 'name', r), this.getValue(t, 'type', 'region')) {
                    case 'region':
                        var a = this.getValue(t, 'path', r)
                        var s = this.attachmentLoader.newRegionAttachment(e, r, a)
                        return s == null ? null : (s.path = a, s.x = this.getValue(t, 'x', 0) * o, s.y = this.getValue(t, 'y', 0) * o, s.scaleX = this.getValue(t, 'scaleX', 1), s.scaleY = this.getValue(t, 'scaleY', 1), s.rotation = this.getValue(t, 'rotation', 0), s.width = t.width * o, s.height = t.height * o, (g = this.getValue(t, 'color', null)) != null && s.color.setFromString(g), s)
                    case 'boundingbox':
                        var u = this.attachmentLoader.newBoundingBoxAttachment(e, r)
                        return u == null ? null : (this.readVertices(t, u, t.vertexCount << 1), (g = this.getValue(t, 'color', null)) != null && u.color.setFromString(g), u)
                    case 'mesh':
                    case 'linkedmesh':
                        a = this.getValue(t, 'path', r)
                        var c = this.attachmentLoader.newMeshAttachment(e, r, a)
                        if (c == null) return null
                        c.path = a, (g = this.getValue(t, 'color', null)) != null && c.color.setFromString(g)
                        var l = this.getValue(t, 'parent', null)
                        if (l != null) return c.inheritDeform = this.getValue(t, 'deform', !0), this.linkedMeshes.push(new fn(c, this.getValue(t, 'skin', null), n, l)), c
                        var h = t.uvs
                        return this.readVertices(t, c, h.length), c.triangles = t.triangles, c.regionUVs = new Float32Array(h), c.hullLength = 2 * this.getValue(t, 'hull', 0), c
                    case 'path':
                        if ((a = this.attachmentLoader.newPathAttachment(e, r)) == null) return null
                        a.closed = this.getValue(t, 'closed', !1), a.constantSpeed = this.getValue(t, 'constantSpeed', !0)
                        var f = t.vertexCount
                        this.readVertices(t, a, f << 1)
                        for (var d = G.newArray(f / 3, 0), p = 0; p < t.lengths.length; p++) d[p] = t.lengths[p] * o
                        return a.lengths = d, (g = this.getValue(t, 'color', null)) != null && a.color.setFromString(g), a
                    case 'point':
                        var m = this.attachmentLoader.newPointAttachment(e, r)
                        return m == null ? null : (m.x = this.getValue(t, 'x', 0) * o, m.y = this.getValue(t, 'y', 0) * o, m.rotation = this.getValue(t, 'rotation', 0), (g = this.getValue(t, 'color', null)) != null && m.color.setFromString(g), m)
                    case 'clipping':
                        var y = this.attachmentLoader.newClippingAttachment(e, r)
                        if (y == null) return null
                        var v = this.getValue(t, 'end', null)
                        if (v != null) {
                            const _ = i.findSlot(v)
                            if (_ == null) throw new Error(`Clipping end slot not found: ${ v}`)
                            y.endSlot = _
                        }
                        var g
                        f = t.vertexCount
                        return this.readVertices(t, y, f << 1), (g = this.getValue(t, 'color', null)) != null && y.color.setFromString(g), y
                }
                return null
            }, t.prototype.readVertices = function (t, e, n) {
                const r = this.scale
                e.worldVerticesLength = n
                let i = t.vertices
                if (n != i.length) {
                    const o = [];
                    var a = []
                    for (l = 0, h = i.length; l < h;) {
                        const s = i[l++]
                        a.push(s)
                        for (let u = l + 4 * s; l < u; l += 4) a.push(i[l]), o.push(i[l + 1] * r), o.push(i[l + 2] * r), o.push(i[l + 3])
                    }
                    e.bones = a, e.vertices = G.toFloatArray(o)
                } else {
                    const c = G.toFloatArray(i)
                    if (r != 1) {
                        for (var l = 0, h = i.length; l < h; l++) c[l] *= r
                    }
                    e.vertices = c
                }
            }, t.prototype.readAnimation = function (t, e, n) {
                const r = this.scale
                var i = []
                var o = 0
                if (t.slots) {
                    for (var a in t.slots) {
                        var s = t.slots[a]
                        if ((J = n.findSlotIndex(a)) == -1) throw new Error(`Slot not found: ${  a}`)
                        for (var u in s) {
                            var c = s[u]
                            if (u == 'attachment') {
                                (b = new Ce(c.length)).slotIndex = J
                                for (var l = 0, h = 0; h < c.length; h++) {
                                    var f = c[h]
                                    b.setFrame(l++, f.time, f.name)
                                }
                                i.push(b), o = Math.max(o, b.frames[b.getFrameCount() - 1])
                            } else if (u == 'color') {
                                (b = new Ae(c.length)).slotIndex = J
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    var d = new F()
                                    d.setFromString(f.color || 'ffffffff'), b.setFrame(l, f.time, d.r, d.g, d.b, d.a), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Ae.ENTRIES])
                            } else {
                                if (u != 'twoColor') throw new Error(`Invalid timeline type for a slot: ${  u  } (${  a  })`);
                                (b = new Ie(c.length)).slotIndex = J
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    var p = new F();
                                        var m = new F()
                                    p.setFromString(f.light), m.setFromString(f.dark), b.setFrame(l, f.time, p.r, p.g, p.b, p.a, m.r, m.g, m.b), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Ie.ENTRIES])
                            }
                        }
                    }
                }
                if (t.bones) {
                    for (const y in t.bones) {
                        let v = t.bones[y]
                                    var g = n.findBoneIndex(y)
                        if (g == -1) throw new Error(`Bone not found: ${  y}`)
                        for (var u in v) {
                            c = v[u]
                            if (u === 'rotate') {
                                (b = new we(c.length)).boneIndex = g
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    b.setFrame(l, f.time, f.angle), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * we.ENTRIES])
                            } else {
                                if (u !== 'translate' && u !== 'scale' && u !== 'shear') throw new Error(`Invalid timeline type for a bone: ${  u  } (${  y  })`);
                                var b = null
                                            var E = 1
                                "scale" === u ? b = new Pe(c.length) : u === 'shear' ? b = new Re(c.length) : (b = new Oe(c.length), E = r), b.boneIndex = g
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    var x = this.getValue(f, 'x', 0)
                                                var T = this.getValue(f, 'y', 0)
                                    b.setFrame(l, f.time, x * E, T * E), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Oe.ENTRIES])
                            }
                        }
                    }
                }
                if (t.ik) {
                    for (var S in t.ik) {
                        var w = t.ik[S]
                                    var O = n.findIkConstraint(S);
                        (b = new De(w.length)).ikConstraintIndex = n.ikConstraints.indexOf(O)
                        for (l = 0, h = 0; h < w.length; h++) {
                            f = w[h]
                            b.setFrame(l, f.time, this.getValue(f, 'mix', 1), this.getValue(f, 'bendPositive', !0) ? 1 : -1, this.getValue(f, 'compress', !1), this.getValue(f, 'stretch', !1)), this.readCurve(f, b, l), l++
                        }
                        i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * De.ENTRIES])
                    }
                }
                if (t.transform) {
                    for (var S in t.transform) {
                        w = t.transform[S], O = n.findTransformConstraint(S);
                        (b = new Le(w.length)).transformConstraintIndex = n.transformConstraints.indexOf(O)
                        for (l = 0, h = 0; h < w.length; h++) {
                            f = w[h]
                            b.setFrame(l, f.time, this.getValue(f, 'rotateMix', 1), this.getValue(f, 'translateMix', 1), this.getValue(f, 'scaleMix', 1), this.getValue(f, 'shearMix', 1)), this.readCurve(f, b, l), l++
                        }
                        i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Le.ENTRIES])
                    }
                }
                if (t.paths) {
                    for (var S in t.paths) {
                        w = t.paths[S]
                        var P = n.findPathConstraintIndex(S)
                        if (P == -1) throw new Error(`Path constraint not found: ${  S}`)
                        var R = n.pathConstraints[P]
                        for (var u in w) {
                            c = w[u]
                            if (u === 'position' || u === 'spacing') {
                                b = null, E = 1
                                "spacing" === u ? (b = new Be(c.length), R.spacingMode != Ve.Length && R.spacingMode != Ve.Fixed || (E = r)) : (b = new Fe(c.length), R.positionMode == _.Fixed && (E = r)), b.pathConstraintIndex = P
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    b.setFrame(l, f.time, this.getValue(f, u, 0) * E), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Fe.ENTRIES])
                            } else if (u === 'mix') {
                                (b = new Ue(c.length)).pathConstraintIndex = P
                                for (l = 0, h = 0; h < c.length; h++) {
                                    f = c[h]
                                    b.setFrame(l, f.time, this.getValue(f, 'rotateMix', 1), this.getValue(f, 'translateMix', 1)), this.readCurve(f, b, l), l++
                                }
                                i.push(b), o = Math.max(o, b.frames[(b.getFrameCount() - 1) * Ue.ENTRIES])
                            }
                        }
                    }
                }
                if (t.deform) {
                    for (const A in t.deform) {
                        let I = t.deform[A]
                                    var C = n.findSkin(A)
                        if (C != null) {
                            for (var a in I) {
                                s = I[a]
                                        if ((J = n.findSlotIndex(a)) == -1) throw new Error('Slot not found: ' + s.name)
                                        for (var u in s) {
                                    c = s[u]
                                            var k = C.getAttachment(J, u)
                                            if (k == null) throw new Error('Deform attachment not found: ' + c.name)
                                            var N = k.bones != null,
                                        M = k.vertices,
                                        j = N ? M.length / 3 * 2 : M.length;
                                    (b = new Ne(c.length)).slotIndex = J, b.attachment = k
                                            l = 0
                                            for (var D = 0; D < c.length; D++) {
                                        f = c[D]
                                                var L = void 0;
                                                    var B = this.getValue(f, 'vertices', null)
                                                if (B == null) { L = N ? G.newFloatArray(j) : M;
}
                                        else {
                                            L = G.newFloatArray(j)
                                                    var U = this.getValue(f, 'offset', 0)
                                                    if (G.arrayCopy(B, 0, L, U, B.length), r != 1) {
                                                        for (var X = (h = U) + B.length; h < X; h++) L[h] *= r;
}
                                            if (!N) {
                                                        for (h = 0; h < j; h++) L[h] += M[h]
}
                                        }
                                        b.setFrame(l, f.time, L), this.readCurve(f, b, l), l++
                                    }
                                    i.push(b), o = Math.max(o, b.frames[b.getFrameCount() - 1])
                                }
                            }
                        } else if (W) { throw new Error('Skin not found: ' + A)
                        }
                    }
                }
                let H = t.drawOrder
                if (H == null && (H = t.draworder), H != null) {
                    b = new je(H.length)
                    let V = n.slots.length
                    for (l = 0, D = 0; D < H.length; D++) {
                        const Y = H[D]
                        var z = null
                        var q = this.getValue(Y, 'offsets', null)
                        if (q != null) {
                            z = G.newArray(V, -1)
                            let K = G.newArray(V - q.length, 0)
                            var Z = 0
                            var $ = 0
                            for (h = 0; h < q.length; h++) {
                                var J; const Q = q[h]
                                if ((J = n.findSlotIndex(Q.slot)) == -1) throw new Error(`Slot not found: ${ Q.slot}`)
                                for (; Z != J;) K[$++] = Z++
                                z[Z + Q.offset] = Z++
                            }
                            for (; Z < V;) K[$++] = Z++
                            for (h = V - 1; h >= 0; h--) z[h] == -1 && (z[h] = K[--$])
                        }
                        b.setFrame(l++, Y.time, z)
                    }
                    i.push(b), o = Math.max(o, b.frames[b.getFrameCount() - 1])
                }
                if (t.events) {
                    for (b = new Me(t.events.length), l = 0, h = 0; h < t.events.length; h++) {
                        const tt = t.events[h]
                        var et = n.findEvent(tt.name)
                        if (et == null) throw new Error(`Event not found: ${ tt.name}`)
                        let nt = new Ze(G.toSinglePrecision(tt.time), et)
                        nt.intValue = this.getValue(tt, 'int', et.intValue), nt.floatValue = this.getValue(tt, 'float', et.floatValue), nt.stringValue = this.getValue(tt, 'string', et.stringValue), nt.data.audioPath != null && (nt.volume = this.getValue(tt, 'volume', 1), nt.balance = this.getValue(tt, 'balance', 0)), b.setFrame(l++, nt)
                    }
                    i.push(b), o = Math.max(o, b.frames[b.getFrameCount() - 1])
                }
                if (isNaN(o)) throw new Error('Error while parsing animation, duration is NaN')
                n.animations.push(new xe(e, i, o))
            }, t.prototype.readCurve = function (t, e, n) {
                if (t.curve) {
                    if (t.curve === 'stepped') { e.setStepped(n)
}
                    else if (Object.prototype.toString.call(t.curve) === '[object Array]') {
                        let r = t.curve
                        e.setCurve(n, r[0], r[1], r[2], r[3])
                    }
                }
            }, t.prototype.getValue = function (t, e, n) {
                return void 0 !== t[e] ? t[e] : n
            }, t.blendModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'normal') return c.b.NORMAL
                if (t == 'additive') return c.b.ADD
                if (t == 'multiply') return c.b.MULTIPLY
                if (t == 'screen') return c.b.SCREEN
                throw new Error(`Unknown blend mode: ${ t}`)
            }, t.positionModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'fixed') return _.Fixed
                if (t == 'percent') return _.Percent
                throw new Error(`Unknown position mode: ${ t}`)
            }, t.spacingModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'length') return Ve.Length
                if (t == 'fixed') return Ve.Fixed
                if (t == 'percent') return Ve.Percent
                throw new Error(`Unknown position mode: ${ t}`)
            }, t.rotateModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'tangent') return g.Tangent
                if (t == 'chain') return g.Chain
                if (t == 'chainscale') return g.ChainScale
                throw new Error(`Unknown rotate mode: ${ t}`)
            }, t.transformModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'normal') return b.Normal
                if (t == 'onlytranslation') return b.OnlyTranslation
                if (t == 'norotationorreflection') return b.NoRotationOrReflection
                if (t == 'noscale') return b.NoScale
                if (t == 'noscaleorreflection') return b.NoScaleOrReflection
                throw new Error(`Unknown transform mode: ${ t}`)
            }, t
        }())
        var fn = function (t, e, n, r) {
            this.mesh = t, this.skin = e, this.slotIndex = n, this.parent = r
        }
        var dn = (function (t) {
            function e() {
                return t !== null && t.apply(this, arguments) || this
            }
            return le(e, t), e.prototype.createSkeleton = function (t) {
                this.skeleton = new on(t), this.skeleton.updateWorldTransform(), this.stateData = new Ye(t), this.state = new Ge(this.stateData)
            }, e
        }($))
        let pn = function (t, e) {
            return (pn = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            })(t, e)
        }

        function mn(t, e) {
            if (typeof e != 'function' && e !== null) throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`)

            function n() {
                this.constructor = t
            }
            pn(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        let yn; var vn = function (t) {
            if (!t) throw new Error('name cannot be null.')
            this.name = t
        }
        var _n = (function (t) {
            function e(n) {
                const r = t.call(this, n) || this
                return r.id = e.nextID++, r.worldVerticesLength = 0, r.deformAttachment = r, r
            }
            return mn(e, t), e.prototype.computeWorldVerticesOld = function (t, e) {
                this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
            }, e.prototype.computeWorldVertices = function (t, e, n, r, i, o) {
                n = i + (n >> 1) * o
                let a = t.bone.skeleton
                var s = t.deform
                var u = this.vertices
                var c = this.bones
                if (c) {
                    for (var l = 0, h = 0, f = 0; f < e; f += 2) {
                        l += (y = c[l]) + 1, h += y
                    }
                    const d = a.bones
                    if (s.length == 0) {
                        for (R = i, S = 3 * h; R < n; R += o) {
                            var p = 0
                                        var m = 0
                                        var y = c[l++]
                            for (y += l; l < y; l++, S += 3) {
                                b = d[c[l]].matrix, A = u[S], I = u[S + 1]
                                var v = u[S + 2]
                                p += (A * b.a + I * b.c + b.tx) * v, m += (A * b.b + I * b.d + b.ty) * v
                            }
                            r[R] = p, r[R + 1] = m
                        }
                    } else {
                        for (let _ = s, g = (R = i, S = 3 * h, h << 1); R < n; R += o) {
                            p = 0, m = 0, y = c[l++]
                            for (y += l; l < y; l++, S += 3, g += 2) {
                                b = d[c[l]].matrix, A = u[S] + _[g], I = u[S + 1] + _[g + 1], v = u[S + 2]
                                p += (A * b.a + I * b.c + b.tx) * v, m += (A * b.b + I * b.d + b.ty) * v
                            }
                            r[R] = p, r[R + 1] = m
                        }
                    }
                } else {
                    s.length > 0 && (u = s)
                    for (var b, E = (b = t.bone.matrix).tx, x = b.ty, T = b.a, S = b.c, w = b.b, O = b.d, P = e, R = i; R < n; P += 2, R += o) {
                        var A = u[P]
                        var I = u[P + 1]
                        r[R] = A * T + I * S + E, r[R + 1] = A * w + I * O + x
                    }
                }
            }, e.prototype.copyTo = function (t) {
                this.bones ? (t.bones = Array.from({ length: this.bones.length }), G.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length)) : t.bones = null, this.vertices ? (t.vertices = G.newFloatArray(this.vertices.length), G.arrayCopy(this.vertices, 0, t.vertices, 0, this.vertices.length)) : t.vertices = null, t.worldVerticesLength = this.worldVerticesLength, t.deformAttachment = this.deformAttachment
            }, e.nextID = 0, e
        }(vn))
        var gn = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.BoundingBox, n.color = new F(1, 1, 1, 1), n
            }
            return mn(e, t), e.prototype.copy = function () {
                const t = new e(this.name)
                return this.copyTo(t), t.color.setFromColor(this.color), t
            }, e
        }(_n))
        var bn = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Clipping, n.color = new F(0.2275, 0.2275, 0.8078, 1), n
            }
            return mn(e, t), e.prototype.copy = function () {
                const t = new e(this.name)
                return this.copyTo(t), t.endSlot = this.endSlot, t.color.setFromColor(this.color), t
            }, e
        }(_n))
        var En = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Mesh, n.color = new F(1, 1, 1, 1), n.tempColor = new F(0, 0, 0, 0), n
            }
            return mn(e, t), e.prototype.getParentMesh = function () {
                return this.parentMesh
            }, e.prototype.setParentMesh = function (t) {
                this.parentMesh = t, t && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength)
            }, e.prototype.copy = function () {
                if (this.parentMesh) return this.newLinkedMesh()
                let t = new e(this.name)
                return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), this.copyTo(t), t.regionUVs = new Float32Array(this.regionUVs.length), G.arrayCopy(this.regionUVs, 0, t.regionUVs, 0, this.regionUVs.length), t.triangles = Array.from({ length: this.triangles.length }), G.arrayCopy(this.triangles, 0, t.triangles, 0, this.triangles.length), t.hullLength = this.hullLength, this.edges && (t.edges = Array.from({ length: this.edges.length }), G.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)), t.width = this.width, t.height = this.height, t
            }, e.prototype.newLinkedMesh = function () {
                const t = new e(this.name)
                return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), t.deformAttachment = this.deformAttachment, t.setParentMesh(this.parentMesh ? this.parentMesh : this), t
            }, e
        }(_n))
        var xn = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Path, n.closed = !1, n.constantSpeed = !1, n.color = new F(1, 1, 1, 1), n
            }
            return mn(e, t), e.prototype.copy = function () {
                const t = new e(this.name)
                return this.copyTo(t), t.lengths = Array.from({ length: this.lengths.length }), G.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length), t.closed = closed, t.constantSpeed = this.constantSpeed, t.color.setFromColor(this.color), t
            }, e
        }(_n))
        var Tn = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Point, n.color = new F(0.38, 0.94, 0, 1), n
            }
            return mn(e, t), e.prototype.computeWorldPosition = function (t, e) {
                const n = t.matrix
                return e.x = this.x * n.a + this.y * n.c + t.worldX, e.y = this.x * n.b + this.y * n.d + t.worldY, e
            }, e.prototype.computeWorldRotation = function (t) {
                const e = t.matrix
                var n = B.cosDeg(this.rotation)
                var r = B.sinDeg(this.rotation)
                var i = n * e.a + r * e.c
                var o = n * e.b + r * e.d
                return Math.atan2(o, i) * B.radDeg
            }, e.prototype.copy = function () {
                const t = new e(this.name)
                return t.x = this.x, t.y = this.y, t.rotation = this.rotation, t.color.setFromColor(this.color), t
            }, e
        }(_n))
        var Sn = (function (t) {
            function e(e) {
                const n = t.call(this, e) || this
                return n.type = a.Region, n.x = 0, n.y = 0, n.scaleX = 1, n.scaleY = 1, n.rotation = 0, n.width = 0, n.height = 0, n.color = new F(1, 1, 1, 1), n.offset = G.newFloatArray(8), n.uvs = G.newFloatArray(8), n.tempColor = new F(1, 1, 1, 1), n
            }
            return mn(e, t), e.prototype.updateOffset = function () {
                const t = this.width / this.region.originalWidth * this.scaleX
                var n = this.height / this.region.originalHeight * this.scaleY
                var r = -this.width / 2 * this.scaleX + this.region.offsetX * t
                var i = -this.height / 2 * this.scaleY + this.region.offsetY * n
                var o = r + this.region.width * t
                var a = i + this.region.height * n
                var s = this.rotation * Math.PI / 180
                var u = Math.cos(s)
                var c = Math.sin(s)
                var l = r * u + this.x
                var h = r * c
                var f = i * u + this.y
                var d = i * c
                var p = o * u + this.x
                var m = o * c
                var y = a * u + this.y
                var v = a * c
                var _ = this.offset
                _[e.OX1] = l - d, _[e.OY1] = f + h, _[e.OX2] = l - v, _[e.OY2] = y + h, _[e.OX3] = p - v, _[e.OY3] = y + m, _[e.OX4] = p - d, _[e.OY4] = f + m
            }, e.prototype.setRegion = function (t) {
                this.region = t
                let e = this.uvs
                t.degrees == 90 ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2)
            }, e.prototype.computeWorldVertices = function (t, n, r, i) {
                const o = this.offset
                var a = t.matrix
                var s = a.tx
                var u = a.ty
                var c = a.a
                var l = a.c
                var h = a.b
                var f = a.d
                var d = 0
                var p = 0
                d = o[e.OX1], p = o[e.OY1], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX2], p = o[e.OY2], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX3], p = o[e.OY3], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u, r += i, d = o[e.OX4], p = o[e.OY4], n[r] = d * c + p * l + s, n[r + 1] = d * h + p * f + u
            }, e.prototype.copy = function () {
                const t = new e(this.name)
                return t.region = this.region, t.rendererObject = this.rendererObject, t.path = this.path, t.x = this.x, t.y = this.y, t.scaleX = this.scaleX, t.scaleY = this.scaleY, t.rotation = this.rotation, t.width = this.width, t.height = this.height, G.arrayCopy(this.uvs, 0, t.uvs, 0, 8), G.arrayCopy(this.offset, 0, t.offset, 0, 8), t.color.setFromColor(this.color), t
            }, e.OX1 = 0, e.OY1 = 1, e.OX2 = 2, e.OY2 = 3, e.OX3 = 4, e.OY3 = 5, e.OX4 = 6, e.OY4 = 7, e.X1 = 0, e.Y1 = 1, e.C1R = 2, e.C1G = 3, e.C1B = 4, e.C1A = 5, e.U1 = 6, e.V1 = 7, e.X2 = 8, e.Y2 = 9, e.C2R = 10, e.C2G = 11, e.C2B = 12, e.C2A = 13, e.U2 = 14, e.V2 = 15, e.X3 = 16, e.Y3 = 17, e.C3R = 18, e.C3G = 19, e.C3B = 20, e.C3A = 21, e.U3 = 22, e.V3 = 23, e.X4 = 24, e.Y4 = 25, e.C4R = 26, e.C4G = 27, e.C4B = 28, e.C4A = 29, e.U4 = 30, e.V4 = 31, e
        }(vn))
        var wn = (function () {
            function t(t, e) {
                this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e
            }
            return t.prototype.begin = function (t) {}, t.prototype.transform = function (t, e, n, r) {
                t.x += B.randomTriangular(-this.jitterX, this.jitterY), t.y += B.randomTriangular(-this.jitterX, this.jitterY)
            }, t.prototype.end = function () {}, t
        }())
        var On = (function () {
            function t(t) {
                this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t
            }
            return t.prototype.begin = function (t) {
                this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY
            }, t.prototype.transform = function (e, n, r, i) {
                const o = this.angle * B.degreesToRadians
                var a = e.x - this.worldX
                var s = e.y - this.worldY
                var u = Math.sqrt(a * a + s * s)
                if (u < this.radius) {
                    const c = t.interpolation.apply(0, o, (this.radius - u) / this.radius)
                    var l = Math.cos(c)
                    var h = Math.sin(c)
                    e.x = l * a - h * s + this.worldX, e.y = h * a + l * s + this.worldY
                }
            }, t.prototype.end = function () {}, t.interpolation = new U(2), t
        }())
        var Pn = (function () {
            function t(t, e, n) {
                if (!t) throw new Error('name cannot be null.')
                this.name = t, this.setTimelines(e), this.duration = n
            }
            return t.prototype.setTimelines = function (t) {
                if (!t) throw new Error('timelines cannot be null.')
                this.timelines = t, this.timelineIds = new L()
                for (let e = 0; e < t.length; e++) this.timelineIds.addAll(t[e].getPropertyIds())
            }, t.prototype.hasTimeline = function (t) {
                for (let e = 0; e < t.length; e++) {
                    if (this.timelineIds.contains(t[e])) return !0
                }
                return !1
            }, t.prototype.apply = function (t, e, n, r, i, o, a, s) {
                if (!t) throw new Error('skeleton cannot be null.')
                r && this.duration != 0 && (n %= this.duration, e > 0 && (e %= this.duration))
                for (let u = this.timelines, c = 0, l = u.length; c < l; c++) u[c].apply(t, e, n, i, o, a, s)
            }, t
        }())
        const Rn = 0
        const An = 1
        const In = 2
        const Cn = 3
        const kn = 4
        const Nn = 5
        const Mn = 6
        const jn = 7
        const Dn = 8
        const Ln = 9
        const Fn = 10
        const Bn = 11
        const Un = 12
        const Gn = 13
        const Xn = 14
        const Hn = 15
        const Vn = 16
        const Wn = 17
        const Yn = 18
        var zn = (function () {
            function t(t, e) {
                this.propertyIds = e, this.frames = G.newFloatArray(t * this.getFrameEntries())
            }
            return t.prototype.getPropertyIds = function () {
                return this.propertyIds
            }, t.prototype.getFrameEntries = function () {
                return 1
            }, t.prototype.getFrameCount = function () {
                return this.frames.length / this.getFrameEntries()
            }, t.prototype.getDuration = function () {
                return this.frames[this.frames.length - this.getFrameEntries()]
            }, t.search1 = function (t, e) {
                for (var n = t.length, r = 1; r < n; r++) {
                    if (t[r] > e) return r - 1
                }
                return n - 1
            }, t.search = function (t, e, n) {
                for (var r = t.length, i = n; i < r; i += n) {
                    if (t[i] > e) return i - n
                }
                return r - n
            }, t
        }())
        var qn = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, r) || this
                return i.curves = G.newFloatArray(e + 18 * n), i.curves[e - 1] = 1, i
            }
            return mn(e, t), e.prototype.setLinear = function (t) {
                this.curves[t] = 0
            }, e.prototype.setStepped = function (t) {
                this.curves[t] = 1
            }, e.prototype.shrink = function (t) {
                const e = this.getFrameCount() + 18 * t
                if (this.curves.length > e) {
                    const n = G.newFloatArray(e)
                    G.arrayCopy(this.curves, 0, n, 0, e), this.curves = n
                }
            }, e.prototype.setBezier = function (t, e, n, r, i, o, a, s, u, c, l) {
                const h = this.curves
                var f = this.getFrameCount() + 18 * t
                n == 0 && (h[e] = 2 + f)
                for (let d = 0.03 * (r - 2 * o + s), p = 0.03 * (i - 2 * a + u), m = 0.006 * (3 * (o - s) - r + c), y = 0.006 * (3 * (a - u) - i + l), v = 2 * d + m, _ = 2 * p + y, g = 0.3 * (o - r) + d + 0.16666667 * m, b = 0.3 * (a - i) + p + 0.16666667 * y, E = r + g, x = i + b, T = f + 18; f < T; f += 2) h[f] = E, h[f + 1] = x, g += v, b += _, v += m, _ += y, E += g, x += b
            }, e.prototype.getBezierValue = function (t, e, n, r) {
                const i = this.curves
                if (i[r] > t) {
                    const o = this.frames[e]
                    var a = this.frames[e + n]
                    return a + (t - o) / (i[r] - o) * (i[r + 1] - a)
                }
                const s = r + 18
                for (r += 2; r < s; r += 2) {
                    if (i[r] >= t) {
                        let u = i[r - 2]
                                    var c = i[r - 1]
                        return c + (t - u) / (i[r] - u) * (i[r + 1] - c)
                    }
                }
                e += this.getFrameEntries()
                let l = i[s - 2]
                var h = i[s - 1]
                return h + (t - l) / (this.frames[e] - l) * (this.frames[e + n] - h)
            }, e
        }(zn))
        var Kn = (function (t) {
            function e(e, n, r) {
                return t.call(this, e, n, [r]) || this
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 2
            }, e.prototype.setFrame = function (t, e, n) {
                t <<= 1, this.frames[t] = e, this.frames[t + 1] = n
            }, e.prototype.getCurveValue = function (t) {
                for (var e = this.frames, n = e.length - 2, r = 2; r <= n; r += 2) {
                    if (e[r] > t) {
                        n = r - 2
                        break
                    }
                }
                const i = this.curves[n >> 1]
                switch (i) {
                    case 0:
                        var o = e[n]
                        var a = e[n + 1]
                        return a + (t - o) / (e[n + 2] - o) * (e[n + 2 + 1] - a)
                    case 1:
                        return e[n + 1]
                }
                return this.getBezierValue(t, n, 1, i - 2)
            }, e
        }(qn))
        var Zn = (function (t) {
            function e(e, n, r, i) {
                return t.call(this, e, n, [r, i]) || this
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 3
            }, e.prototype.setFrame = function (t, e, n, r) {
                t *= 3, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r
            }, e
        }(qn))
        var $n = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Rn }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.rotation = s.data.rotation)
                                case y.first:
                            s.rotation += (s.data.rotation - s.rotation) * i
                    }
                    } else {
                        let u = this.getCurveValue(n)
                        switch (o) {
                            case y.setup:
                                s.rotation = s.data.rotation + u * i
                                break;
                            case y.first:
                            case y.replace:
                                u += s.data.rotation - s.rotation
                            case y.add:
                                s.rotation += u * i
                        }
                    }
                }
            }, e
        }(Kn))
        var Jn = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${An }|${ r}`, `${In }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    const u = this.frames
                    if (n < u[0]) { switch (o) {
                        case y.setup:
                            return s.x = s.data.x, void (s.y = s.data.y)
                        case y.first:
                            s.x += (s.data.x - s.x) * i, s.y += (s.data.y - s.y) * i
                    }
                    } else {
                        let c = 0
                        var l = 0
                        var h = zn.search(u, n, 3)
                        var f = this.curves[h / 3]
                        switch (f) {
                            case 0:
                                var d = u[h]
                                c = u[h + 1], l = u[h + 2]
                                var p = (n - d) / (u[h + 3] - d)
                                c += (u[h + 3 + 1] - c) * p, l += (u[h + 3 + 2] - l) * p
                                break
                            case 1:
                                c = u[h + 1], l = u[h + 2]
                                break
                            default:
                                c = this.getBezierValue(n, h, 1, f - 2), l = this.getBezierValue(n, h, 2, f + 18 - 2)
                        }
                        switch (o) {
                            case y.setup:
                                s.x = s.data.x + c * i, s.y = s.data.y + l * i
                                break
                            case y.first:
                            case y.replace:
                                s.x += (s.data.x + c - s.x) * i, s.y += (s.data.y + l - s.y) * i
                                break
                            case y.add:
                                s.x += c * i, s.y += l * i
                        }
                    }
                }
            }, e
        }(Zn))
        var Qn = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${An }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.x = s.data.x)
                                case y.first:
                            s.x += (s.data.x - s.x) * i
                    }
                    } else {
                        let u = this.getCurveValue(n)
                        switch (o) {
                            case y.setup:
                                s.x = s.data.x + u * i
                                break;
                            case y.first:
                            case y.replace:
                                s.x += (s.data.x + u - s.x) * i
                                break;
                            case y.add:
                                s.x += u * i
                        }
                    }
                }
            }, e
        }(Kn))
        var tr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${In }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.y = s.data.y)
                                case y.first:
                            s.y += (s.data.y - s.y) * i
                    }
                    } else {
                        let u = this.getCurveValue(n)
                        switch (o) {
                            case y.setup:
                                s.y = s.data.y + u * i
                                break;
                            case y.first:
                            case y.replace:
                                s.y += (s.data.y + u - s.y) * i
                                break;
                            case y.add:
                                s.y += u * i
                        }
                    }
                }
            }, e
        }(Kn))
        var er = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Cn }|${ r}`, `${kn }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    const u = this.frames
                    if (n < u[0]) { switch (o) {
                        case y.setup:
                            return s.scaleX = s.data.scaleX, void (s.scaleY = s.data.scaleY)
                        case y.first:
                            s.scaleX += (s.data.scaleX - s.scaleX) * i, s.scaleY += (s.data.scaleY - s.scaleY) * i
                    }
                    } else {
                        let c; let l; const h = zn.search(u, n, 3)
                        var f = this.curves[h / 3]
                        switch (f) {
                            case 0:
                                var d = u[h]
                                c = u[h + 1], l = u[h + 2]
                                var p = (n - d) / (u[h + 3] - d)
                                c += (u[h + 3 + 1] - c) * p, l += (u[h + 3 + 2] - l) * p
                                break
                            case 1:
                                c = u[h + 1], l = u[h + 2]
                                break
                            default:
                                c = this.getBezierValue(n, h, 1, f - 2), l = this.getBezierValue(n, h, 2, f + 18 - 2)
                        }
                        if (c *= s.data.scaleX, l *= s.data.scaleY, i == 1) { o == y.add ? (s.scaleX += c - s.data.scaleX, s.scaleY += l - s.data.scaleY) : (s.scaleX = c, s.scaleY = l)
                        }
                        else {
                            let m = 0
                            var _ = 0
                            if (a == v.mixOut) { switch (o) {
                                case y.setup:
                                    m = s.data.scaleX, _ = s.data.scaleY, s.scaleX = m + (Math.abs(c) * B.signum(m) - m) * i, s.scaleY = _ + (Math.abs(l) * B.signum(_) - _) * i
                                    break;
                                case y.first:
                                case y.replace:
                                    m = s.scaleX, _ = s.scaleY, s.scaleX = m + (Math.abs(c) * B.signum(m) - m) * i, s.scaleY = _ + (Math.abs(l) * B.signum(_) - _) * i
                                    break;
                                case y.add:
                                    m = s.scaleX, _ = s.scaleY, s.scaleX = m + (Math.abs(c) * B.signum(m) - s.data.scaleX) * i, s.scaleY = _ + (Math.abs(l) * B.signum(_) - s.data.scaleY) * i
                            }
                            } else { switch (o) {
                                case y.setup:
                                    m = Math.abs(s.data.scaleX) * B.signum(c), _ = Math.abs(s.data.scaleY) * B.signum(l), s.scaleX = m + (c - m) * i, s.scaleY = _ + (l - _) * i
                                    break;
                                case y.first:
                                case y.replace:
                                    m = Math.abs(s.scaleX) * B.signum(c), _ = Math.abs(s.scaleY) * B.signum(l), s.scaleX = m + (c - m) * i, s.scaleY = _ + (l - _) * i
                                    break;
                                case y.add:
                                    m = B.signum(c), _ = B.signum(l), s.scaleX = Math.abs(s.scaleX) * m + (c - Math.abs(s.data.scaleX) * m) * i, s.scaleY = Math.abs(s.scaleY) * _ + (l - Math.abs(s.data.scaleY) * _) * i
                            }
                            }
                        }
                    }
                }
            }, e
        }(Zn))
        var nr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Cn }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.scaleX = s.data.scaleX)
                                case y.first:
                            s.scaleX += (s.data.scaleX - s.scaleX) * i
                    }
                    } else {
                        let u = this.getCurveValue(n) * s.data.scaleX
                        if (i == 1) { o == y.add ? s.scaleX += u - s.data.scaleX : s.scaleX = u
}
                        else {
                            let c = 0
                            if (a == v.mixOut) { switch (o) {
                                case y.setup:
                                    c = s.data.scaleX, s.scaleX = c + (Math.abs(u) * B.signum(c) - c) * i
                                            break;
                                case y.first:
                                case y.replace:
                                    c = s.scaleX, s.scaleX = c + (Math.abs(u) * B.signum(c) - c) * i
                                            break;
                                case y.add:
                                    c = s.scaleX, s.scaleX = c + (Math.abs(u) * B.signum(c) - s.data.scaleX) * i
                            }
                            } else { switch (o) {
                                case y.setup:
                                    c = Math.abs(s.data.scaleX) * B.signum(u), s.scaleX = c + (u - c) * i
                                            break;
                                case y.first:
                                case y.replace:
                                    c = Math.abs(s.scaleX) * B.signum(u), s.scaleX = c + (u - c) * i
                                            break;
                                case y.add:
                                    c = B.signum(u), s.scaleX = Math.abs(s.scaleX) * c + (u - Math.abs(s.data.scaleX) * c) * i
                            }
                            }
                        }
                    }
                }
            }, e
        }(Kn))
        var rr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${kn }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.scaleY = s.data.scaleY)
                                case y.first:
                            s.scaleY += (s.data.scaleY - s.scaleY) * i
                    }
                    } else {
                        let u = this.getCurveValue(n) * s.data.scaleY
                        if (i == 1) { o == y.add ? s.scaleY += u - s.data.scaleY : s.scaleY = u
}
                        else {
                            let c = 0
                            if (a == v.mixOut) { switch (o) {
                                case y.setup:
                                    c = s.data.scaleY, s.scaleY = c + (Math.abs(u) * B.signum(c) - c) * i
                                            break;
                                case y.first:
                                case y.replace:
                                    c = s.scaleY, s.scaleY = c + (Math.abs(u) * B.signum(c) - c) * i
                                            break;
                                case y.add:
                                    c = s.scaleY, s.scaleY = c + (Math.abs(u) * B.signum(c) - s.data.scaleY) * i
                            }
                            } else { switch (o) {
                                case y.setup:
                                    c = Math.abs(s.data.scaleY) * B.signum(u), s.scaleY = c + (u - c) * i
                                            break;
                                case y.first:
                                case y.replace:
                                    c = Math.abs(s.scaleY) * B.signum(u), s.scaleY = c + (u - c) * i
                                            break;
                                case y.add:
                                    c = B.signum(u), s.scaleY = Math.abs(s.scaleY) * c + (u - Math.abs(s.data.scaleY) * c) * i
                            }
                            }
                        }
                    }
                }
            }, e
        }(Kn))
        var ir = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Nn }|${ r}`, `${Mn }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    const u = this.frames
                    if (n < u[0]) { switch (o) {
                        case y.setup:
                            return s.shearX = s.data.shearX, void (s.shearY = s.data.shearY)
                        case y.first:
                            s.shearX += (s.data.shearX - s.shearX) * i, s.shearY += (s.data.shearY - s.shearY) * i
                    }
                    } else {
                        let c = 0
                        var l = 0
                        var h = zn.search(u, n, 3)
                        var f = this.curves[h / 3]
                        switch (f) {
                            case 0:
                                var d = u[h]
                                c = u[h + 1], l = u[h + 2]
                                var p = (n - d) / (u[h + 3] - d)
                                c += (u[h + 3 + 1] - c) * p, l += (u[h + 3 + 2] - l) * p
                                break
                            case 1:
                                c = u[h + 1], l = u[h + 2]
                                break
                            default:
                                c = this.getBezierValue(n, h, 1, f - 2), l = this.getBezierValue(n, h, 2, f + 18 - 2)
                        }
                        switch (o) {
                            case y.setup:
                                s.shearX = s.data.shearX + c * i, s.shearY = s.data.shearY + l * i
                                break
                            case y.first:
                            case y.replace:
                                s.shearX += (s.data.shearX + c - s.shearX) * i, s.shearY += (s.data.shearY + l - s.shearY) * i
                                break
                            case y.add:
                                s.shearX += c * i, s.shearY += l * i
                        }
                    }
                }
            }, e
        }(Zn))
        var or = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Nn }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.shearX = s.data.shearX)
                                case y.first:
                            s.shearX += (s.data.shearX - s.shearX) * i
                    }
                    } else {
                        let u = this.getCurveValue(n)
                        switch (o) {
                            case y.setup:
                                s.shearX = s.data.shearX + u * i
                                break;
                            case y.first:
                            case y.replace:
                                s.shearX += (s.data.shearX + u - s.shearX) * i
                                break;
                            case y.add:
                                s.shearX += u * i
                        }
                    }
                }
            }, e
        }(Kn))
        var ar = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Mn }|${ r}`) || this
                return i.boneIndex = 0, i.boneIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.bones[this.boneIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.shearY = s.data.shearY)
                                case y.first:
                            s.shearY += (s.data.shearY - s.shearY) * i
                    }
                    } else {
                        let u = this.getCurveValue(n)
                        switch (o) {
                            case y.setup:
                                s.shearY = s.data.shearY + u * i
                                break;
                            case y.first:
                            case y.replace:
                                s.shearY += (s.data.shearY + u - s.shearY) * i
                                break;
                            case y.add:
                                s.shearY += u * i
                        }
                    }
                }
            }, e
        }(Kn))
        var sr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, [`${jn }|${ r}`, `${Dn }|${ r}`]) || this
                return i.slotIndex = 0, i.slotIndex = r, i
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 5
            }, e.prototype.setFrame = function (t, e, n, r, i, o) {
                t *= 5, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r, this.frames[t + 3] = i, this.frames[t + 4] = o
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (s.bone.active) {
                    const u = this.frames
                    var c = s.color
                    if (n < u[0]) {
                        const l = s.data.color
                        switch (o) {
                            case y.setup:
                                return void c.setFromColor(l)
                            case y.first:
                                c.add((l.r - c.r) * i, (l.g - c.g) * i, (l.b - c.b) * i, (l.a - c.a) * i)
                        }
                    } else {
                        let h = 0
                        var f = 0
                        var d = 0
                        var p = 0
                        var m = zn.search(u, n, 5)
                        var v = this.curves[m / 5]
                        switch (v) {
                            case 0:
                                var _ = u[m]
                                h = u[m + 1], f = u[m + 2], d = u[m + 3], p = u[m + 4]
                                var g = (n - _) / (u[m + 5] - _)
                                h += (u[m + 5 + 1] - h) * g, f += (u[m + 5 + 2] - f) * g, d += (u[m + 5 + 3] - d) * g, p += (u[m + 5 + 4] - p) * g
                                break
                            case 1:
                                h = u[m + 1], f = u[m + 2], d = u[m + 3], p = u[m + 4]
                                break
                            default:
                                h = this.getBezierValue(n, m, 1, v - 2), f = this.getBezierValue(n, m, 2, v + 18 - 2), d = this.getBezierValue(n, m, 3, v + 36 - 2), p = this.getBezierValue(n, m, 4, v + 54 - 2)
                        }
                        i == 1 ? c.set(h, f, d, p) : (o == y.setup && c.setFromColor(s.data.color), c.add((h - c.r) * i, (f - c.g) * i, (d - c.b) * i, (p - c.a) * i))
                    }
                }
            }, e
        }(qn))
        var ur = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, [`${jn }|${ r}`]) || this
                return i.slotIndex = 0, i.slotIndex = r, i
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 4
            }, e.prototype.setFrame = function (t, e, n, r, i) {
                t <<= 2, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r, this.frames[t + 3] = i
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (s.bone.active) {
                    const u = this.frames
                    var c = s.color
                    if (n < u[0]) {
                        var l = s.data.color
                        switch (o) {
                            case y.setup:
                                return c.r = l.r, c.g = l.g, void (c.b = l.b)
                            case y.first:
                                c.r += (l.r - c.r) * i, c.g += (l.g - c.g) * i, c.b += (l.b - c.b) * i
                        }
                    } else {
                        let h = 0
                        var f = 0
                        var d = 0
                        var p = zn.search(u, n, 4)
                        var m = this.curves[p >> 2]
                        switch (m) {
                            case 0:
                                var v = u[p]
                                h = u[p + 1], f = u[p + 2], d = u[p + 3]
                                var _ = (n - v) / (u[p + 4] - v)
                                h += (u[p + 4 + 1] - h) * _, f += (u[p + 4 + 2] - f) * _, d += (u[p + 4 + 3] - d) * _
                                break
                            case 1:
                                h = u[p + 1], f = u[p + 2], d = u[p + 3]
                                break
                            default:
                                h = this.getBezierValue(n, p, 1, m - 2), f = this.getBezierValue(n, p, 2, m + 18 - 2), d = this.getBezierValue(n, p, 3, m + 36 - 2)
                        }
                        if (i == 1) { c.r = h, c.g = f, c.b = d
                        }
                        else {
                            if (o == y.setup) {
                                l = s.data.color
                                c.r = l.r, c.g = l.g, c.b = l.b
                            }
                            c.r += (h - c.r) * i, c.g += (f - c.g) * i, c.b += (d - c.b) * i
                        }
                    }
                }
            }, e
        }(qn))
        var cr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Dn }|${ r}`) || this
                return i.slotIndex = 0, i.slotIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (s.bone.active) {
                    const u = s.color
                    if (n < this.frames[0]) {
                        const c = s.data.color
                        switch (o) {
                            case y.setup:
                                return void (u.a = c.a)
                            case y.first:
                                u.a += (c.a - u.a) * i
                        }
                    } else {
                        const l = this.getCurveValue(n)
                        i == 1 ? u.a = l : (o == y.setup && (u.a = s.data.color.a), u.a += (l - u.a) * i)
                    }
                }
            }, e
        }(Kn))
        var lr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, [`${jn }|${ r}`, `${Dn }|${ r}`, `${Ln }|${ r}`]) || this
                return i.slotIndex = 0, i.slotIndex = r, i
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 8
            }, e.prototype.setFrame = function (t, e, n, r, i, o, a, s, u) {
                t <<= 3, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r, this.frames[t + 3] = i, this.frames[t + 4] = o, this.frames[t + 5] = a, this.frames[t + 6] = s, this.frames[t + 7] = u
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (s.bone.active) {
                    const u = this.frames
                    var c = s.color
                    var l = s.darkColor
                    if (n < u[0]) {
                        const h = s.data.color
                        var f = s.data.darkColor
                        switch (o) {
                            case y.setup:
                                return c.setFromColor(h), l.r = f.r, l.g = f.g, void (l.b = f.b)
                            case y.first:
                                c.add((h.r - c.r) * i, (h.g - c.g) * i, (h.b - c.b) * i, (h.a - c.a) * i), l.r += (f.r - l.r) * i, l.g += (f.g - l.g) * i, l.b += (f.b - l.b) * i
                        }
                    } else {
                        let d = 0
                        var p = 0
                        var m = 0
                        var v = 0
                        var _ = 0
                        var g = 0
                        var b = 0
                        var E = zn.search(u, n, 8)
                        var x = this.curves[E >> 3]
                        switch (x) {
                            case 0:
                                var T = u[E]
                                d = u[E + 1], p = u[E + 2], m = u[E + 3], v = u[E + 4], _ = u[E + 5], g = u[E + 6], b = u[E + 7]
                                var S = (n - T) / (u[E + 8] - T)
                                d += (u[E + 8 + 1] - d) * S, p += (u[E + 8 + 2] - p) * S, m += (u[E + 8 + 3] - m) * S, v += (u[E + 8 + 4] - v) * S, _ += (u[E + 8 + 5] - _) * S, g += (u[E + 8 + 6] - g) * S, b += (u[E + 8 + 7] - b) * S
                                break
                            case 1:
                                d = u[E + 1], p = u[E + 2], m = u[E + 3], v = u[E + 4], _ = u[E + 5], g = u[E + 6], b = u[E + 7]
                                break
                            default:
                                d = this.getBezierValue(n, E, 1, x - 2), p = this.getBezierValue(n, E, 2, x + 18 - 2), m = this.getBezierValue(n, E, 3, x + 36 - 2), v = this.getBezierValue(n, E, 4, x + 54 - 2), _ = this.getBezierValue(n, E, 5, x + 72 - 2), g = this.getBezierValue(n, E, 6, x + 90 - 2), b = this.getBezierValue(n, E, 7, x + 108 - 2)
                        }
                        if (i == 1) { c.set(d, p, m, v), l.r = _, l.g = g, l.b = b
                        }
                        else {
                            if (o == y.setup) {
                                c.setFromColor(s.data.color)
                                f = s.data.darkColor
                                l.r = f.r, l.g = f.g, l.b = f.b
                            }
                            c.add((d - c.r) * i, (p - c.g) * i, (m - c.b) * i, (v - c.a) * i), l.r += (_ - l.r) * i, l.g += (g - l.g) * i, l.b += (b - l.b) * i
                        }
                    }
                }
            }, e
        }(qn))
        var hr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, [`${jn }|${ r}`, `${Ln }|${ r}`]) || this
                return i.slotIndex = 0, i.slotIndex = r, i
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 7
            }, e.prototype.setFrame = function (t, e, n, r, i, o, a, s) {
                t *= 7, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r, this.frames[t + 3] = i, this.frames[t + 4] = o, this.frames[t + 5] = a, this.frames[t + 6] = s
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (s.bone.active) {
                    const u = this.frames
                    var c = s.color
                    var l = s.darkColor
                    if (n < u[0]) {
                        var h = s.data.color
                        var f = s.data.darkColor
                        switch (o) {
                            case y.setup:
                                return c.r = h.r, c.g = h.g, c.b = h.b, l.r = f.r, l.g = f.g, void (l.b = f.b)
                            case y.first:
                                c.r += (h.r - c.r) * i, c.g += (h.g - c.g) * i, c.b += (h.b - c.b) * i, l.r += (f.r - l.r) * i, l.g += (f.g - l.g) * i, l.b += (f.b - l.b) * i
                        }
                    } else {
                        let d = 0
                        var p = 0
                        var m = 0
                        var v = 0
                        var _ = 0
                        var g = 0
                        var b = zn.search(u, n, 7)
                        var E = this.curves[b / 7]
                        switch (E) {
                            case 0:
                                var x = u[b]
                                d = u[b + 1], p = u[b + 2], m = u[b + 3], v = u[b + 4], _ = u[b + 5], g = u[b + 6]
                                var T = (n - x) / (u[b + 7] - x)
                                d += (u[b + 7 + 1] - d) * T, p += (u[b + 7 + 2] - p) * T, m += (u[b + 7 + 3] - m) * T, v += (u[b + 7 + 4] - v) * T, _ += (u[b + 7 + 5] - _) * T, g += (u[b + 7 + 6] - g) * T
                                break
                            case 1:
                                d = u[b + 1], p = u[b + 2], m = u[b + 3], v = u[b + 4], _ = u[b + 5], g = u[b + 6]
                                break
                            default:
                                d = this.getBezierValue(n, b, 1, E - 2), p = this.getBezierValue(n, b, 2, E + 18 - 2), m = this.getBezierValue(n, b, 3, E + 36 - 2), v = this.getBezierValue(n, b, 4, E + 54 - 2), _ = this.getBezierValue(n, b, 5, E + 72 - 2), g = this.getBezierValue(n, b, 6, E + 90 - 2)
                        }
                        if (i == 1) { c.r = d, c.g = p, c.b = m, l.r = v, l.g = _, l.b = g
                        }
                        else {
                            if (o == y.setup) {
                                h = s.data.color, f = s.data.darkColor
                                c.r = h.r, c.g = h.g, c.b = h.b, l.r = f.r, l.g = f.g, l.b = f.b
                            }
                            c.r += (d - c.r) * i, c.g += (p - c.g) * i, c.b += (m - c.b) * i, l.r += (v - l.r) * i, l.g += (_ - l.g) * i, l.b += (g - l.b) * i
                        }
                    }
                }
            }, e
        }(qn))
        var fr = (function (t) {
            function e(e, n) {
                const r = t.call(this, e, [`${Fn }|${ n}`]) || this
                return r.slotIndex = 0, r.slotIndex = n, r.attachmentNames = new Array(e), r
            }
            return mn(e, t), e.prototype.getFrameCount = function () {
                return this.frames.length
            }, e.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.attachmentNames[t] = n
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                s.bone.active && (a != v.mixOut ? n < this.frames[0] ? o != y.setup && o != y.first || this.setAttachment(t, s, s.data.attachmentName) : this.setAttachment(t, s, this.attachmentNames[zn.search1(this.frames, n)]) : o == y.setup && this.setAttachment(t, s, s.data.attachmentName))
            }, e.prototype.setAttachment = function (t, e, n) {
                e.setAttachment(n ? t.getAttachment(this.slotIndex, n) : null)
            }, e
        }(zn))
        var dr = (function (t) {
            function e(e, n, r, i) {
                const o = t.call(this, e, n, [`${Bn }|${ r }|${ i.id}`]) || this
                return o.slotIndex = 0, o.slotIndex = r, o.attachment = i, o.vertices = new Array(e), o
            }
            return mn(e, t), e.prototype.getFrameCount = function () {
                return this.frames.length
            }, e.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.vertices[t] = n
            }, e.prototype.setBezier = function (t, e, n, r, i, o, a, s, u, c, l) {
                const h = this.curves
                var f = this.getFrameCount() + 18 * t
                n == 0 && (h[e] = 2 + f)
                for (let d = 0.03 * (r - 2 * o + s), p = 0.03 * u - 0.06 * a, m = 0.006 * (3 * (o - s) - r + c), y = 0.018 * (a - u + 0.33333333), v = 2 * d + m, _ = 2 * p + y, g = 0.3 * (o - r) + d + 0.16666667 * m, b = 0.3 * a + p + 0.16666667 * y, E = r + g, x = b, T = f + 18; f < T; f += 2) h[f] = E, h[f + 1] = x, g += v, b += _, v += m, _ += y, E += g, x += b
            }, e.prototype.getCurvePercent = function (t, e) {
                const n = this.curves
                var r = n[e]
                switch (r) {
                    case 0:
                        var i = this.frames[e]
                        return (t - i) / (this.frames[e + this.getFrameEntries()] - i)
                    case 1:
                        return 0
                }
                if (n[r -= 2] > t) {
                    const o = this.frames[e]
                    return n[r + 1] * (t - o) / (n[r] - o)
                }
                const a = r + 18
                for (r += 2; r < a; r += 2) {
                    if (n[r] >= t) {
                        let s = n[r - 2]
                                    var u = n[r - 1]
                        return u + (t - s) / (n[r] - s) * (n[r + 1] - u)
                    }
                }
                const c = n[a - 2]
                var l = n[a - 1]
                return l + (1 - l) * (t - c) / (this.frames[e + this.getFrameEntries()] - c)
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.slots[this.slotIndex]
                if (s.bone.active) {
                    const u = s.getAttachment()
                    if (u instanceof _n && u.deformAttachment == this.attachment) {
                        const c = s.deform
                        c.length == 0 && (o = y.setup)
                        let l = this.vertices
                        var h = l[0].length
                        var f = this.frames
                        if (n < f[0]) {
                            var d = u
                            switch (o) {
                                case y.setup:
                                    return void (c.length = 0)
                                case y.first:
                                    if (i == 1) return void (c.length = 0)
                                    if (c.length = h, d.bones) {
                                        i = 1 - i
                                        for (m = 0; m < h; m++) c[m] *= i
                                    } else {
                                        for (var p = d.vertices, m = 0; m < h; m++) c[m] += (p[m] - c[m]) * i
                                    }
                            }
                        } else if (c.length = h, n >= f[f.length - 1]) {
                            const v = l[f.length - 1]
                            if (i == 1) {
                                if (o == y.add) {
                                    if ((d = u).bones) {
                                                for (var _ = 0; _ < h; _++) c[_] += v[_];
}
                                    else {
                                        p = d.vertices
                                                for (let g = 0; g < h; g++) c[g] += v[g] - p[g]
                                    }
                                }
                                else { G.arrayCopy(v, 0, c, 0, h)
}
                            }
                            else { switch (o) {
                                case y.setup:
                                    var b = u
                                    if (b.bones) {
                                        for (let E = 0; E < h; E++) c[E] = v[E] * i
}
                                    else {
                                        p = b.vertices
                                        for (let x = 0; x < h; x++) {
                                            var T = p[x]
                                            c[x] = T + (v[x] - T) * i
                                        }
                                    }
                                    break
                                case y.first:
                                case y.replace:
                                    for (let S = 0; S < h; S++) c[S] += (v[S] - c[S]) * i
                                    break;
                                case y.add:
                                    if ((d = u).bones) {
                                        for (let w = 0; w < h; w++) c[w] += v[w] * i
}
                                    else {
                                        p = d.vertices
                                        for (let O = 0; O < h; O++) c[O] += (v[O] - p[O]) * i
                                    }
                            }
                            }
                        } else {
                            const P = zn.search1(f, n)
                            var R = this.getCurvePercent(n, P)
                            var A = l[P]
                            var I = l[P + 1]
                            if (i == 1) {
                                if (o == y.add) {
                                    if ((d = u).bones) {
                                                for (var C = 0; C < h; C++) {
                                                    N = A[C];
                                                    c[C] += N + (I[C] - N) * R
                                                }
} else {
                                        p = d.vertices
                                                    for (let k = 0; k < h; k++) {
                                            var N = A[k]
                                                        c[k] += N + (I[k] - N) * R - p[k]
                                        }
                                    }
                                } else {
                                    for (let M = 0; M < h; M++) {
                                        N = A[M]
                                                        c[M] = N + (I[M] - N) * R
                                    }
                                }
                            } else { switch (o) {
                                case y.setup:
                                    var j = u
                                    if (j.bones) {
                                        for (let D = 0; D < h; D++) {
                                            N = A[D]
                                                                    c[D] = (N + (I[D] - N) * R) * i
                                        }
                                    } else {
                                        p = j.vertices
                                        for (let L = 0; L < h; L++) {
                                            var N = A[L]
                                            T = p[L]
                                            c[L] = T + (N + (I[L] - N) * R - T) * i
                                        }
                                    }
                                    break
                                case y.first:
                                case y.replace:
                                    for (let F = 0; F < h; F++) {
                                        N = A[F]
                                        c[F] += (N + (I[F] - N) * R - c[F]) * i
                                    }
                                    break
                                case y.add:
                                    if ((d = u).bones) {
                                        for (let B = 0; B < h; B++) {
                                            N = A[B]
                                                                    c[B] += (N + (I[B] - N) * R) * i
                                        }
                                    } else {
                                        p = d.vertices
                                        for (let U = 0; U < h; U++) {
                                            N = A[U]
                                            c[U] += (N + (I[U] - N) * R - p[U]) * i
                                        }
                                    }
                            }
                            }
                        }
                    }
                }
            }, e
        }(qn))
        var pr = (function (t) {
            function e(n) {
                const r = t.call(this, n, e.propertyIds) || this
                return r.events = new Array(n), r
            }
            return mn(e, t), e.prototype.getFrameCount = function () {
                return this.frames.length
            }, e.prototype.setFrame = function (t, e) {
                this.frames[t] = e.time, this.events[t] = e
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                if (r) {
                    const s = this.frames
                    var u = this.frames.length
                    if (e > n) this.apply(t, e, Number.MAX_VALUE, r, i, o, a), e = -1
                    else if (e >= s[u - 1]) return
                    if (!(n < s[0])) {
                        let c = 0
                        if (e < s[0]) { c = 0
                        }
                        else {
                            for (let l = s[c = zn.search1(s, e) + 1]; c > 0 && s[c - 1] == l;) c--
                        }
                        for (; c < u && n >= s[c]; c++) r.push(this.events[c])
                    }
                }
            }, e.propertyIds = [`${ Un}`], e
        }(zn))
        var mr = (function (t) {
            function e(n) {
                const r = t.call(this, n, e.propertyIds) || this
                return r.drawOrders = new Array(n), r
            }
            return mn(e, t), e.prototype.getFrameCount = function () {
                return this.frames.length
            }, e.prototype.setFrame = function (t, e, n) {
                this.frames[t] = e, this.drawOrders[t] = n
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                if (a != v.mixOut) {
                    if (n < this.frames[0]) { o != y.setup && o != y.first || G.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length)
}
                    else {
                        let s = this.drawOrders[zn.search1(this.frames, n)]
                        if (s) {
                            for (let u = t.drawOrder, c = t.slots, l = 0, h = s.length; l < h; l++) u[l] = c[s[l]]
}
                        else { G.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length)
                        }
                    }
                }
                else { o == y.setup && G.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length)
                }
            }, e.propertyIds = [`${ Gn}`], e
        }(zn))
        var yr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, [`${Xn }|${ r}`]) || this
                return i.ikConstraintIndex = r, i
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 6
            }, e.prototype.setFrame = function (t, e, n, r, i, o, a) {
                t *= 6, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r, this.frames[t + 3] = i, this.frames[t + 4] = o ? 1 : 0, this.frames[t + 5] = a ? 1 : 0
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.ikConstraints[this.ikConstraintIndex]
                if (s.active) {
                    const u = this.frames
                    if (n < u[0]) { switch (o) {
                        case y.setup:
                            return s.mix = s.data.mix, s.softness = s.data.softness, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, void (s.stretch = s.data.stretch)
                        case y.first:
                            s.mix += (s.data.mix - s.mix) * i, s.softness += (s.data.softness - s.softness) * i, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch
                    }
                    } else {
                        let c = 0
                        var l = 0
                        var h = zn.search(u, n, 6)
                        var f = this.curves[h / 6]
                        switch (f) {
                            case 0:
                                var d = u[h]
                                c = u[h + 1], l = u[h + 2]
                                var p = (n - d) / (u[h + 6] - d)
                                c += (u[h + 6 + 1] - c) * p, l += (u[h + 6 + 2] - l) * p
                                break
                            case 1:
                                c = u[h + 1], l = u[h + 2]
                                break
                            default:
                                c = this.getBezierValue(n, h, 1, f - 2), l = this.getBezierValue(n, h, 2, f + 18 - 2)
                        }
                        o == y.setup ? (s.mix = s.data.mix + (c - s.data.mix) * i, s.softness = s.data.softness + (l - s.data.softness) * i, a == v.mixOut ? (s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch) : (s.bendDirection = u[h + 3], s.compress = u[h + 4] != 0, s.stretch = u[h + 5] != 0)) : (s.mix += (c - s.mix) * i, s.softness += (l - s.softness) * i, a == v.mixIn && (s.bendDirection = u[h + 3], s.compress = u[h + 4] != 0, s.stretch = u[h + 5] != 0))
                    }
                }
            }, e
        }(qn))
        var vr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, [`${Hn }|${ r}`]) || this
                return i.transformConstraintIndex = r, i
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 7
            }, e.prototype.setFrame = function (t, e, n, r, i, o, a, s) {
                const u = this.frames
                u[t *= 7] = e, u[t + 1] = n, u[t + 2] = r, u[t + 3] = i, u[t + 4] = o, u[t + 5] = a, u[t + 6] = s
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.transformConstraints[this.transformConstraintIndex]
                if (s.active) {
                    const u = this.frames
                    if (n < u[0]) {
                        var c = s.data
                        switch (o) {
                            case y.setup:
                                return s.mixRotate = c.mixRotate, s.mixX = c.mixX, s.mixY = c.mixY, s.mixScaleX = c.mixScaleX, s.mixScaleY = c.mixScaleY, void (s.mixShearY = c.mixShearY)
                            case y.first:
                                s.mixRotate += (c.mixRotate - s.mixRotate) * i, s.mixX += (c.mixX - s.mixX) * i, s.mixY += (c.mixY - s.mixY) * i, s.mixScaleX += (c.mixScaleX - s.mixScaleX) * i, s.mixScaleY += (c.mixScaleY - s.mixScaleY) * i, s.mixShearY += (c.mixShearY - s.mixShearY) * i
                        }
                    } else {
                        let l; let h; let f; let d; let p; let m; const v = zn.search(u, n, 7)
                        var _ = this.curves[v / 7]
                        switch (_) {
                            case 0:
                                var g = u[v]
                                l = u[v + 1], h = u[v + 2], f = u[v + 3], d = u[v + 4], p = u[v + 5], m = u[v + 6]
                                var b = (n - g) / (u[v + 7] - g)
                                l += (u[v + 7 + 1] - l) * b, h += (u[v + 7 + 2] - h) * b, f += (u[v + 7 + 3] - f) * b, d += (u[v + 7 + 4] - d) * b, p += (u[v + 7 + 5] - p) * b, m += (u[v + 7 + 6] - m) * b
                                break
                            case 1:
                                l = u[v + 1], h = u[v + 2], f = u[v + 3], d = u[v + 4], p = u[v + 5], m = u[v + 6]
                                break
                            default:
                                l = this.getBezierValue(n, v, 1, _ - 2), h = this.getBezierValue(n, v, 2, _ + 18 - 2), f = this.getBezierValue(n, v, 3, _ + 36 - 2), d = this.getBezierValue(n, v, 4, _ + 54 - 2), p = this.getBezierValue(n, v, 5, _ + 72 - 2), m = this.getBezierValue(n, v, 6, _ + 90 - 2)
                        }
                        if (o == y.setup) {
                            c = s.data
                            s.mixRotate = c.mixRotate + (l - c.mixRotate) * i, s.mixX = c.mixX + (h - c.mixX) * i, s.mixY = c.mixY + (f - c.mixY) * i, s.mixScaleX = c.mixScaleX + (d - c.mixScaleX) * i, s.mixScaleY = c.mixScaleY + (p - c.mixScaleY) * i, s.mixShearY = c.mixShearY + (m - c.mixShearY) * i
                        } else { s.mixRotate += (l - s.mixRotate) * i, s.mixX += (h - s.mixX) * i, s.mixY += (f - s.mixY) * i, s.mixScaleX += (d - s.mixScaleX) * i, s.mixScaleY += (p - s.mixScaleY) * i, s.mixShearY += (m - s.mixShearY) * i
                        }
                    }
                }
            }, e
        }(qn))
        var _r = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Vn }|${ r}`) || this
                return i.pathConstraintIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.pathConstraints[this.pathConstraintIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.position = s.data.position)
                                case y.first:
                            s.position += (s.data.position - s.position) * i
                    }
                    } else {
                        let u = this.getCurveValue(n)
                        o == y.setup ? s.position = s.data.position + (u - s.data.position) * i : s.position += (u - s.position) * i
                    }
                }
            }, e
        }(Kn))
        var gr = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, `${Wn }|${ r}`) || this
                return i.pathConstraintIndex = 0, i.pathConstraintIndex = r, i
            }
            return mn(e, t), e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.pathConstraints[this.pathConstraintIndex]
                if (s.active) {
                    if (n < this.frames[0]) { switch (o) {
                        case y.setup:
                            return void (s.spacing = s.data.spacing)
                                case y.first:
                            s.spacing += (s.data.spacing - s.spacing) * i
                    }
                    } else {
                        let u = this.getCurveValue(n)
                        o == y.setup ? s.spacing = s.data.spacing + (u - s.data.spacing) * i : s.spacing += (u - s.spacing) * i
                    }
                }
            }, e
        }(Kn))
        var br = (function (t) {
            function e(e, n, r) {
                const i = t.call(this, e, n, [`${Yn }|${ r}`]) || this
                return i.pathConstraintIndex = 0, i.pathConstraintIndex = r, i
            }
            return mn(e, t), e.prototype.getFrameEntries = function () {
                return 4
            }, e.prototype.setFrame = function (t, e, n, r, i) {
                const o = this.frames
                o[t <<= 2] = e, o[t + 1] = n, o[t + 2] = r, o[t + 3] = i
            }, e.prototype.apply = function (t, e, n, r, i, o, a) {
                const s = t.pathConstraints[this.pathConstraintIndex]
                if (s.active) {
                    const u = this.frames
                    if (n < u[0]) { switch (o) {
                        case y.setup:
                            return s.mixRotate = s.data.mixRotate, s.mixX = s.data.mixX, void (s.mixY = s.data.mixY)
                        case y.first:
                            s.mixRotate += (s.data.mixRotate - s.mixRotate) * i, s.mixX += (s.data.mixX - s.mixX) * i, s.mixY += (s.data.mixY - s.mixY) * i
                    }
                    } else {
                        let c; let l; let h; const f = zn.search(u, n, 4)
                        var d = this.curves[f >> 2]
                        switch (d) {
                            case 0:
                                var p = u[f]
                                c = u[f + 1], l = u[f + 2], h = u[f + 3]
                                var m = (n - p) / (u[f + 4] - p)
                                c += (u[f + 4 + 1] - c) * m, l += (u[f + 4 + 2] - l) * m, h += (u[f + 4 + 3] - h) * m
                                break
                            case 1:
                                c = u[f + 1], l = u[f + 2], h = u[f + 3]
                                break
                            default:
                                c = this.getBezierValue(n, f, 1, d - 2), l = this.getBezierValue(n, f, 2, d + 18 - 2), h = this.getBezierValue(n, f, 3, d + 36 - 2)
                        }
                        if (o == y.setup) {
                            const v = s.data
                            s.mixRotate = v.mixRotate + (c - v.mixRotate) * i, s.mixX = v.mixX + (l - v.mixX) * i, s.mixY = v.mixY + (h - v.mixY) * i
                        } else { s.mixRotate += (c - s.mixRotate) * i, s.mixX += (l - s.mixX) * i, s.mixY += (h - s.mixY) * i
                        }
                    }
                }
            }, e
        }(qn))
        var Er = (function () {
            function t(t) {
                this.tracks = [], this.timeScale = 1, this.unkeyedState = 0, this.events = [], this.listeners = [], this.queue = new Tr(this), this.propertyIDs = new L(), this.animationsChanged = !1, this.trackEntryPool = new X(() => {
                    return new xr()
                }), this.data = t
            }
            return t.emptyAnimation = function () {
                return Nr || (Nr = new Pn('<empty>', [], 0)), Nr
            }, t.prototype.update = function (t) {
                t *= this.timeScale
                for (let e = this.tracks, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i) {
                        i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast
                        let o = t * i.timeScale
                        if (i.delay > 0) {
                            if (i.delay -= o, i.delay > 0) continue
                            o = -i.delay, i.delay = 0
                        }
                        let a = i.next
                        if (a) {
                            const s = i.trackLast - a.delay
                            if (s >= 0) {
                                for (a.delay = 0, a.trackTime += i.timeScale == 0 ? 0 : (s / i.timeScale + t) * a.timeScale, i.trackTime += o, this.setCurrent(n, a, !0); a.mixingFrom;) a.mixTime += t, a = a.mixingFrom
                                continue
                            }
                        } else if (i.trackLast >= i.trackEnd && !i.mixingFrom) {
                            e[n] = null, this.queue.end(i), this.clearNext(i)
                            continue
                        }
                        if (i.mixingFrom && this.updateMixingFrom(i, t)) {
                            let u = i.mixingFrom
                            for (i.mixingFrom = null, u && (u.mixingTo = null); u;) this.queue.end(u), u = u.mixingFrom
                        }
                        i.trackTime += o
                    }
                }
                this.queue.drain()
            }, t.prototype.updateMixingFrom = function (t, e) {
                const n = t.mixingFrom
                if (!n) return !0
                let r = this.updateMixingFrom(n, e)
                return n.animationLast = n.nextAnimationLast, n.trackLast = n.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? (n.totalAlpha != 0 && t.mixDuration != 0 || (t.mixingFrom = n.mixingFrom, n.mixingFrom && (n.mixingFrom.mixingTo = t), t.interruptAlpha = n.interruptAlpha, this.queue.end(n)), r) : (n.trackTime += e * n.timeScale, t.mixTime += e, !1)
            }, t.prototype.apply = function (t) {
                if (!t) throw new Error('skeleton cannot be null.')
                this.animationsChanged && this._animationsChanged()
                for (var e = this.events, n = this.tracks, r = !1, i = 0, o = n.length; i < o; i++) {
                    const a = n[i]
                    if (a && !(a.delay > 0)) {
                        r = !0
                        let s = i == 0 ? y.first : a.mixBlend
                        var u = a.alpha
                        a.mixingFrom ? u *= this.applyMixingFrom(a, t, s) : a.trackTime >= a.trackEnd && !a.next && (u = 0)
                        let c = a.animationLast
                        var l = a.getAnimationTime()
                        var h = l
                        var f = e
                        a.reverse && (h = a.animation.duration - h, f = null)
                        let d = a.animation.timelines
                        var p = d.length
                        if (i == 0 && u == 1 || s == y.add) {
                            for (var m = 0; m < p; m++) {
                                G.webkit602BugfixHelper(u, s)
                                var _ = d[m]
                                _ instanceof fr ? this.applyAttachmentTimeline(_, t, h, s, !0) : _.apply(t, c, h, f, u, s, v.mixIn)
                            }
                        } else {
                            const g = a.timelineMode
                            var b = a.timelinesRotation.length != p << 1
                            b && (a.timelinesRotation.length = p << 1)
                            for (m = 0; m < p; m++) {
                                const E = d[m]
                                var x = g[m] == Or ? s : y.setup
                                E instanceof $n ? this.applyRotateTimeline(E, t, h, u, x, a.timelinesRotation, m << 1, b) : E instanceof fr ? this.applyAttachmentTimeline(E, t, h, s, !0) : (G.webkit602BugfixHelper(u, s), E.apply(t, c, h, f, u, x, v.mixIn))
                            }
                        }
                        this.queueEvents(a, l), e.length = 0, a.nextAnimationLast = l, a.nextTrackLast = a.trackTime
                    }
                }
                for (let T = this.unkeyedState + Cr, S = t.slots, w = 0, O = t.slots.length; w < O; w++) {
                    const P = S[w]
                    if (P.attachmentState == T) {
                        const R = P.data.attachmentName
                        P.setAttachment(R ? t.getAttachment(P.data.index, R) : null)
                    }
                }
                return this.unkeyedState += 2, this.queue.drain(), r
            }, t.prototype.applyMixingFrom = function (t, e, n) {
                const r = t.mixingFrom
                r.mixingFrom && this.applyMixingFrom(r, e, n)
                let i = 0
                t.mixDuration == 0 ? (i = 1, n == y.first && (n = y.setup)) : ((i = t.mixTime / t.mixDuration) > 1 && (i = 1), n != y.first && (n = r.mixBlend))
                let o = i < r.attachmentThreshold
                var a = i < r.drawOrderThreshold
                var s = r.animation.timelines
                var u = s.length
                var c = r.alpha * t.interruptAlpha
                var l = c * (1 - i)
                var h = r.animationLast
                var f = r.getAnimationTime()
                var d = f
                var p = null
                if (r.reverse ? d = r.animation.duration - d : i < r.eventThreshold && (p = this.events), n == y.add) {
                    for (var m = 0; m < u; m++) s[m].apply(e, h, d, p, l, n, v.mixOut)
                }
                else {
                    const _ = r.timelineMode
                    var g = r.timelineHoldMix
                    var b = r.timelinesRotation.length != u << 1
                    b && (r.timelinesRotation.length = u << 1), r.totalAlpha = 0
                    for (m = 0; m < u; m++) {
                        const E = s[m]
                        var x = v.mixOut
                        var T = void 0
                        var S = 0
                        switch (_[m]) {
                            case Or:
                                if (!a && E instanceof mr) continue
                                T = n, S = l
                                break
                            case Pr:
                                T = y.setup, S = l
                                break
                            case Rr:
                                T = n, S = c
                                break
                            case Ar:
                                T = y.setup, S = c
                                break
                            default:
                                T = y.setup
                                var w = g[m]
                                S = c * Math.max(0, 1 - w.mixTime / w.mixDuration)
                        }
                        r.totalAlpha += S, E instanceof $n ? this.applyRotateTimeline(E, e, d, S, T, r.timelinesRotation, m << 1, b) : E instanceof fr ? this.applyAttachmentTimeline(E, e, d, T, o) : (G.webkit602BugfixHelper(S, n), a && E instanceof mr && T == y.setup && (x = v.mixIn), E.apply(e, h, d, p, S, T, x))
                    }
                }
                return t.mixDuration > 0 && this.queueEvents(r, f), this.events.length = 0, r.nextAnimationLast = f, r.nextTrackLast = r.trackTime, i
            }, t.prototype.applyAttachmentTimeline = function (t, e, n, r, i) {
                const o = e.slots[t.slotIndex]
                o.bone.active && (n < t.frames[0] ? r != y.setup && r != y.first || this.setAttachment(e, o, o.data.attachmentName, i) : this.setAttachment(e, o, t.attachmentNames[zn.search1(t.frames, n)], i), o.attachmentState <= this.unkeyedState && (o.attachmentState = this.unkeyedState + Cr))
            }, t.prototype.setAttachment = function (t, e, n, r) {
                e.setAttachment(n ? t.getAttachment(e.data.index, n) : null), r && (e.attachmentState = this.unkeyedState + kr)
            }, t.prototype.applyRotateTimeline = function (t, e, n, r, i, o, a, s) {
                if (s && (o[a] = 0), r != 1) {
                    const u = e.bones[t.boneIndex]
                    if (u.active) {
                        let c = 0
                        var l = 0
                        if (n < t.frames[0]) { switch (i) {
                            case y.setup:
                                u.rotation = u.data.rotation
                            default:
                                return
                            case y.first:
                                c = u.rotation, l = u.data.rotation
                        }
                        } else { c = i == y.setup ? u.data.rotation : u.rotation, l = u.data.rotation + t.getCurveValue(n)
                        }
                        let h = 0
                        var f = l - c
                        if ((f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))) == 0) { h = o[a]
                        }
                        else {
                            let d = 0
                            var p = 0
                            s ? (d = 0, p = f) : (d = o[a], p = o[a + 1])
                            let m = f > 0
                            var _ = d >= 0
                            B.signum(p) != B.signum(f) && Math.abs(p) <= 90 && (Math.abs(d) > 180 && (d += 360 * B.signum(d)), _ = m), h = f + d - d % 360, _ != m && (h += 360 * B.signum(d)), o[a] = h
                        }
                        o[a + 1] = f, u.rotation = c + h * r
                    }
                } else { t.apply(e, 0, n, null, 1, i, v.mixIn)
                }
            }, t.prototype.queueEvents = function (t, e) {
                for (var n = t.animationStart, r = t.animationEnd, i = r - n, o = t.trackLast % i, a = this.events, s = 0, u = a.length; s < u; s++) {
                    const c = a[s]
                    if (c.time < o) break
                    c.time > r || this.queue.event(t, c)
                }
                for ((t.loop ? i == 0 || o > t.trackTime % i : e >= r && t.animationLast < r) && this.queue.complete(t); s < u; s++) {
                    const l = a[s]
                    l.time < n || this.queue.event(t, l)
                }
            }, t.prototype.clearTracks = function () {
                const t = this.queue.drainDisabled
                this.queue.drainDisabled = !0
                for (let e = 0, n = this.tracks.length; e < n; e++) this.clearTrack(e)
                this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain()
            }, t.prototype.clearTrack = function (t) {
                if (!(t >= this.tracks.length)) {
                    const e = this.tracks[t]
                    if (e) {
                        this.queue.end(e), this.clearNext(e)
                        for (let n = e; ;) {
                            const r = n.mixingFrom
                            if (!r) break
                            this.queue.end(r), n.mixingFrom = null, n.mixingTo = null, n = r
                        }
                        this.tracks[e.trackIndex] = null, this.queue.drain()
                    }
                }
            }, t.prototype.setCurrent = function (t, e, n) {
                const r = this.expandToIndex(t)
                this.tracks[t] = e, e.previous = null, r && (n && this.queue.interrupt(r), e.mixingFrom = r, r.mixingTo = e, e.mixTime = 0, r.mixingFrom && r.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)), r.timelinesRotation.length = 0), this.queue.start(e)
            }, t.prototype.setAnimation = function (t, e, n) {
                void 0 === n && (n = !1)
                let r = this.data.skeletonData.findAnimation(e)
                if (!r) throw new Error(`Animation not found: ${ e}`)
                return this.setAnimationWith(t, r, n)
            }, t.prototype.setAnimationWith = function (t, e, n) {
                if (void 0 === n && (n = !1), !e) throw new Error('animation cannot be null.')
                let r = !0
                var i = this.expandToIndex(t)
                i && (i.nextTrackLast == -1 ? (this.tracks[t] = i.mixingFrom, this.queue.interrupt(i), this.queue.end(i), this.clearNext(i), i = i.mixingFrom, r = !1) : this.clearNext(i))
                let o = this.trackEntry(t, e, n, i)
                return this.setCurrent(t, o, r), this.queue.drain(), o
            }, t.prototype.addAnimation = function (t, e, n, r) {
                void 0 === n && (n = !1), void 0 === r && (r = 0)
                let i = this.data.skeletonData.findAnimation(e)
                if (!i) throw new Error(`Animation not found: ${ e}`)
                return this.addAnimationWith(t, i, n, r)
            }, t.prototype.addAnimationWith = function (t, e, n, r) {
                if (void 0 === n && (n = !1), void 0 === r && (r = 0), !e) throw new Error('animation cannot be null.')
                let i = this.expandToIndex(t)
                if (i) {
                    for (; i.next;) i = i.next
                }
                const o = this.trackEntry(t, e, n, i)
                return i ? (i.next = o, o.previous = i, r <= 0 && (r += i.getTrackComplete() - o.mixDuration)) : (this.setCurrent(t, o, !0), this.queue.drain()), o.delay = r, o
            }, t.prototype.setEmptyAnimation = function (e, n) {
                void 0 === n && (n = 0)
                let r = this.setAnimationWith(e, t.emptyAnimation(), !1)
                return r.mixDuration = n, r.trackEnd = n, r
            }, t.prototype.addEmptyAnimation = function (e, n, r) {
                void 0 === n && (n = 0), void 0 === r && (r = 0)
                let i = this.addAnimationWith(e, t.emptyAnimation(), !1, r)
                return r <= 0 && (i.delay += i.mixDuration - n), i.mixDuration = n, i.trackEnd = n, i
            }, t.prototype.setEmptyAnimations = function (t) {
                void 0 === t && (t = 0)
                let e = this.queue.drainDisabled
                this.queue.drainDisabled = !0
                for (let n = 0, r = this.tracks.length; n < r; n++) {
                    const i = this.tracks[n]
                    i && this.setEmptyAnimation(i.trackIndex, t)
                }
                this.queue.drainDisabled = e, this.queue.drain()
            }, t.prototype.expandToIndex = function (t) {
                return t < this.tracks.length ? this.tracks[t] : (G.ensureArrayCapacity(this.tracks, t + 1, null), this.tracks.length = t + 1, null)
            }, t.prototype.trackEntry = function (t, e, n, r) {
                const i = this.trackEntryPool.obtain()
                return i.trackIndex = t, i.animation = e, i.loop = n, i.holdPrevious = !1, i.eventThreshold = 0, i.attachmentThreshold = 0, i.drawOrderThreshold = 0, i.animationStart = 0, i.animationEnd = e.duration, i.animationLast = -1, i.nextAnimationLast = -1, i.delay = 0, i.trackTime = 0, i.trackLast = -1, i.nextTrackLast = -1, i.trackEnd = Number.MAX_VALUE, i.timeScale = 1, i.alpha = 1, i.interruptAlpha = 1, i.mixTime = 0, i.mixDuration = r ? this.data.getMix(r.animation, e) : 0, i.mixBlend = y.replace, i
            }, t.prototype.clearNext = function (t) {
                for (let e = t.next; e;) this.queue.dispose(e), e = e.next
                t.next = null
            }, t.prototype._animationsChanged = function () {
                this.animationsChanged = !1, this.propertyIDs.clear()
                for (let t = this.tracks, e = 0, n = t.length; e < n; e++) {
                    let r = t[e]
                    if (r) {
                        for (; r.mixingFrom;) r = r.mixingFrom
                        do {
                            r.mixingTo && r.mixBlend == y.add || this.computeHold(r), r = r.mixingTo
                        } while (r)
                    }
                }
            }, t.prototype.computeHold = function (t) {
                const e = t.mixingTo
                var n = t.animation.timelines
                var r = t.animation.timelines.length
                var i = t.timelineMode
                i.length = r
                let o = t.timelineHoldMix
                o.length = 0
                let a = this.propertyIDs
                if (e && e.holdPrevious) {
                    for (var s = 0; s < r; s++) i[s] = a.addAll(n[s].getPropertyIds()) ? Ar : Rr
                }
                else { t: for (s = 0; s < r; s++) {
                    let u = n[s]
                                var c = u.getPropertyIds()
                    if (a.addAll(c)) {
                        if (!e || u instanceof fr || u instanceof mr || u instanceof pr || !e.animation.hasTimeline(c)) { i[s] = Pr;
}
                        else {
                            for (let l = e.mixingTo; l; l = l.mixingTo) {
                                        if (!l.animation.hasTimeline(c)) {
                                            if (t.mixDuration > 0) {
                                                i[s] = Ir, o[s] = l;
                                                continue t
                                            }
                                            break
                                        }
}
                            i[s] = Ar
                        }
                    }
                    else { i[s] = Or
                    }
                }
                }
            }, t.prototype.getCurrent = function (t) {
                return t >= this.tracks.length ? null : this.tracks[t]
            }, t.prototype.addListener = function (t) {
                if (!t) throw new Error('listener cannot be null.')
                this.listeners.push(t)
            }, t.prototype.removeListener = function (t) {
                const e = this.listeners.indexOf(t)
                e >= 0 && this.listeners.splice(e, 1)
            }, t.prototype.clearListeners = function () {
                this.listeners.length = 0
            }, t.prototype.clearListenerNotifications = function () {
                this.queue.clear()
            }, t.prototype.setAnimationByName = function (e, n, r) {
                t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.')), this.setAnimation(e, n, r)
            }, t.prototype.addAnimationByName = function (e, n, r, i) {
                t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.')), this.addAnimation(e, n, r, i)
            }, t.prototype.hasAnimation = function (t) {
                return this.data.skeletonData.findAnimation(t) !== null
            }, t.prototype.hasAnimationByName = function (e) {
                return t.deprecatedWarning3 || (t.deprecatedWarning3 = !0, console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.')), this.hasAnimation(e)
            }, t.deprecatedWarning1 = !1, t.deprecatedWarning2 = !1, t.deprecatedWarning3 = !1, t
        }())
        var xr = (function () {
            function t() {
                this.mixBlend = y.replace, this.timelineMode = [], this.timelineHoldMix = [], this.timelinesRotation = []
            }
            return t.prototype.reset = function () {
                this.previous = null, this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0
            }, t.prototype.getAnimationTime = function () {
                if (this.loop) {
                    const t = this.animationEnd - this.animationStart
                    return t == 0 ? this.animationStart : this.trackTime % t + this.animationStart
                }
                return Math.min(this.trackTime + this.animationStart, this.animationEnd)
            }, t.prototype.setAnimationLast = function (t) {
                this.animationLast = t, this.nextAnimationLast = t
            }, t.prototype.isComplete = function () {
                return this.trackTime >= this.animationEnd - this.animationStart
            }, t.prototype.resetRotationDirections = function () {
                this.timelinesRotation.length = 0
            }, t.prototype.getTrackComplete = function () {
                const t = this.animationEnd - this.animationStart
                if (t != 0) {
                    if (this.loop) return t * (1 + (this.trackTime / t | 0))
                    if (this.trackTime < t) return t
                }
                return this.trackTime
            }, Object.defineProperty(t.prototype, 'time', {
                get() {
                    return t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.')), this.trackTime
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.')), this.trackTime = e
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'endTime', {
                get() {
                    return t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.')), this.trackTime
                },
                set(e) {
                    t.deprecatedWarning2 || (t.deprecatedWarning2 = !0, console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.')), this.trackTime = e
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.loopsCount = function () {
                return Math.floor(this.trackTime / this.trackEnd)
            }, t.deprecatedWarning1 = !1, t.deprecatedWarning2 = !1, t
        }())
        var Tr = (function () {
            function t(t) {
                this.objects = [], this.drainDisabled = !1, this.animState = t
            }
            return t.prototype.start = function (t) {
                this.objects.push(yn.start), this.objects.push(t), this.animState.animationsChanged = !0
            }, t.prototype.interrupt = function (t) {
                this.objects.push(yn.interrupt), this.objects.push(t)
            }, t.prototype.end = function (t) {
                this.objects.push(yn.end), this.objects.push(t), this.animState.animationsChanged = !0
            }, t.prototype.dispose = function (t) {
                this.objects.push(yn.dispose), this.objects.push(t)
            }, t.prototype.complete = function (t) {
                this.objects.push(yn.complete), this.objects.push(t)
            }, t.prototype.event = function (t, e) {
                this.objects.push(yn.event), this.objects.push(t), this.objects.push(e)
            }, t.prototype.drain = function () {
                if (!this.drainDisabled) {
                    this.drainDisabled = !0
                    for (let t = this.objects, e = this.animState.listeners, n = 0; n < t.length; n += 2) {
                        const r = t[n]
                        let i = t[n + 1]
                        switch (r) {
                            case yn.start:
                                i.listener != null && i.listener.start && i.listener.start(i)
                                for (var o = 0; o < e.length; o++) e[o].start && e[o].start(i)
                                break
                            case yn.interrupt:
                                i.listener != null && i.listener.interrupt && i.listener.interrupt(i)
                                for (o = 0; o < e.length; o++) e[o].interrupt && e[o].interrupt(i)
                                break
                            case yn.end:
                                i.listener != null && i.listener.end && i.listener.end(i)
                                for (o = 0; o < e.length; o++) e[o].end && e[o].end(i)
                            case yn.dispose:
                                i.listener != null && i.listener.dispose && i.listener.dispose(i)
                                for (o = 0; o < e.length; o++) e[o].dispose && e[o].dispose(i)
                                this.animState.trackEntryPool.free(i)
                                break
                            case yn.complete:
                                i.listener != null && i.listener.complete && i.listener.complete(i)
                                for (o = 0; o < e.length; o++) e[o].complete && e[o].complete(i)
                                break
                            case yn.event:
                                var a = t[2 + n++]
                                i.listener != null && i.listener.event && i.listener.event(i, a)
                                for (o = 0; o < e.length; o++) e[o].event && e[o].event(i, a)
                        }
                    }
                    this.clear(), this.drainDisabled = !1
                }
            }, t.prototype.clear = function () {
                this.objects.length = 0
            }, t
        }())
        !(function (t) {
            t[t.start = 0] = 'start', t[t.interrupt = 1] = 'interrupt', t[t.end = 2] = 'end', t[t.dispose = 3] = 'dispose', t[t.complete = 4] = 'complete', t[t.event = 5] = 'event'
        }(yn || (yn = {})))
        let Sr; var wr = (function () {
            function t() {}
            return t.prototype.start = function (t) {}, t.prototype.interrupt = function (t) {}, t.prototype.end = function (t) {}, t.prototype.dispose = function (t) {}, t.prototype.complete = function (t) {}, t.prototype.event = function (t, e) {}, t
        }())
        var Or = 0
        var Pr = 1
        var Rr = 2
        var Ar = 3
        var Ir = 4
        var Cr = 1
        var kr = 2
        var Nr = null
        var Mr = (function () {
            function t(t) {
                if (this.animationToMixTime = {}, this.defaultMix = 0, t == null) throw new Error('skeletonData cannot be null.')
                this.skeletonData = t
            }
            return t.prototype.setMix = function (t, e, n) {
                const r = this.skeletonData.findAnimation(t)
                if (r == null) throw new Error(`Animation not found: ${ t}`)
                let i = this.skeletonData.findAnimation(e)
                if (i == null) throw new Error(`Animation not found: ${ e}`)
                this.setMixWith(r, i, n)
            }, t.prototype.setMixWith = function (t, e, n) {
                if (t == null) throw new Error('from cannot be null.')
                if (e == null) throw new Error('to cannot be null.')
                let r = `${t.name}.${e.name}`
                this.animationToMixTime[r] = n
            }, t.prototype.getMix = function (t, e) {
                const n = `${t.name }.${ e.name}`;
                var r = this.animationToMixTime[n]
                return void 0 === r ? this.defaultMix : r
            }, t
        }())
        var jr = (function () {
            function t(t) {
                this.atlas = t
            }
            return t.prototype.newRegionAttachment = function (t, e, n) {
                const r = this.atlas.findRegion(n)
                if (r == null) throw new Error(`Region not found in atlas: ${ n } (region attachment: ${ e })`)
                let i = new Sn(e)
                return i.region = r, i
            }, t.prototype.newMeshAttachment = function (t, e, n) {
                const r = this.atlas.findRegion(n)
                if (r == null) throw new Error(`Region not found in atlas: ${ n } (mesh attachment: ${ e })`)
                let i = new En(e)
                return i.region = r, i
            }, t.prototype.newBoundingBoxAttachment = function (t, e) {
                return new gn(e)
            }, t.prototype.newPathAttachment = function (t, e) {
                return new xn(e)
            }, t.prototype.newPointAttachment = function (t, e) {
                return new Tn(e)
            }, t.prototype.newClippingAttachment = function (t, e) {
                return new bn(e)
            }, t
        }())
        var Dr = (function () {
            function t(t, e, n) {
                if (this.matrix = new l.d(), this.children = [], this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.sorted = !1, this.active = !1, !t) throw new Error('data cannot be null.')
                if (!e) throw new Error('skeleton cannot be null.')
                this.data = t, this.skeleton = e, this.parent = n, this.setToSetupPose()
            }
            return Object.defineProperty(t.prototype, 'worldX', {
                get() {
                    return this.matrix.tx
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'worldY', {
                get() {
                    return this.matrix.ty
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.isActive = function () {
                return this.active
            }, t.prototype.update = function () {
                this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY)
            }, t.prototype.updateWorldTransform = function () {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            }, t.prototype.updateWorldTransformWith = function (t, e, n, r, i, o, a) {
                this.ax = t, this.ay = e, this.arotation = n, this.ascaleX = r, this.ascaleY = i, this.ashearX = o, this.ashearY = a
                let s = this.parent
                var u = this.matrix
                var c = this.skeleton.scaleX
                var l = V ? -this.skeleton.scaleY : this.skeleton.scaleY
                if (!s) {
                    const h = this.skeleton
                    var f = n + 90 + a
                    return u.a = B.cosDeg(n + o) * r * c, u.c = B.cosDeg(f) * i * c, u.b = B.sinDeg(n + o) * r * l, u.d = B.sinDeg(f) * i * l, u.tx = t * c + h.x, void (u.ty = e * l + h.y)
                }
                let d = s.matrix.a
                var p = s.matrix.c
                var m = s.matrix.b
                var y = s.matrix.d
                switch (u.tx = d * t + p * e + s.matrix.tx, u.ty = m * t + y * e + s.matrix.ty, this.data.transformMode) {
                    case b.Normal:
                        f = n + 90 + a
                        var v = B.cosDeg(n + o) * r
                        var _ = B.cosDeg(f) * i
                        var g = B.sinDeg(n + o) * r
                        var E = B.sinDeg(f) * i
                        return u.a = d * v + p * g, u.c = d * _ + p * E, u.b = m * v + y * g, void (u.d = m * _ + y * E)
                    case b.OnlyTranslation:
                        f = n + 90 + a
                        u.a = B.cosDeg(n + o) * r, u.c = B.cosDeg(f) * i, u.b = B.sinDeg(n + o) * r, u.d = B.sinDeg(f) * i
                        break
                    case b.NoRotationOrReflection:
                        var x = 0;
                        (w = d * d + m * m) > 1e-4 ? (w = Math.abs(d * y - p * m) / w, d /= this.skeleton.scaleX, p = (m /= this.skeleton.scaleY) * w, y = d * w, x = Math.atan2(m, d) * B.radDeg) : (d = 0, m = 0, x = 90 - Math.atan2(y, p) * B.radDeg)
                        var T = n + o - x
                        var S = n + a - x + 90
                        v = B.cosDeg(T) * r, _ = B.cosDeg(S) * i, g = B.sinDeg(T) * r, E = B.sinDeg(S) * i
                        u.a = d * v - p * g, u.c = d * _ - p * E, u.b = m * v + y * g, u.d = m * _ + y * E
                        break
                    case b.NoScale:
                    case b.NoScaleOrReflection:
                        var w; var O = B.cosDeg(n)
                        var P = B.sinDeg(n)
                        var R = (d * O + p * P) / c
                        var A = (m * O + y * P) / l;
                        (w = Math.sqrt(R * R + A * A)) > 1e-5 && (w = 1 / w), R *= w, A *= w, w = Math.sqrt(R * R + A * A), this.data.transformMode == b.NoScale && d * y - p * m < 0 != (V ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (w = -w)
                        var I = Math.PI / 2 + Math.atan2(A, R)
                        var C = Math.cos(I) * w
                        var k = Math.sin(I) * w
                        v = B.cosDeg(o) * r, _ = B.cosDeg(90 + a) * i, g = B.sinDeg(o) * r, E = B.sinDeg(90 + a) * i
                        u.a = R * v + C * g, u.c = R * _ + C * E, u.b = A * v + k * g, u.d = A * _ + k * E
                }
                u.a *= c, u.c *= c, u.b *= l, u.d *= l
            }, t.prototype.setToSetupPose = function () {
                const t = this.data
                this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY
            }, t.prototype.getWorldRotationX = function () {
                return Math.atan2(this.matrix.b, this.matrix.a) * B.radDeg
            }, t.prototype.getWorldRotationY = function () {
                return Math.atan2(this.matrix.d, this.matrix.c) * B.radDeg
            }, t.prototype.getWorldScaleX = function () {
                const t = this.matrix
                return Math.sqrt(t.a * t.a + t.b * t.b)
            }, t.prototype.getWorldScaleY = function () {
                const t = this.matrix
                return Math.sqrt(t.c * t.c + t.d * t.d)
            }, t.prototype.updateAppliedTransform = function () {
                const t = this.parent
                var e = this.matrix
                if (!t) return this.ax = e.tx, this.ay = e.ty, this.arotation = Math.atan2(e.b, e.a) * B.radDeg, this.ascaleX = Math.sqrt(e.a * e.a + e.b * e.b), this.ascaleY = Math.sqrt(e.c * e.c + e.d * e.d), this.ashearX = 0, void (this.ashearY = Math.atan2(e.a * e.c + e.b * e.d, e.a * e.d - e.b * e.c) * B.radDeg)
                let n = t.matrix
                var r = 1 / (n.a * n.d - n.b * n.c)
                var i = e.tx - n.tx
                var o = e.ty - n.ty
                this.ax = i * n.d * r - o * n.c * r, this.ay = o * n.a * r - i * n.b * r
                let a = r * n.d
                var s = r * n.a
                var u = r * n.c
                var c = r * n.b
                var l = a * e.a - u * e.b
                var h = a * e.c - u * e.d
                var f = s * e.b - c * e.a
                var d = s * e.d - c * e.c
                if (this.ashearX = 0, this.ascaleX = Math.sqrt(l * l + f * f), this.ascaleX > 1e-4) {
                    const p = l * d - h * f
                    this.ascaleY = p / this.ascaleX, this.ashearY = Math.atan2(l * h + f * d, p) * B.radDeg, this.arotation = Math.atan2(f, l) * B.radDeg
                } else { this.ascaleX = 0, this.ascaleY = Math.sqrt(h * h + d * d), this.ashearY = 0, this.arotation = 90 - Math.atan2(d, h) * B.radDeg
                }
            }, t.prototype.worldToLocal = function (t) {
                const e = this.matrix
                var n = e.a
                var r = e.c
                var i = e.b
                var o = e.d
                var a = 1 / (n * o - r * i)
                var s = t.x - e.tx
                var u = t.y - e.ty
                return t.x = s * o * a - u * r * a, t.y = u * n * a - s * i * a, t
            }, t.prototype.localToWorld = function (t) {
                const e = this.matrix
                var n = t.x
                var r = t.y
                return t.x = n * e.a + r * e.c + e.tx, t.y = n * e.b + r * e.d + e.ty, t
            }, t.prototype.worldToLocalRotation = function (t) {
                const e = B.sinDeg(t)
                var n = B.cosDeg(t)
                var r = this.matrix
                return Math.atan2(r.a * e - r.b * n, r.d * n - r.c * e) * B.radDeg
            }, t.prototype.localToWorldRotation = function (t) {
                t -= this.rotation - this.shearX
                let e = B.sinDeg(t)
                var n = B.cosDeg(t)
                var r = this.matrix
                return Math.atan2(n * r.b + e * r.d, n * r.a + e * r.c) * B.radDeg
            }, t.prototype.rotateWorld = function (t) {
                const e = this.matrix
                var n = e.a
                var r = e.c
                var i = e.b
                var o = e.d
                var a = B.cosDeg(t)
                var s = B.sinDeg(t)
                e.a = a * n - s * i, e.c = a * r - s * o, e.b = s * n + a * i, e.d = s * r + a * o
            }, t
        }())
        var Lr = function (t, e, n) {
            if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = b.Normal, this.skinRequired = !1, this.color = new F(), t < 0) throw new Error('index must be >= 0.')
            if (e == null) throw new Error('name cannot be null.')
            this.index = t, this.name = e, this.parent = n
        }
        var Fr = function (t, e, n) {
            this.name = t, this.order = e, this.skinRequired = n
        }
        var Br = function (t, e) {
            if (e == null) throw new Error('data cannot be null.')
            this.time = t, this.data = e
        }
        var Ur = function (t) {
            this.name = t
        }
        var Gr = (function () {
            function t(t, e) {
                if (this.bendDirection = 0, this.compress = !1, this.stretch = !1, this.mix = 1, this.softness = 0, this.active = !1, !t) throw new Error('data cannot be null.')
                if (!e) throw new Error('skeleton cannot be null.')
                this.data = t, this.mix = t.mix, this.softness = t.softness, this.bendDirection = t.bendDirection, this.compress = t.compress, this.stretch = t.stretch, this.bones = []
                for (let n = 0; n < t.bones.length; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findBone(t.target.name)
            }
            return t.prototype.isActive = function () {
                return this.active
            }, t.prototype.update = function () {
                if (this.mix != 0) {
                    const t = this.target
                    var e = this.bones
                    switch (e.length) {
                        case 1:
                            this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix)
                            break
                        case 2:
                            this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix)
                    }
                }
            }, t.prototype.apply1 = function (t, e, n, r, i, o, a) {
                const s = t.parent.matrix
                var u = s.a
                var c = s.c
                var l = s.b
                var h = s.d
                var f = -t.ashearX - t.arotation
                var d = 0
                var p = 0
                switch (t.data.transformMode) {
                    case b.OnlyTranslation:
                        d = e - t.worldX, p = n - t.worldY
                        break
                    case b.NoRotationOrReflection:
                        var m = Math.abs(u * h - c * l) / (u * u + l * l)
                        var y = u / t.skeleton.scaleX
                        var v = l / t.skeleton.scaleY
                        c = -v * m * t.skeleton.scaleX, h = y * m * t.skeleton.scaleY, f += Math.atan2(v, y) * B.radDeg
                    default:
                        var _ = e - s.tx
                        var g = n - s.ty
                        var E = u * h - c * l
                        d = (_ * h - g * c) / E - t.ax, p = (g * u - _ * l) / E - t.ay
                }
                f += Math.atan2(p, d) * B.radDeg, t.ascaleX < 0 && (f += 180), f > 180 ? f -= 360 : f < -180 && (f += 360)
                let x = t.ascaleX
                var T = t.ascaleY
                if (r || i) {
                    switch (t.data.transformMode) {
                        case b.NoScale:
                        case b.NoScaleOrReflection:
                            d = e - t.worldX, p = n - t.worldY
                    }
                    const S = t.data.length * x
                    var w = Math.sqrt(d * d + p * p)
                    if (r && w < S || i && w > S && S > 1e-4) x *= m = (w / S - 1) * a + 1, o && (T *= m)
                }
                t.updateWorldTransformWith(t.ax, t.ay, t.arotation + f * a, x, T, t.ashearX, t.ashearY)
            }, t.prototype.apply2 = function (t, e, n, r, i, o, a, s, u) {
                const c = t.ax
                var l = t.ay
                var h = t.ascaleX
                var f = t.ascaleY
                var d = h
                var p = f
                var m = e.ascaleX
                var y = t.matrix
                var v = 0
                var _ = 0
                var g = 0
                h < 0 ? (h = -h, v = 180, g = -1) : (v = 0, g = 1), f < 0 && (f = -f, g = -g), m < 0 ? (m = -m, _ = 180) : _ = 0
                let b = e.ax
                var E = 0
                var x = 0
                var T = 0
                var S = y.a
                var w = y.c
                var O = y.b
                var P = y.d
                var R = Math.abs(h - f) <= 1e-4
                !R || o ? (E = 0, x = S * b + y.tx, T = O * b + y.ty) : (x = S * b + w * (E = e.ay) + y.tx, T = O * b + P * E + y.ty)
                let A = t.parent.matrix
                S = A.a, w = A.c, O = A.b
                let I; let C; const k = 1 / (S * (P = A.d) - w * O)
                var N = x - A.tx
                var M = T - A.ty
                var j = (N * P - M * w) * k - c
                var D = (M * S - N * O) * k - l
                var L = Math.sqrt(j * j + D * D)
                var F = e.data.length * m
                if (L < 1e-4) return this.apply1(t, n, r, !1, o, !1, u), void e.updateWorldTransformWith(b, E, 0, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY)
                let U = ((N = n - A.tx) * P - (M = r - A.ty) * w) * k - c
                var G = (M * S - N * O) * k - l
                var X = U * U + G * G
                if (s != 0) {
                    s *= h * (m + 1) * 0.5
                    let H = Math.sqrt(X)
                    var V = H - L - F * h + s
                    if (V > 0) {
                        let W = Math.min(1, V / (2 * s)) - 1
                        X = (U -= (W = (V - s * (1 - W * W)) / H) * U) * U + (G -= W * G) * G
                    }
                }
                t: if (R) {
                    let Y = (X - L * L - (F *= h) * F) / (2 * L * F)
                    Y < -1 ? (Y = -1, C = Math.PI * i) : Y > 1 ? (Y = 1, C = 0, o && (d *= S = (Math.sqrt(X) / (L + F) - 1) * u + 1, a && (p *= S))) : C = Math.acos(Y) * i, S = L + F * Y, w = F * Math.sin(C), I = Math.atan2(G * S - U * w, U * S + G * w)
                } else {
                    const z = (S = h * F) * S
                    var q = (w = f * F) * w
                    var K = Math.atan2(G, U)
                    var Z = -2 * q * L
                    var $ = q - z
                    if ((P = Z * Z - 4 * $ * (O = q * L * L + z * X - z * q)) >= 0) {
                        let J = Math.sqrt(P)
                        Z < 0 && (J = -J)
                        let Q = (J = 0.5 * -(Z + J)) / $
                        var tt = O / J
                        var et = Math.abs(Q) < Math.abs(tt) ? Q : tt
                        if (et * et <= X) {
                            M = Math.sqrt(X - et * et) * i, I = K - Math.atan2(M, et), C = Math.atan2(M / f, (et - L) / h)
                            break t
                        }
                    }
                    let nt = B.PI
                    var rt = L - S
                    var it = rt * rt
                    var ot = 0
                    var at = 0
                    var st = L + S
                    var ut = st * st
                    var ct = 0;
                    (O = -S * L / (z - q)) >= -1 && O <= 1 && (O = Math.acos(O), (P = (N = S * Math.cos(O) + L) * N + (M = w * Math.sin(O)) * M) < it && (nt = O, it = P, rt = N, ot = M), P > ut && (at = O, ut = P, st = N, ct = M)), X <= 0.5 * (it + ut) ? (I = K - Math.atan2(ot * i, rt), C = nt * i) : (I = K - Math.atan2(ct * i, st), C = at * i)
                }
                const lt = Math.atan2(E, b) * g
                var ht = t.arotation;
                (I = (I - lt) * B.radDeg + v - ht) > 180 ? I -= 360 : I < -180 && (I += 360), t.updateWorldTransformWith(c, l, ht + I * u, d, p, 0, 0), ht = e.arotation, (C = ((C + lt) * B.radDeg - e.ashearX) * g + _ - ht) > 180 ? C -= 360 : C < -180 && (C += 360), e.updateWorldTransformWith(b, E, ht + C * u, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY)
            }, t
        }())
        var Xr = (function (t) {
            function e(e) {
                const n = t.call(this, e, 0, !1) || this
                return n.bones = [], n.bendDirection = 1, n.compress = !1, n.stretch = !1, n.uniform = !1, n.mix = 1, n.softness = 0, n
            }
            return mn(e, t), e
        }(Fr))
        var Hr = (function (t) {
            function e(e) {
                const n = t.call(this, e, 0, !1) || this
                return n.bones = [], n.mixRotate = 0, n.mixX = 0, n.mixY = 0, n
            }
            return mn(e, t), e
        }(Fr))
        !(function (t) {
            t[t.Length = 0] = 'Length', t[t.Fixed = 1] = 'Fixed', t[t.Percent = 2] = 'Percent', t[t.Proportional = 3] = 'Proportional'
        }(Sr || (Sr = {})))
        var Vr = (function () {
            function t(t, e) {
                if (this.position = 0, this.spacing = 0, this.mixRotate = 0, this.mixX = 0, this.mixY = 0, this.spaces = [], this.positions = [], this.world = [], this.curves = [], this.lengths = [], this.segments = [], this.active = !1, t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('skeleton cannot be null.')
                this.data = t, this.bones = []
                for (let n = 0, r = t.bones.length; n < r; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.mixRotate = t.mixRotate, this.mixX = t.mixX, this.mixY = t.mixY
            }
            return t.prototype.isActive = function () {
                return this.active
            }, t.prototype.update = function () {
                const e = this.target.getAttachment()
                if (e instanceof xn) {
                    const n = this.mixRotate
                    let r = this.mixX
                    let i = this.mixY
                    if (n != 0 || r != 0 || i != 0) {
                        const o = this.data
                        let a = o.rotateMode == g.Tangent
                        let s = o.rotateMode == g.ChainScale
                        let u = this.bones.length
                        let c = a ? u : u + 1
                        let l = this.bones
                        let h = G.setArraySize(this.spaces, c)
                        let f = s ? this.lengths = G.setArraySize(this.lengths, u) : null
                        let d = this.spacing
                        switch (o.spacingMode) {
                            case Sr.Percent:
                                if (s) {
                                    for (var p = 0, m = c - 1; p < m; p++) {
                                        if ((x = (I = l[p]).data.length) < t.epsilon) { f[p] = 0
                                        }
                                        else {
                                            var y = x * I.matrix.a
                                            var v = x * I.matrix.b
                                            f[p] = Math.sqrt(y * y + v * v)
                                        }
                                    }
                                }
                                G.arrayFill(h, 1, c, d)
                                break
                            case Sr.Proportional:
                                var _ = 0
                                for (p = 0, m = c - 1; p < m;) {
                                    if ((x = (I = l[p]).data.length) < t.epsilon) { s && (f[p] = 0), h[++p] = d
                                    }
                                    else {
                                        y = x * I.matrix.a, v = x * I.matrix.b
                                        const b = Math.sqrt(y * y + v * v)
                                        s && (f[p] = b), h[++p] = b, _ += b
                                    }
                                }
                                if (_ > 0) {
                                    _ = c / _ * d
                                    for (p = 1; p < c; p++) h[p] *= _
                                }
                                break
                            default:
                                var E = o.spacingMode == Sr.Length
                                for (p = 0, m = c - 1; p < m;) {
                                    var x
                                    if ((x = (I = l[p]).data.length) < t.epsilon) { s && (f[p] = 0), h[++p] = d
                                    }
                                    else {
                                        y = x * I.matrix.a, v = x * I.matrix.b
                                        const T = Math.sqrt(y * y + v * v)
                                        s && (f[p] = T), h[++p] = (E ? x + d : d) * T / x
                                    }
                                }
                        }
                        const S = this.computeWorldPositions(e, c, a)
                        let w = S[0]
                        let O = S[1]
                        let P = o.offsetRotation
                        let R = !1
                        if (P == 0) R = o.rotateMode == g.Chain
                        else R = !1, P *= (A = this.target.bone.matrix).a * A.d - A.b * A.c > 0 ? B.degRad : -B.degRad
                        p = 0
                        for (var A = 3; p < u; p++, A += 3) {
                            var I; const C = (I = l[p]).matrix
                            C.tx += (w - C.tx) * r, C.ty += (O - C.ty) * i
                            const k = (y = S[A]) - w
                            let N = (v = S[A + 1]) - O
                            if (s) {
                                const M = f[p]
                                if (M != 0) {
                                    const j = (Math.sqrt(k * k + N * N) / M - 1) * n + 1
                                    C.a *= j, C.b *= j
                                }
                            }
                            if (w = y, O = v, n > 0) {
                                const D = C.a
                                let L = C.c
                                let F = C.b
                                let U = C.d
                                let X = 0
                                let H = 0
                                let V = 0
                                if (X = a ? S[A - 1] : h[p + 1] == 0 ? S[A + 2] : Math.atan2(N, k), X -= Math.atan2(F, D), R) {
                                    H = Math.cos(X), V = Math.sin(X)
                                    const W = I.data.length
                                    w += (W * (H * D - V * F) - k) * n, O += (W * (V * D + H * F) - N) * n
                                } else { X += P
                                }
                                X > B.PI ? X -= B.PI2 : X < -B.PI && (X += B.PI2), X *= n, H = Math.cos(X), V = Math.sin(X), C.a = H * D - V * F, C.c = H * L - V * U, C.b = V * D + H * F, C.d = V * L + H * U
                            }
                            I.updateAppliedTransform()
                        }
                    }
                }
            }, t.prototype.computeWorldPositions = function (e, n, r) {
                const i = this.target
                let o = this.position
                let a = this.spaces
                let s = G.setArraySize(this.positions, 3 * n + 2)
                let u = null
                let c = e.closed
                let l = e.worldVerticesLength
                let h = l / 6
                let f = t.NONE
                if (!e.constantSpeed) {
                    let d; const p = e.lengths
                    let m = p[h -= c ? 1 : 2]
                    switch (this.data.positionMode == _.Percent && (o *= m), this.data.spacingMode) {
                        case Sr.Percent:
                            d = m
                            break
                        case Sr.Proportional:
                            d = m / n
                            break
                        default:
                            d = 1
                    }
                    u = G.setArraySize(this.world, 8)
                    for (var y = 0, v = 0, g = 0; y < n; y++, v += 3) {
                        var b = o += Y = a[y] * d
                        if (c) { (b %= m) < 0 && (b += m), g = 0
                        }
                        else {
                            if (b < 0) {
                                f != t.BEFORE && (f = t.BEFORE, e.computeWorldVertices(i, 2, 4, u, 0, 2)), this.addBeforePosition(b, u, 0, s, v)
                                continue
                            }
                            if (b > m) {
                                f != t.AFTER && (f = t.AFTER, e.computeWorldVertices(i, l - 6, 4, u, 0, 2)), this.addAfterPosition(b - m, u, 0, s, v)
                                continue
                            }
                        }
                        for (;; g++) {
                            const E = p[g]
                            if (!(b > E)) {
                                if (g == 0) b /= E
                                else b = (b - (Z = p[g - 1])) / (E - Z)
                                break
                            }
                        }
                        g != f && (f = g, c && g == h ? (e.computeWorldVertices(i, l - 4, 4, u, 0, 2), e.computeWorldVertices(i, 0, 4, u, 4, 2)) : e.computeWorldVertices(i, 6 * g + 2, 8, u, 0, 2)), this.addCurvePosition(b, u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], s, v, r || y > 0 && Y == 0)
                    }
                    return s
                }
                c ? (l += 2, u = G.setArraySize(this.world, l), e.computeWorldVertices(i, 2, l - 4, u, 0, 2), e.computeWorldVertices(i, 0, 2, u, l - 4, 2), u[l - 2] = u[0], u[l - 1] = u[1]) : (h--, l -= 4, u = G.setArraySize(this.world, l), e.computeWorldVertices(i, 2, l, u, 0, 2))
                for (var x = G.setArraySize(this.curves, h), T = 0, S = u[0], w = u[1], O = 0, P = 0, R = 0, A = 0, I = 0, C = 0, k = 0, N = 0, M = 0, j = 0, D = 0, L = 0, F = 0, B = 0, U = (y = 0, 2); y < h; y++, U += 6) O = u[U], P = u[U + 1], R = u[U + 2], A = u[U + 3], D = 2 * (k = 0.1875 * (S - 2 * O + R)) + (M = 0.09375 * (3 * (O - R) - S + (I = u[U + 4]))), L = 2 * (N = 0.1875 * (w - 2 * P + A)) + (j = 0.09375 * (3 * (P - A) - w + (C = u[U + 5]))), F = 0.75 * (O - S) + k + 0.16666667 * M, B = 0.75 * (P - w) + N + 0.16666667 * j, T += Math.sqrt(F * F + B * B), F += D, B += L, D += M, L += j, T += Math.sqrt(F * F + B * B), F += D, B += L, T += Math.sqrt(F * F + B * B), F += D + M, B += L + j, T += Math.sqrt(F * F + B * B), x[y] = T, S = I, w = C
                this.data.positionMode == _.Percent && (o *= T)
                let X = 0
                switch (this.data.spacingMode) {
                    case Sr.Percent:
                        X = T
                        break
                    case Sr.Proportional:
                        X = T / n
                        break
                    default:
                        X = 1
                }
                for (let H = this.segments, V = 0, W = (y = 0, v = 0, g = 0, 0); y < n; y++, v += 3) {
                    var Y
                    b = o += Y = a[y] * X
                    if (c) { (b %= T) < 0 && (b += T), g = 0
                    }
                    else {
                        if (b < 0) {
                            this.addBeforePosition(b, u, 0, s, v)
                            continue
                        }
                        if (b > T) {
                            this.addAfterPosition(b - T, u, l - 4, s, v)
                            continue
                        }
                    }
                    for (;; g++) {
                        const z = x[g]
                        if (!(b > z)) {
                            if (g == 0) b /= z
                            else b = (b - (Z = x[g - 1])) / (z - Z)
                            break
                        }
                    }
                    if (g != f) {
                        f = g
                        let q = 6 * g
                        for (S = u[q], w = u[q + 1], O = u[q + 2], P = u[q + 3], R = u[q + 4], A = u[q + 5], D = 2 * (k = 0.03 * (S - 2 * O + R)) + (M = 0.006 * (3 * (O - R) - S + (I = u[q + 6]))), L = 2 * (N = 0.03 * (w - 2 * P + A)) + (j = 0.006 * (3 * (P - A) - w + (C = u[q + 7]))), F = 0.3 * (O - S) + k + 0.16666667 * M, B = 0.3 * (P - w) + N + 0.16666667 * j, V = Math.sqrt(F * F + B * B), H[0] = V, q = 1; q < 8; q++) F += D, B += L, D += M, L += j, V += Math.sqrt(F * F + B * B), H[q] = V
                        F += D, B += L, V += Math.sqrt(F * F + B * B), H[8] = V, F += D + M, B += L + j, V += Math.sqrt(F * F + B * B), H[9] = V, W = 0
                    }
                    for (b *= V; ; W++) {
                        const K = H[W]
                        if (!(b > K)) {
                            var Z
                            if (W == 0) b /= K
                            else b = W + (b - (Z = H[W - 1])) / (K - Z)
                            break
                        }
                    }
                    this.addCurvePosition(0.1 * b, S, w, O, P, R, A, I, C, s, v, r || y > 0 && Y == 0)
                }
                return s
            }, t.prototype.addBeforePosition = function (t, e, n, r, i) {
                const o = e[n]
                let a = e[n + 1]
                let s = e[n + 2] - o
                let u = e[n + 3] - a
                let c = Math.atan2(u, s)
                r[i] = o + t * Math.cos(c), r[i + 1] = a + t * Math.sin(c), r[i + 2] = c
            }, t.prototype.addAfterPosition = function (t, e, n, r, i) {
                const o = e[n + 2]
                let a = e[n + 3]
                let s = o - e[n]
                let u = a - e[n + 1]
                let c = Math.atan2(u, s)
                r[i] = o + t * Math.cos(c), r[i + 1] = a + t * Math.sin(c), r[i + 2] = c
            }, t.prototype.addCurvePosition = function (t, e, n, r, i, o, a, s, u, c, l, h) {
                if (t == 0 || isNaN(t)) return c[l] = e, c[l + 1] = n, void (c[l + 2] = Math.atan2(i - n, r - e))
                const f = t * t
                let d = f * t
                let p = 1 - t
                let m = p * p
                let y = m * p
                let v = p * t
                let _ = 3 * v
                let g = p * _
                let b = _ * t
                let E = e * y + r * g + o * b + s * d
                let x = n * y + i * g + a * b + u * d
                c[l] = E, c[l + 1] = x, h && (c[l + 2] = t < 0.001 ? Math.atan2(i - n, r - e) : Math.atan2(x - (n * m + i * v * 2 + a * f), E - (e * m + r * v * 2 + o * f)))
            }, t.NONE = -1, t.BEFORE = -2, t.AFTER = -3, t.epsilon = 1e-5, t
        }())
        var Wr = (function () {
            function t(t, e) {
                if (this.deform = [], t == null) throw new Error('data cannot be null.')
                if (e == null) throw new Error('bone cannot be null.')
                this.data = t, this.bone = e, this.color = new F(), this.darkColor = t.darkColor == null ? null : new F(), this.setToSetupPose(), this.blendMode = this.data.blendMode
            }
            return t.prototype.getSkeleton = function () {
                return this.bone.skeleton
            }, t.prototype.getAttachment = function () {
                return this.attachment
            }, t.prototype.setAttachment = function (t) {
                this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, this.deform.length = 0)
            }, t.prototype.setAttachmentTime = function (t) {
                this.attachmentTime = this.bone.skeleton.time - t
            }, t.prototype.getAttachmentTime = function () {
                return this.bone.skeleton.time - this.attachmentTime
            }, t.prototype.setToSetupPose = function () {
                this.color.setFromColor(this.data.color), this.darkColor != null && this.darkColor.setFromColor(this.data.darkColor), this.data.attachmentName == null ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
            }, t
        }())
        var Yr = (function () {
            function t(t, e) {
                if (this.mixRotate = 0, this.mixX = 0, this.mixY = 0, this.mixScaleX = 0, this.mixScaleY = 0, this.mixShearY = 0, this.temp = new H(), this.active = !1, !t) throw new Error('data cannot be null.')
                if (!e) throw new Error('skeleton cannot be null.')
                this.data = t, this.mixRotate = t.mixRotate, this.mixX = t.mixX, this.mixY = t.mixY, this.mixScaleX = t.mixScaleX, this.mixScaleY = t.mixScaleY, this.mixShearY = t.mixShearY, this.bones = []
                for (let n = 0; n < t.bones.length; n++) this.bones.push(e.findBone(t.bones[n].name))
                this.target = e.findBone(t.target.name)
            }
            return t.prototype.isActive = function () {
                return this.active
            }, t.prototype.update = function () {
                this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0 || (this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld())
            }, t.prototype.applyAbsoluteWorld = function () {
                for (let t = this.mixRotate, e = this.mixX, n = this.mixY, r = this.mixScaleX, i = this.mixScaleY, o = this.mixShearY, a = e != 0 || n != 0, s = this.target, u = s.matrix, c = u.a, l = u.c, h = u.b, f = u.d, d = c * f - l * h > 0 ? B.degRad : -B.degRad, p = this.data.offsetRotation * d, m = this.data.offsetShearY * d, y = this.bones, v = 0, _ = y.length; v < _; v++) {
                    const g = y[v]
                    var b = g.matrix
                    if (t != 0) {
                        const E = b.a
                        var x = b.c
                        var T = b.b
                        var S = b.d;
                        (R = Math.atan2(h, c) - Math.atan2(T, E) + p) > B.PI ? R -= B.PI2 : R < -B.PI && (R += B.PI2), R *= t
                        let w = Math.cos(R)
                        var O = Math.sin(R)
                        b.a = w * E - O * T, b.c = w * x - O * S, b.b = O * E + w * T, b.d = O * x + w * S
                    }
                    if (a) {
                        const P = this.temp
                        s.localToWorld(P.set(this.data.offsetX, this.data.offsetY)), b.tx += (P.x - b.tx) * e, b.ty += (P.y - b.ty) * n
                    }
                    if (r != 0) (I = Math.sqrt(b.a * b.a + b.b * b.b)) != 0 && (I = (I + (Math.sqrt(c * c + h * h) - I + this.data.offsetScaleX) * r) / I), b.a *= I, b.b *= I
                    if (i != 0) (I = Math.sqrt(b.c * b.c + b.d * b.d)) != 0 && (I = (I + (Math.sqrt(l * l + f * f) - I + this.data.offsetScaleY) * i) / I), b.c *= I, b.d *= I
                    if (o > 0) {
                        x = b.c, S = b.d
                        var R; const A = Math.atan2(S, x);
                        (R = Math.atan2(f, l) - Math.atan2(h, c) - (A - Math.atan2(b.b, b.a))) > B.PI ? R -= B.PI2 : R < -B.PI && (R += B.PI2), R = A + (R + m) * o
                        var I = Math.sqrt(x * x + S * S)
                        b.c = Math.cos(R) * I, b.d = Math.sin(R) * I
                    }
                    g.updateAppliedTransform()
                }
            }, t.prototype.applyRelativeWorld = function () {
                for (let t = this.mixRotate, e = this.mixX, n = this.mixY, r = this.mixScaleX, i = this.mixScaleY, o = this.mixShearY, a = e != 0 || n != 0, s = this.target, u = s.matrix, c = u.a, l = u.c, h = u.b, f = u.d, d = c * f - l * h > 0 ? B.degRad : -B.degRad, p = this.data.offsetRotation * d, m = this.data.offsetShearY * d, y = this.bones, v = 0, _ = y.length; v < _; v++) {
                    const g = y[v]
                    var b = g.matrix
                    if (t != 0) {
                        const E = b.a
                        var x = b.c
                        var T = b.b
                        var S = b.d;
                        (A = Math.atan2(h, c) + p) > B.PI ? A -= B.PI2 : A < -B.PI && (A += B.PI2), A *= t
                        let w = Math.cos(A)
                        var O = Math.sin(A)
                        b.a = w * E - O * T, b.c = w * x - O * S, b.b = O * E + w * T, b.d = O * x + w * S
                    }
                    if (a) {
                        const P = this.temp
                        s.localToWorld(P.set(this.data.offsetX, this.data.offsetY)), b.tx += P.x * e, b.ty += P.y * n
                    }
                    if (r != 0) {
                        var R = (Math.sqrt(c * c + h * h) - 1 + this.data.offsetScaleX) * r + 1
                        b.a *= R, b.b *= R
                    }
                    if (i != 0) {
                        R = (Math.sqrt(l * l + f * f) - 1 + this.data.offsetScaleY) * i + 1
                        b.c *= R, b.d *= R
                    }
                    if (o > 0) {
                        var A;
                        (A = Math.atan2(f, l) - Math.atan2(h, c)) > B.PI ? A -= B.PI2 : A < -B.PI && (A += B.PI2)
                        x = b.c, S = b.d
                        A = Math.atan2(S, x) + (A - B.PI / 2 + m) * o
                        R = Math.sqrt(x * x + S * S)
                        b.c = Math.cos(A) * R, b.d = Math.sin(A) * R
                    }
                    g.updateAppliedTransform()
                }
            }, t.prototype.applyAbsoluteLocal = function () {
                for (let t = this.mixRotate, e = this.mixX, n = this.mixY, r = this.mixScaleX, i = this.mixScaleY, o = this.mixShearY, a = this.target, s = this.bones, u = 0, c = s.length; u < c; u++) {
                    const l = s[u]
                    var h = l.arotation
                    if (t != 0) {
                        var f = a.arotation - h + this.data.offsetRotation
                        h += (f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * t
                    }
                    let d = l.ax
                    var p = l.ay
                    d += (a.ax - d + this.data.offsetX) * e, p += (a.ay - p + this.data.offsetY) * n
                    let m = l.ascaleX
                    var y = l.ascaleY
                    r != 0 && m != 0 && (m = (m + (a.ascaleX - m + this.data.offsetScaleX) * r) / m), i != 0 && y != 0 && (y = (y + (a.ascaleY - y + this.data.offsetScaleY) * i) / y)
                    let v = l.ashearY
                    if (o != 0) {
                        f = a.ashearY - v + this.data.offsetShearY
                        v += (f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * o
                    }
                    l.updateWorldTransformWith(d, p, h, m, y, l.ashearX, v)
                }
            }, t.prototype.applyRelativeLocal = function () {
                for (let t = this.mixRotate, e = this.mixX, n = this.mixY, r = this.mixScaleX, i = this.mixScaleY, o = this.mixShearY, a = this.target, s = this.bones, u = 0, c = s.length; u < c; u++) {
                    const l = s[u]
                    var h = l.arotation + (a.arotation + this.data.offsetRotation) * t
                    var f = l.ax + (a.ax + this.data.offsetX) * e
                    var d = l.ay + (a.ay + this.data.offsetY) * n
                    var p = l.ascaleX * ((a.ascaleX - 1 + this.data.offsetScaleX) * r) + 1
                    var m = l.ascaleY * ((a.ascaleY - 1 + this.data.offsetScaleY) * i) + 1
                    var y = l.ashearY + (a.ashearY + this.data.offsetShearY) * o
                    l.updateWorldTransformWith(f, d, h, p, m, l.ashearX, y)
                }
            }, t
        }())
        var zr = (function () {
            function t(t) {
                if (this._updateCache = [], this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, !t) throw new Error('data cannot be null.')
                this.data = t, this.bones = []
                for (var e = 0; e < t.bones.length; e++) {
                    const n = t.bones[e]
                    var r = void 0
                    if (n.parent) {
                        const i = this.bones[n.parent.index]
                        r = new Dr(n, this, i), i.children.push(r)
                    } else { r = new Dr(n, this, null)
                    }
                    this.bones.push(r)
                }
                this.slots = [], this.drawOrder = []
                for (e = 0; e < t.slots.length; e++) {
                    const o = t.slots[e]
                    var a = (r = this.bones[o.boneData.index], new Wr(o, r))
                    this.slots.push(a), this.drawOrder.push(a)
                }
                this.ikConstraints = []
                for (e = 0; e < t.ikConstraints.length; e++) {
                    const s = t.ikConstraints[e]
                    this.ikConstraints.push(new Gr(s, this))
                }
                this.transformConstraints = []
                for (e = 0; e < t.transformConstraints.length; e++) {
                    const u = t.transformConstraints[e]
                    this.transformConstraints.push(new Yr(u, this))
                }
                this.pathConstraints = []
                for (e = 0; e < t.pathConstraints.length; e++) {
                    const c = t.pathConstraints[e]
                    this.pathConstraints.push(new Vr(c, this))
                }
                this.color = new F(1, 1, 1, 1), this.updateCache()
            }
            return t.prototype.updateCache = function () {
                this._updateCache.length = 0
                for (var t = this.bones, e = 0, n = t.length; e < n; e++) {
                    (i = t[e]).sorted = i.data.skinRequired, i.active = !i.sorted
                }
                if (this.skin) {
                    const r = this.skin.bones
                    for (e = 0, n = this.skin.bones.length; e < n; e++) {
                        var i = this.bones[r[e].index]
                        do {
                            i.sorted = !1, i.active = !0, i = i.parent
                        } while (i)
                    }
                }
                const o = this.ikConstraints
                var a = this.transformConstraints
                var s = this.pathConstraints
                var u = o.length
                var c = a.length
                var l = s.length
                var h = u + c + l
                t: for (e = 0; e < h; e++) {
                    for (var f = 0; f < u; f++) {
                        if ((d = o[f]).data.order == e) {
                            this.sortIkConstraint(d)
                            continue t
                        }
                    }
                    for (f = 0; f < c; f++) {
                        if ((d = a[f]).data.order == e) {
                            this.sortTransformConstraint(d)
                            continue t
                        }
                    }
                    for (f = 0; f < l; f++) {
                        var d
                        if ((d = s[f]).data.order == e) {
                            this.sortPathConstraint(d)
                            continue t
                        }
                    }
                }
                for (e = 0, n = t.length; e < n; e++) this.sortBone(t[e])
            }, t.prototype.sortIkConstraint = function (t) {
                if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && G.contains(this.skin.constraints, t.data, !0)), t.active) {
                    const e = t.target
                    this.sortBone(e)
                    let n = t.bones
                    var r = n[0]
                    if (this.sortBone(r), n.length == 1) { this._updateCache.push(t), this.sortReset(r.children)
                    }
                    else {
                        const i = n[n.length - 1]
                        this.sortBone(i), this._updateCache.push(t), this.sortReset(r.children), i.sorted = !0
                    }
                }
            }, t.prototype.sortPathConstraint = function (t) {
                if (t.active = t.target.bone.isActive() && (!t.data.skinRequired || this.skin && G.contains(this.skin.constraints, t.data, !0)), t.active) {
                    const e = t.target
                    var n = e.data.index
                    var r = e.bone
                    this.skin && this.sortPathConstraintAttachment(this.skin, n, r), this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, r)
                    for (var i = 0, o = this.data.skins.length; i < o; i++) this.sortPathConstraintAttachment(this.data.skins[i], n, r)
                    let a = e.getAttachment()
                    a instanceof xn && this.sortPathConstraintAttachmentWith(a, r)
                    let s = t.bones
                    var u = s.length
                    for (i = 0; i < u; i++) this.sortBone(s[i])
                    this._updateCache.push(t)
                    for (i = 0; i < u; i++) this.sortReset(s[i].children)
                    for (i = 0; i < u; i++) s[i].sorted = !0
                }
            }, t.prototype.sortTransformConstraint = function (t) {
                if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && G.contains(this.skin.constraints, t.data, !0)), t.active) {
                    this.sortBone(t.target)
                    let e = t.bones
                    var n = e.length
                    if (t.data.local) {
                        for (var r = 0; r < n; r++) {
                            let i = e[r]
                            this.sortBone(i.parent), this.sortBone(i)
                        }
                    } else {
                        for (r = 0; r < n; r++) this.sortBone(e[r])
                    }
                    this._updateCache.push(t)
                    for (r = 0; r < n; r++) this.sortReset(e[r].children)
                    for (r = 0; r < n; r++) e[r].sorted = !0
                }
            }, t.prototype.sortPathConstraintAttachment = function (t, e, n) {
                const r = t.attachments[e]
                if (r) {
                    for (const i in r) this.sortPathConstraintAttachmentWith(r[i], n)
                }
            }, t.prototype.sortPathConstraintAttachmentWith = function (t, e) {
                if (t instanceof xn) {
                    const n = t.bones
                    if (n) {
                        for (let r = this.bones, i = 0, o = n.length; i < o;) {
                            let a = n[i++]
                            for (a += i; i < a;) this.sortBone(r[n[i++]])
                        }
                    } else { this.sortBone(e)
                    }
                }
            }, t.prototype.sortBone = function (t) {
                if (!t.sorted) {
                    const e = t.parent
                    e && this.sortBone(e), t.sorted = !0, this._updateCache.push(t)
                }
            }, t.prototype.sortReset = function (t) {
                for (let e = 0, n = t.length; e < n; e++) {
                    const r = t[e]
                    r.active && (r.sorted && this.sortReset(r.children), r.sorted = !1)
                }
            }, t.prototype.updateWorldTransform = function () {
                for (var t = this.bones, e = 0, n = t.length; e < n; e++) {
                    const r = t[e]
                    r.ax = r.x, r.ay = r.y, r.arotation = r.rotation, r.ascaleX = r.scaleX, r.ascaleY = r.scaleY, r.ashearX = r.shearX, r.ashearY = r.shearY
                }
                const i = this._updateCache
                for (e = 0, n = i.length; e < n; e++) i[e].update()
            }, t.prototype.updateWorldTransformWith = function (t) {
                const e = this.getRootBone()
                var n = t.matrix.a
                var r = t.matrix.c
                var i = t.matrix.b
                var o = t.matrix.d
                e.matrix.tx = n * this.x + r * this.y + t.worldX, e.matrix.ty = i * this.x + o * this.y + t.worldY
                let a = e.rotation + 90 + e.shearY
                var s = B.cosDeg(e.rotation + e.shearX) * e.scaleX
                var u = B.cosDeg(a) * e.scaleY
                var c = B.sinDeg(e.rotation + e.shearX) * e.scaleX
                var l = B.sinDeg(a) * e.scaleY
                var h = this.scaleX
                var f = V ? -this.scaleY : this.scaleY
                e.matrix.a = (n * s + r * c) * h, e.matrix.c = (n * u + r * l) * h, e.matrix.b = (i * s + o * c) * f, e.matrix.d = (i * u + o * l) * f
                for (let d = this._updateCache, p = 0, m = d.length; p < m; p++) {
                    const y = d[p]
                    y != e && y.update()
                }
            }, t.prototype.setToSetupPose = function () {
                this.setBonesToSetupPose(), this.setSlotsToSetupPose()
            }, t.prototype.setBonesToSetupPose = function () {
                for (var t = this.bones, e = 0, n = t.length; e < n; e++) t[e].setToSetupPose()
                let r = this.ikConstraints
                for (e = 0, n = r.length; e < n; e++) {
                    (s = r[e]).mix = s.data.mix, s.softness = s.data.softness, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch
                }
                const i = this.transformConstraints
                for (e = 0, n = i.length; e < n; e++) {
                    var o = (s = i[e]).data
                    s.mixRotate = o.mixRotate, s.mixX = o.mixX, s.mixY = o.mixY, s.mixScaleX = o.mixScaleX, s.mixScaleY = o.mixScaleY, s.mixShearY = o.mixShearY
                }
                const a = this.pathConstraints
                for (e = 0, n = a.length; e < n; e++) {
                    var s
                    o = (s = a[e]).data
                    s.position = o.position, s.spacing = o.spacing, s.mixRotate = o.mixRotate, s.mixX = o.mixX, s.mixY = o.mixY
                }
            }, t.prototype.setSlotsToSetupPose = function () {
                const t = this.slots
                G.arrayCopy(t, 0, this.drawOrder, 0, t.length)
                for (let e = 0, n = t.length; e < n; e++) t[e].setToSetupPose()
            }, t.prototype.getRootBone = function () {
                return this.bones.length == 0 ? null : this.bones[0]
            }, t.prototype.findBone = function (t) {
                if (!t) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findBoneIndex = function (t) {
                if (!t) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    if (e[n].data.name == t) return n
                }
                return -1
            }, t.prototype.findSlot = function (t) {
                if (!t) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findSlotIndex = function (t) {
                if (!t) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    if (e[n].data.name == t) return n
                }
                return -1
            }, t.prototype.setSkinByName = function (t) {
                const e = this.data.findSkin(t)
                if (!e) throw new Error(`Skin not found: ${ t}`)
                this.setSkin(e)
            }, t.prototype.setSkin = function (t) {
                if (t != this.skin) {
                    if (t) {
                        if (this.skin) { t.attachAll(this, this.skin)
}
                        else {
                            for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                            var o = i.data.attachmentName
                                        if (o) {
                                    var a = t.getAttachment(n, o)
                                            a && i.setAttachment(a)
                                }
                            }
                        }
                    }
                    this.skin = t, this.updateCache()
                }
            }, t.prototype.getAttachmentByName = function (t, e) {
                return this.getAttachment(this.data.findSlotIndex(t), e)
            }, t.prototype.getAttachment = function (t, e) {
                if (!e) throw new Error('attachmentName cannot be null.')
                if (this.skin) {
                    const n = this.skin.getAttachment(t, e)
                    if (n) return n
                }
                return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
            }, t.prototype.setAttachment = function (t, e) {
                if (!t) throw new Error('slotName cannot be null.')
                for (let n = this.slots, r = 0, i = n.length; r < i; r++) {
                    const o = n[r]
                    if (o.data.name == t) {
                        let a = null
                        if (e && !(a = this.getAttachment(r, e))) throw new Error(`Attachment not found: ${ e }, for slot: ${ t}`)
                        return void o.setAttachment(a)
                    }
                }
                throw new Error(`Slot not found: ${ t}`)
            }, t.prototype.findIkConstraint = function (t) {
                if (!t) throw new Error('constraintName cannot be null.')
                for (let e = this.ikConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findTransformConstraint = function (t) {
                if (!t) throw new Error('constraintName cannot be null.')
                for (let e = this.transformConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraint = function (t) {
                if (!t) throw new Error('constraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.data.name == t) return i
                }
                return null
            }, t.prototype.getBounds = function (t, e, n) {
                if (void 0 === n && (n = Array.from({ length: 2 })), !t) throw new Error('offset cannot be null.')
                if (!e) throw new Error('size cannot be null.')
                for (var r = this.drawOrder, i = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY, u = 0, c = r.length; u < c; u++) {
                    const l = r[u]
                    if (l.bone.active) {
                        let h = 0
                        var f = null
                        var d = l.getAttachment()
                        if (d instanceof Sn) { h = 8, f = G.setArraySize(n, h, 0), d.computeWorldVertices(l.bone, f, 0, 2)
                        }
                        else if (d instanceof En) {
                            const p = d
                            h = p.worldVerticesLength, f = G.setArraySize(n, h, 0), p.computeWorldVertices(l, 0, h, f, 0, 2)
                        }
                        if (f) {
                            for (let m = 0, y = f.length; m < y; m += 2) {
                                let v = f[m]
                                            var _ = f[m + 1]
                                i = Math.min(i, v), o = Math.min(o, _), a = Math.max(a, v), s = Math.max(s, _)
                            }
                        }
                    }
                }
                t.set(i, o), e.set(a - i, s - o)
            }, t.prototype.update = function (t) {
                this.time += t
            }, Object.defineProperty(t.prototype, 'flipX', {
                get() {
                    return this.scaleX == -1
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY')), this.scaleX = e ? 1 : -1
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'flipY', {
                get() {
                    return this.scaleY == -1
                },
                set(e) {
                    t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY')), this.scaleY = e ? 1 : -1
                },
                enumerable: !1,
                configurable: !0
            }), t.deprecatedWarning1 = !1, t
        }())
        var qr = (function () {
            function t() {
                this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], this.ikConstraints = [], this.transformConstraints = [], this.pathConstraints = [], this.fps = 0
            }
            return t.prototype.findBone = function (t) {
                if (!t) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findBoneIndex = function (t) {
                if (!t) throw new Error('boneName cannot be null.')
                for (let e = this.bones, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t.prototype.findSlot = function (t) {
                if (!t) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findSlotIndex = function (t) {
                if (!t) throw new Error('slotName cannot be null.')
                for (let e = this.slots, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t.prototype.findSkin = function (t) {
                if (!t) throw new Error('skinName cannot be null.')
                for (let e = this.skins, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findEvent = function (t) {
                if (!t) throw new Error('eventDataName cannot be null.')
                for (let e = this.events, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findAnimation = function (t) {
                if (!t) throw new Error('animationName cannot be null.')
                for (let e = this.animations, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findIkConstraint = function (t) {
                if (!t) throw new Error('constraintName cannot be null.')
                for (let e = this.ikConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findTransformConstraint = function (t) {
                if (!t) throw new Error('constraintName cannot be null.')
                for (let e = this.transformConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraint = function (t) {
                if (!t) throw new Error('constraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    const i = e[n]
                    if (i.name == t) return i
                }
                return null
            }, t.prototype.findPathConstraintIndex = function (t) {
                if (t == null) throw new Error('pathConstraintName cannot be null.')
                for (let e = this.pathConstraints, n = 0, r = e.length; n < r; n++) {
                    if (e[n].name == t) return n
                }
                return -1
            }, t
        }())
        var Kr = function (t, e, n) {
            if (this.color = new F(1, 1, 1, 1), t < 0) throw new Error('index must be >= 0.')
            if (!e) throw new Error('name cannot be null.')
            if (!n) throw new Error('boneData cannot be null.')
            this.index = t, this.name = e, this.boneData = n
        }
        var Zr = (function (t) {
            function e(e) {
                const n = t.call(this, e, 0, !1) || this
                return n.bones = [], n.mixRotate = 0, n.mixX = 0, n.mixY = 0, n.mixScaleX = 0, n.mixScaleY = 0, n.mixShearY = 0, n.offsetRotation = 0, n.offsetX = 0, n.offsetY = 0, n.offsetScaleX = 0, n.offsetScaleY = 0, n.offsetShearY = 0, n.relative = !1, n.local = !1, n
            }
            return mn(e, t), e
        }(Fr))
        var $r = function (t, e, n) {
            this.slotIndex = t, this.name = e, this.attachment = n
        }
        var Jr = (function () {
            function t(t) {
                if (this.attachments = [], this.bones = [], this.constraints = [], !t) throw new Error('name cannot be null.')
                this.name = t
            }
            return t.prototype.setAttachment = function (t, e, n) {
                if (!n) throw new Error('attachment cannot be null.')
                let r = this.attachments
                t >= r.length && (r.length = t + 1), r[t] || (r[t] = {}), r[t][e] = n
            }, t.prototype.addSkin = function (t) {
                for (var e = 0; e < t.bones.length; e++) {
                    for (var n = t.bones[e], r = !1, i = 0; i < this.bones.length; i++) {
                        if (this.bones[i] == n) {
                            r = !0
                            break
                        }
                    }
                    r || this.bones.push(n)
                }
                for (e = 0; e < t.constraints.length; e++) {
                    const o = t.constraints[e]
                    for (r = !1, i = 0; i < this.constraints.length; i++) {
                        if (this.constraints[i] == o) {
                            r = !0
                            break
                        }
                    }
                    r || this.constraints.push(o)
                }
                const a = t.getAttachments()
                for (e = 0; e < a.length; e++) {
                    const s = a[e]
                    this.setAttachment(s.slotIndex, s.name, s.attachment)
                }
            }, t.prototype.copySkin = function (t) {
                for (var e = 0; e < t.bones.length; e++) {
                    for (var n = t.bones[e], r = !1, i = 0; i < this.bones.length; i++) {
                        if (this.bones[i] == n) {
                            r = !0
                            break
                        }
                    }
                    r || this.bones.push(n)
                }
                for (e = 0; e < t.constraints.length; e++) {
                    const o = t.constraints[e]
                    for (r = !1, i = 0; i < this.constraints.length; i++) {
                        if (this.constraints[i] == o) {
                            r = !0
                            break
                        }
                    }
                    r || this.constraints.push(o)
                }
                const a = t.getAttachments()
                for (e = 0; e < a.length; e++) {
                    const s = a[e]
                    s.attachment && (s.attachment instanceof En ? (s.attachment = s.attachment.newLinkedMesh(), this.setAttachment(s.slotIndex, s.name, s.attachment)) : (s.attachment = s.attachment.copy(), this.setAttachment(s.slotIndex, s.name, s.attachment)))
                }
            }, t.prototype.getAttachment = function (t, e) {
                const n = this.attachments[t]
                return n ? n[e] : null
            }, t.prototype.removeAttachment = function (t, e) {
                const n = this.attachments[t]
                n && (n[e] = null)
            }, t.prototype.getAttachments = function () {
                for (var t = [], e = 0; e < this.attachments.length; e++) {
                    const n = this.attachments[e]
                    if (n) {
                        for (const r in n) {
                            let i = n[r]
                            i && t.push(new $r(e, r, i))
                        }
                    }
                }
                return t
            }, t.prototype.getAttachmentsForSlot = function (t, e) {
                const n = this.attachments[t]
                if (n) {
                    for (const r in n) {
                        let i = n[r]
                        i && e.push(new $r(t, r, i))
                    }
                }
            }, t.prototype.clear = function () {
                this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0
            }, t.prototype.attachAll = function (t, e) {
                for (let n = 0, r = 0; r < t.slots.length; r++) {
                    const i = t.slots[r]
                    var o = i.getAttachment()
                    if (o && n < e.attachments.length) {
                        const a = e.attachments[n]
                        for (const s in a) {
                            if (o == a[s]) {
                                const u = this.getAttachment(n, s)
                                u && i.setAttachment(u)
                                break
                            }
                        }
                    }
                    n++
                }
            }, t
        }())
        var Qr = (function () {
            function t(t) {
                this.scale = 1, this.linkedMeshes = [], this.attachmentLoader = t
            }
            return t.prototype.readSkeletonData = function (e) {
                const n = this.scale
                var r = new qr()
                r.name = ''
                let i = new E(e)
                var o = i.readInt32()
                var a = i.readInt32()
                if (r.hash = a == 0 && o == 0 ? null : a.toString(16) + o.toString(16), r.version = i.readString(), r.version.substr(0, 3) !== '4.0') {
                    const s = `Spine 4.0 loader cant load version ${  r.version  }. Please configure your pixi-spine bundle`;
                    console.error(s)
                }
                r.x = i.readFloat(), r.y = i.readFloat(), r.width = i.readFloat(), r.height = i.readFloat()
                let u = i.readBoolean()
                u && (r.fps = i.readFloat(), r.imagesPath = i.readString(), r.audioPath = i.readString())
                let c = 0
                c = i.readInt(!0)
                for (var l = 0; l < c; l++) i.strings.push(i.readString())
                c = i.readInt(!0)
                for (l = 0; l < c; l++) {
                    const h = i.readString()
                    var f = l == 0 ? null : r.bones[i.readInt(!0)];
                    (m = new Lr(l, h, f)).rotation = i.readFloat(), m.x = i.readFloat() * n, m.y = i.readFloat() * n, m.scaleX = i.readFloat(), m.scaleY = i.readFloat(), m.shearX = i.readFloat(), m.shearY = i.readFloat(), m.length = i.readFloat() * n, m.transformMode = i.readInt(!0), m.skinRequired = i.readBoolean(), u && F.rgba8888ToColor(m.color, i.readInt32()), r.bones.push(m)
                }
                c = i.readInt(!0)
                for (l = 0; l < c; l++) {
                    const d = i.readString()
                    var p = r.bones[i.readInt(!0)]
                    var m = new Kr(l, d, p)
                    F.rgba8888ToColor(m.color, i.readInt32())
                    let y = i.readInt32(); y != -1 && F.rgb888ToColor(m.darkColor = new F(), y), m.attachmentName = i.readStringRef(), m.blendMode = t.BlendModeValues[i.readInt(!0)], r.slots.push(m)
                }
                c = i.readInt(!0)
                l = 0
                for (var v = void 0; l < c; l++) {
                    (m = new Xr(i.readString())).order = i.readInt(!0), m.skinRequired = i.readBoolean(), v = i.readInt(!0)
                    for (var g = 0; g < v; g++) m.bones.push(r.bones[i.readInt(!0)])
                    m.target = r.bones[i.readInt(!0)], m.mix = i.readFloat(), m.softness = i.readFloat() * n, m.bendDirection = i.readByte(), m.compress = i.readBoolean(), m.stretch = i.readBoolean(), m.uniform = i.readBoolean(), r.ikConstraints.push(m)
                }
                c = i.readInt(!0)
                for (l = 0, v = void 0; l < c; l++) {
                    (m = new Zr(i.readString())).order = i.readInt(!0), m.skinRequired = i.readBoolean(), v = i.readInt(!0)
                    for (g = 0; g < v; g++) m.bones.push(r.bones[i.readInt(!0)])
                    m.target = r.bones[i.readInt(!0)], m.local = i.readBoolean(), m.relative = i.readBoolean(), m.offsetRotation = i.readFloat(), m.offsetX = i.readFloat() * n, m.offsetY = i.readFloat() * n, m.offsetScaleX = i.readFloat(), m.offsetScaleY = i.readFloat(), m.offsetShearY = i.readFloat(), m.mixRotate = i.readFloat(), m.mixX = i.readFloat(), m.mixY = i.readFloat(), m.mixScaleX = i.readFloat(), m.mixScaleY = i.readFloat(), m.mixShearY = i.readFloat(), r.transformConstraints.push(m)
                }
                c = i.readInt(!0)
                for (l = 0, v = void 0; l < c; l++) {
                    (m = new Hr(i.readString())).order = i.readInt(!0), m.skinRequired = i.readBoolean(), v = i.readInt(!0)
                    for (g = 0; g < v; g++) m.bones.push(r.bones[i.readInt(!0)])
                    m.target = r.slots[i.readInt(!0)], m.positionMode = i.readInt(!0), m.spacingMode = i.readInt(!0), m.rotateMode = i.readInt(!0), m.offsetRotation = i.readFloat(), m.position = i.readFloat(), m.positionMode == _.Fixed && (m.position *= n), m.spacing = i.readFloat(), m.spacingMode != Sr.Length && m.spacingMode != Sr.Fixed || (m.spacing *= n), m.mixRotate = i.readFloat(), m.mixX = i.readFloat(), m.mixY = i.readFloat(), r.pathConstraints.push(m)
                }
                const b = this.readSkin(i, r, !0, u)
                b && (r.defaultSkin = b, r.skins.push(b))
                l = r.skins.length
                for (G.setArraySize(r.skins, c = l + i.readInt(!0)); l < c; l++) r.skins[l] = this.readSkin(i, r, !1, u)
                c = this.linkedMeshes.length
                for (l = 0; l < c; l++) {
                    const x = this.linkedMeshes[l]
                    var T = (x.skin ? r.findSkin(x.skin) : r.defaultSkin).getAttachment(x.slotIndex, x.parent)
                    x.mesh.deformAttachment = x.inheritDeform ? T : x.mesh, x.mesh.setParentMesh(T)
                }
                this.linkedMeshes.length = 0, c = i.readInt(!0)
                for (l = 0; l < c; l++) {
                    (m = new Ur(i.readStringRef())).intValue = i.readInt(!1), m.floatValue = i.readFloat(), m.stringValue = i.readString(), m.audioPath = i.readString(), m.audioPath && (m.volume = i.readFloat(), m.balance = i.readFloat()), r.events.push(m)
                }
                c = i.readInt(!0)
                for (l = 0; l < c; l++) r.animations.push(this.readAnimation(i, i.readString(), r))
                return r
            }, t.prototype.readSkin = function (t, e, n, r) {
                let i = null
                var o = 0
                if (n) {
                    if ((o = t.readInt(!0)) == 0) return null
                    i = new Jr('default')
                } else {
                    (i = new Jr(t.readStringRef())).bones.length = t.readInt(!0)
                    for (var a = 0, s = i.bones.length; a < s; a++) i.bones[a] = e.bones[t.readInt(!0)]
                    for (a = 0, s = t.readInt(!0); a < s; a++) i.constraints.push(e.ikConstraints[t.readInt(!0)])
                    for (a = 0, s = t.readInt(!0); a < s; a++) i.constraints.push(e.transformConstraints[t.readInt(!0)])
                    for (a = 0, s = t.readInt(!0); a < s; a++) i.constraints.push(e.pathConstraints[t.readInt(!0)])
                    o = t.readInt(!0)
                }
                for (a = 0; a < o; a++) {
                    for (let u = t.readInt(!0), c = 0, l = t.readInt(!0); c < l; c++) {
                        let h = t.readStringRef()
                                    var f = this.readAttachment(t, e, i, u, h, r)
                        f && i.setAttachment(u, h, f)
                    }
                }
                return i
            }, t.prototype.readAttachment = function (t, e, n, r, i, o) {
                const s = this.scale
                var u = t.readStringRef()
                switch (u || (u = i), t.readByte()) {
                    case a.Region:
                        var c = t.readStringRef()
                        var l = t.readFloat()
                        var h = t.readFloat()
                        var f = t.readFloat()
                        var d = t.readFloat()
                        var p = t.readFloat()
                        var m = t.readFloat()
                        var y = t.readFloat()
                        var v = t.readInt32()
                        c || (c = u)
                        var _ = this.attachmentLoader.newRegionAttachment(n, u, c)
                        return _ ? (_.path = c, _.x = h * s, _.y = f * s, _.scaleX = d, _.scaleY = p, _.rotation = l, _.width = m * s, _.height = y * s, F.rgba8888ToColor(_.color, v), _) : null
                    case a.BoundingBox:
                        var g = t.readInt(!0)
                        var b = this.readVertices(t, g)
                        var E = (v = o ? t.readInt32() : 0, this.attachmentLoader.newBoundingBoxAttachment(n, u))
                        return E ? (E.worldVerticesLength = g << 1, E.vertices = b.vertices, E.bones = b.bones, o && F.rgba8888ToColor(E.color, v), E) : null
                    case a.Mesh:
                        c = t.readStringRef(), v = t.readInt32(), g = t.readInt(!0)
                        var x = this.readFloatArray(t, g << 1, 1)
                        var T = this.readShortArray(t)
                        var S = (b = this.readVertices(t, g), t.readInt(!0))
                        var w = null
                        m = 0, y = 0
                        return o && (w = this.readShortArray(t), m = t.readFloat(), y = t.readFloat()), c || (c = u), (O = this.attachmentLoader.newMeshAttachment(n, u, c)) ? (O.path = c, F.rgba8888ToColor(O.color, v), O.bones = b.bones, O.vertices = b.vertices, O.worldVerticesLength = g << 1, O.triangles = T, O.regionUVs = new Float32Array(x), O.hullLength = S << 1, o && (O.edges = w, O.width = m * s, O.height = y * s), O) : null
                    case a.LinkedMesh:
                        c = t.readStringRef(), v = t.readInt32()
                        var O; var P = t.readStringRef()
                        var R = t.readStringRef()
                        var A = t.readBoolean()
                        m = 0, y = 0
                        return o && (m = t.readFloat(), y = t.readFloat()), c || (c = u), (O = this.attachmentLoader.newMeshAttachment(n, u, c)) ? (O.path = c, F.rgba8888ToColor(O.color, v), o && (O.width = m * s, O.height = y * s), this.linkedMeshes.push(new ti(O, P, r, R, A)), O) : null
                    case a.Path:
                        for (var I = t.readBoolean(), C = t.readBoolean(), k = (g = t.readInt(!0), b = this.readVertices(t, g), G.newArray(g / 3, 0)), N = 0, M = k.length; N < M; N++) k[N] = t.readFloat() * s
                        v = o ? t.readInt32() : 0
                        return (c = this.attachmentLoader.newPathAttachment(n, u)) ? (c.closed = I, c.constantSpeed = C, c.worldVerticesLength = g << 1, c.vertices = b.vertices, c.bones = b.bones, c.lengths = k, o && F.rgba8888ToColor(c.color, v), c) : null
                    case a.Point:
                        l = t.readFloat(), h = t.readFloat(), f = t.readFloat(), v = o ? t.readInt32() : 0
                        var j = this.attachmentLoader.newPointAttachment(n, u)
                        return j ? (j.x = h * s, j.y = f * s, j.rotation = l, o && F.rgba8888ToColor(j.color, v), j) : null
                    case a.Clipping:
                        var D = t.readInt(!0)
                        var L = (g = t.readInt(!0), b = this.readVertices(t, g), v = o ? t.readInt32() : 0, this.attachmentLoader.newClippingAttachment(n, u))
                        return L ? (L.endSlot = e.slots[D], L.worldVerticesLength = g << 1, L.vertices = b.vertices, L.bones = b.bones, o && F.rgba8888ToColor(L.color, v), L) : null
                }
                return null
            }, t.prototype.readVertices = function (t, e) {
                const n = this.scale
                var r = e << 1
                var i = new ei()
                if (!t.readBoolean()) return i.vertices = this.readFloatArray(t, r, n), i
                for (var o = [], a = [], s = 0; s < e; s++) {
                    const u = t.readInt(!0)
                    a.push(u)
                    for (let c = 0; c < u; c++) a.push(t.readInt(!0)), o.push(t.readFloat() * n), o.push(t.readFloat() * n), o.push(t.readFloat())
                }
                return i.vertices = G.toFloatArray(o), i.bones = a, i
            }, t.prototype.readFloatArray = function (t, e, n) {
                const r = new Array(e)
                if (n == 1) {
                    for (var i = 0; i < e; i++) r[i] = t.readFloat()
                }
                else {
                    for (i = 0; i < e; i++) r[i] = t.readFloat() * n
                }
                return r
            }, t.prototype.readShortArray = function (t) {
                for (var e = t.readInt(!0), n = new Array(e), r = 0; r < e; r++) n[r] = t.readShort()
                return n
            }, t.prototype.readAnimation = function (t, e, n) {
                t.readInt(!0)
                for (var r = [], i = this.scale, o = 0, a = t.readInt(!0); o < a; o++) {
                    for (var s = t.readInt(!0), u = 0, c = t.readInt(!0); u < c; u++) {
                        let l = t.readByte()
                                    var h = (D = t.readInt(!0)) - 1
                        switch (l) {
                            case mi:
                                for (var f = new fr(D, s), d = 0; d < D; d++) f.setFrame(d, t.readFloat(), t.readStringRef())
                                r.push(f)
                                break;
                            case yi:
                                for (var p = t.readInt(!0), m = (f = new sr(D, p, s), t.readFloat()), y = t.readUnsignedByte() / 255, v = t.readUnsignedByte() / 255, g = t.readUnsignedByte() / 255, b = t.readUnsignedByte() / 255, E = (d = 0, 0); f.setFrame(d, m, y, v, g, b), d != h; d++) {
                                    var x = t.readFloat()
                                                var T = t.readUnsignedByte() / 255
                                                var S = t.readUnsignedByte() / 255
                                                var w = t.readUnsignedByte() / 255
                                                var O = t.readUnsignedByte() / 255
                                    switch (t.readByte()) {
                                        case Si:
                                            f.setStepped(d)
                                            break;
                                        case wi:
                                            ii(t, f, E++, d, 0, m, x, y, T, 1), ii(t, f, E++, d, 1, m, x, v, S, 1), ii(t, f, E++, d, 2, m, x, g, w, 1), ii(t, f, E++, d, 3, m, x, b, O, 1)
                                    }
                                    m = x, y = T, v = S, g = w, b = O
                                }
                                r.push(f)
                                break;
                            case vi:
                                for (p = t.readInt(!0), f = new ur(D, p, s), m = t.readFloat(), y = t.readUnsignedByte() / 255, v = t.readUnsignedByte() / 255, g = t.readUnsignedByte() / 255, d = 0, E = 0; f.setFrame(d, m, y, v, g), d != h; d++) {
                                    x = t.readFloat(), T = t.readUnsignedByte() / 255, S = t.readUnsignedByte() / 255, w = t.readUnsignedByte() / 255
                                    switch (t.readByte()) {
                                        case Si:
                                            f.setStepped(d)
                                            break;
                                        case wi:
                                            ii(t, f, E++, d, 0, m, x, y, T, 1), ii(t, f, E++, d, 1, m, x, v, S, 1), ii(t, f, E++, d, 2, m, x, g, w, 1)
                                    }
                                    m = x, y = T, v = S, g = w
                                }
                                r.push(f)
                                break;
                            case _i:
                                for (p = t.readInt(!0), f = new lr(D, p, s), m = t.readFloat(), y = t.readUnsignedByte() / 255, v = t.readUnsignedByte() / 255, g = t.readUnsignedByte() / 255, b = t.readUnsignedByte() / 255, T = t.readUnsignedByte() / 255, S = t.readUnsignedByte() / 255, w = t.readUnsignedByte() / 255, d = 0, E = 0; f.setFrame(d, m, y, v, g, b, T, S, w), d != h; d++) {
                                    x = t.readFloat()
                                    var P = t.readUnsignedByte() / 255
                                                var R = t.readUnsignedByte() / 255
                                                var A = t.readUnsignedByte() / 255
                                                var I = t.readUnsignedByte() / 255
                                                var C = t.readUnsignedByte() / 255
                                                var k = t.readUnsignedByte() / 255
                                                var N = t.readUnsignedByte() / 255
                                    switch (t.readByte()) {
                                        case Si:
                                            f.setStepped(d)
                                            break;
                                        case wi:
                                            ii(t, f, E++, d, 0, m, x, y, P, 1), ii(t, f, E++, d, 1, m, x, v, R, 1), ii(t, f, E++, d, 2, m, x, g, A, 1), ii(t, f, E++, d, 3, m, x, b, I, 1), ii(t, f, E++, d, 4, m, x, T, C, 1), ii(t, f, E++, d, 5, m, x, S, k, 1), ii(t, f, E++, d, 6, m, x, w, N, 1)
                                    }
                                    m = x, y = P, v = R, g = A, b = I, T = C, S = k, w = N
                                }
                                r.push(f)
                                break;
                            case gi:
                                for (p = t.readInt(!0), f = new hr(D, p, s), m = t.readFloat(), y = t.readUnsignedByte() / 255, v = t.readUnsignedByte() / 255, g = t.readUnsignedByte() / 255, T = t.readUnsignedByte() / 255, S = t.readUnsignedByte() / 255, w = t.readUnsignedByte() / 255, d = 0, E = 0; f.setFrame(d, m, y, v, g, T, S, w), d != h; d++) {
                                    x = t.readFloat(), P = t.readUnsignedByte() / 255, R = t.readUnsignedByte() / 255, A = t.readUnsignedByte() / 255, C = t.readUnsignedByte() / 255, k = t.readUnsignedByte() / 255, N = t.readUnsignedByte() / 255
                                    switch (t.readByte()) {
                                        case Si:
                                            f.setStepped(d)
                                            break;
                                        case wi:
                                            ii(t, f, E++, d, 0, m, x, y, P, 1), ii(t, f, E++, d, 1, m, x, v, R, 1), ii(t, f, E++, d, 2, m, x, g, A, 1), ii(t, f, E++, d, 3, m, x, T, C, 1), ii(t, f, E++, d, 4, m, x, S, k, 1), ii(t, f, E++, d, 5, m, x, w, N, 1)
                                    }
                                    m = x, y = P, v = R, g = A, T = C, S = k, w = N
                                }
                                r.push(f)
                                break;
                            case bi:
                                for (f = new cr(D, t.readInt(!0), s), m = t.readFloat(), b = t.readUnsignedByte() / 255, d = 0, E = 0; f.setFrame(d, m, b), d != h; d++) {
                                    x = t.readFloat(), O = t.readUnsignedByte() / 255
                                    switch (t.readByte()) {
                                        case Si:
                                            f.setStepped(d)
                                            break;
                                        case wi:
                                            ii(t, f, E++, d, 0, m, x, b, O, 1)
                                    }
                                    m = x, b = O
                                }
                                r.push(f)
                        }
                    }
                }
                for (o = 0, a = t.readInt(!0); o < a; o++) {
                    const M = t.readInt(!0)
                    for (u = 0, c = t.readInt(!0); u < c; u++) {
                        const j = t.readByte()
                        var D = t.readInt(!0)
                        p = t.readInt(!0)
                        switch (j) {
                            case oi:
                                r.push(ni(t, new $n(D, p, M), 1))
                                break
                            case ai:
                                r.push(ri(t, new Jn(D, p, M), i))
                                break
                            case si:
                                r.push(ni(t, new Qn(D, p, M), i))
                                break
                            case ui:
                                r.push(ni(t, new tr(D, p, M), i))
                                break
                            case ci:
                                r.push(ri(t, new er(D, p, M), 1))
                                break
                            case li:
                                r.push(ni(t, new nr(D, p, M), 1))
                                break
                            case hi:
                                r.push(ni(t, new rr(D, p, M), 1))
                                break
                            case fi:
                                r.push(ri(t, new ir(D, p, M), 1))
                                break
                            case di:
                                r.push(ni(t, new or(D, p, M), 1))
                                break
                            case pi:
                                r.push(ni(t, new ar(D, p, M), 1))
                        }
                    }
                }
                for (o = 0, a = t.readInt(!0); o < a; o++) {
                    var L = t.readInt(!0)
                    var F = (h = (D = t.readInt(!0)) - 1, f = new yr(D, t.readInt(!0), L), m = t.readFloat(), t.readFloat())
                    var B = t.readFloat() * i
                    for (d = 0, E = 0; f.setFrame(d, m, F, B, t.readByte(), t.readBoolean(), t.readBoolean()), d != h; d++) {
                        x = t.readFloat()
                        let U = t.readFloat()
                        var X = t.readFloat() * i
                        switch (t.readByte()) {
                            case Si:
                                f.setStepped(d)
                                break
                            case wi:
                                ii(t, f, E++, d, 0, m, x, F, U, 1), ii(t, f, E++, d, 1, m, x, B, X, i)
                        }
                        m = x, F = U, B = X
                    }
                    r.push(f)
                }
                for (o = 0, a = t.readInt(!0); o < a; o++) {
                    L = t.readInt(!0), h = (D = t.readInt(!0)) - 1, f = new vr(D, t.readInt(!0), L), m = t.readFloat()
                    var H = t.readFloat()
                    var V = t.readFloat()
                    var W = t.readFloat()
                    var Y = t.readFloat()
                    var z = t.readFloat()
                    var q = t.readFloat()
                    for (d = 0, E = 0; f.setFrame(d, m, H, V, W, Y, z, q), d != h; d++) {
                        x = t.readFloat()
                        var K = t.readFloat()
                        var Z = t.readFloat()
                        var $ = t.readFloat()
                        var J = t.readFloat()
                        var Q = t.readFloat()
                        var tt = t.readFloat()
                        switch (t.readByte()) {
                            case Si:
                                f.setStepped(d)
                                break
                            case wi:
                                ii(t, f, E++, d, 0, m, x, H, K, 1), ii(t, f, E++, d, 1, m, x, V, Z, 1), ii(t, f, E++, d, 2, m, x, W, $, 1), ii(t, f, E++, d, 3, m, x, Y, J, 1), ii(t, f, E++, d, 4, m, x, z, Q, 1), ii(t, f, E++, d, 5, m, x, q, tt, 1)
                        }
                        m = x, H = K, V = Z, W = $, Y = J, z = Q, q = tt
                    }
                    r.push(f)
                }
                for (o = 0, a = t.readInt(!0); o < a; o++) {
                    L = t.readInt(!0)
                    let et = n.pathConstraints[L]
                    for (u = 0, c = t.readInt(!0); u < c; u++) { switch (t.readByte()) {
                        case Ei:
                            r.push(ni(t, new _r(t.readInt(!0), t.readInt(!0), L), et.positionMode == _.Fixed ? i : 1))
                            break;
                        case xi:
                            r.push(ni(t, new gr(t.readInt(!0), t.readInt(!0), L), et.spacingMode == Sr.Length || et.spacingMode == Sr.Fixed ? i : 1))
                            break;
                        case Ti:
                            for (f = new br(t.readInt(!0), t.readInt(!0), L), m = t.readFloat(), H = t.readFloat(), V = t.readFloat(), W = t.readFloat(), d = 0, E = 0, h = f.getFrameCount() - 1; f.setFrame(d, m, H, V, W), d != h; d++) {
                                x = t.readFloat(), K = t.readFloat(), Z = t.readFloat(), $ = t.readFloat()
                                switch (t.readByte()) {
                                    case Si:
                                        f.setStepped(d)
                                        break;
                                    case wi:
                                        ii(t, f, E++, d, 0, m, x, H, K, 1), ii(t, f, E++, d, 1, m, x, V, Z, 1), ii(t, f, E++, d, 2, m, x, W, $, 1)
                                }
                                m = x, H = K, V = Z, W = $
                            }
                            r.push(f)
                    }
                    }
                }
                for (o = 0, a = t.readInt(!0); o < a; o++) {
                    const nt = n.skins[t.readInt(!0)]
                    for (u = 0, c = t.readInt(!0); u < c; u++) {
                        s = t.readInt(!0)
                        for (let rt = 0, it = t.readInt(!0); rt < it; rt++) {
                            const ot = t.readStringRef()
                            var at = nt.getAttachment(s, ot)
                            var st = at.bones
                            var ut = at.vertices
                            var ct = st ? ut.length / 3 * 2 : ut.length
                            for (h = (D = t.readInt(!0)) - 1, p = t.readInt(!0), f = new dr(D, p, s, at), m = t.readFloat(), d = 0, E = 0; ; d++) {
                                let lt = void 0
                                var ht = t.readInt(!0)
                                if (ht == 0) { lt = st ? G.newFloatArray(ct) : ut
                                }
                                else {
                                    lt = G.newFloatArray(ct)
                                    let ft = t.readInt(!0)
                                    if (ht += ft, i == 1) {
                                        for (var dt = ft; dt < ht; dt++) lt[dt] = t.readFloat()
                                    }
                                    else {
                                        for (dt = ft; dt < ht; dt++) lt[dt] = t.readFloat() * i
                                    }
                                    if (!st) {
                                        dt = 0
                                        for (let pt = lt.length; dt < pt; dt++) lt[dt] += ut[dt]
                                    }
                                }
                                if (f.setFrame(d, m, lt), d == h) break
                                x = t.readFloat()
                                switch (t.readByte()) {
                                    case Si:
                                        f.setStepped(d)
                                        break
                                    case wi:
                                        ii(t, f, E++, d, 0, m, x, 0, 1, 1)
                                }
                                m = x
                            }
                            r.push(f)
                        }
                    }
                }
                const mt = t.readInt(!0)
                if (mt > 0) {
                    f = new mr(mt)
                    let yt = n.slots.length
                    for (o = 0; o < mt; o++) {
                        m = t.readFloat()
                        let vt = t.readInt(!0)
                        var _t = G.newArray(yt, 0)
                        for (u = yt - 1; u >= 0; u--) _t[u] = -1
                        let gt = G.newArray(yt - vt, 0)
                        var bt = 0
                        var Et = 0
                        for (u = 0; u < vt; u++) {
                            for (s = t.readInt(!0); bt != s;) gt[Et++] = bt++
                            _t[bt + t.readInt(!0)] = bt++
                        }
                        for (; bt < yt;) gt[Et++] = bt++
                        for (u = yt - 1; u >= 0; u--) _t[u] == -1 && (_t[u] = gt[--Et])
                        f.setFrame(o, m, _t)
                    }
                    r.push(f)
                }
                const xt = t.readInt(!0)
                if (xt > 0) {
                    for (f = new pr(xt), o = 0; o < xt; o++) {
                        m = t.readFloat()
                        let Tt = n.events[t.readInt(!0)]
                        var St = new Br(m, Tt)
                        St.intValue = t.readInt(!1), St.floatValue = t.readFloat(), St.stringValue = t.readBoolean() ? t.readString() : Tt.stringValue, St.data.audioPath && (St.volume = t.readFloat(), St.balance = t.readFloat()), f.setFrame(o, St)
                    }
                    r.push(f)
                }
                let wt = 0
                for (o = 0, a = r.length; o < a; o++) wt = Math.max(wt, r[o].getDuration())
                return new Pn(e, r, wt)
            }, t.BlendModeValues = [c.b.NORMAL, c.b.ADD, c.b.MULTIPLY, c.b.SCREEN], t
        }())
        var ti = function (t, e, n, r, i) {
            this.mesh = t, this.skin = e, this.slotIndex = n, this.parent = r, this.inheritDeform = i
        }
        var ei = function (t, e) {
            void 0 === t && (t = null), void 0 === e && (e = null), this.bones = t, this.vertices = e
        }

        function ni(t, e, n) {
            for (let r = t.readFloat(), i = t.readFloat() * n, o = 0, a = 0, s = e.getFrameCount() - 1; e.setFrame(o, r, i), o != s; o++) {
                const u = t.readFloat()
                const c = t.readFloat() * n
                switch (t.readByte()) {
                    case Si:
                        e.setStepped(o)
                        break
                    case wi:
                        ii(t, e, a++, o, 0, r, u, i, c, n)
                }
                r = u, i = c
            }
            return e
        }

        function ri(t, e, n) {
            for (let r = t.readFloat(), i = t.readFloat() * n, o = t.readFloat() * n, a = 0, s = 0, u = e.getFrameCount() - 1; e.setFrame(a, r, i, o), a != u; a++) {
                const c = t.readFloat()
                const l = t.readFloat() * n
                const h = t.readFloat() * n
                switch (t.readByte()) {
                    case Si:
                        e.setStepped(a)
                        break
                    case wi:
                        ii(t, e, s++, a, 0, r, c, i, l, n), ii(t, e, s++, a, 1, r, c, o, h, n)
                }
                r = c, i = l, o = h
            }
            return e
        }

        function ii(t, e, n, r, i, o, a, s, u, c) {
            e.setBezier(n, r, i, o, s, t.readFloat(), t.readFloat() * c, t.readFloat(), t.readFloat() * c, a, u)
        }
        var oi = 0
        var ai = 1
        var si = 2
        var ui = 3
        var ci = 4
        var li = 5
        var hi = 6
        var fi = 7
        var di = 8
        var pi = 9
        var mi = 0
        var yi = 1
        var vi = 2
        var _i = 3
        var gi = 4
        var bi = 5
        var Ei = 0
        var xi = 1
        var Ti = 2
        var Si = 1
        var wi = 2
        var Oi = (function () {
            function t() {
                this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = [], this.polygons = [], this.polygonPool = new X(() => {
                    return G.newFloatArray(16)
                })
            }
            return t.prototype.update = function (t, e) {
                if (t == null) throw new Error('skeleton cannot be null.')
                let n = this.boundingBoxes
                var r = this.polygons
                var i = this.polygonPool
                var o = t.slots
                var a = o.length
                n.length = 0, i.freeAll(r), r.length = 0
                for (let s = 0; s < a; s++) {
                    const u = o[s]
                    if (u.bone.active) {
                        const c = u.getAttachment()
                        if (c instanceof gn) {
                            const l = c
                            n.push(l)
                            let h = i.obtain()
                            h.length != l.worldVerticesLength && (h = G.newFloatArray(l.worldVerticesLength)), r.push(h), l.computeWorldVertices(u, 0, l.worldVerticesLength, h, 0, 2)
                        }
                    }
                }
                e ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY)
            }, t.prototype.aabbCompute = function () {
                for (var t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, r = Number.NEGATIVE_INFINITY, i = this.polygons, o = 0, a = i.length; o < a; o++) {
                    for (let s = i[o], u = s, c = 0, l = s.length; c < l; c += 2) {
                        let h = u[c]
                                    var f = u[c + 1]
                        t = Math.min(t, h), e = Math.min(e, f), n = Math.max(n, h), r = Math.max(r, f)
                    }
                }
                this.minX = t, this.minY = e, this.maxX = n, this.maxY = r
            }, t.prototype.aabbContainsPoint = function (t, e) {
                return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
            }, t.prototype.aabbIntersectsSegment = function (t, e, n, r) {
                const i = this.minX
                var o = this.minY
                var a = this.maxX
                var s = this.maxY
                if (t <= i && n <= i || e <= o && r <= o || t >= a && n >= a || e >= s && r >= s) return !1
                let u = (r - e) / (n - t)
                var c = u * (i - t) + e
                if (c > o && c < s) return !0
                if ((c = u * (a - t) + e) > o && c < s) return !0
                let l = (o - e) / u + t
                return l > i && l < a || (l = (s - e) / u + t) > i && l < a
            }, t.prototype.aabbIntersectsSkeleton = function (t) {
                return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
            }, t.prototype.containsPoint = function (t, e) {
                for (let n = this.polygons, r = 0, i = n.length; r < i; r++) {
                    if (this.containsPointPolygon(n[r], t, e)) return this.boundingBoxes[r]
                }
                return null
            }, t.prototype.containsPointPolygon = function (t, e, n) {
                for (var r = t, i = t.length, o = i - 2, a = !1, s = 0; s < i; s += 2) {
                    const u = r[s + 1]
                    var c = r[o + 1]
                    if (u < n && c >= n || c < n && u >= n) {
                        const l = r[s]
                        l + (n - u) / (c - u) * (r[o] - l) < e && (a = !a)
                    }
                    o = s
                }
                return a
            }, t.prototype.intersectsSegment = function (t, e, n, r) {
                for (let i = this.polygons, o = 0, a = i.length; o < a; o++) {
                    if (this.intersectsSegmentPolygon(i[o], t, e, n, r)) return this.boundingBoxes[o]
                }
                return null
            }, t.prototype.intersectsSegmentPolygon = function (t, e, n, r, i) {
                for (let o = t, a = t.length, s = e - r, u = n - i, c = e * i - n * r, l = o[a - 2], h = o[a - 1], f = 0; f < a; f += 2) {
                    const d = o[f]
                    var p = o[f + 1]
                    var m = l * p - h * d
                    var y = l - d
                    var v = h - p
                    var _ = s * v - u * y
                    var g = (c * y - s * m) / _
                    if ((g >= l && g <= d || g >= d && g <= l) && (g >= e && g <= r || g >= r && g <= e)) {
                        const b = (c * v - u * m) / _
                        if ((b >= h && b <= p || b >= p && b <= h) && (b >= n && b <= i || b >= i && b <= n)) return !0
                    }
                    l = d, h = p
                }
                return !1
            }, t.prototype.getPolygon = function (t) {
                if (t == null) throw new Error('boundingBox cannot be null.')
                let e = this.boundingBoxes.indexOf(t)
                return e == -1 ? null : this.polygons[e]
            }, t.prototype.getWidth = function () {
                return this.maxX - this.minX
            }, t.prototype.getHeight = function () {
                return this.maxY - this.minY
            }, t
        }())
        var Pi = (function () {
            function t(t) {
                this.scale = 1, this.linkedMeshes = [], this.attachmentLoader = t
            }
            return t.prototype.readSkeletonData = function (e) {
                const n = this.scale
                var r = new qr()
                var i = typeof e == 'string' ? JSON.parse(e) : e
                var o = i.skeleton
                if (o) {
                    if (r.hash = o.hash, r.version = o.spine, r.version.substr(0, 3) !== '4.0') {
                        const a = `Spine 4.0 loader cant load version ${  o.spine  }. Please configure your pixi-spine bundle`;
                        console.error(a)
                    }
                    r.x = o.x, r.y = o.y, r.width = o.width, r.height = o.height, r.fps = o.fps, r.imagesPath = o.images
                }
                if (i.bones) {
                    for (var s = 0; s < i.bones.length; s++) {
                        let u = i.bones[s]
                                    var c = null
                                    var l = ki(u, 'parent', null)
                        if (l != null && (c = r.findBone(l)) == null) throw new Error(`Parent bone not found: ${  l}`);
                        (m = new Lr(r.bones.length, u.name, c)).length = ki(u, 'length', 0) * n, m.x = ki(u, 'x', 0) * n, m.y = ki(u, 'y', 0) * n, m.rotation = ki(u, 'rotation', 0), m.scaleX = ki(u, 'scaleX', 1), m.scaleY = ki(u, 'scaleY', 1), m.shearX = ki(u, 'shearX', 0), m.shearY = ki(u, 'shearY', 0), m.transformMode = G.enumValue(b, ki(u, 'transform', 'Normal')), m.skinRequired = ki(u, 'skin', !1), (p = ki(u, 'color', null)) && m.color.setFromString(p), r.bones.push(m)
                    }
                }
                if (i.slots) {
                    for (s = 0; s < i.slots.length; s++) {
                        var h = (R = i.slots[s]).name
                                    var f = R.bone
                                    var d = r.findBone(f)
                        if (d == null) throw new Error(`Slot bone not found: ${  f}`)
                        var p; var m = new Kr(r.slots.length, h, d);
                        (p = ki(R, 'color', null)) && m.color.setFromString(p)
                        var y = ki(R, 'dark', null)
                        y && (m.darkColor = F.fromString(y)), m.attachmentName = ki(R, 'attachment', null), m.blendMode = t.blendModeFromString(ki(R, 'blend', 'normal')), r.slots.push(m)
                    }
                }
                if (i.ik) {
                    for (s = 0; s < i.ik.length; s++) {
                        var v = i.ik[s];
                        (m = new Xr(v.name)).order = ki(v, 'order', 0), m.skinRequired = ki(v, 'skin', !1)
                        for (var E = 0; E < v.bones.length; E++) {
                            f = v.bones[E]
                            if ((w = r.findBone(f)) == null) throw new Error(`IK bone not found: ${  f}`)
                            m.bones.push(w)
                        }
                        m.target = r.findBone(v.target), m.mix = ki(v, 'mix', 1), m.softness = ki(v, 'softness', 0) * n, m.bendDirection = ki(v, 'bendPositive', !0) ? 1 : -1, m.compress = ki(v, 'compress', !1), m.stretch = ki(v, 'stretch', !1), m.uniform = ki(v, 'uniform', !1), r.ikConstraints.push(m)
                    }
                }
                if (i.transform) {
                    for (s = 0; s < i.transform.length; s++) {
                        v = i.transform[s];
                        (m = new Zr(v.name)).order = ki(v, 'order', 0), m.skinRequired = ki(v, 'skin', !1)
                        for (E = 0; E < v.bones.length; E++) {
                            f = v.bones[E]
                            if ((w = r.findBone(f)) == null) throw new Error(`Transform constraint bone not found: ${  f}`)
                            m.bones.push(w)
                        }
                        var x = v.target
                        if (m.target = r.findBone(x), m.target == null) throw new Error(`Transform constraint target bone not found: ${  x}`)
                        m.local = ki(v, 'local', !1), m.relative = ki(v, 'relative', !1), m.offsetRotation = ki(v, 'rotation', 0), m.offsetX = ki(v, 'x', 0) * n, m.offsetY = ki(v, 'y', 0) * n, m.offsetScaleX = ki(v, 'scaleX', 0), m.offsetScaleY = ki(v, 'scaleY', 0), m.offsetShearY = ki(v, 'shearY', 0), m.mixRotate = ki(v, 'mixRotate', 1), m.mixX = ki(v, 'mixX', 1), m.mixY = ki(v, 'mixY', m.mixX), m.mixScaleX = ki(v, 'mixScaleX', 1), m.mixScaleY = ki(v, 'mixScaleY', m.mixScaleX), m.mixShearY = ki(v, 'mixShearY', 1), r.transformConstraints.push(m)
                    }
                }
                if (i.path) {
                    for (s = 0; s < i.path.length; s++) {
                        v = i.path[s];
                        (m = new Hr(v.name)).order = ki(v, 'order', 0), m.skinRequired = ki(v, 'skin', !1)
                        for (E = 0; E < v.bones.length; E++) {
                            f = v.bones[E]
                            if ((w = r.findBone(f)) == null) throw new Error(`Transform constraint bone not found: ${  f}`)
                            m.bones.push(w)
                        }
                        x = v.target
                        if (m.target = r.findSlot(x), m.target == null) throw new Error(`Path target slot not found: ${  x}`)
                        m.positionMode = G.enumValue(_, ki(v, 'positionMode', 'Percent')), m.spacingMode = G.enumValue(Sr, ki(v, 'spacingMode', 'Length')), m.rotateMode = G.enumValue(g, ki(v, 'rotateMode', 'Tangent')), m.offsetRotation = ki(v, 'rotation', 0), m.position = ki(v, 'position', 0), m.positionMode == _.Fixed && (m.position *= n), m.spacing = ki(v, 'spacing', 0), m.spacingMode != Sr.Length && m.spacingMode != Sr.Fixed || (m.spacing *= n), m.mixRotate = ki(v, 'mixRotate', 1), m.mixX = ki(v, 'mixX', 1), m.mixY = ki(v, 'mixY', m.mixX), r.pathConstraints.push(m)
                    }
                }
                if (i.skins) {
                    for (s = 0; s < i.skins.length; s++) {
                        let T = i.skins[s]
                                    var S = new Jr(T.name)
                        if (T.bones) {
                            for (E = 0; E < T.bones.length; E++) {
                                var w
                                        if ((w = r.findBone(T.bones[E])) == null) throw new Error('Skin bone not found: ' + T.bones[s])
                                        S.bones.push(w)
                            }
                        }
                        if (T.ik) {
                            for (E = 0; E < T.ik.length; E++) {
                                if ((O = r.findIkConstraint(T.ik[E])) == null) throw new Error('Skin IK constraint not found: ' + T.ik[s])
                                        S.constraints.push(O)
                            }
                        }
                        if (T.transform) {
                            for (E = 0; E < T.transform.length; E++) {
                                if ((O = r.findTransformConstraint(T.transform[E])) == null) throw new Error('Skin transform constraint not found: ' + T.transform[s])
                                        S.constraints.push(O)
                            }
                        }
                        if (T.path) {
                            for (E = 0; E < T.path.length; E++) {
                                var O
                                        if ((O = r.findPathConstraint(T.path[E])) == null) throw new Error('Skin path constraint not found: ' + T.path[s])
                                        S.constraints.push(O)
                            }
                        }
                        for (var h in T.attachments) {
                            let P = r.findSlot(h)
                            if (P == null) throw new Error(`Slot not found: ${  h}`)
                            var R = T.attachments[h]
                            for (const A in R) {
                                let I = this.readAttachment(R[A], S, P.index, A, r)
                                I && S.setAttachment(P.index, A, I)
                            }
                        }
                        r.skins.push(S), S.name == 'default' && (r.defaultSkin = S)
                    }
                }
                s = 0
                for (let C = this.linkedMeshes.length; s < C; s++) {
                    const k = this.linkedMeshes[s]
                    var N = (S = k.skin ? r.findSkin(k.skin) : r.defaultSkin).getAttachment(k.slotIndex, k.parent)
                    k.mesh.deformAttachment = k.inheritDeform ? N : k.mesh, k.mesh.setParentMesh(N)
                }
                if (this.linkedMeshes.length = 0, i.events) {
                    for (const M in i.events) {
                        let j = i.events[M];
                        (m = new Ur(M)).intValue = ki(j, 'int', 0), m.floatValue = ki(j, 'float', 0), m.stringValue = ki(j, 'string', ''), m.audioPath = ki(j, 'audio', null), m.audioPath && (m.volume = ki(j, 'volume', 1), m.balance = ki(j, 'balance', 0)), r.events.push(m)
                    }
                }
                if (i.animations) {
                    for (const D in i.animations) {
                        let L = i.animations[D]
                        this.readAnimation(L, D, r)
                    }
                }
                return r
            }, t.prototype.readAttachment = function (t, e, n, r, i) {
                const o = this.scale
                switch (r = ki(t, 'name', r), ki(t, 'type', 'region')) {
                    case 'region':
                        var a = ki(t, 'path', r)
                        var s = this.attachmentLoader.newRegionAttachment(e, r, a)
                        return s ? (s.path = a, s.x = ki(t, 'x', 0) * o, s.y = ki(t, 'y', 0) * o, s.scaleX = ki(t, 'scaleX', 1), s.scaleY = ki(t, 'scaleY', 1), s.rotation = ki(t, 'rotation', 0), s.width = t.width * o, s.height = t.height * o, (g = ki(t, 'color', null)) && s.color.setFromString(g), s) : null
                    case 'boundingbox':
                        var u = this.attachmentLoader.newBoundingBoxAttachment(e, r)
                        return u ? (this.readVertices(t, u, t.vertexCount << 1), (g = ki(t, 'color', null)) && u.color.setFromString(g), u) : null
                    case 'mesh':
                    case 'linkedmesh':
                        a = ki(t, 'path', r)
                        var c = this.attachmentLoader.newMeshAttachment(e, r, a)
                        if (!c) return null
                        c.path = a, (g = ki(t, 'color', null)) && c.color.setFromString(g), c.width = ki(t, 'width', 0) * o, c.height = ki(t, 'height', 0) * o
                        var l = ki(t, 'parent', null)
                        if (l) return this.linkedMeshes.push(new Ri(c, ki(t, 'skin', null), n, l, ki(t, 'deform', !0))), c
                        var h = t.uvs
                        return this.readVertices(t, c, h.length), c.triangles = t.triangles, c.regionUVs = new Float32Array(h), c.edges = ki(t, 'edges', null), c.hullLength = 2 * ki(t, 'hull', 0), c
                    case 'path':
                        if (!(a = this.attachmentLoader.newPathAttachment(e, r))) return null
                        a.closed = ki(t, 'closed', !1), a.constantSpeed = ki(t, 'constantSpeed', !0)
                        var f = t.vertexCount
                        this.readVertices(t, a, f << 1)
                        for (var d = G.newArray(f / 3, 0), p = 0; p < t.lengths.length; p++) d[p] = t.lengths[p] * o
                        return a.lengths = d, (g = ki(t, 'color', null)) && a.color.setFromString(g), a
                    case 'point':
                        var m = this.attachmentLoader.newPointAttachment(e, r)
                        return m ? (m.x = ki(t, 'x', 0) * o, m.y = ki(t, 'y', 0) * o, m.rotation = ki(t, 'rotation', 0), (g = ki(t, 'color', null)) && m.color.setFromString(g), m) : null
                    case 'clipping':
                        var y = this.attachmentLoader.newClippingAttachment(e, r)
                        if (!y) return null
                        var v = ki(t, 'end', null)
                        if (v != null) {
                            const _ = i.findSlot(v)
                            if (_ == null) throw new Error(`Clipping end slot not found: ${ v}`)
                            y.endSlot = _
                        }
                        var g
                        f = t.vertexCount
                        return this.readVertices(t, y, f << 1), (g = ki(t, 'color', null)) && y.color.setFromString(g), y
                }
                return null
            }, t.prototype.readVertices = function (t, e, n) {
                const r = this.scale
                e.worldVerticesLength = n
                let i = t.vertices
                if (n != i.length) {
                    const o = [];
                    var a = []
                    for (l = 0, h = i.length; l < h;) {
                        const s = i[l++]
                        a.push(s)
                        for (let u = l + 4 * s; l < u; l += 4) a.push(i[l]), o.push(i[l + 1] * r), o.push(i[l + 2] * r), o.push(i[l + 3])
                    }
                    e.bones = a, e.vertices = G.toFloatArray(o)
                } else {
                    const c = G.toFloatArray(i)
                    if (r != 1) {
                        for (var l = 0, h = i.length; l < h; l++) c[l] *= r
                    }
                    e.vertices = c
                }
            }, t.prototype.readAnimation = function (t, e, n) {
                const r = this.scale
                var i = []
                if (t.slots) {
                    for (var o in t.slots) {
                        var a = t.slots[o]
                        if ((mt = n.findSlotIndex(o)) == -1) throw new Error(`Slot not found: ${  o}`)
                        for (var s in a) {
                            if (q = a[s]) {
                                if ('attachment' == s) {
                                    for (var u = new fr(q.length, mt), c = 0; c < q.length; c++) {
                                        var l = q[c]
                                                u.setFrame(c, ki(l, 'time', 0), l.name)
                                    }
                                    i.push(u)
                                } else if ('rgba' == s) {
                                    u = new sr(q.length, q.length << 2, mt)
                                        for (var h = ki(l = q[0], 'time', 0), f = F.fromString(l.color), d = (c = 0, 0); ; c++) {
                                        if (u.setFrame(c, h, f.r, f.g, f.b, f.a), !(Q = q[c + 1])) {
                                            u.shrink(d)
                                                break
                                        }
                                        var p = ki(Q, 'time', 0);
                                                var m = F.fromString(Q.color);
                                        (ot = l.curve) && (d = Ci(ot, u, d, c, 0, h, p, f.r, m.r, 1), d = Ci(ot, u, d, c, 1, h, p, f.g, m.g, 1), d = Ci(ot, u, d, c, 2, h, p, f.b, m.b, 1), d = Ci(ot, u, d, c, 3, h, p, f.a, m.a, 1)), h = p, f = m, l = Q
                                    }
                                    i.push(u)
                                } else if ('rgb' == s) {
                                    for (u = new ur(q.length, 3 * q.length, mt), h = ki(l = q[0], 'time', 0), f = F.fromString(l.color), c = 0, d = 0; ; c++) {
                                        if (u.setFrame(c, h, f.r, f.g, f.b), !(Q = q[c + 1])) {
                                            u.shrink(d)
                                                break
                                        }
                                        p = ki(Q, 'time', 0), m = F.fromString(Q.color);
                                        (ot = l.curve) && (d = Ci(ot, u, d, c, 0, h, p, f.r, m.r, 1), d = Ci(ot, u, d, c, 1, h, p, f.g, m.g, 1), d = Ci(ot, u, d, c, 2, h, p, f.b, m.b, 1)), h = p, f = m, l = Q
                                    }
                                    i.push(u)
                                } else if ('alpha' == s) { i.push(Ai(q, new cr(q.length, q.length, mt), 0, 1));
}
                                else if ('rgba2' == s) {
                                    u = new lr(q.length, 7 * q.length, mt), h = ki(l = q[0], 'time', 0), f = F.fromString(l.light)
                                        var y = F.fromString(l.dark)
                                        for (c = 0, d = 0; ; c++) {
                                        if (u.setFrame(c, h, f.r, f.g, f.b, f.a, y.r, y.g, y.b), !(Q = q[c + 1])) {
                                            u.shrink(d)
                                                break
                                        }
                                        p = ki(Q, 'time', 0), m = F.fromString(Q.light)
                                            var v = F.fromString(Q.dark);
                                        (ot = l.curve) && (d = Ci(ot, u, d, c, 0, h, p, f.r, m.r, 1), d = Ci(ot, u, d, c, 1, h, p, f.g, m.g, 1), d = Ci(ot, u, d, c, 2, h, p, f.b, m.b, 1), d = Ci(ot, u, d, c, 3, h, p, f.a, m.a, 1), d = Ci(ot, u, d, c, 4, h, p, y.r, v.r, 1), d = Ci(ot, u, d, c, 5, h, p, y.g, v.g, 1), d = Ci(ot, u, d, c, 6, h, p, y.b, v.b, 1)), h = p, f = m, y = v, l = Q
                                    }
                                    i.push(u)
                                } else {
                                    if ('rgb2' != s) throw new Error('Invalid timeline type for a slot: ' + s + ' (' + o + ')');
                                    for (u = new hr(q.length, 6 * q.length, mt), h = ki(l = q[0], 'time', 0), f = F.fromString(l.light), y = F.fromString(l.dark), c = 0, d = 0; ; c++) {
                                        if (u.setFrame(c, h, f.r, f.g, f.b, y.r, y.g, y.b), !(Q = q[c + 1])) {
                                            u.shrink(d)
                                                break
                                        }
                                        p = ki(Q, 'time', 0), m = F.fromString(Q.light), v = F.fromString(Q.dark);
                                        (ot = l.curve) && (d = Ci(ot, u, d, c, 0, h, p, f.r, m.r, 1), d = Ci(ot, u, d, c, 1, h, p, f.g, m.g, 1), d = Ci(ot, u, d, c, 2, h, p, f.b, m.b, 1), d = Ci(ot, u, d, c, 3, h, p, y.r, v.r, 1), d = Ci(ot, u, d, c, 4, h, p, y.g, v.g, 1), d = Ci(ot, u, d, c, 5, h, p, y.b, v.b, 1)), h = p, f = m, y = v, l = Q
                                    }
                                    i.push(u)
                                }
                            }
                        }
                    }
                }
                if (t.bones) {
                    for (const g in t.bones) {
                        let b = t.bones[g]
                                    var E = n.findBoneIndex(g)
                        if (E == -1) throw new Error(`Bone not found: ${  g}`)
                        for (var s in b) {
                            if ((q = b[s]).length != 0) {
                                if ('rotate' === s) { i.push(Ai(q, new $n(q.length, q.length, E), 0, 1));
}
                                else if ('translate' === s) {
                                    u = new Jn(q.length, q.length << 1, E)
                                        i.push(Ii(q, u, 'x', 'y', 0, r))
                                } else if ('translatex' === s) {
                                    u = new Qn(q.length, q.length, E)
                                        i.push(Ai(q, u, 0, r))
                                } else if ('translatey' === s) {
                                    u = new tr(q.length, q.length, E)
                                        i.push(Ai(q, u, 0, r))
                                } else if ('scale' === s) {
                                    u = new er(q.length, q.length << 1, E)
                                        i.push(Ii(q, u, 'x', 'y', 1, 1))
                                } else if ('scalex' === s) {
                                    u = new nr(q.length, q.length, E)
                                        i.push(Ai(q, u, 1, 1))
                                } else if ('scaley' === s) {
                                    u = new rr(q.length, q.length, E)
                                        i.push(Ai(q, u, 1, 1))
                                } else if ('shear' === s) {
                                    u = new ir(q.length, q.length << 1, E)
                                        i.push(Ii(q, u, 'x', 'y', 0, 1))
                                } else if ('shearx' === s) {
                                    u = new or(q.length, q.length, E)
                                        i.push(Ai(q, u, 0, 1))
                                } else if ('sheary' === s) {
                                    u = new ar(q.length, q.length, E)
                                        i.push(Ai(q, u, 0, 1))
                                }
                            }
                        }
                    }
                }
                if (t.ik) {
                    for (var x in t.ik) {
                        if (l = (H = t.ik[x])[0]) {
                            var T = n.findIkConstraint(x)
                                        var S = n.ikConstraints.indexOf(T)
                                        var w = (u = new yr(H.length, H.length << 1, S), h = ki(l, 'time', 0), ki(l, 'mix', 1))
                                        var O = ki(l, 'softness', 0) * r
                            for (c = 0, d = 0; ; c++) {
                                if (u.setFrame(c, h, w, O, ki(l, 'bendPositive', !0) ? 1 : -1, ki(l, 'compress', !1), ki(l, 'stretch', !1)), !(Q = H[c + 1])) {
                                    u.shrink(d)
                                    break
                                }
                                p = ki(Q, 'time', 0)
                                var P = ki(Q, 'mix', 1)
                                            var R = ki(Q, 'softness', 0) * r;
                                (ot = l.curve) && (d = Ci(ot, u, d, c, 0, h, p, w, P, 1), d = Ci(ot, u, d, c, 1, h, p, O, R, r)), h = p, w = P, O = R, l = Q
                            }
                            i.push(u)
                        }
                    }
                }
                if (t.transform) {
                    for (var x in t.transform) {
                        if (l = (q = t.transform[x])[0]) {
                            T = n.findTransformConstraint(x), S = n.transformConstraints.indexOf(T), u = new vr(q.length, q.length << 2, S), h = ki(l, 'time', 0)
                            var A = ki(l, 'mixRotate', 1)
                                        var I = ki(l, 'mixX', 1)
                                        var C = ki(l, 'mixY', I)
                                        var k = ki(l, 'mixScaleX', 1)
                                        var N = ki(l, 'mixScaleY', k)
                                        var M = ki(l, 'mixShearY', 1)
                            for (c = 0, d = 0; ; c++) {
                                if (u.setFrame(c, h, A, I, C, k, N, M), !(Q = q[c + 1])) {
                                    u.shrink(d)
                                    break
                                }
                                p = ki(Q, 'time', 0)
                                var j = ki(Q, 'mixRotate', 1)
                                            var D = ki(Q, 'mixX', 1)
                                            var L = ki(Q, 'mixY', D)
                                            var B = ki(Q, 'mixScaleX', 1)
                                            var U = ki(Q, 'mixScaleY', B)
                                            var X = ki(Q, 'mixShearY', 1);
                                (ot = l.curve) && (d = Ci(ot, u, d, c, 0, h, p, A, j, 1), d = Ci(ot, u, d, c, 1, h, p, I, D, 1), d = Ci(ot, u, d, c, 2, h, p, C, L, 1), d = Ci(ot, u, d, c, 3, h, p, k, B, 1), d = Ci(ot, u, d, c, 4, h, p, N, U, 1), d = Ci(ot, u, d, c, 5, h, p, M, X, 1)), h = p, A = j, I = D, C = L, k = B, N = U, k = B, l = Q
                            }
                            i.push(u)
                        }
                    }
                }
                if (t.path) {
                    for (var x in t.path) {
                        var H = t.path[x]
                        if ((S = n.findPathConstraintIndex(x)) == -1) throw new Error(`Path constraint not found: ${  x}`)
                        T = n.pathConstraints[S]
                        for (var s in H) {
                            if (l = (q = H[s])[0]) {
                                if ('position' === s) {
                                    u = new _r(q.length, q.length, S)
                                            i.push(Ai(q, u, 0, T.positionMode == _.Fixed ? r : 1))
                                } else if ('spacing' === s) {
                                    u = new gr(q.length, q.length, S)
                                        i.push(Ai(q, u, 0, T.spacingMode == Sr.Length || T.spacingMode == Sr.Fixed ? r : 1))
                                } else if ('mix' === s) {
                                    for (u = new br(q.length, 3 * q.length, S), h = ki(l, 'time', 0), A = ki(l, 'mixRotate', 1), I = ki(l, 'mixX', 1), C = ki(l, 'mixY', I), c = 0, d = 0; ; c++) {
                                        if (u.setFrame(c, h, A, I, C), !(Q = q[c + 1])) {
                                            u.shrink(d)
                                                break
                                        }
                                        p = ki(Q, 'time', 0), j = ki(Q, 'mixRotate', 1), D = ki(Q, 'mixX', 1), L = ki(Q, 'mixY', D);
                                        (ot = l.curve) && (d = Ci(ot, u, d, c, 0, h, p, A, j, 1), d = Ci(ot, u, d, c, 1, h, p, I, D, 1), d = Ci(ot, u, d, c, 2, h, p, C, L, 1)), h = p, A = j, I = D, C = L, l = Q
                                    }
                                    i.push(u)
                                }
                            }
                        }
                    }
                }
                if (t.deform) {
                    for (const V in t.deform) {
                        let Y = t.deform[V]
                                    var z = n.findSkin(V)
                        if (z != null) {
                            for (var o in Y) {
                                a = Y[o]
                                        if ((mt = n.findSlotIndex(o)) == -1) throw new Error('Slot not found: ' + a.name)
                                        for (var s in a) {
                                    var q
                                            if (l = (q = a[s])[0]) {
                                        var K = z.getAttachment(mt, s)
                                                if (K == null) throw new Error('Deform attachment not found: ' + q.name)
                                                var Z = K.bones != null,
                                            $ = K.vertices,
                                            J = Z ? $.length / 3 * 2 : $.length
                                                for (u = new dr(q.length, q.length, mt, K), h = ki(l, 'time', 0), c = 0, d = 0; ; c++) {
                                            var Q; var tt = void 0;
                                                        var et = ki(l, 'vertices', null)
                                                    if (et) {
                                                tt = G.newFloatArray(J)
                                                        var nt = ki(l, 'offset', 0)
                                                        if (G.arrayCopy(et, 0, tt, nt, et.length), r != 1) {
                                                            for (var rt = (it = nt) + et.length; it < rt; it++) tt[it] *= r;
}
                                                if (!Z) {
                                                            for (var it = 0; it < J; it++) tt[it] += $[it]
}
                                            } else { tt = Z ? G.newFloatArray(J) : $;
}
                                            if (u.setFrame(c, h, tt), !(Q = q[c + 1])) {
                                                u.shrink(d)
                                                        break
                                            }
                                            var ot
                                                    p = ki(Q, 'time', 0);
                                            (ot = l.curve) && (d = Ci(ot, u, d, c, 0, h, p, 0, 1, 1)), h = p, l = Q
                                        }
                                        i.push(u)
                                    }
                                }
                            }
                        } else if (W) { throw new Error('Skin not found: ' + V)
                        }
                    }
                }
                if (t.drawOrder) {
                    u = new mr(t.drawOrder.length)
                    let at = n.slots.length
                    for (c = 0, it = 0; it < t.drawOrder.length; it++, c++) {
                        const st = t.drawOrder[it]
                        var ut = null
                        var ct = ki(st, 'offsets', null)
                        if (ct) {
                            ut = G.newArray(at, -1)
                            for (var lt = G.newArray(at - ct.length, 0), ht = 0, ft = 0, dt = 0; dt < ct.length; dt++) {
                                for (var pt = ct[dt], mt = n.findSlotIndex(pt.slot); ht != mt;) lt[ft++] = ht++
                                ut[ht + pt.offset] = ht++
                            }
                            for (; ht < at;) lt[ft++] = ht++
                            for (dt = at - 1; dt >= 0; dt--) ut[dt] == -1 && (ut[dt] = lt[--ft])
                        }
                        u.setFrame(c, ki(st, 'time', 0), ut)
                    }
                    i.push(u)
                }
                if (t.events) {
                    for (u = new pr(t.events.length), c = 0, it = 0; it < t.events.length; it++, c++) {
                        const yt = t.events[it]
                        var vt = n.findEvent(yt.name)
                        var _t = new Br(G.toSinglePrecision(ki(yt, 'time', 0)), vt)
                        _t.intValue = ki(yt, 'int', vt.intValue), _t.floatValue = ki(yt, 'float', vt.floatValue), _t.stringValue = ki(yt, 'string', vt.stringValue), _t.data.audioPath && (_t.volume = ki(yt, 'volume', 1), _t.balance = ki(yt, 'balance', 0)), u.setFrame(c, _t)
                    }
                    i.push(u)
                }
                let gt = 0
                for (it = 0, rt = i.length; it < rt; it++) gt = Math.max(gt, i[it].getDuration())
                if (isNaN(gt)) throw new Error('Error while parsing animation, duration is NaN')
                n.animations.push(new Pn(e, i, gt))
            }, t.blendModeFromString = function (t) {
                if ((t = t.toLowerCase()) == 'normal') return c.b.NORMAL
                if (t == 'additive') return c.b.ADD
                if (t == 'multiply') return c.b.MULTIPLY
                if (t == 'screen') return c.b.SCREEN
                throw new Error(`Unknown blend mode: ${ t}`)
            }, t
        }())
        var Ri = function (t, e, n, r, i) {
            this.mesh = t, this.skin = e, this.slotIndex = n, this.parent = r, this.inheritDeform = i
        }

        function Ai(t, e, n, r) {
            for (let i = t[0], o = ki(i, 'time', 0), a = ki(i, 'value', n) * r, s = 0, u = 0; ; u++) {
                e.setFrame(u, o, a)
                const c = t[u + 1]
                if (!c) return e.shrink(s), e
                const l = ki(c, 'time', 0)
                const h = ki(c, 'value', n) * r
                i.curve && (s = Ci(i.curve, e, s, u, 0, o, l, a, h, r)), o = l, a = h, i = c
            }
        }

        function Ii(t, e, n, r, i, o) {
            for (let a = t[0], s = ki(a, 'time', 0), u = ki(a, n, i) * o, c = ki(a, r, i) * o, l = 0, h = 0; ; h++) {
                e.setFrame(h, s, u, c)
                const f = t[h + 1]
                if (!f) return e.shrink(l), e
                const d = ki(f, 'time', 0)
                const p = ki(f, n, i) * o
                const m = ki(f, r, i) * o
                const y = a.curve
                y && (l = Ci(y, e, l, h, 0, s, d, u, p, o), l = Ci(y, e, l, h, 1, s, d, c, m, o)), s = d, u = p, c = m, a = f
            }
        }

        function Ci(t, e, n, r, i, o, a, s, u, c) {
            if (t == 'stepped') return e.setStepped(r), n
            const l = i << 2
            const h = t[l]
            const f = t[l + 1] * c
            const d = t[l + 2]
            const p = t[l + 3] * c
            return e.setBezier(n, r, i, o, s, h, f, d, p, a, u), n + 1
        }

        function ki(t, e, n) {
            return void 0 !== t[e] ? t[e] : n
        }
        let Ni; var Mi = (function (t) {
            function e() {
                return t !== null && t.apply(this, arguments) || this
            }
            return mn(e, t), e.prototype.createSkeleton = function (t) {
                this.skeleton = new zr(t), this.skeleton.updateWorldTransform(), this.stateData = new Mr(t), this.state = new Er(this.stateData)
            }, e
        }($))
        let ji = function (t, e) {
            return (ji = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            })(t, e)
        }
        /*!
             * @pixi-spine/loader-uni - v3.0.13
             * Compiled Mon, 13 Sep 2021 16:46:40 UTC
             *
             * @pixi-spine/loader-uni is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             *
             * Copyright 2019-2020, Mat Groves, All Rights Reserved
             */
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
        function Di(t, e) {
            if (typeof e != 'function' && e !== null) throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`)

            function n() {
                this.constructor = t
            }
            ji(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }

        function Li(t) {
            const e = t.substr(0, 3)
            const n = Math.floor(10 * +e + 0.001)
            return e === '3.7' ? Ni.VER37 : e === '3.8' ? Ni.VER38 : e === '4.0' ? Ni.VER40 : n < Ni.VER37 ? Ni.VER37 : Ni.UNKNOWN
        }!(function (t) {
            t[t.UNKNOWN = 0] = 'UNKNOWN', t[t.VER37 = 37] = 'VER37', t[t.VER38 = 38] = 'VER38', t[t.VER40 = 40] = 'VER40'
        }(Ni || (Ni = {})))
        const Fi = (function () {
            function t() {
                this.scale = 1
            }
            return t.prototype.readSkeletonData = function (t, e) {
                let n = new E(e)
                n.readString()
                let r = n.readString()
                var i = Li(r)
                var o = null
                if (i === Ni.VER38 && (o = new ne(new Ft(t))), (n = new E(e)).readInt32(), n.readInt32(), (i = Li(r = n.readString())) === Ni.VER40 && (o = new Qr(new jr(t))), !o) {
                    let a = `Unsupported version of spine model ${ r }, please update pixi-spine`;
                    console.error(a)
                }
                return o.scale = this.scale, o.readSkeletonData(e)
            }, t
        }())
        let Bi = (function () {
            function t() {
                this.scale = 1
            }
            return t.prototype.readSkeletonData = function (t, e) {
                const n = e.skeleton.spine
                var r = Li(n)
                var i = null
                if (r === Ni.VER37 && (i = new hn(new ze(t))), r === Ni.VER38 && (i = new ae(new Ft(t))), r === Ni.VER40 && (i = new Pi(new jr(t))), !i) {
                    const o = `Unsupported version of spine model ${  n  }, please update pixi-spine`;
                    console.error(o)
                }
                return i.scale = this.scale, i.readSkeletonData(e)
            }, t
        }())
        let Ui = (function (t) {
            function e() {
                return t !== null && t.apply(this, arguments) || this
            }
            return Di(e, t), e.prototype.createBinaryParser = function () {
                return new Fi()
            }, e.prototype.createJsonParser = function () {
                return new Bi()
            }, e.prototype.parseData = function (t, e, n, r) {
                const i = e
                t.spineData = i.readSkeletonData(n, r), t.spineAtlas = n
            }, e.registerLoaderPlugin = function () {
                s.b.registerPlugin(e)
            }, e.use = (new e()).genMiddleware().use, e
        }(J))
        var Gi = (function (t) {
            function e() {
                return t !== null && t.apply(this, arguments) || this
            }
            return Di(e, t), e.prototype.createSkeleton = function (t) {
                const e = Li(t.version)
                let n = null
                if (e === Ni.VER37 && (n = i), e === Ni.VER38 && (n = r), e === Ni.VER40 && (n = o), !n) {
                    const a = `Cant detect version of spine model ${ t.version}`
                    console.error(a)
                }
                this.skeleton = new n.Skeleton(t), this.skeleton.updateWorldTransform(), this.stateData = new n.AnimationStateData(t), this.state = new n.AnimationState(this.stateData)
            }, e
        }($))
        /*!
             * pixi-spine - v3.0.0
             * Compiled Thu, 29 Apr 2021 13:42:29 UTC
             *
             * pixi-spine is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             *
             * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
             */
        Ui.registerLoaderPlugin()
    },
    './node_modules/pixi.js/dist/esm/pixi.js': function (t, e, n) {
        'use strict'
        n.r(e), n.d(e, 'utils', () => {
            return h
        }), n.d(e, 'AccessibilityManager', () => {
            return p
        }), n.d(e, 'accessibleTarget', () => {
            return d
        }), n.d(e, 'InteractionData', () => {
            return v
        }), n.d(e, 'InteractionEvent', () => {
            return g
        }), n.d(e, 'InteractionManager', () => {
            return S
        }), n.d(e, 'InteractionTrackingData', () => {
            return b
        }), n.d(e, 'interactiveTarget', () => {
            return x
        }), n.d(e, 'Application', () => {
            return O
        }), n.d(e, 'AbstractBatchRenderer', () => {
            return w.a
        }), n.d(e, 'AbstractMultiResource', () => {
            return w.b
        }), n.d(e, 'AbstractRenderer', () => {
            return w.c
        }), n.d(e, 'ArrayResource', () => {
            return w.d
        }), n.d(e, 'Attribute', () => {
            return w.e
        }), n.d(e, 'BaseImageResource', () => {
            return w.f
        }), n.d(e, 'BaseRenderTexture', () => {
            return w.g
        }), n.d(e, 'BaseTexture', () => {
            return w.h
        }), n.d(e, 'BatchDrawCall', () => {
            return w.i
        }), n.d(e, 'BatchGeometry', () => {
            return w.j
        }), n.d(e, 'BatchPluginFactory', () => {
            return w.k
        }), n.d(e, 'BatchRenderer', () => {
            return w.l
        }), n.d(e, 'BatchShaderGenerator', () => {
            return w.m
        }), n.d(e, 'BatchSystem', () => {
            return w.n
        }), n.d(e, 'BatchTextureArray', () => {
            return w.o
        }), n.d(e, 'Buffer', () => {
            return w.p
        }), n.d(e, 'BufferResource', () => {
            return w.q
        }), n.d(e, 'CanvasResource', () => {
            return w.r
        }), n.d(e, 'ContextSystem', () => {
            return w.s
        }), n.d(e, 'CubeResource', () => {
            return w.t
        }), n.d(e, 'Filter', () => {
            return w.u
        }), n.d(e, 'FilterState', () => {
            return w.v
        }), n.d(e, 'FilterSystem', () => {
            return w.w
        }), n.d(e, 'Framebuffer', () => {
            return w.x
        }), n.d(e, 'FramebufferSystem', () => {
            return w.y
        }), n.d(e, 'GLFramebuffer', () => {
            return w.z
        }), n.d(e, 'GLProgram', () => {
            return w.A
        }), n.d(e, 'GLTexture', () => {
            return w.B
        }), n.d(e, 'Geometry', () => {
            return w.C
        }), n.d(e, 'GeometrySystem', () => {
            return w.D
        }), n.d(e, 'IGLUniformData', () => {
            return w.E
        }), n.d(e, 'INSTALLED', () => {
            return w.F
        }), n.d(e, 'ImageBitmapResource', () => {
            return w.G
        }), n.d(e, 'ImageResource', () => {
            return w.H
        }), n.d(e, 'MaskData', () => {
            return w.I
        }), n.d(e, 'MaskSystem', () => {
            return w.J
        }), n.d(e, 'ObjectRenderer', () => {
            return w.K
        }), n.d(e, 'Program', () => {
            return w.L
        }), n.d(e, 'ProjectionSystem', () => {
            return w.M
        }), n.d(e, 'Quad', () => {
            return w.N
        }), n.d(e, 'QuadUv', () => {
            return w.O
        }), n.d(e, 'RenderTexture', () => {
            return w.P
        }), n.d(e, 'RenderTexturePool', () => {
            return w.Q
        }), n.d(e, 'RenderTextureSystem', () => {
            return w.R
        }), n.d(e, 'Renderer', () => {
            return w.S
        }), n.d(e, 'Resource', () => {
            return w.T
        }), n.d(e, 'SVGResource', () => {
            return w.U
        }), n.d(e, 'ScissorSystem', () => {
            return w.V
        }), n.d(e, 'Shader', () => {
            return w.W
        }), n.d(e, 'ShaderSystem', () => {
            return w.X
        }), n.d(e, 'SpriteMaskFilter', () => {
            return w.Y
        }), n.d(e, 'State', () => {
            return w.Z
        }), n.d(e, 'StateSystem', () => {
            return w.ab
        }), n.d(e, 'StencilSystem', () => {
            return w.bb
        }), n.d(e, 'System', () => {
            return w.cb
        }), n.d(e, 'Texture', () => {
            return w.db
        }), n.d(e, 'TextureGCSystem', () => {
            return w.eb
        }), n.d(e, 'TextureMatrix', () => {
            return w.fb
        }), n.d(e, 'TextureSystem', () => {
            return w.gb
        }), n.d(e, 'TextureUvs', () => {
            return w.hb
        }), n.d(e, 'UniformGroup', () => {
            return w.ib
        }), n.d(e, 'VideoResource', () => {
            return w.jb
        }), n.d(e, 'ViewableBuffer', () => {
            return w.kb
        }), n.d(e, 'autoDetectRenderer', () => {
            return w.lb
        }), n.d(e, 'autoDetectResource', () => {
            return w.mb
        }), n.d(e, 'checkMaxIfStatementsInShader', () => {
            return w.nb
        }), n.d(e, 'createUBOElements', () => {
            return w.ob
        }), n.d(e, 'defaultFilterVertex', () => {
            return w.pb
        }), n.d(e, 'defaultVertex', () => {
            return w.qb
        }), n.d(e, 'generateProgram', () => {
            return w.rb
        }), n.d(e, 'generateUniformBufferSync', () => {
            return w.sb
        }), n.d(e, 'getTestContext', () => {
            return w.tb
        }), n.d(e, 'getUBOData', () => {
            return w.ub
        }), n.d(e, 'resources', () => {
            return w.vb
        }), n.d(e, 'systems', () => {
            return w.wb
        }), n.d(e, 'uniformParsers', () => {
            return w.xb
        }), n.d(e, 'Extract', () => {
            return C
        }), n.d(e, 'AppLoaderPlugin', () => {
            return k.a
        }), n.d(e, 'Loader', () => {
            return k.b
        }), n.d(e, 'LoaderResource', () => {
            return k.c
        }), n.d(e, 'TextureLoader', () => {
            return k.d
        }), n.d(e, 'BlobResource', () => {
            return U
        }), n.d(e, 'CompressedTextureLoader', () => {
            return X
        }), n.d(e, 'CompressedTextureResource', () => {
            return G
        }), n.d(e, 'DDSLoader', () => {
            return at
        }), n.d(e, 'FORMATS_TO_COMPONENTS', () => {
            return bt
        }), n.d(e, 'INTERNAL_FORMATS', () => {
            return A
        }), n.d(e, 'INTERNAL_FORMAT_TO_BYTES_PER_PIXEL', () => {
            return M
        }), n.d(e, 'KTXLoader', () => {
            return xt
        }), n.d(e, 'TYPES_TO_BYTES_PER_COMPONENT', () => {
            return gt
        }), n.d(e, 'TYPES_TO_BYTES_PER_PIXEL', () => {
            return Et
        }), n.d(e, 'ParticleContainer', () => {
            return Tt.a
        }), n.d(e, 'ParticleRenderer', () => {
            return Tt.b
        }), n.d(e, 'BasePrepare', () => {
            return St.a
        }), n.d(e, 'CountLimiter', () => {
            return St.b
        }), n.d(e, 'Prepare', () => {
            return St.c
        }), n.d(e, 'TimeLimiter', () => {
            return St.d
        }), n.d(e, 'Spritesheet', () => {
            return wt.a
        }), n.d(e, 'SpritesheetLoader', () => {
            return wt.b
        }), n.d(e, 'TilingSprite', () => {
            return Ot.a
        }), n.d(e, 'TilingSpriteRenderer', () => {
            return Ot.b
        }), n.d(e, 'BitmapFont', () => {
            return Pt.a
        }), n.d(e, 'BitmapFontData', () => {
            return Pt.b
        }), n.d(e, 'BitmapFontLoader', () => {
            return Pt.c
        }), n.d(e, 'BitmapText', () => {
            return Pt.d
        }), n.d(e, 'Ticker', () => {
            return y.a
        }), n.d(e, 'TickerPlugin', () => {
            return y.b
        }), n.d(e, 'UPDATE_PRIORITY', () => {
            return y.c
        }), n.d(e, 'ALPHA_MODES', () => {
            return N.a
        }), n.d(e, 'BLEND_MODES', () => {
            return N.b
        }), n.d(e, 'BUFFER_BITS', () => {
            return N.c
        }), n.d(e, 'BUFFER_TYPE', () => {
            return N.d
        }), n.d(e, 'CLEAR_MODES', () => {
            return N.e
        }), n.d(e, 'DRAW_MODES', () => {
            return N.f
        }), n.d(e, 'ENV', () => {
            return N.g
        }), n.d(e, 'FORMATS', () => {
            return N.h
        }), n.d(e, 'GC_MODES', () => {
            return N.i
        }), n.d(e, 'MASK_TYPES', () => {
            return N.j
        }), n.d(e, 'MIPMAP_MODES', () => {
            return N.k
        }), n.d(e, 'MSAA_QUALITY', () => {
            return N.l
        }), n.d(e, 'PRECISION', () => {
            return N.m
        }), n.d(e, 'RENDERER_TYPE', () => {
            return N.n
        }), n.d(e, 'SAMPLER_TYPES', () => {
            return N.o
        }), n.d(e, 'SCALE_MODES', () => {
            return N.p
        }), n.d(e, 'TARGETS', () => {
            return N.q
        }), n.d(e, 'TYPES', () => {
            return N.r
        }), n.d(e, 'WRAP_MODES', () => {
            return N.s
        }), n.d(e, 'Bounds', () => {
            return f.a
        }), n.d(e, 'Container', () => {
            return f.b
        }), n.d(e, 'DisplayObject', () => {
            return f.c
        }), n.d(e, 'TemporaryDisplayObject', () => {
            return f.d
        }), n.d(e, 'FillStyle', () => {
            return ke.a
        }), n.d(e, 'GRAPHICS_CURVES', () => {
            return ke.b
        }), n.d(e, 'Graphics', () => {
            return ke.c
        }), n.d(e, 'GraphicsData', () => {
            return ke.d
        }), n.d(e, 'GraphicsGeometry', () => {
            return ke.e
        }), n.d(e, 'LINE_CAP', () => {
            return ke.f
        }), n.d(e, 'LINE_JOIN', () => {
            return ke.g
        }), n.d(e, 'LineStyle', () => {
            return ke.h
        }), n.d(e, 'graphicsUtils', () => {
            return ke.i
        }), n.d(e, 'Circle', () => {
            return m.a
        }), n.d(e, 'DEG_TO_RAD', () => {
            return m.b
        }), n.d(e, 'Ellipse', () => {
            return m.c
        }), n.d(e, 'Matrix', () => {
            return m.d
        }), n.d(e, 'ObservablePoint', () => {
            return m.e
        }), n.d(e, 'PI_2', () => {
            return m.f
        }), n.d(e, 'Point', () => {
            return m.g
        }), n.d(e, 'Polygon', () => {
            return m.h
        }), n.d(e, 'RAD_TO_DEG', () => {
            return m.i
        }), n.d(e, 'Rectangle', () => {
            return m.j
        }), n.d(e, 'RoundedRectangle', () => {
            return m.k
        }), n.d(e, 'SHAPES', () => {
            return m.l
        }), n.d(e, 'Transform', () => {
            return m.m
        }), n.d(e, 'groupD8', () => {
            return m.n
        }), n.d(e, 'Mesh', () => {
            return Ne.a
        }), n.d(e, 'MeshBatchUvs', () => {
            return Ne.b
        }), n.d(e, 'MeshGeometry', () => {
            return Ne.c
        }), n.d(e, 'MeshMaterial', () => {
            return Ne.d
        }), n.d(e, 'NineSlicePlane', () => {
            return Me.a
        }), n.d(e, 'PlaneGeometry', () => {
            return Me.b
        }), n.d(e, 'RopeGeometry', () => {
            return Me.c
        }), n.d(e, 'SimpleMesh', () => {
            return Me.d
        }), n.d(e, 'SimplePlane', () => {
            return Me.e
        }), n.d(e, 'SimpleRope', () => {
            return Me.f
        }), n.d(e, 'Runner', () => {
            return je.a
        }), n.d(e, 'Sprite', () => {
            return Ae.a
        }), n.d(e, 'AnimatedSprite', () => {
            return Le
        }), n.d(e, 'TEXT_GRADIENT', () => {
            return Fe.a
        }), n.d(e, 'Text', () => {
            return Fe.b
        }), n.d(e, 'TextMetrics', () => {
            return Fe.c
        }), n.d(e, 'TextStyle', () => {
            return Fe.d
        }), n.d(e, 'isMobile', () => {
            return It.a
        }), n.d(e, 'settings', () => {
            return It.b
        }), n.d(e, 'VERSION', () => {
            return Be
        }), n.d(e, 'filters', () => {
            return Ue
        })
        const r = n('./node_modules/promise-polyfill/src/index.js')
        const i = n('./node_modules/object-assign/index.js')
        const o = n.n(i)
        /*!
             * @pixi/polyfill - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/polyfill is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        self.Promise || (self.Promise = r.a), Object.assign || (Object.assign = o.a)
        if (Date.now && Date.prototype.getTime || (Date.now = function () {
            return (new Date()).getTime()
        }), !self.performance || !self.performance.now) {
            const a = Date.now()
            self.performance || (self.performance = {}), self.performance.now = function () {
                return Date.now() - a
            }
        }
        for (var s = Date.now(), u = ['ms', 'moz', 'webkit', 'o'], c = 0; c < u.length && !self.requestAnimationFrame; ++c) {
            const l = u[c]
            self.requestAnimationFrame = self[`${l}RequestAnimationFrame`], self.cancelAnimationFrame = self[`${l}CancelAnimationFrame`] || self[`${l}CancelRequestAnimationFrame`]
        }
        self.requestAnimationFrame || (self.requestAnimationFrame = function (t) {
            if (typeof t != 'function') throw new TypeError(`${t}is not a function`)
            const e = Date.now()
            let n = 16 + s - e
            return n < 0 && (n = 0), s = e, self.setTimeout(() => {
                s = Date.now(), t(performance.now())
            }, n)
        }), self.cancelAnimationFrame || (self.cancelAnimationFrame = function (t) {
            return clearTimeout(t)
        }), Math.sign || (Math.sign = function (t) {
            return (t = Number(t)) === 0 || isNaN(t) ? t : t > 0 ? 1 : -1
        }), Number.isInteger || (Number.isInteger = function (t) {
            return typeof t == 'number' && isFinite(t) && Math.floor(t) === t
        }), self.ArrayBuffer || (self.ArrayBuffer = Array), self.Float32Array || (self.Float32Array = Array), self.Uint32Array || (self.Uint32Array = Array), self.Uint16Array || (self.Uint16Array = Array), self.Uint8Array || (self.Uint8Array = Array), self.Int32Array || (self.Int32Array = Array)
        var h = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        var f = n('./node_modules/@pixi/display/dist/esm/display.js')
        var d = {
            accessible: !1,
            accessibleTitle: null,
            accessibleHint: null,
            tabIndex: 0,
            _accessibleActive: !1,
            _accessibleDiv: null,
            accessibleType: 'button',
            accessiblePointerEvents: 'auto',
            accessibleChildren: !0,
            renderId: -1
        }
        f.c.mixin(d)
        var p = (function () {
            function t(t) {
                this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (h.isMobile.tablet || h.isMobile.phone) && this.createTouchHook()
                const e = document.createElement('div')
                e.style.width = '100px', e.style.height = '100px', e.style.position = 'absolute', e.style.top = '0px', e.style.left = '0px', e.style.zIndex = 2.0.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), self.addEventListener('keydown', this._onKeyDown, !1)
            }
            return Object.defineProperty(t.prototype, 'isActive', {
                get() {
                    return this._isActive
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'isMobileAccessibility', {
                get() {
                    return this._isMobileAccessibility
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.createTouchHook = function () {
                const t = this
                let e = document.createElement('button')
                e.style.width = '1px', e.style.height = '1px', e.style.position = 'absolute', e.style.top = '-1000px', e.style.left = '-1000px', e.style.zIndex = 2.0.toString(), e.style.backgroundColor = '#FF0000', e.title = 'select to enable accessibility for this content', e.addEventListener('focus', () => {
                    t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook()
                }), document.body.appendChild(e), this._hookDiv = e
            }, t.prototype.destroyTouchHook = function () {
                this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
            }, t.prototype.activate = function () {
                let t
                this._isActive || (this._isActive = !0, self.document.addEventListener('mousemove', this._onMouseMove, !0), self.removeEventListener('keydown', this._onKeyDown, !1), this.renderer.on('postrender', this.update, this), (t = this.renderer.view.parentNode) === null || void 0 === t || t.appendChild(this.div))
            }, t.prototype.deactivate = function () {
                let t
                this._isActive && !this._isMobileAccessibility && (this._isActive = !1, self.document.removeEventListener('mousemove', this._onMouseMove, !0), self.addEventListener('keydown', this._onKeyDown, !1), this.renderer.off('postrender', this.update), (t = this.div.parentNode) === null || void 0 === t || t.removeChild(this.div))
            }, t.prototype.updateAccessibleObjects = function (t) {
                if (t.visible && t.accessibleChildren) {
                    t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId)
                    const e = t.children
                    if (e) {
                        for (let n = 0; n < e.length; n++) this.updateAccessibleObjects(e[n])
                    }
                }
            }, t.prototype.update = function () {
                const t = performance.now()
                if (!(h.isMobile.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, this.renderer.renderingToScreen)) {
                    this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered)
                    const e = this.renderer.view.getBoundingClientRect()
                    let n = e.left
                    let r = e.top
                    let i = e.width
                    let o = e.height
                    let a = this.renderer
                    let s = a.width
                    let u = a.height
                    let c = a.resolution
                    let l = i / s * c
                    let f = o / u * c
                    let d = this.div
                    d.style.left = `${n}px`, d.style.top = `${r}px`, d.style.width = `${s}px`, d.style.height = `${u}px`
                    for (let p = 0; p < this.children.length; p++) {
                        const m = this.children[p]
                        if (m.renderId !== this.renderId) { m._accessibleActive = !1, new Object(h.removeItems)(this.children, p, 1), this.div.removeChild(m._accessibleDiv), this.pool.push(m._accessibleDiv), m._accessibleDiv = null, p--
                        }
                        else {
                            d = m._accessibleDiv
                            let y = m.hitArea
                            let v = m.worldTransform
                            m.hitArea ? (d.style.left = `${(v.tx + y.x * v.a) * l}px`, d.style.top = `${(v.ty + y.y * v.d) * f}px`, d.style.width = `${y.width * v.a * l}px`, d.style.height = `${y.height * v.d * f}px`) : (y = m.getBounds(), this.capHitArea(y), d.style.left = `${y.x * l}px`, d.style.top = `${y.y * f}px`, d.style.width = `${y.width * l}px`, d.style.height = `${y.height * f}px`, d.title !== m.accessibleTitle && m.accessibleTitle !== null && (d.title = m.accessibleTitle), d.getAttribute('aria-label') !== m.accessibleHint && m.accessibleHint !== null && d.setAttribute('aria-label', m.accessibleHint)), m.accessibleTitle === d.title && m.tabIndex === d.tabIndex || (d.title = m.accessibleTitle, d.tabIndex = m.tabIndex, this.debug && this.updateDebugHTML(d))
                        }
                    }
                    this.renderId++
                }
            }, t.prototype.updateDebugHTML = function (t) {
                t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
            }, t.prototype.capHitArea = function (t) {
                t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0)
                const e = this.renderer
                let n = e.width
                let r = e.height
                t.x + t.width > n && (t.width = n - t.x), t.y + t.height > r && (t.height = r - t.y)
            }, t.prototype.addChild = function (t) {
                let e = this.pool.pop()
                e || ((e = document.createElement('button')).style.width = '100px', e.style.height = '100px', e.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent', e.style.position = 'absolute', e.style.zIndex = 2.0.toString(), e.style.borderStyle = 'none', navigator.userAgent.toLowerCase().includes('chrome') ? e.setAttribute('aria-live', 'off') : e.setAttribute('aria-live', 'polite'), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute('aria-relevant', 'additions') : e.setAttribute('aria-relevant', 'text'), e.addEventListener('click', this._onClick.bind(this)), e.addEventListener('focus', this._onFocus.bind(this)), e.addEventListener('focusout', this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : t.accessibleHint && t.accessibleHint !== null || (e.title = `displayObject ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && e.setAttribute('aria-label', t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
            }, t.prototype._onClick = function (t) {
                const e = this.renderer.plugins.interaction
                let n = t.target.displayObject
                let r = e.eventData
                e.dispatchEvent(n, 'click', r), e.dispatchEvent(n, 'pointertap', r), e.dispatchEvent(n, 'tap', r)
            }, t.prototype._onFocus = function (t) {
                t.target.getAttribute('aria-live') || t.target.setAttribute('aria-live', 'assertive')
                let e = this.renderer.plugins.interaction
                let n = t.target.displayObject
                let r = e.eventData
                e.dispatchEvent(n, 'mouseover', r)
            }, t.prototype._onFocusOut = function (t) {
                t.target.getAttribute('aria-live') || t.target.setAttribute('aria-live', 'polite')
                let e = this.renderer.plugins.interaction
                let n = t.target.displayObject
                let r = e.eventData
                e.dispatchEvent(n, 'mouseout', r)
            }, t.prototype._onKeyDown = function (t) {
                t.keyCode === 9 && this.activate()
            }, t.prototype._onMouseMove = function (t) {
                t.movementX === 0 && t.movementY === 0 || this.deactivate()
            }, t.prototype.destroy = function () {
                this.destroyTouchHook(), this.div = null, self.document.removeEventListener('mousemove', this._onMouseMove, !0), self.removeEventListener('keydown', this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
            }, t
        }())
        var m = n('./node_modules/@pixi/math/dist/esm/math.js')
        var y = n('./node_modules/@pixi/ticker/dist/esm/ticker.js')
        var v = (function () {
            function t() {
                this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new m.g(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0
            }
            return Object.defineProperty(t.prototype, 'pointerId', {
                get() {
                    return this.identifier
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.getLocalPosition = function (t, e, n) {
                return t.worldTransform.applyInverse(n || this.global, e)
            }, t.prototype.copyEvent = function (t) {
                'isPrimary' in t && t.isPrimary && (this.isPrimary = !0), this.button = 'button' in t && t.button
                let e = 'buttons' in t && t.buttons
                this.buttons = Number.isInteger(e) ? e : 'which' in t && t.which, this.width = 'width' in t && t.width, this.height = 'height' in t && t.height, this.tiltX = 'tiltX' in t && t.tiltX, this.tiltY = 'tiltY' in t && t.tiltY, this.pointerType = 'pointerType' in t && t.pointerType, this.pressure = 'pressure' in t && t.pressure, this.rotationAngle = 'rotationAngle' in t && t.rotationAngle, this.twist = 'twist' in t && t.twist || 0, this.tangentialPressure = 'tangentialPressure' in t && t.tangentialPressure || 0
            }, t.prototype.reset = function () {
                this.isPrimary = !1
            }, t
        }())
        let _ = function (t, e) {
            return (_ = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        var g = (function () {
            function t() {
                this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null
            }
            return t.prototype.stopPropagation = function () {
                this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget
            }, t.prototype.reset = function () {
                this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null
            }, t
        }())
        var b = (function () {
            function t(e) {
                this._pointerId = e, this._flags = t.FLAGS.NONE
            }
            return t.prototype._doSet = function (t, e) {
                this._flags = e ? this._flags | t : this._flags & ~t
            }, Object.defineProperty(t.prototype, 'pointerId', {
                get() {
                    return this._pointerId
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'flags', {
                get() {
                    return this._flags
                },
                set(t) {
                    this._flags = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'none', {
                get() {
                    return this._flags === t.FLAGS.NONE
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'over', {
                get() {
                    return (this._flags & t.FLAGS.OVER) != 0
                },
                set(e) {
                    this._doSet(t.FLAGS.OVER, e)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'rightDown', {
                get() {
                    return (this._flags & t.FLAGS.RIGHT_DOWN) != 0
                },
                set(e) {
                    this._doSet(t.FLAGS.RIGHT_DOWN, e)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'leftDown', {
                get() {
                    return (this._flags & t.FLAGS.LEFT_DOWN) != 0
                },
                set(e) {
                    this._doSet(t.FLAGS.LEFT_DOWN, e)
                },
                enumerable: !1,
                configurable: !0
            }), t.FLAGS = Object.freeze({
                NONE: 0,
                OVER: 1,
                LEFT_DOWN: 2,
                RIGHT_DOWN: 4
            }), t
        }())
        let E = (function () {
            function t() {
                this._tempPoint = new m.g()
            }
            return t.prototype.recursiveFindHit = function (t, e, n, r, i) {
                if (!e || !e.visible) return !1
                let o = t.data.global
                var a = !1
                var s = i = e.interactive || i
                var u = !0
                if (e.hitArea ? (r && (e.worldTransform.applyInverse(o, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? a = !0 : (r = !1, u = !1)), s = !1) : e._mask && r && (e._mask.containsPoint && e._mask.containsPoint(o) || (r = !1)), u && e.interactiveChildren && e.children) {
                    for (let c = e.children, l = c.length - 1; l >= 0; l--) {
                        let h = c[l]
                                    var f = this.recursiveFindHit(t, h, n, r, s)
                        if (f) {
                            if (!h.parent) continue
                            s = !1, f && (t.target && (r = !1), a = !0)
                        }
                    }
                }
                return i && (r && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(o) && (a = !0), e.interactive && (a && !t.target && (t.target = e), n && n(t, e, !!a))), a
            }, t.prototype.findHit = function (t, e, n, r) {
                this.recursiveFindHit(t, e, n, r, !1)
            }, t
        }())
        var x = {
            interactive: !1,
            interactiveChildren: !0,
            hitArea: null,
            get buttonMode() {
                return this.cursor === 'pointer'
            },
            set buttonMode(t) {
                t ? this.cursor = 'pointer' : this.cursor === 'pointer' && (this.cursor = null)
            },
            cursor: null,
            get trackedPointers() {
                return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers
            },
            _trackedPointers: void 0
        }
        f.c.mixin(x)
        const T = {
            target: null,
            data: {
                global: null
            }
        }
        var S = (function (t) {
            function e(e, n) {
                const r = t.call(this) || this
                return n = n || {}, r.renderer = e, r.autoPreventDefault = void 0 === n.autoPreventDefault || n.autoPreventDefault, r.interactionFrequency = n.interactionFrequency || 10, r.mouse = new v(), r.mouse.identifier = 1, r.mouse.global.set(-999999), r.activeInteractionData = {}, r.activeInteractionData[1] = r.mouse, r.interactionDataPool = [], r.eventData = new g(), r.interactionDOMElement = null, r.moveWhenInside = !1, r.eventsAdded = !1, r.tickerAdded = !1, r.mouseOverRenderer = !('PointerEvent' in self), r.supportsTouchEvents = 'ontouchstart' in self, r.supportsPointerEvents = !!self.PointerEvent, r.onPointerUp = r.onPointerUp.bind(r), r.processPointerUp = r.processPointerUp.bind(r), r.onPointerCancel = r.onPointerCancel.bind(r), r.processPointerCancel = r.processPointerCancel.bind(r), r.onPointerDown = r.onPointerDown.bind(r), r.processPointerDown = r.processPointerDown.bind(r), r.onPointerMove = r.onPointerMove.bind(r), r.processPointerMove = r.processPointerMove.bind(r), r.onPointerOut = r.onPointerOut.bind(r), r.processPointerOverOut = r.processPointerOverOut.bind(r), r.onPointerOver = r.onPointerOver.bind(r), r.cursorStyles = {
                    default: 'inherit',
                    pointer: 'pointer'
                }, r.currentCursorMode = null, r.cursor = null, r.resolution = 1, r.delayedEvents = [], r.search = new E(), r._tempDisplayObject = new f.d(), r._eventListenerOptions = {
                    capture: !0,
                    passive: !1
                }, r._useSystemTicker = void 0 === n.useSystemTicker || n.useSystemTicker, r.setTargetElement(r.renderer.view, r.renderer.resolution), r
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                _(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), Object.defineProperty(e.prototype, 'useSystemTicker', {
                get() {
                    return this._useSystemTicker
                },
                set(t) {
                    this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'lastObjectRendered', {
                get() {
                    return this.renderer._lastObjectRendered || this._tempDisplayObject
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.hitTest = function (t, e) {
                return T.target = null, T.data.global = t, e || (e = this.lastObjectRendered), this.processInteractive(T, e, null, !0), T.target
            }, e.prototype.setTargetElement = function (t, e) {
                void 0 === e && (e = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = e, this.addEvents(), this.addTickerListener()
            }, e.prototype.addTickerListener = function () {
                !this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (y.a.system.add(this.tickerUpdate, this, y.c.INTERACTION), this.tickerAdded = !0)
            }, e.prototype.removeTickerListener = function () {
                this.tickerAdded && (y.a.system.remove(this.tickerUpdate, this), this.tickerAdded = !1)
            }, e.prototype.addEvents = function () {
                if (!this.eventsAdded && this.interactionDOMElement) {
                    const t = this.interactionDOMElement.style
                    self.navigator.msPointerEnabled ? (t.msContentZooming = 'none', t.msTouchAction = 'none') : this.supportsPointerEvents && (t.touchAction = 'none'), this.supportsPointerEvents ? (self.document.addEventListener('pointermove', this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, this._eventListenerOptions), self.addEventListener('pointercancel', this.onPointerCancel, this._eventListenerOptions), self.addEventListener('pointerup', this.onPointerUp, this._eventListenerOptions)) : (self.document.addEventListener('mousemove', this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, this._eventListenerOptions), self.addEventListener('mouseup', this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0
                }
            }, e.prototype.removeEvents = function () {
                if (this.eventsAdded && this.interactionDOMElement) {
                    const t = this.interactionDOMElement.style
                    self.navigator.msPointerEnabled ? (t.msContentZooming = '', t.msTouchAction = '') : this.supportsPointerEvents && (t.touchAction = ''), this.supportsPointerEvents ? (self.document.removeEventListener('pointermove', this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, this._eventListenerOptions), self.removeEventListener('pointercancel', this.onPointerCancel, this._eventListenerOptions), self.removeEventListener('pointerup', this.onPointerUp, this._eventListenerOptions)) : (self.document.removeEventListener('mousemove', this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, this._eventListenerOptions), self.removeEventListener('mouseup', this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1
                }
            }, e.prototype.tickerUpdate = function (t) {
                this._deltaTime += t, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update())
            }, e.prototype.update = function () {
                if (this.interactionDOMElement) {
                    if (this._didMove) { this._didMove = !1
}
                    else {
                        for (const t in this.cursor = null, this.activeInteractionData) {
                            if (this.activeInteractionData.hasOwnProperty(t)) {
                                var e = this.activeInteractionData[t]
                                        if (e.originalEvent && 'touch' !== e.pointerType) {
                                    var n = this.configureInteractionEventForDOMEvent(this.eventData, e.originalEvent, e)
                                            this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !0)
                                }
                            }
                        }
                        this.setCursorMode(this.cursor)
                    }
                }
            }, e.prototype.setCursorMode = function (t) {
                t = t || 'default'
                let e = !0
                if (self.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (e = !1), this.currentCursorMode !== t) {
                    this.currentCursorMode = t
                    let n = this.cursorStyles[t]
                    if (n) { switch (typeof n) {
                        case 'string':
                            e && (this.interactionDOMElement.style.cursor = n)
                            break;
                        case 'function':
                            n(t)
                            break;
                        case 'object':
                            e && Object.assign(this.interactionDOMElement.style, n)
                    }
                    } else { e && typeof t == 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.interactionDOMElement.style.cursor = t)
                    }
                }
            }, e.prototype.dispatchEvent = function (t, e, n) {
                n.stopPropagationHint && t !== n.stopsPropagatingAt || (n.currentTarget = t, n.type = e, t.emit(e, n), t[e] && t[e](n))
            }, e.prototype.delayDispatchEvent = function (t, e, n) {
                this.delayedEvents.push({
                    displayObject: t,
                    eventString: e,
                    eventData: n
                })
            }, e.prototype.mapPositionToPoint = function (t, e, n) {
                let r
                r = this.interactionDOMElement.parentElement
                    ? this.interactionDOMElement.getBoundingClientRect()
                    : {
                            x: 0,
                            y: 0,
                            width: this.interactionDOMElement.width,
                            height: this.interactionDOMElement.height,
                            left: 0,
                            top: 0
                        }
                let i = 1 / this.resolution
                t.x = (e - r.left) * (this.interactionDOMElement.width / r.width) * i, t.y = (n - r.top) * (this.interactionDOMElement.height / r.height) * i
            }, e.prototype.processInteractive = function (t, e, n, r) {
                const i = this.search.findHit(t, e, n, r)
                var o = this.delayedEvents
                if (!o.length) return i
                t.stopPropagationHint = !1
                let a = o.length
                this.delayedEvents = []
                for (let s = 0; s < a; s++) {
                    const u = o[s]
                    var c = u.displayObject
                    var l = u.eventString
                    var h = u.eventData
                    h.stopsPropagatingAt === c && (h.stopPropagationHint = !0), this.dispatchEvent(c, l, h)
                }
                return i
            }, e.prototype.onPointerDown = function (t) {
                if (!this.supportsTouchEvents || t.pointerType !== 'touch') {
                    const e = this.normalizeToPointerData(t)
                    if (this.autoPreventDefault && e[0].isNormalized)(t.cancelable || !('cancelable' in t)) && t.preventDefault()
                    for (let n = e.length, r = 0; r < n; r++) {
                        const i = e[r]
                        var o = this.getInteractionDataForPointerId(i)
                        var a = this.configureInteractionEventForDOMEvent(this.eventData, i, o)
                        if (a.data.originalEvent = t, this.processInteractive(a, this.lastObjectRendered, this.processPointerDown, !0), this.emit('pointerdown', a), i.pointerType === 'touch') { this.emit('touchstart', a)
                        }
                        else if (i.pointerType === 'mouse' || i.pointerType === 'pen') {
                            const s = i.button === 2
                            this.emit(s ? 'rightdown' : 'mousedown', this.eventData)
                        }
                    }
                }
            }, e.prototype.processPointerDown = function (t, e, n) {
                const r = t.data
                var i = t.data.identifier
                if (n) {
                    if (e.trackedPointers[i] || (e.trackedPointers[i] = new b(i)), this.dispatchEvent(e, 'pointerdown', t), r.pointerType === 'touch') { this.dispatchEvent(e, 'touchstart', t)
}
                    else if (r.pointerType === 'mouse' || r.pointerType === 'pen') {
                        let o = r.button === 2
                        o ? e.trackedPointers[i].rightDown = !0 : e.trackedPointers[i].leftDown = !0, this.dispatchEvent(e, o ? 'rightdown' : 'mousedown', t)
                    }
                }
            }, e.prototype.onPointerComplete = function (t, e, n) {
                for (let r = this.normalizeToPointerData(t), i = r.length, o = t.target !== this.interactionDOMElement ? 'outside' : '', a = 0; a < i; a++) {
                    const s = r[a]
                    var u = this.getInteractionDataForPointerId(s)
                    var c = this.configureInteractionEventForDOMEvent(this.eventData, s, u)
                    if (c.data.originalEvent = t, this.processInteractive(c, this.lastObjectRendered, n, e || !o), this.emit(e ? 'pointercancel' : `pointerup${ o}`, c), s.pointerType === 'mouse' || s.pointerType === 'pen') {
                        const l = s.button === 2
                        this.emit(l ? `rightup${ o}` : `mouseup${ o}`, c)
                    } else { s.pointerType === 'touch' && (this.emit(e ? 'touchcancel' : `touchend${  o}`, c), this.releaseInteractionDataForPointerId(s.pointerId))
                    }
                }
            }, e.prototype.onPointerCancel = function (t) {
                this.supportsTouchEvents && t.pointerType === 'touch' || this.onPointerComplete(t, !0, this.processPointerCancel)
            }, e.prototype.processPointerCancel = function (t, e) {
                const n = t.data
                var r = t.data.identifier
                void 0 !== e.trackedPointers[r] && (delete e.trackedPointers[r], this.dispatchEvent(e, 'pointercancel', t), n.pointerType === 'touch' && this.dispatchEvent(e, 'touchcancel', t))
            }, e.prototype.onPointerUp = function (t) {
                this.supportsTouchEvents && t.pointerType === 'touch' || this.onPointerComplete(t, !1, this.processPointerUp)
            }, e.prototype.processPointerUp = function (t, e, n) {
                const r = t.data
                var i = t.data.identifier
                var o = e.trackedPointers[i]
                var a = r.pointerType === 'touch'
                var s = r.pointerType === 'mouse' || r.pointerType === 'pen'
                var u = !1
                if (s) {
                    const c = r.button === 2;
                    var l = b.FLAGS
                        var h = c ? l.RIGHT_DOWN : l.LEFT_DOWN
                        var f = void 0 !== o && o.flags & h
                    n ? (this.dispatchEvent(e, c ? 'rightup' : 'mouseup', t), f && (this.dispatchEvent(e, c ? 'rightclick' : 'click', t), u = !0)) : f && this.dispatchEvent(e, c ? 'rightupoutside' : 'mouseupoutside', t), o && (c ? o.rightDown = !1 : o.leftDown = !1)
                }
                n ? (this.dispatchEvent(e, 'pointerup', t), a && this.dispatchEvent(e, 'touchend', t), o && (s && !u || this.dispatchEvent(e, 'pointertap', t), a && (this.dispatchEvent(e, 'tap', t), o.over = !1))) : o && (this.dispatchEvent(e, 'pointerupoutside', t), a && this.dispatchEvent(e, 'touchendoutside', t)), o && o.none && delete e.trackedPointers[i]
            }, e.prototype.onPointerMove = function (t) {
                if (!this.supportsTouchEvents || t.pointerType !== 'touch') {
                    const e = this.normalizeToPointerData(t)
                    'mouse' !== e[0].pointerType && e[0].pointerType !== 'pen' || (this._didMove = !0, this.cursor = null)
                    for (let n = e.length, r = 0; r < n; r++) {
                        const i = e[r]
                        var o = this.getInteractionDataForPointerId(i)
                        var a = this.configureInteractionEventForDOMEvent(this.eventData, i, o)
                        a.data.originalEvent = t, this.processInteractive(a, this.lastObjectRendered, this.processPointerMove, !0), this.emit('pointermove', a), i.pointerType === 'touch' && this.emit('touchmove', a), i.pointerType !== 'mouse' && i.pointerType !== 'pen' || this.emit('mousemove', a)
                    }
                    e[0].pointerType === 'mouse' && this.setCursorMode(this.cursor)
                }
            }, e.prototype.processPointerMove = function (t, e, n) {
                const r = t.data
                var i = r.pointerType === 'touch'
                var o = r.pointerType === 'mouse' || r.pointerType === 'pen'
                o && this.processPointerOverOut(t, e, n), this.moveWhenInside && !n || (this.dispatchEvent(e, 'pointermove', t), i && this.dispatchEvent(e, 'touchmove', t), o && this.dispatchEvent(e, 'mousemove', t))
            }, e.prototype.onPointerOut = function (t) {
                if (!this.supportsTouchEvents || t.pointerType !== 'touch') {
                    const e = this.normalizeToPointerData(t)[0]
                    'mouse' === e.pointerType && (this.mouseOverRenderer = !1, this.setCursorMode(null))
                    let n = this.getInteractionDataForPointerId(e)
                    var r = this.configureInteractionEventForDOMEvent(this.eventData, e, n)
                    r.data.originalEvent = e, this.processInteractive(r, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit('pointerout', r), e.pointerType === 'mouse' || e.pointerType === 'pen' ? this.emit('mouseout', r) : this.releaseInteractionDataForPointerId(n.identifier)
                }
            }, e.prototype.processPointerOverOut = function (t, e, n) {
                const r = t.data
                var i = t.data.identifier
                var o = r.pointerType === 'mouse' || r.pointerType === 'pen'
                var a = e.trackedPointers[i]
                n && !a && (a = e.trackedPointers[i] = new b(i)), void 0 !== a && (n && this.mouseOverRenderer ? (a.over || (a.over = !0, this.delayDispatchEvent(e, 'pointerover', t), o && this.delayDispatchEvent(e, 'mouseover', t)), o && this.cursor === null && (this.cursor = e.cursor)) : a.over && (a.over = !1, this.dispatchEvent(e, 'pointerout', this.eventData), o && this.dispatchEvent(e, 'mouseout', t), a.none && delete e.trackedPointers[i]))
            }, e.prototype.onPointerOver = function (t) {
                const e = this.normalizeToPointerData(t)[0]
                var n = this.getInteractionDataForPointerId(e)
                var r = this.configureInteractionEventForDOMEvent(this.eventData, e, n)
                r.data.originalEvent = e, e.pointerType === 'mouse' && (this.mouseOverRenderer = !0), this.emit('pointerover', r), e.pointerType !== 'mouse' && e.pointerType !== 'pen' || this.emit('mouseover', r)
            }, e.prototype.getInteractionDataForPointerId = function (t) {
                let e; const n = t.pointerId
                return n === 1 || t.pointerType === 'mouse' ? e = this.mouse : this.activeInteractionData[n] ? e = this.activeInteractionData[n] : ((e = this.interactionDataPool.pop() || new v()).identifier = n, this.activeInteractionData[n] = e), e.copyEvent(t), e
            }, e.prototype.releaseInteractionDataForPointerId = function (t) {
                const e = this.activeInteractionData[t]
                e && (delete this.activeInteractionData[t], e.reset(), this.interactionDataPool.push(e))
            }, e.prototype.configureInteractionEventForDOMEvent = function (t, e, n) {
                return t.data = n, this.mapPositionToPoint(n.global, e.clientX, e.clientY), e.pointerType === 'touch' && (e.globalX = n.global.x, e.globalY = n.global.y), n.originalEvent = e, t.reset(), t
            }, e.prototype.normalizeToPointerData = function (t) {
                const e = []
                if (this.supportsTouchEvents && t instanceof TouchEvent) {
                    for (let n = 0, r = t.changedTouches.length; n < r; n++) {
                        let i = t.changedTouches[n]
                        void 0 === i.button && (i.button = t.touches.length ? 1 : 0), void 0 === i.buttons && (i.buttons = t.touches.length ? 1 : 0), void 0 === i.isPrimary && (i.isPrimary = t.touches.length === 1 && t.type === 'touchstart'), void 0 === i.width && (i.width = i.radiusX || 1), void 0 === i.height && (i.height = i.radiusY || 1), void 0 === i.tiltX && (i.tiltX = 0), void 0 === i.tiltY && (i.tiltY = 0), void 0 === i.pointerType && (i.pointerType = 'touch'), void 0 === i.pointerId && (i.pointerId = i.identifier || 0), void 0 === i.pressure && (i.pressure = i.force || 0.5), void 0 === i.twist && (i.twist = 0), void 0 === i.tangentialPressure && (i.tangentialPressure = 0), void 0 === i.layerX && (i.layerX = i.offsetX = i.clientX), void 0 === i.layerY && (i.layerY = i.offsetY = i.clientY), i.isNormalized = !0, e.push(i)
                    }
                } else if (self.MouseEvent && (!(t instanceof MouseEvent) || this.supportsPointerEvents && t instanceof self.PointerEvent)) { e.push(t)
                }
                else {
                    const o = t
                    void 0 === o.isPrimary && (o.isPrimary = !0), void 0 === o.width && (o.width = 1), void 0 === o.height && (o.height = 1), void 0 === o.tiltX && (o.tiltX = 0), void 0 === o.tiltY && (o.tiltY = 0), void 0 === o.pointerType && (o.pointerType = 'mouse'), void 0 === o.pointerId && (o.pointerId = 1), void 0 === o.pressure && (o.pressure = 0.5), void 0 === o.twist && (o.twist = 0), void 0 === o.tangentialPressure && (o.tangentialPressure = 0), o.isNormalized = !0, e.push(o)
                }
                return e
            }, e.prototype.destroy = function () {
                this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null
            }, e
        }(h.EventEmitter))
        var w = n('./node_modules/@pixi/core/dist/esm/core.js')
        var O = (function () {
            function t(e) {
                const n = this
                this.stage = new f.b(), e = Object.assign({
                    forceCanvas: !1
                }, e), this.renderer = new Object(w.lb)(e), t._plugins.forEach((t) => {
                    t.init.call(n, e)
                })
            }
            return t.registerPlugin = function (e) {
                t._plugins.push(e)
            }, t.prototype.render = function () {
                this.renderer.render(this.stage)
            }, Object.defineProperty(t.prototype, 'view', {
                get() {
                    return this.renderer.view
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(t.prototype, 'screen', {
                get() {
                    return this.renderer.screen
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.destroy = function (e, n) {
                const r = this
                var i = t._plugins.slice(0)
                i.reverse(), i.forEach((t) => {
                    t.destroy.call(r)
                }), this.stage.destroy(n), this.stage = null, this.renderer.destroy(e), this.renderer = null
            }, t._plugins = [], t
        }())
        const P = (function () {
            function t() {}
            return t.init = function (t) {
                const e = this
                Object.defineProperty(this, 'resizeTo', {
                    set(t) {
                        self.removeEventListener('resize', this.queueResize), this._resizeTo = t, t && (self.addEventListener('resize', this.queueResize), this.resize())
                    },
                    get() {
                        return this._resizeTo
                    }
                }), this.queueResize = function () {
                    e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(() => {
                        return e.resize()
                    }))
                }, this.cancelResize = function () {
                    e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null)
                }, this.resize = function () {
                    if (e._resizeTo) {
                        let t, n
                        if (e.cancelResize(), e._resizeTo === self) { t = self.innerWidth, n = self.innerHeight
                        }
                        else {
                            const r = e._resizeTo
                            t = r.clientWidth, n = r.clientHeight
                        }
                        e.renderer.resize(t, n)
                    }
                }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null
            }, t.destroy = function () {
                self.removeEventListener('resize', this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
            }, t
        }())
        O.registerPlugin(P)
        /*!
             * @pixi/extract - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/extract is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        let R; let A; const I = new m.j()
        var C = (function () {
            function t(t) {
                this.renderer = t
            }
            return t.prototype.image = function (t, e, n) {
                const r = new Image()
                return r.src = this.base64(t, e, n), r
            }, t.prototype.base64 = function (t, e, n) {
                return this.canvas(t).toDataURL(e, n)
            }, t.prototype.canvas = function (e) {
                let n; let r; let i; const o = this.renderer
                var a = !1
                var s = !1
                e && (e instanceof w.P ? i = e : (i = this.renderer.generateTexture(e), s = !0)), i ? (n = i.baseTexture.resolution, r = i.frame, a = !1, o.renderTexture.bind(i)) : (n = this.renderer.resolution, a = !0, (r = I).width = this.renderer.width, r.height = this.renderer.height, o.renderTexture.bind(null))
                let u = Math.floor(r.width * n + 1e-4)
                var c = Math.floor(r.height * n + 1e-4)
                var l = new h.CanvasRenderTarget(u, c, 1)
                var f = new Uint8Array(4 * u * c)
                var d = o.gl
                d.readPixels(r.x * n, r.y * n, u, c, d.RGBA, d.UNSIGNED_BYTE, f)
                let p = l.context.getImageData(0, 0, u, c)
                if (t.arrayPostDivide(f, p.data), l.context.putImageData(p, 0, 0), a) {
                    const m = new h.CanvasRenderTarget(l.width, l.height, 1)
                    m.context.scale(1, -1), m.context.drawImage(l.canvas, 0, -c), l.destroy(), l = m
                }
                return s && i.destroy(!0), l.canvas
            }, t.prototype.pixels = function (e) {
                let n; let r; let i; const o = this.renderer
                var a = !1
                e && (e instanceof w.P ? i = e : (i = this.renderer.generateTexture(e), a = !0)), i ? (n = i.baseTexture.resolution, r = i.frame, o.renderTexture.bind(i)) : (n = o.resolution, (r = I).width = o.width, r.height = o.height, o.renderTexture.bind(null))
                let s = r.width * n
                var u = r.height * n
                var c = new Uint8Array(4 * s * u)
                var l = o.gl
                return l.readPixels(r.x * n, r.y * n, s, u, l.RGBA, l.UNSIGNED_BYTE, c), a && i.destroy(!0), t.arrayPostDivide(c, c), c
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t.arrayPostDivide = function (t, e) {
                for (let n = 0; n < t.length; n += 4) {
                    const r = e[n + 3] = t[n + 3]
                    r !== 0 ? (e[n] = Math.round(Math.min(255 * t[n] / r, 255)), e[n + 1] = Math.round(Math.min(255 * t[n + 1] / r, 255)), e[n + 2] = Math.round(Math.min(255 * t[n + 2] / r, 255))) : (e[n] = t[n], e[n + 1] = t[n + 1], e[n + 2] = t[n + 2])
                }
            }, t
        }())
        var k = n('./node_modules/@pixi/loaders/dist/esm/loaders.js')
        var N = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        !(function (t) {
            t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = 'COMPRESSED_RGB_S3TC_DXT1_EXT', t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = 'COMPRESSED_RGBA_S3TC_DXT1_EXT', t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = 'COMPRESSED_RGBA_S3TC_DXT3_EXT', t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = 'COMPRESSED_RGBA_S3TC_DXT5_EXT', t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = 'COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT', t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = 'COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT', t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = 'COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT', t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = 'COMPRESSED_SRGB_S3TC_DXT1_EXT', t[t.COMPRESSED_R11_EAC = 37488] = 'COMPRESSED_R11_EAC', t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = 'COMPRESSED_SIGNED_R11_EAC', t[t.COMPRESSED_RG11_EAC = 37490] = 'COMPRESSED_RG11_EAC', t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = 'COMPRESSED_SIGNED_RG11_EAC', t[t.COMPRESSED_RGB8_ETC2 = 37492] = 'COMPRESSED_RGB8_ETC2', t[t.COMPRESSED_RGBA8_ETC2_EAC = 37496] = 'COMPRESSED_RGBA8_ETC2_EAC', t[t.COMPRESSED_SRGB8_ETC2 = 37493] = 'COMPRESSED_SRGB8_ETC2', t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = 'COMPRESSED_SRGB8_ALPHA8_ETC2_EAC', t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = 'COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2', t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = 'COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2', t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = 'COMPRESSED_RGB_PVRTC_4BPPV1_IMG', t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = 'COMPRESSED_RGBA_PVRTC_4BPPV1_IMG', t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = 'COMPRESSED_RGB_PVRTC_2BPPV1_IMG', t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = 'COMPRESSED_RGBA_PVRTC_2BPPV1_IMG', t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = 'COMPRESSED_RGB_ETC1_WEBGL', t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = 'COMPRESSED_RGB_ATC_WEBGL', t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = 'COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL', t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = 'COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL'
        }(A || (A = {})))
        var M = ((R = {})[A.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, R[A.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, R[A.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, R[A.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, R[A.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, R[A.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, R[A.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, R[A.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, R[A.COMPRESSED_R11_EAC] = 0.5, R[A.COMPRESSED_SIGNED_R11_EAC] = 0.5, R[A.COMPRESSED_RG11_EAC] = 1, R[A.COMPRESSED_SIGNED_RG11_EAC] = 1, R[A.COMPRESSED_RGB8_ETC2] = 0.5, R[A.COMPRESSED_RGBA8_ETC2_EAC] = 1, R[A.COMPRESSED_SRGB8_ETC2] = 0.5, R[A.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, R[A.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, R[A.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, R[A.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, R[A.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, R[A.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, R[A.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, R[A.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, R[A.COMPRESSED_RGB_ATC_WEBGL] = 0.5, R[A.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, R[A.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, R)
        let j = function (t, e) {
            return (j = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0

            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.

            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
            ***************************************************************************** */
        function D(t, e) {
            function n() {
                this.constructor = t
            }
            j(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }

        function L(t, e) {
            let n; let r; let i; let o; let a = {
                label: 0,
                sent() {
                    if (1 & i[0]) throw i[1]
                    return i[1]
                },
                trys: [],
                ops: []
            }
            return o = {
                next: s(0),
                throw: s(1),
                return: s(2)
            }, typeof Symbol == 'function' && (o[Symbol.iterator] = function () {
                return this
            }), o

            function s(o) {
                return function (s) {
                    return (function (o) {
                        if (n) throw new TypeError('Generator is already executing.')
                        for (; a;) { try {
                            if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i
                            switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                                case 0:
                                case 1:
                                    i = o
                                    break
                                case 4:
                                    return a.label++, {
                                        value: o[1],
                                        done: !1
                                    }
                                case 5:
                                    a.label++, r = o[1], o = [0]
                                    continue
                                case 7:
                                    o = a.ops.pop(), a.trys.pop()
                                    continue
                                default:
                                    if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || o[0] !== 6 && o[0] !== 2)) {
                                        a = 0
                                        continue
                                    }
                                    if (o[0] === 3 && (!i || o[1] > i[0] && o[1] < i[3])) {
                                        a.label = o[1]
                                        break
                                    }
                                    if (o[0] === 6 && a.label < i[1]) {
                                        a.label = i[1], i = o
                                        break
                                    }
                                    if (i && a.label < i[2]) {
                                        a.label = i[2], a.ops.push(o)
                                        break
                                    }
                                    i[2] && a.ops.pop(), a.trys.pop()
                                    continue
                            }
                            o = e.call(t, a)
                        } catch (t) {
                            o = [6, t], r = 0
                        } finally {
                            n = i = 0
                        }
                        }
                        if (5 & o[0]) throw o[1]
                        return {
                            value: o[0] ? o[1] : void 0,
                            done: !0
                        }
                    }([o, s]))
                }
            }
        }
        let F; let B; var U = (function (t) {
            function e(e, n) {
                void 0 === n && (n = {
                    width: 1,
                    height: 1,
                    autoLoad: !0
                })
                let r; let i; let o = this
                return typeof e == 'string' ? (r = e, i = new Uint8Array()) : (r = null, i = e), (o = t.call(this, i, n) || this).origin = r, o.buffer = i ? new w.kb(i) : null, o.origin && !1 !== n.autoLoad && o.load(), i && i.length && (o.loaded = !0, o.onBlobLoaded(o.buffer.rawBinaryData)), o
            }
            return D(e, t), e.prototype.onBlobLoaded = function (t) {}, e.prototype.load = function () {
                return t = this, e = void 0, r = function () {
                    let t
                    return L(this, function (e) {
                        switch (e.label) {
                            case 0:
                                return [4, fetch(this.origin)]
                            case 1:
                                return [4, e.sent().blob()]
                            case 2:
                                return [4, e.sent().arrayBuffer()]
                            case 3:
                                return t = e.sent(), this.data = new Uint32Array(t), this.buffer = new w.kb(t), this.loaded = !0, this.onBlobLoaded(t), this.update(), [2, this]
                        }
                    })
                }, new ((n = Promise) || (n = Promise))((i, o) => {
                    function a(t) {
                        try {
                            u(r.next(t))
                        } catch (t) {
                            o(t)
                        }
                    }

                    function s(t) {
                        try {
                            u(r.throw(t))
                        } catch (t) {
                            o(t)
                        }
                    }

                    function u(t) {
                        t.done
                            ? i(t.value)
                            : new n((e) => {
                                    e(t.value)
                                }).then(a, s)
                    }
                    u((r = r.apply(t, e || [])).next())
                })
                let t, e, n, r
            }, e
        }(w.q))
        var G = (function (t) {
            function e(n, r) {
                const i = t.call(this, n, r) || this
                return i.format = r.format, i.levels = r.levels || 1, i._width = r.width, i._height = r.height, i._extension = e._formatToExtension(i.format), (r.levelBuffers || i.buffer) && (i._levelBuffers = r.levelBuffers || e._createLevelBuffers(n instanceof Uint8Array ? n : i.buffer.uint8View, i.format, i.levels, 4, 4, i.width, i.height)), i
            }
            return D(e, t), e.prototype.upload = function (t, e, n) {
                const r = t.gl
                if (!t.context.extensions[this._extension]) throw new Error(`${this._extension} textures are not supported on the current machine`)
                if (!this._levelBuffers) return !1
                for (let i = 0, o = this.levels; i < o; i++) {
                    const a = this._levelBuffers[i]
                    var s = a.levelID
                    var u = a.levelWidth
                    var c = a.levelHeight
                    var l = a.levelBuffer
                    r.compressedTexImage2D(r.TEXTURE_2D, s, this.format, u, c, 0, l)
                }
                return !0
            }, e.prototype.onBlobLoaded = function () {
                this._levelBuffers = e._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
            }, e._formatToExtension = function (t) {
                if (t >= 33776 && t <= 33779) return 's3tc'
                if (t >= 37488 && t <= 37497) return 'etc'
                if (t >= 35840 && t <= 35843) return 'pvrtc'
                if (t >= 36196) return 'etc1'
                if (t >= 35986 && t <= 34798) return 'atc'
                throw new Error('Invalid (compressed) texture format given!')
            }, e._createLevelBuffers = function (t, e, n, r, i, o, a) {
                for (var s = new Array(n), u = t.byteOffset, c = o, l = a, h = c + r - 1 & ~(r - 1), f = l + i - 1 & ~(i - 1), d = h * f * M[e], p = 0; p < n; p++) { s[p] = {
                    levelID: p,
                    levelWidth: n > 1 ? c : h,
                    levelHeight: n > 1 ? l : f,
                    levelBuffer: new Uint8Array(t.buffer, u, d)
                }, u += d, d = (h = (c = c >> 1 || 1) + r - 1 & ~(r - 1)) * (f = (l = l >> 1 || 1) + i - 1 & ~(i - 1)) * M[e]
                }
                return s
            }, e
        }(U))
        var X = (function () {
            function t() {}
            return t.use = function (e, n) {
                const r = e.data
                if (e.type === k.c.TYPE.JSON && r && r.cacheID && r.textures) {
                    for (var i = r.textures, o = void 0, a = void 0, s = 0, u = i.length; s < u; s++) {
                        const c = i[s]
                        let l = c.src
                        let f = c.format
                        if (f || (a = l), t.textureFormats[f]) {
                            o = l
                            break
                        }
                    }
                    if (!(o = o || a)) return void n(new Error(`Cannot load compressed-textures in ${e.url}, make sure you provide a fallback`))
                    if (o === e.url) return void n(new Error('URL of compressed texture cannot be the same as the manifest\'s URL'))
                    const d = {
                        crossOrigin: e.crossOrigin,
                        metadata: e.metadata.imageMetadata,
                        parentResource: e
                    }
                    let p = h.url.resolve(e.url.replace(this.baseUrl, ''), o)
                    let m = r.cacheID
                    this.add(m, p, d, (t) => {
                        if (t.error) { n(t.error)
                        }
                        else {
                            const r = t.texture
                            var i = void 0 === r ? null : r
                            var o = t.textures
                            var a = void 0 === o ? {} : o
                            Object.assign(e, {
                                texture: i,
                                textures: a
                            }), n()
                        }
                    })
                } else { n()
                }
            }, t.add = function () {
                const e = document.createElement('canvas').getContext('webgl')
                if (e) {
                    const n = {
                        s3tc: e.getExtension('WEBGL_compressed_texture_s3tc'),
                        s3tc_sRGB: e.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
                        etc: e.getExtension('WEBGL_compressed_texture_etc'),
                        etc1: e.getExtension('WEBGL_compressed_texture_etc1'),
                        pvrtc: e.getExtension('WEBGL_compressed_texture_pvrtc') || e.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
                        atc: e.getExtension('WEBGL_compressed_texture_atc'),
                        astc: e.getExtension('WEBGL_compressed_texture_astc')
                    }
                    for (const r in t.textureExtensions = n, t.textureFormats = {}, n) {
                        const i = n[r]
                        i && Object.assign(t.textureFormats, Object.getPrototypeOf(i))
                    }
                } else { console.warn('WebGL not available for compressed textures. Silently failing.')
                }
            }, t
        }())

        function H(t, e, n) {
            const r = {
                textures: {},
                texture: null
            }
            return e
                ? (e.map((t) => {
                        return new w.db(new w.h(t, Object.assign({
                            mipmap: N.k.OFF,
                            alphaMode: N.a.NO_PREMULTIPLIED_ALPHA
                        }, n)))
                    }).forEach((e, n) => {
                        const i = e.baseTexture
                        const o = `${t}-${n + 1}`
                        w.h.addToCache(i, o), w.db.addToCache(e, o), n === 0 && (w.h.addToCache(i, t), w.db.addToCache(e, t), r.texture = e), r.textures[o] = e
                    }), r)
                : r
        }
        k.c.setExtensionXhrType('dds', k.c.XHR_RESPONSE_TYPE.BUFFER)
        let V; let W; const Y = 3
        const z = 4
        const q = 7
        const K = 19
        const Z = 2
        const $ = 0
        const J = 1
        const Q = 2
        const tt = 3
        !(function (t) {
            t[t.DXGI_FORMAT_UNKNOWN = 0] = 'DXGI_FORMAT_UNKNOWN', t[t.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = 'DXGI_FORMAT_R32G32B32A32_TYPELESS', t[t.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = 'DXGI_FORMAT_R32G32B32A32_FLOAT', t[t.DXGI_FORMAT_R32G32B32A32_UINT = 3] = 'DXGI_FORMAT_R32G32B32A32_UINT', t[t.DXGI_FORMAT_R32G32B32A32_SINT = 4] = 'DXGI_FORMAT_R32G32B32A32_SINT', t[t.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = 'DXGI_FORMAT_R32G32B32_TYPELESS', t[t.DXGI_FORMAT_R32G32B32_FLOAT = 6] = 'DXGI_FORMAT_R32G32B32_FLOAT', t[t.DXGI_FORMAT_R32G32B32_UINT = 7] = 'DXGI_FORMAT_R32G32B32_UINT', t[t.DXGI_FORMAT_R32G32B32_SINT = 8] = 'DXGI_FORMAT_R32G32B32_SINT', t[t.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = 'DXGI_FORMAT_R16G16B16A16_TYPELESS', t[t.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = 'DXGI_FORMAT_R16G16B16A16_FLOAT', t[t.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = 'DXGI_FORMAT_R16G16B16A16_UNORM', t[t.DXGI_FORMAT_R16G16B16A16_UINT = 12] = 'DXGI_FORMAT_R16G16B16A16_UINT', t[t.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = 'DXGI_FORMAT_R16G16B16A16_SNORM', t[t.DXGI_FORMAT_R16G16B16A16_SINT = 14] = 'DXGI_FORMAT_R16G16B16A16_SINT', t[t.DXGI_FORMAT_R32G32_TYPELESS = 15] = 'DXGI_FORMAT_R32G32_TYPELESS', t[t.DXGI_FORMAT_R32G32_FLOAT = 16] = 'DXGI_FORMAT_R32G32_FLOAT', t[t.DXGI_FORMAT_R32G32_UINT = 17] = 'DXGI_FORMAT_R32G32_UINT', t[t.DXGI_FORMAT_R32G32_SINT = 18] = 'DXGI_FORMAT_R32G32_SINT', t[t.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = 'DXGI_FORMAT_R32G8X24_TYPELESS', t[t.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = 'DXGI_FORMAT_D32_FLOAT_S8X24_UINT', t[t.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = 'DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS', t[t.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = 'DXGI_FORMAT_X32_TYPELESS_G8X24_UINT', t[t.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = 'DXGI_FORMAT_R10G10B10A2_TYPELESS', t[t.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = 'DXGI_FORMAT_R10G10B10A2_UNORM', t[t.DXGI_FORMAT_R10G10B10A2_UINT = 25] = 'DXGI_FORMAT_R10G10B10A2_UINT', t[t.DXGI_FORMAT_R11G11B10_FLOAT = 26] = 'DXGI_FORMAT_R11G11B10_FLOAT', t[t.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = 'DXGI_FORMAT_R8G8B8A8_TYPELESS', t[t.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = 'DXGI_FORMAT_R8G8B8A8_UNORM', t[t.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = 'DXGI_FORMAT_R8G8B8A8_UNORM_SRGB', t[t.DXGI_FORMAT_R8G8B8A8_UINT = 30] = 'DXGI_FORMAT_R8G8B8A8_UINT', t[t.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = 'DXGI_FORMAT_R8G8B8A8_SNORM', t[t.DXGI_FORMAT_R8G8B8A8_SINT = 32] = 'DXGI_FORMAT_R8G8B8A8_SINT', t[t.DXGI_FORMAT_R16G16_TYPELESS = 33] = 'DXGI_FORMAT_R16G16_TYPELESS', t[t.DXGI_FORMAT_R16G16_FLOAT = 34] = 'DXGI_FORMAT_R16G16_FLOAT', t[t.DXGI_FORMAT_R16G16_UNORM = 35] = 'DXGI_FORMAT_R16G16_UNORM', t[t.DXGI_FORMAT_R16G16_UINT = 36] = 'DXGI_FORMAT_R16G16_UINT', t[t.DXGI_FORMAT_R16G16_SNORM = 37] = 'DXGI_FORMAT_R16G16_SNORM', t[t.DXGI_FORMAT_R16G16_SINT = 38] = 'DXGI_FORMAT_R16G16_SINT', t[t.DXGI_FORMAT_R32_TYPELESS = 39] = 'DXGI_FORMAT_R32_TYPELESS', t[t.DXGI_FORMAT_D32_FLOAT = 40] = 'DXGI_FORMAT_D32_FLOAT', t[t.DXGI_FORMAT_R32_FLOAT = 41] = 'DXGI_FORMAT_R32_FLOAT', t[t.DXGI_FORMAT_R32_UINT = 42] = 'DXGI_FORMAT_R32_UINT', t[t.DXGI_FORMAT_R32_SINT = 43] = 'DXGI_FORMAT_R32_SINT', t[t.DXGI_FORMAT_R24G8_TYPELESS = 44] = 'DXGI_FORMAT_R24G8_TYPELESS', t[t.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = 'DXGI_FORMAT_D24_UNORM_S8_UINT', t[t.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = 'DXGI_FORMAT_R24_UNORM_X8_TYPELESS', t[t.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = 'DXGI_FORMAT_X24_TYPELESS_G8_UINT', t[t.DXGI_FORMAT_R8G8_TYPELESS = 48] = 'DXGI_FORMAT_R8G8_TYPELESS', t[t.DXGI_FORMAT_R8G8_UNORM = 49] = 'DXGI_FORMAT_R8G8_UNORM', t[t.DXGI_FORMAT_R8G8_UINT = 50] = 'DXGI_FORMAT_R8G8_UINT', t[t.DXGI_FORMAT_R8G8_SNORM = 51] = 'DXGI_FORMAT_R8G8_SNORM', t[t.DXGI_FORMAT_R8G8_SINT = 52] = 'DXGI_FORMAT_R8G8_SINT', t[t.DXGI_FORMAT_R16_TYPELESS = 53] = 'DXGI_FORMAT_R16_TYPELESS', t[t.DXGI_FORMAT_R16_FLOAT = 54] = 'DXGI_FORMAT_R16_FLOAT', t[t.DXGI_FORMAT_D16_UNORM = 55] = 'DXGI_FORMAT_D16_UNORM', t[t.DXGI_FORMAT_R16_UNORM = 56] = 'DXGI_FORMAT_R16_UNORM', t[t.DXGI_FORMAT_R16_UINT = 57] = 'DXGI_FORMAT_R16_UINT', t[t.DXGI_FORMAT_R16_SNORM = 58] = 'DXGI_FORMAT_R16_SNORM', t[t.DXGI_FORMAT_R16_SINT = 59] = 'DXGI_FORMAT_R16_SINT', t[t.DXGI_FORMAT_R8_TYPELESS = 60] = 'DXGI_FORMAT_R8_TYPELESS', t[t.DXGI_FORMAT_R8_UNORM = 61] = 'DXGI_FORMAT_R8_UNORM', t[t.DXGI_FORMAT_R8_UINT = 62] = 'DXGI_FORMAT_R8_UINT', t[t.DXGI_FORMAT_R8_SNORM = 63] = 'DXGI_FORMAT_R8_SNORM', t[t.DXGI_FORMAT_R8_SINT = 64] = 'DXGI_FORMAT_R8_SINT', t[t.DXGI_FORMAT_A8_UNORM = 65] = 'DXGI_FORMAT_A8_UNORM', t[t.DXGI_FORMAT_R1_UNORM = 66] = 'DXGI_FORMAT_R1_UNORM', t[t.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = 'DXGI_FORMAT_R9G9B9E5_SHAREDEXP', t[t.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = 'DXGI_FORMAT_R8G8_B8G8_UNORM', t[t.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = 'DXGI_FORMAT_G8R8_G8B8_UNORM', t[t.DXGI_FORMAT_BC1_TYPELESS = 70] = 'DXGI_FORMAT_BC1_TYPELESS', t[t.DXGI_FORMAT_BC1_UNORM = 71] = 'DXGI_FORMAT_BC1_UNORM', t[t.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = 'DXGI_FORMAT_BC1_UNORM_SRGB', t[t.DXGI_FORMAT_BC2_TYPELESS = 73] = 'DXGI_FORMAT_BC2_TYPELESS', t[t.DXGI_FORMAT_BC2_UNORM = 74] = 'DXGI_FORMAT_BC2_UNORM', t[t.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = 'DXGI_FORMAT_BC2_UNORM_SRGB', t[t.DXGI_FORMAT_BC3_TYPELESS = 76] = 'DXGI_FORMAT_BC3_TYPELESS', t[t.DXGI_FORMAT_BC3_UNORM = 77] = 'DXGI_FORMAT_BC3_UNORM', t[t.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = 'DXGI_FORMAT_BC3_UNORM_SRGB', t[t.DXGI_FORMAT_BC4_TYPELESS = 79] = 'DXGI_FORMAT_BC4_TYPELESS', t[t.DXGI_FORMAT_BC4_UNORM = 80] = 'DXGI_FORMAT_BC4_UNORM', t[t.DXGI_FORMAT_BC4_SNORM = 81] = 'DXGI_FORMAT_BC4_SNORM', t[t.DXGI_FORMAT_BC5_TYPELESS = 82] = 'DXGI_FORMAT_BC5_TYPELESS', t[t.DXGI_FORMAT_BC5_UNORM = 83] = 'DXGI_FORMAT_BC5_UNORM', t[t.DXGI_FORMAT_BC5_SNORM = 84] = 'DXGI_FORMAT_BC5_SNORM', t[t.DXGI_FORMAT_B5G6R5_UNORM = 85] = 'DXGI_FORMAT_B5G6R5_UNORM', t[t.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = 'DXGI_FORMAT_B5G5R5A1_UNORM', t[t.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = 'DXGI_FORMAT_B8G8R8A8_UNORM', t[t.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = 'DXGI_FORMAT_B8G8R8X8_UNORM', t[t.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = 'DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM', t[t.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = 'DXGI_FORMAT_B8G8R8A8_TYPELESS', t[t.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = 'DXGI_FORMAT_B8G8R8A8_UNORM_SRGB', t[t.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = 'DXGI_FORMAT_B8G8R8X8_TYPELESS', t[t.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = 'DXGI_FORMAT_B8G8R8X8_UNORM_SRGB', t[t.DXGI_FORMAT_BC6H_TYPELESS = 94] = 'DXGI_FORMAT_BC6H_TYPELESS', t[t.DXGI_FORMAT_BC6H_UF16 = 95] = 'DXGI_FORMAT_BC6H_UF16', t[t.DXGI_FORMAT_BC6H_SF16 = 96] = 'DXGI_FORMAT_BC6H_SF16', t[t.DXGI_FORMAT_BC7_TYPELESS = 97] = 'DXGI_FORMAT_BC7_TYPELESS', t[t.DXGI_FORMAT_BC7_UNORM = 98] = 'DXGI_FORMAT_BC7_UNORM', t[t.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = 'DXGI_FORMAT_BC7_UNORM_SRGB', t[t.DXGI_FORMAT_AYUV = 100] = 'DXGI_FORMAT_AYUV', t[t.DXGI_FORMAT_Y410 = 101] = 'DXGI_FORMAT_Y410', t[t.DXGI_FORMAT_Y416 = 102] = 'DXGI_FORMAT_Y416', t[t.DXGI_FORMAT_NV12 = 103] = 'DXGI_FORMAT_NV12', t[t.DXGI_FORMAT_P010 = 104] = 'DXGI_FORMAT_P010', t[t.DXGI_FORMAT_P016 = 105] = 'DXGI_FORMAT_P016', t[t.DXGI_FORMAT_420_OPAQUE = 106] = 'DXGI_FORMAT_420_OPAQUE', t[t.DXGI_FORMAT_YUY2 = 107] = 'DXGI_FORMAT_YUY2', t[t.DXGI_FORMAT_Y210 = 108] = 'DXGI_FORMAT_Y210', t[t.DXGI_FORMAT_Y216 = 109] = 'DXGI_FORMAT_Y216', t[t.DXGI_FORMAT_NV11 = 110] = 'DXGI_FORMAT_NV11', t[t.DXGI_FORMAT_AI44 = 111] = 'DXGI_FORMAT_AI44', t[t.DXGI_FORMAT_IA44 = 112] = 'DXGI_FORMAT_IA44', t[t.DXGI_FORMAT_P8 = 113] = 'DXGI_FORMAT_P8', t[t.DXGI_FORMAT_A8P8 = 114] = 'DXGI_FORMAT_A8P8', t[t.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = 'DXGI_FORMAT_B4G4R4A4_UNORM', t[t.DXGI_FORMAT_P208 = 116] = 'DXGI_FORMAT_P208', t[t.DXGI_FORMAT_V208 = 117] = 'DXGI_FORMAT_V208', t[t.DXGI_FORMAT_V408 = 118] = 'DXGI_FORMAT_V408', t[t.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = 'DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE', t[t.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = 'DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE', t[t.DXGI_FORMAT_FORCE_UINT = 121] = 'DXGI_FORMAT_FORCE_UINT'
        }(V || (V = {}))),
        (function (t) {
            t[t.DDS_DIMENSION_TEXTURE1D = 2] = 'DDS_DIMENSION_TEXTURE1D', t[t.DDS_DIMENSION_TEXTURE2D = 3] = 'DDS_DIMENSION_TEXTURE2D', t[t.DDS_DIMENSION_TEXTURE3D = 6] = 'DDS_DIMENSION_TEXTURE3D'
        }(W || (W = {})))
        let et; let nt; let rt; const it = ((F = {})[827611204] = A.COMPRESSED_RGBA_S3TC_DXT1_EXT, F[861165636] = A.COMPRESSED_RGBA_S3TC_DXT3_EXT, F[894720068] = A.COMPRESSED_RGBA_S3TC_DXT5_EXT, F)
        const ot = ((B = {})[V.DXGI_FORMAT_BC1_TYPELESS] = A.COMPRESSED_RGBA_S3TC_DXT1_EXT, B[V.DXGI_FORMAT_BC1_UNORM] = A.COMPRESSED_RGBA_S3TC_DXT1_EXT, B[V.DXGI_FORMAT_BC2_TYPELESS] = A.COMPRESSED_RGBA_S3TC_DXT3_EXT, B[V.DXGI_FORMAT_BC2_UNORM] = A.COMPRESSED_RGBA_S3TC_DXT3_EXT, B[V.DXGI_FORMAT_BC3_TYPELESS] = A.COMPRESSED_RGBA_S3TC_DXT5_EXT, B[V.DXGI_FORMAT_BC3_UNORM] = A.COMPRESSED_RGBA_S3TC_DXT5_EXT, B[V.DXGI_FORMAT_BC1_UNORM_SRGB] = A.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, B[V.DXGI_FORMAT_BC2_UNORM_SRGB] = A.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, B[V.DXGI_FORMAT_BC3_UNORM_SRGB] = A.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, B)
        var at = (function () {
            function t() {}
            return t.use = function (e, n) {
                if (e.extension === 'dds' && e.data) { try {
                    Object.assign(e, H(e.name || e.url, t.parse(e.data), e.metadata))
                } catch (t) {
                    return void n(t)
                }
                }
                n()
            }, t.parse = function (t) {
                const e = new Uint32Array(t)
                if (e[0] !== 542327876) throw new Error('Invalid DDS file magic word')
                const n = new Uint32Array(t, 0, 124 / Uint32Array.BYTES_PER_ELEMENT)
                let r = n[Y]
                let i = n[z]
                let o = n[q]
                let a = new Uint32Array(t, K * Uint32Array.BYTES_PER_ELEMENT, 32 / Uint32Array.BYTES_PER_ELEMENT)
                let s = a[1]
                if (4 & s) {
                    const u = a[Z]
                    if (u !== 808540228) {
                        const c = it[u]
                        let l = new Uint8Array(t, 128)
                        return [new G(l, {
                            format: c,
                            width: i,
                            height: r,
                            levels: o
                        })]
                    }
                    const h = new Uint32Array(e.buffer, 128, 20 / Uint32Array.BYTES_PER_ELEMENT)
                    let f = h[$]
                    let d = h[J]
                    let p = h[Q]
                    let m = h[tt]
                    let y = ot[f]
                    if (void 0 === y) throw new Error(`DDSLoader cannot parse texture data with DXGI format ${f}`)
                    if (p === 4) throw new Error('DDSLoader does not support cubemap textures')
                    if (d === W.DDS_DIMENSION_TEXTURE3D) throw new Error('DDSLoader does not supported 3D texture data')
                    const v = []
                    if (m === 1) { v.push(new Uint8Array(t, 148))
                    }
                    else {
                        for (var _ = M[y], g = 0, b = i, E = r, x = 0; x < o; x++) {
                            g += Math.max(1, b + 3 & -4) * Math.max(1, E + 3 & -4) * _, b >>>= 1, E >>>= 1
                        }
                        let T = 148
                        for (x = 0; x < m; x++) v.push(new Uint8Array(t, T, g)), T += g
                    }
                    return v.map((t) => {
                        return new G(t, {
                            format: y,
                            width: i,
                            height: r,
                            levels: o
                        })
                    })
                }
                if (64 & s) throw new Error('DDSLoader does not support uncompressed texture data.')
                if (512 & s) throw new Error('DDSLoader does not supported YUV uncompressed texture data.')
                if (131072 & s) throw new Error('DDSLoader does not support single-channel (lumninance) texture data!')
                if (2 & s) throw new Error('DDSLoader does not support single-channel (alpha) texture data!')
                throw new Error('DDSLoader failed to load a texture file due to an unknown reason!')
            }, t
        }())
        k.c.setExtensionXhrType('ktx', k.c.XHR_RESPONSE_TYPE.BUFFER)
        const st = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
        const ut = 12
        const ct = 16
        const lt = 24
        const ht = 28
        const ft = 36
        const dt = 40
        const pt = 44
        const mt = 48
        const yt = 52
        const vt = 56
        const _t = 60
        var gt = ((et = {})[N.r.UNSIGNED_BYTE] = 1, et[N.r.UNSIGNED_SHORT] = 2, et[N.r.FLOAT] = 4, et[N.r.HALF_FLOAT] = 8, et)
        var bt = ((nt = {})[N.h.RGBA] = 4, nt[N.h.RGB] = 3, nt[N.h.LUMINANCE] = 1, nt[N.h.LUMINANCE_ALPHA] = 2, nt[N.h.ALPHA] = 1, nt)
        var Et = ((rt = {})[N.r.UNSIGNED_SHORT_4_4_4_4] = 2, rt[N.r.UNSIGNED_SHORT_5_5_5_1] = 2, rt[N.r.UNSIGNED_SHORT_5_6_5] = 2, rt)
        var xt = (function () {
            function t() {}
            return t.use = function (e, n) {
                if (e.extension === 'ktx' && e.data) { try {
                    let r = e.name || e.url
                    Object.assign(e, H(r, t.parse(r, e.data), e.metadata))
                } catch (t) {
                    return void n(t)
                }
                }
                n()
            }, t.parse = function (e, n) {
                const r = new DataView(n)
                if (!t.validate(e, r)) return null
                let i = r.getUint32(ut, !0) === 67305985
                    var o = r.getUint32(ct, i)
                    var a = r.getUint32(lt, i)
                    var s = r.getUint32(ht, i)
                    var u = r.getUint32(ft, i)
                    var c = r.getUint32(dt, i) || 1
                    var l = r.getUint32(pt, i) || 1
                    var h = r.getUint32(mt, i) || 1
                    var f = r.getUint32(yt, i)
                    var d = r.getUint32(vt, i)
                    var p = r.getUint32(_t, i)
                if (c === 0 || l !== 1) throw new Error('Only 2D textures are supported')
                if (f !== 1) throw new Error('CubeTextures are not supported by KTXLoader yet!')
                if (h !== 1) throw new Error('WebGL does not support array textures')
                let m; const y = u + 3 & -4
                var v = c + 3 & -4
                var _ = new Array(h)
                var g = u * c
                if (o === 0 && (g = y * v), void 0 === (m = o !== 0 ? gt[o] ? gt[o] * bt[a] : Et[o] : M[s])) throw new Error('Unable to resolve the pixel format stored in the *.ktx file!')
                for (let b = g * m, E = u, x = c, T = y, S = v, w = 64 + p, O = 0; O < d; O++) {
                    for (var P = r.getUint32(w, i), R = w + 4, A = 0; A < h; A++) {
                        let I = _[A]
                        I || (I = _[A] = new Array(d)), I[O] = {
                            levelID: O,
                            levelWidth: d > 1 ? E : T,
                            levelHeight: d > 1 ? x : S,
                            levelBuffer: new Uint8Array(n, R, b)
                        }, R += b
                    }
                    w = (w += P + 4) % 4 != 0 ? w + 4 - w % 4 : w, b = (T = (E = E >> 1 || 1) + 4 - 1 & -4) * (S = (x = x >> 1 || 1) + 4 - 1 & -4) * m
                }
                if (o !== 0) throw new Error('TODO: Uncompressed')
                return _.map((t) => {
                    return new G(null, {
                        format: s,
                        width: u,
                        height: c,
                        levels: d,
                        levelBuffers: t
                    })
                })
            }, t.validate = function (t, e) {
                for (let n = 0; n < st.length; n++) {
                    if (e.getUint8(n) !== st[n]) return console.error(`${t } is not a valid *.ktx file!`), !1
                }
                return !0
            }, t
        }())
        var Tt = n('./node_modules/@pixi/particle-container/dist/esm/particle-container.js')
        var St = n('./node_modules/@pixi/prepare/dist/esm/prepare.js')
        var wt = n('./node_modules/@pixi/spritesheet/dist/esm/spritesheet.js')
        var Ot = n('./node_modules/@pixi/sprite-tiling/dist/esm/sprite-tiling.js')
        var Pt = n('./node_modules/@pixi/text-bitmap/dist/esm/text-bitmap.js')
        let Rt = function (t, e) {
            return (Rt = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        const At = (function (t) {
            function e(e) {
                void 0 === e && (e = 1)
                let n = t.call(this, w.qb, 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n', {
                    uAlpha: 1
                }) || this
                return n.alpha = e, n
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                Rt(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), Object.defineProperty(e.prototype, 'alpha', {
                get () {
                    return this.uniforms.uAlpha
                },
                set (t) {
                    this.uniforms.uAlpha = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(w.u))
        var It = n('./node_modules/@pixi/settings/dist/esm/settings.js')
        let Ct = function (t, e) {
            return (Ct = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }

        function kt(t, e) {
            function n() {
                this.constructor = t
            }
            Ct(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
        }
        let Nt; let Mt; let jt; let Dt; let Lt; let Ft; let Bt; let Ut; let Gt; let Xt; let Ht; let Vt; let Wt; let Yt; let zt; let qt; let Kt; let Zt; let $t; const Jt = {
            5: [0.153388, 0.221461, 0.250301],
            7: [0.071303, 0.131514, 0.189879, 0.214607],
            9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
            11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
            13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
            15: [489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
        }
        const Qt = ['varying vec2 vBlurTexCoords[%size%];', 'uniform sampler2D uSampler;', 'void main(void)', '{', '    gl_FragColor = vec4(0.0);', '    %blur%', '}'].join('\n')
        !(function (t) {
            t[t.WEBGL_LEGACY = 0] = 'WEBGL_LEGACY', t[t.WEBGL = 1] = 'WEBGL', t[t.WEBGL2 = 2] = 'WEBGL2'
        }(Nt || (Nt = {}))),
        (function (t) {
            t[t.UNKNOWN = 0] = 'UNKNOWN', t[t.WEBGL = 1] = 'WEBGL', t[t.CANVAS = 2] = 'CANVAS'
        }(Mt || (Mt = {}))),
        (function (t) {
            t[t.COLOR = 16384] = 'COLOR', t[t.DEPTH = 256] = 'DEPTH', t[t.STENCIL = 1024] = 'STENCIL'
        }(jt || (jt = {}))),
        (function (t) {
            t[t.NORMAL = 0] = 'NORMAL', t[t.ADD = 1] = 'ADD', t[t.MULTIPLY = 2] = 'MULTIPLY', t[t.SCREEN = 3] = 'SCREEN', t[t.OVERLAY = 4] = 'OVERLAY', t[t.DARKEN = 5] = 'DARKEN', t[t.LIGHTEN = 6] = 'LIGHTEN', t[t.COLOR_DODGE = 7] = 'COLOR_DODGE', t[t.COLOR_BURN = 8] = 'COLOR_BURN', t[t.HARD_LIGHT = 9] = 'HARD_LIGHT', t[t.SOFT_LIGHT = 10] = 'SOFT_LIGHT', t[t.DIFFERENCE = 11] = 'DIFFERENCE', t[t.EXCLUSION = 12] = 'EXCLUSION', t[t.HUE = 13] = 'HUE', t[t.SATURATION = 14] = 'SATURATION', t[t.COLOR = 15] = 'COLOR', t[t.LUMINOSITY = 16] = 'LUMINOSITY', t[t.NORMAL_NPM = 17] = 'NORMAL_NPM', t[t.ADD_NPM = 18] = 'ADD_NPM', t[t.SCREEN_NPM = 19] = 'SCREEN_NPM', t[t.NONE = 20] = 'NONE', t[t.SRC_OVER = 0] = 'SRC_OVER', t[t.SRC_IN = 21] = 'SRC_IN', t[t.SRC_OUT = 22] = 'SRC_OUT', t[t.SRC_ATOP = 23] = 'SRC_ATOP', t[t.DST_OVER = 24] = 'DST_OVER', t[t.DST_IN = 25] = 'DST_IN', t[t.DST_OUT = 26] = 'DST_OUT', t[t.DST_ATOP = 27] = 'DST_ATOP', t[t.ERASE = 26] = 'ERASE', t[t.SUBTRACT = 28] = 'SUBTRACT', t[t.XOR = 29] = 'XOR'
        }(Dt || (Dt = {}))),
        (function (t) {
            t[t.POINTS = 0] = 'POINTS', t[t.LINES = 1] = 'LINES', t[t.LINE_LOOP = 2] = 'LINE_LOOP', t[t.LINE_STRIP = 3] = 'LINE_STRIP', t[t.TRIANGLES = 4] = 'TRIANGLES', t[t.TRIANGLE_STRIP = 5] = 'TRIANGLE_STRIP', t[t.TRIANGLE_FAN = 6] = 'TRIANGLE_FAN'
        }(Lt || (Lt = {}))),
        (function (t) {
            t[t.RGBA = 6408] = 'RGBA', t[t.RGB = 6407] = 'RGB', t[t.RG = 33319] = 'RG', t[t.RED = 6403] = 'RED', t[t.RGBA_INTEGER = 36249] = 'RGBA_INTEGER', t[t.RGB_INTEGER = 36248] = 'RGB_INTEGER', t[t.RG_INTEGER = 33320] = 'RG_INTEGER', t[t.RED_INTEGER = 36244] = 'RED_INTEGER', t[t.ALPHA = 6406] = 'ALPHA', t[t.LUMINANCE = 6409] = 'LUMINANCE', t[t.LUMINANCE_ALPHA = 6410] = 'LUMINANCE_ALPHA', t[t.DEPTH_COMPONENT = 6402] = 'DEPTH_COMPONENT', t[t.DEPTH_STENCIL = 34041] = 'DEPTH_STENCIL'
        }(Ft || (Ft = {}))),
        (function (t) {
            t[t.TEXTURE_2D = 3553] = 'TEXTURE_2D', t[t.TEXTURE_CUBE_MAP = 34067] = 'TEXTURE_CUBE_MAP', t[t.TEXTURE_2D_ARRAY = 35866] = 'TEXTURE_2D_ARRAY', t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = 'TEXTURE_CUBE_MAP_POSITIVE_X', t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = 'TEXTURE_CUBE_MAP_NEGATIVE_X', t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = 'TEXTURE_CUBE_MAP_POSITIVE_Y', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = 'TEXTURE_CUBE_MAP_NEGATIVE_Y', t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = 'TEXTURE_CUBE_MAP_POSITIVE_Z', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = 'TEXTURE_CUBE_MAP_NEGATIVE_Z'
        }(Bt || (Bt = {}))),
        (function (t) {
            t[t.UNSIGNED_BYTE = 5121] = 'UNSIGNED_BYTE', t[t.UNSIGNED_SHORT = 5123] = 'UNSIGNED_SHORT', t[t.UNSIGNED_SHORT_5_6_5 = 33635] = 'UNSIGNED_SHORT_5_6_5', t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = 'UNSIGNED_SHORT_4_4_4_4', t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = 'UNSIGNED_SHORT_5_5_5_1', t[t.UNSIGNED_INT = 5125] = 'UNSIGNED_INT', t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = 'UNSIGNED_INT_10F_11F_11F_REV', t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = 'UNSIGNED_INT_2_10_10_10_REV', t[t.UNSIGNED_INT_24_8 = 34042] = 'UNSIGNED_INT_24_8', t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = 'UNSIGNED_INT_5_9_9_9_REV', t[t.BYTE = 5120] = 'BYTE', t[t.SHORT = 5122] = 'SHORT', t[t.INT = 5124] = 'INT', t[t.FLOAT = 5126] = 'FLOAT', t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = 'FLOAT_32_UNSIGNED_INT_24_8_REV', t[t.HALF_FLOAT = 36193] = 'HALF_FLOAT'
        }(Ut || (Ut = {}))),
        (function (t) {
            t[t.FLOAT = 0] = 'FLOAT', t[t.INT = 1] = 'INT', t[t.UINT = 2] = 'UINT'
        }(Gt || (Gt = {}))),
        (function (t) {
            t[t.NEAREST = 0] = 'NEAREST', t[t.LINEAR = 1] = 'LINEAR'
        }(Xt || (Xt = {}))),
        (function (t) {
            t[t.CLAMP = 33071] = 'CLAMP', t[t.REPEAT = 10497] = 'REPEAT', t[t.MIRRORED_REPEAT = 33648] = 'MIRRORED_REPEAT'
        }(Ht || (Ht = {}))),
        (function (t) {
            t[t.OFF = 0] = 'OFF', t[t.POW2 = 1] = 'POW2', t[t.ON = 2] = 'ON', t[t.ON_MANUAL = 3] = 'ON_MANUAL'
        }(Vt || (Vt = {}))),
        (function (t) {
            t[t.NPM = 0] = 'NPM', t[t.UNPACK = 1] = 'UNPACK', t[t.PMA = 2] = 'PMA', t[t.NO_PREMULTIPLIED_ALPHA = 0] = 'NO_PREMULTIPLIED_ALPHA', t[t.PREMULTIPLY_ON_UPLOAD = 1] = 'PREMULTIPLY_ON_UPLOAD', t[t.PREMULTIPLY_ALPHA = 2] = 'PREMULTIPLY_ALPHA', t[t.PREMULTIPLIED_ALPHA = 2] = 'PREMULTIPLIED_ALPHA'
        }(Wt || (Wt = {}))),
        (function (t) {
            t[t.NO = 0] = 'NO', t[t.YES = 1] = 'YES', t[t.AUTO = 2] = 'AUTO', t[t.BLEND = 0] = 'BLEND', t[t.CLEAR = 1] = 'CLEAR', t[t.BLIT = 2] = 'BLIT'
        }(Yt || (Yt = {}))),
        (function (t) {
            t[t.AUTO = 0] = 'AUTO', t[t.MANUAL = 1] = 'MANUAL'
        }(zt || (zt = {}))),
        (function (t) {
            t.LOW = 'lowp', t.MEDIUM = 'mediump', t.HIGH = 'highp'
        }(qt || (qt = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.SCISSOR = 1] = 'SCISSOR', t[t.STENCIL = 2] = 'STENCIL', t[t.SPRITE = 3] = 'SPRITE'
        }(Kt || (Kt = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.LOW = 2] = 'LOW', t[t.MEDIUM = 4] = 'MEDIUM', t[t.HIGH = 8] = 'HIGH'
        }(Zt || (Zt = {}))),
        (function (t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = 'ELEMENT_ARRAY_BUFFER', t[t.ARRAY_BUFFER = 34962] = 'ARRAY_BUFFER', t[t.UNIFORM_BUFFER = 35345] = 'UNIFORM_BUFFER'
        }($t || ($t = {})))
        const te = (function (t) {
            function e(e, n, r, i, o) {
                void 0 === n && (n = 8), void 0 === r && (r = 4), void 0 === i && (i = It.b.FILTER_RESOLUTION), void 0 === o && (o = 5)
                let a = this
                var s = (function (t, e) {
                    var n; var r = Math.ceil(t / 2);
                                    var i = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
                                    var o = '';
                    n = e ? 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);' : 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);';
                    for (let a = 0; a < t; a++) {
                        var s = n.replace('%index%', a.toString())
                                    o += s = s.replace('%sampleIndex%', `${a - (r - 1)  }.0`), o += '\n'
                    }
                    return i = (i = i.replace('%blur%', o)).replace('%size%', t.toString())
                }(o, e))
                var u = (function (t) {
                    for (var e, n = Jt[t], r = n.length, i = Qt, o = '', a = 0; a < t; a++) {
                        let s = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;'.replace('%index%', a.toString())
                        e = a, a >= r && (e = t - a - 1), o += s = s.replace('%value%', n[e].toString()), o += '\n'
                    }
                    return i = (i = i.replace('%blur%', o)).replace('%size%', t.toString())
                }
                /*!
                         * @pixi/constants - v6.2.0
                         * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                         *
                         * @pixi/constants is licensed under the MIT License.
                         * http://www.opensource.org/licenses/mit-license
                         */
                (o))
                return (a = t.call(this, s, u) || this).horizontal = e, a.resolution = i, a._quality = 0, a.quality = r, a.blur = n, a
            }
            return kt(e, t), e.prototype.apply = function (t, e, n, r) {
                if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / e.width) : this.uniforms.strength = 1 / n.height * (n.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1) { t.applyFilter(this, e, n, r)
                }
                else {
                    let i = t.getFilterTexture()
                    var o = t.renderer
                    var a = e
                    var s = i
                    this.state.blend = !1, t.applyFilter(this, a, s, Yt.CLEAR)
                    for (let u = 1; u < this.passes - 1; u++) {
                        t.bindAndClear(a, Yt.BLIT), this.uniforms.uSampler = s
                        let c = s
                        s = a, a = c, o.shader.bind(this), o.geometry.draw(5)
                    }
                    this.state.blend = !0, t.applyFilter(this, s, n, r), t.returnFilterTexture(i)
                }
            }, Object.defineProperty(e.prototype, 'blur', {
                get () {
                    return this.strength
                },
                set (t) {
                    this.padding = 1 + 2 * Math.abs(t), this.strength = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'quality', {
                get () {
                    return this._quality
                },
                set (t) {
                    this._quality = t, this.passes = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(w.u))
        let ee = (function (t) {
            function e(e, n, r, i) {
                void 0 === e && (e = 8), void 0 === n && (n = 4), void 0 === r && (r = It.b.FILTER_RESOLUTION), void 0 === i && (i = 5)
                let o = t.call(this) || this
                return o.blurXFilter = new te(!0, e, n, r, i), o.blurYFilter = new te(!1, e, n, r, i), o.resolution = r, o.quality = n, o.blur = e, o.repeatEdgePixels = !1, o
            }
            return kt(e, t), e.prototype.apply = function (t, e, n, r) {
                const i = Math.abs(this.blurXFilter.strength)
                var o = Math.abs(this.blurYFilter.strength)
                if (i && o) {
                    const a = t.getFilterTexture()
                    this.blurXFilter.apply(t, e, a, Yt.CLEAR), this.blurYFilter.apply(t, a, n, r), t.returnFilterTexture(a)
                } else { o ? this.blurYFilter.apply(t, e, n, r) : this.blurXFilter.apply(t, e, n, r)
                }
            }, e.prototype.updatePadding = function () {
                this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength))
            }, Object.defineProperty(e.prototype, 'blur', {
                get() {
                    return this.blurXFilter.blur
                },
                set(t) {
                    this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'quality', {
                get() {
                    return this.blurXFilter.quality
                },
                set(t) {
                    this.blurXFilter.quality = this.blurYFilter.quality = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'blurX', {
                get() {
                    return this.blurXFilter.blur
                },
                set(t) {
                    this.blurXFilter.blur = t, this.updatePadding()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'blurY', {
                get() {
                    return this.blurYFilter.blur
                },
                set(t) {
                    this.blurYFilter.blur = t, this.updatePadding()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'blendMode', {
                get() {
                    return this.blurYFilter.blendMode
                },
                set(t) {
                    this.blurYFilter.blendMode = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'repeatEdgePixels', {
                get() {
                    return this._repeatEdgePixels
                },
                set(t) {
                    this._repeatEdgePixels = t, this.updatePadding()
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(w.u))
        let ne = function (t, e) {
            return (ne = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        const re = (function (t) {
            function e() {
                let e = this
                var n = {
                    m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
                    uAlpha: 1
                }
                return (e = t.call(this, w.pb, 'varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n', n) || this).alpha = 1, e
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                ne(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype._loadMatrix = function (t, e) {
                void 0 === e && (e = !1)
                let n = t
                e && (this._multiply(n, this.uniforms.m, t), n = this._colorMatrix(n)), this.uniforms.m = n
            }, e.prototype._multiply = function (t, e, n) {
                return t[0] = e[0] * n[0] + e[1] * n[5] + e[2] * n[10] + e[3] * n[15], t[1] = e[0] * n[1] + e[1] * n[6] + e[2] * n[11] + e[3] * n[16], t[2] = e[0] * n[2] + e[1] * n[7] + e[2] * n[12] + e[3] * n[17], t[3] = e[0] * n[3] + e[1] * n[8] + e[2] * n[13] + e[3] * n[18], t[4] = e[0] * n[4] + e[1] * n[9] + e[2] * n[14] + e[3] * n[19] + e[4], t[5] = e[5] * n[0] + e[6] * n[5] + e[7] * n[10] + e[8] * n[15], t[6] = e[5] * n[1] + e[6] * n[6] + e[7] * n[11] + e[8] * n[16], t[7] = e[5] * n[2] + e[6] * n[7] + e[7] * n[12] + e[8] * n[17], t[8] = e[5] * n[3] + e[6] * n[8] + e[7] * n[13] + e[8] * n[18], t[9] = e[5] * n[4] + e[6] * n[9] + e[7] * n[14] + e[8] * n[19] + e[9], t[10] = e[10] * n[0] + e[11] * n[5] + e[12] * n[10] + e[13] * n[15], t[11] = e[10] * n[1] + e[11] * n[6] + e[12] * n[11] + e[13] * n[16], t[12] = e[10] * n[2] + e[11] * n[7] + e[12] * n[12] + e[13] * n[17], t[13] = e[10] * n[3] + e[11] * n[8] + e[12] * n[13] + e[13] * n[18], t[14] = e[10] * n[4] + e[11] * n[9] + e[12] * n[14] + e[13] * n[19] + e[14], t[15] = e[15] * n[0] + e[16] * n[5] + e[17] * n[10] + e[18] * n[15], t[16] = e[15] * n[1] + e[16] * n[6] + e[17] * n[11] + e[18] * n[16], t[17] = e[15] * n[2] + e[16] * n[7] + e[17] * n[12] + e[18] * n[17], t[18] = e[15] * n[3] + e[16] * n[8] + e[17] * n[13] + e[18] * n[18], t[19] = e[15] * n[4] + e[16] * n[9] + e[17] * n[14] + e[18] * n[19] + e[19], t
            }, e.prototype._colorMatrix = function (t) {
                const e = new Float32Array(t)
                return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e
            }, e.prototype.brightness = function (t, e) {
                const n = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0]
                this._loadMatrix(n, e)
            }, e.prototype.tint = function (t, e) {
                const n = [(t >> 16 & 255) / 255, 0, 0, 0, 0, 0, (t >> 8 & 255) / 255, 0, 0, 0, 0, 0, (255 & t) / 255, 0, 0, 0, 0, 0, 1, 0]
                this._loadMatrix(n, e)
            }, e.prototype.greyscale = function (t, e) {
                const n = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0]
                this._loadMatrix(n, e)
            }, e.prototype.blackAndWhite = function (t) {
                this._loadMatrix([0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], t)
            }, e.prototype.hue = function (t, e) {
                t = (t || 0) / 180 * Math.PI
                let n = Math.cos(t)
                var r = Math.sin(t)
                var i = 1 / 3
                var o = (0, Math.sqrt)(i)
                var a = [n + (1 - n) * i, i * (1 - n) - o * r, i * (1 - n) + o * r, 0, 0, i * (1 - n) + o * r, n + i * (1 - n), i * (1 - n) - o * r, 0, 0, i * (1 - n) - o * r, i * (1 - n) + o * r, n + i * (1 - n), 0, 0, 0, 0, 0, 1, 0]
                this._loadMatrix(a, e)
            }, e.prototype.contrast = function (t, e) {
                const n = (t || 0) + 1
                var r = -0.5 * (n - 1)
                var i = [n, 0, 0, 0, r, 0, n, 0, 0, r, 0, 0, n, 0, r, 0, 0, 0, 1, 0]
                this._loadMatrix(i, e)
            }, e.prototype.saturate = function (t, e) {
                void 0 === t && (t = 0)
                let n = 2 * t / 3 + 1
                var r = -0.5 * (n - 1)
                var i = [n, r, r, 0, 0, r, n, r, 0, 0, r, r, n, 0, 0, 0, 0, 0, 1, 0]
                this._loadMatrix(i, e)
            }, e.prototype.desaturate = function () {
                this.saturate(-1)
            }, e.prototype.negative = function (t) {
                this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t)
            }, e.prototype.sepia = function (t) {
                this._loadMatrix([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], t)
            }, e.prototype.technicolor = function (t) {
                this._loadMatrix([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t)
            }, e.prototype.polaroid = function (t) {
                this._loadMatrix([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t)
            }, e.prototype.toBGR = function (t) {
                this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t)
            }, e.prototype.kodachrome = function (t) {
                this._loadMatrix([1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t)
            }, e.prototype.browni = function (t) {
                this._loadMatrix([0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t)
            }, e.prototype.vintage = function (t) {
                this._loadMatrix([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t)
            }, e.prototype.colorTone = function (t, e, n, r, i) {
                const o = ((n = n || 16770432) >> 16 & 255) / 255
                var a = (n >> 8 & 255) / 255
                var s = (255 & n) / 255
                var u = ((r = r || 3375104) >> 16 & 255) / 255
                var c = (r >> 8 & 255) / 255
                var l = (255 & r) / 255
                var h = [0.3, 0.59, 0.11, 0, 0, o, a, s, t = t || 0.2, 0, u, c, l, e = e || 0.15, 0, o - u, a - c, s - l, 0, 0]
                this._loadMatrix(h, i)
            }, e.prototype.night = function (t, e) {
                const n = [-2 * (t = t || 0.1), -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0]
                this._loadMatrix(n, e)
            }, e.prototype.predator = function (t, e) {
                const n = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, 0.40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, 0.8044459223747253 * t, 0, 0, 0, 1, 0]
                this._loadMatrix(n, e)
            }, e.prototype.lsd = function (t) {
                this._loadMatrix([2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], t)
            }, e.prototype.reset = function () {
                this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1)
            }, Object.defineProperty(e.prototype, 'matrix', {
                get() {
                    return this.uniforms.m
                },
                set(t) {
                    this.uniforms.m = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'alpha', {
                get() {
                    return this.uniforms.uAlpha
                },
                set(t) {
                    this.uniforms.uAlpha = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(w.u))
        re.prototype.grayscale = re.prototype.greyscale
        /*!
             * @pixi/filter-displacement - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/filter-displacement is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0

            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.

            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
            ***************************************************************************** */
        let ie = function (t, e) {
            return (ie = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        const oe = (function (t) {
            function e(e, n) {
                let r = this
                var i = new m.d()
                return e.renderable = !1, (r = t.call(this, 'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n', 'varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n', {
                    mapSampler: e._texture,
                    filterMatrix: i,
                    scale: {
                        x: 1,
                        y: 1
                    },
                    rotation: new Float32Array([1, 0, 0, 1])
                }) || this).maskSprite = e, r.maskMatrix = i, n == null && (n = 20), r.scale = new m.g(n, n), r
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                ie(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype.apply = function (t, e, n, r) {
                this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y
                let i = this.maskSprite.worldTransform
                var o = Math.sqrt(i.a * i.a + i.b * i.b)
                var a = Math.sqrt(i.c * i.c + i.d * i.d)
                o !== 0 && a !== 0 && (this.uniforms.rotation[0] = i.a / o, this.uniforms.rotation[1] = i.b / o, this.uniforms.rotation[2] = i.c / a, this.uniforms.rotation[3] = i.d / a), t.applyFilter(this, e, n, r)
            }, Object.defineProperty(e.prototype, 'map', {
                get () {
                    return this.uniforms.mapSampler
                },
                set (t) {
                    this.uniforms.mapSampler = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(w.u))
        let ae = function (t, e) {
            return (ae = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        const se = (function (t) {
            function e() {
                return t.call(this, '\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n', 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n') || this
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                ae(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e
        }(w.u))
        let ue = function (t, e) {
            return (ue = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        let ce; let le; let he; let fe; let de; let pe; let me; let ye; let ve; let _e; let ge; let be; let Ee; let xe; let Te; let Se; let we; let Oe; let Pe; const Re = (function (t) {
            function e(e, n) {
                void 0 === e && (e = 0.5), void 0 === n && (n = Math.random())
                var r = t.call(this, w.pb, 'precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n', {
                    uNoise: 0,
                    uSeed: 0
                }) || this
                return r.noise = e, r.seed = n, r
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                ue(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), Object.defineProperty(e.prototype, 'noise', {
                get () {
                    return this.uniforms.uNoise
                },
                set (t) {
                    this.uniforms.uNoise = t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'seed', {
                get () {
                    return this.uniforms.uSeed
                },
                set (t) {
                    this.uniforms.uSeed = t
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(w.u))
        var Ae = n('./node_modules/@pixi/sprite/dist/esm/sprite.js')
        !(function (t) {
            t[t.WEBGL_LEGACY = 0] = 'WEBGL_LEGACY', t[t.WEBGL = 1] = 'WEBGL', t[t.WEBGL2 = 2] = 'WEBGL2'
        }(ce || (ce = {}))),
        (function (t) {
            t[t.UNKNOWN = 0] = 'UNKNOWN', t[t.WEBGL = 1] = 'WEBGL', t[t.CANVAS = 2] = 'CANVAS'
        }(le || (le = {}))),
        (function (t) {
            t[t.COLOR = 16384] = 'COLOR', t[t.DEPTH = 256] = 'DEPTH', t[t.STENCIL = 1024] = 'STENCIL'
        }(he || (he = {}))),
        (function (t) {
            t[t.NORMAL = 0] = 'NORMAL', t[t.ADD = 1] = 'ADD', t[t.MULTIPLY = 2] = 'MULTIPLY', t[t.SCREEN = 3] = 'SCREEN', t[t.OVERLAY = 4] = 'OVERLAY', t[t.DARKEN = 5] = 'DARKEN', t[t.LIGHTEN = 6] = 'LIGHTEN', t[t.COLOR_DODGE = 7] = 'COLOR_DODGE', t[t.COLOR_BURN = 8] = 'COLOR_BURN', t[t.HARD_LIGHT = 9] = 'HARD_LIGHT', t[t.SOFT_LIGHT = 10] = 'SOFT_LIGHT', t[t.DIFFERENCE = 11] = 'DIFFERENCE', t[t.EXCLUSION = 12] = 'EXCLUSION', t[t.HUE = 13] = 'HUE', t[t.SATURATION = 14] = 'SATURATION', t[t.COLOR = 15] = 'COLOR', t[t.LUMINOSITY = 16] = 'LUMINOSITY', t[t.NORMAL_NPM = 17] = 'NORMAL_NPM', t[t.ADD_NPM = 18] = 'ADD_NPM', t[t.SCREEN_NPM = 19] = 'SCREEN_NPM', t[t.NONE = 20] = 'NONE', t[t.SRC_OVER = 0] = 'SRC_OVER', t[t.SRC_IN = 21] = 'SRC_IN', t[t.SRC_OUT = 22] = 'SRC_OUT', t[t.SRC_ATOP = 23] = 'SRC_ATOP', t[t.DST_OVER = 24] = 'DST_OVER', t[t.DST_IN = 25] = 'DST_IN', t[t.DST_OUT = 26] = 'DST_OUT', t[t.DST_ATOP = 27] = 'DST_ATOP', t[t.ERASE = 26] = 'ERASE', t[t.SUBTRACT = 28] = 'SUBTRACT', t[t.XOR = 29] = 'XOR'
        }(fe || (fe = {}))),
        (function (t) {
            t[t.POINTS = 0] = 'POINTS', t[t.LINES = 1] = 'LINES', t[t.LINE_LOOP = 2] = 'LINE_LOOP', t[t.LINE_STRIP = 3] = 'LINE_STRIP', t[t.TRIANGLES = 4] = 'TRIANGLES', t[t.TRIANGLE_STRIP = 5] = 'TRIANGLE_STRIP', t[t.TRIANGLE_FAN = 6] = 'TRIANGLE_FAN'
        }(de || (de = {}))),
        (function (t) {
            t[t.RGBA = 6408] = 'RGBA', t[t.RGB = 6407] = 'RGB', t[t.RG = 33319] = 'RG', t[t.RED = 6403] = 'RED', t[t.RGBA_INTEGER = 36249] = 'RGBA_INTEGER', t[t.RGB_INTEGER = 36248] = 'RGB_INTEGER', t[t.RG_INTEGER = 33320] = 'RG_INTEGER', t[t.RED_INTEGER = 36244] = 'RED_INTEGER', t[t.ALPHA = 6406] = 'ALPHA', t[t.LUMINANCE = 6409] = 'LUMINANCE', t[t.LUMINANCE_ALPHA = 6410] = 'LUMINANCE_ALPHA', t[t.DEPTH_COMPONENT = 6402] = 'DEPTH_COMPONENT', t[t.DEPTH_STENCIL = 34041] = 'DEPTH_STENCIL'
        }(pe || (pe = {}))),
        (function (t) {
            t[t.TEXTURE_2D = 3553] = 'TEXTURE_2D', t[t.TEXTURE_CUBE_MAP = 34067] = 'TEXTURE_CUBE_MAP', t[t.TEXTURE_2D_ARRAY = 35866] = 'TEXTURE_2D_ARRAY', t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = 'TEXTURE_CUBE_MAP_POSITIVE_X', t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = 'TEXTURE_CUBE_MAP_NEGATIVE_X', t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = 'TEXTURE_CUBE_MAP_POSITIVE_Y', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = 'TEXTURE_CUBE_MAP_NEGATIVE_Y', t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = 'TEXTURE_CUBE_MAP_POSITIVE_Z', t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = 'TEXTURE_CUBE_MAP_NEGATIVE_Z'
        }(me || (me = {}))),
        (function (t) {
            t[t.UNSIGNED_BYTE = 5121] = 'UNSIGNED_BYTE', t[t.UNSIGNED_SHORT = 5123] = 'UNSIGNED_SHORT', t[t.UNSIGNED_SHORT_5_6_5 = 33635] = 'UNSIGNED_SHORT_5_6_5', t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = 'UNSIGNED_SHORT_4_4_4_4', t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = 'UNSIGNED_SHORT_5_5_5_1', t[t.UNSIGNED_INT = 5125] = 'UNSIGNED_INT', t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = 'UNSIGNED_INT_10F_11F_11F_REV', t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = 'UNSIGNED_INT_2_10_10_10_REV', t[t.UNSIGNED_INT_24_8 = 34042] = 'UNSIGNED_INT_24_8', t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = 'UNSIGNED_INT_5_9_9_9_REV', t[t.BYTE = 5120] = 'BYTE', t[t.SHORT = 5122] = 'SHORT', t[t.INT = 5124] = 'INT', t[t.FLOAT = 5126] = 'FLOAT', t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = 'FLOAT_32_UNSIGNED_INT_24_8_REV', t[t.HALF_FLOAT = 36193] = 'HALF_FLOAT'
        }(ye || (ye = {}))),
        (function (t) {
            t[t.FLOAT = 0] = 'FLOAT', t[t.INT = 1] = 'INT', t[t.UINT = 2] = 'UINT'
        }(ve || (ve = {}))),
        (function (t) {
            t[t.NEAREST = 0] = 'NEAREST', t[t.LINEAR = 1] = 'LINEAR'
        }(_e || (_e = {}))),
        (function (t) {
            t[t.CLAMP = 33071] = 'CLAMP', t[t.REPEAT = 10497] = 'REPEAT', t[t.MIRRORED_REPEAT = 33648] = 'MIRRORED_REPEAT'
        }(ge || (ge = {}))),
        (function (t) {
            t[t.OFF = 0] = 'OFF', t[t.POW2 = 1] = 'POW2', t[t.ON = 2] = 'ON', t[t.ON_MANUAL = 3] = 'ON_MANUAL'
        }(be || (be = {}))),
        (function (t) {
            t[t.NPM = 0] = 'NPM', t[t.UNPACK = 1] = 'UNPACK', t[t.PMA = 2] = 'PMA', t[t.NO_PREMULTIPLIED_ALPHA = 0] = 'NO_PREMULTIPLIED_ALPHA', t[t.PREMULTIPLY_ON_UPLOAD = 1] = 'PREMULTIPLY_ON_UPLOAD', t[t.PREMULTIPLY_ALPHA = 2] = 'PREMULTIPLY_ALPHA', t[t.PREMULTIPLIED_ALPHA = 2] = 'PREMULTIPLIED_ALPHA'
        }(Ee || (Ee = {}))),
        (function (t) {
            t[t.NO = 0] = 'NO', t[t.YES = 1] = 'YES', t[t.AUTO = 2] = 'AUTO', t[t.BLEND = 0] = 'BLEND', t[t.CLEAR = 1] = 'CLEAR', t[t.BLIT = 2] = 'BLIT'
        }(xe || (xe = {}))),
        (function (t) {
            t[t.AUTO = 0] = 'AUTO', t[t.MANUAL = 1] = 'MANUAL'
        }(Te || (Te = {}))),
        (function (t) {
            t.LOW = 'lowp', t.MEDIUM = 'mediump', t.HIGH = 'highp'
        }(Se || (Se = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.SCISSOR = 1] = 'SCISSOR', t[t.STENCIL = 2] = 'STENCIL', t[t.SPRITE = 3] = 'SPRITE'
        }(we || (we = {}))),
        (function (t) {
            t[t.NONE = 0] = 'NONE', t[t.LOW = 2] = 'LOW', t[t.MEDIUM = 4] = 'MEDIUM', t[t.HIGH = 8] = 'HIGH'
        }(Oe || (Oe = {}))),
        (function (t) {
            t[t.ELEMENT_ARRAY_BUFFER = 34963] = 'ELEMENT_ARRAY_BUFFER', t[t.ARRAY_BUFFER = 34962] = 'ARRAY_BUFFER', t[t.UNIFORM_BUFFER = 35345] = 'UNIFORM_BUFFER'
        }(Pe || (Pe = {})))
        const Ie = new m.d()
        f.c.prototype._cacheAsBitmap = !1, f.c.prototype._cacheData = null, f.c.prototype._cacheAsBitmapResolution = null, f.c.prototype._cacheAsBitmapMultisample = Oe.NONE
        const Ce = function () {
            this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
        }
        Object.defineProperties(f.c.prototype, {
            cacheAsBitmapResolution: {
                get() {
                    return this._cacheAsBitmapResolution
                },
                set(t) {
                    t !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
                }
            },
            cacheAsBitmapMultisample: {
                get() {
                    return this._cacheAsBitmapMultisample
                },
                set(t) {
                    t !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
                }
            },
            cacheAsBitmap: {
                get() {
                    return this._cacheAsBitmap
                },
                set(t) {
                    let e
                    this._cacheAsBitmap !== t && (this._cacheAsBitmap = t, t ? (this._cacheData || (this._cacheData = new Ce()), (e = this._cacheData).originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea))
                }
            }
        }), f.c.prototype._renderCached = function (t) {
            !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
        }, f.c.prototype._initCachedDisplayObject = function (t) {
            let e
            if (!this._cacheData || !this._cacheData.sprite) {
                const n = this.alpha
                this.alpha = 1, t.batch.flush()
                const r = this.getLocalBounds(null, !0).clone()
                if (this.filters) {
                    const i = this.filters[0].padding
                    r.pad(i)
                }
                r.ceil(It.b.RESOLUTION)
                const o = t.renderTexture.current
                const a = t.renderTexture.sourceFrame.clone()
                const s = t.renderTexture.destinationFrame.clone()
                const u = t.projection.transform
                const c = w.P.create({
                    width: r.width,
                    height: r.height,
                    resolution: this.cacheAsBitmapResolution || t.resolution,
                    multisample: (e = this.cacheAsBitmapMultisample) !== null && void 0 !== e ? e : t.multisample
                })
                const l = `cacheAsBitmap_${new Object(h.uid)()}`
                this._cacheData.textureCacheId = l, w.h.addToCache(c.baseTexture, l), w.db.addToCache(c, l)
                const f = this.transform.localTransform.copyTo(Ie).invert().translate(-r.x, -r.y)
                this.render = this._cacheData.originalRender, t.render(this, {
                    renderTexture: c,
                    clear: !0,
                    transform: f,
                    skipUpdateTransform: !1
                }), t.framebuffer.blit(), t.projection.transform = u, t.renderTexture.bind(o, a, s), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = n
                const d = new Ae.a(c)
                d.transform.worldTransform = this.transform.worldTransform, d.anchor.x = -r.x / r.width, d.anchor.y = -r.y / r.height, d.alpha = n, d._bounds = this._bounds, this._cacheData.sprite = d, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = d.containsPoint.bind(d)
            }
        }, f.c.prototype._renderCachedCanvas = function (t) {
            !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
        }, f.c.prototype._initCachedDisplayObjectCanvas = function (t) {
            if (!this._cacheData || !this._cacheData.sprite) {
                const e = this.getLocalBounds(null, !0)
                const n = this.alpha
                this.alpha = 1
                const r = t.context
                const i = t._projTransform
                e.ceil(It.b.RESOLUTION)
                const o = w.P.create({
                    width: e.width,
                    height: e.height
                })
                const a = `cacheAsBitmap_${new Object(h.uid)()}`
                this._cacheData.textureCacheId = a, w.h.addToCache(o.baseTexture, a), w.db.addToCache(o, a)
                const s = Ie
                this.transform.localTransform.copyTo(s), s.invert(), s.tx -= e.x, s.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, {
                    renderTexture: o,
                    clear: !0,
                    transform: s,
                    skipUpdateTransform: !1
                }), t.context = r, t._projTransform = i, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = n
                const u = new Ae.a(o)
                u.transform.worldTransform = this.transform.worldTransform, u.anchor.x = -e.x / e.width, u.anchor.y = -e.y / e.height, u.alpha = n, u._bounds = this._bounds, this._cacheData.sprite = u, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = u.containsPoint.bind(u)
            }
        }, f.c.prototype._calculateCachedBounds = function () {
            this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
        }, f.c.prototype._getCachedLocalBounds = function () {
            return this._cacheData.sprite.getLocalBounds(null)
        }, f.c.prototype._destroyCachedDisplayObject = function () {
            this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, w.h.removeFromCache(this._cacheData.textureCacheId), w.db.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
        }, f.c.prototype._cacheAsBitmapDestroy = function (t) {
            this.cacheAsBitmap = !1, this.destroy(t)
        },
        /*!
                 * @pixi/mixin-get-child-by-name - v6.2.0
                 * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                 *
                 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
                 * http://www.opensource.org/licenses/mit-license
                 */
        f.c.prototype.name = null, f.b.prototype.getChildByName = function (t, e) {
            for (var n = 0, r = this.children.length; n < r; n++) {
                if (this.children[n].name === t) return this.children[n]
            }
            if (e) {
                for (n = 0, r = this.children.length; n < r; n++) {
                    if (this.children[n].getChildByName) {
                        const i = this.children[n].getChildByName(t, !0)
                        if (i) return i
                    }
                }
            }
            return null
        },
        /*!
                 * @pixi/mixin-get-global-position - v6.2.0
                 * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                 *
                 * @pixi/mixin-get-global-position is licensed under the MIT License.
                 * http://www.opensource.org/licenses/mit-license
                 */
        f.c.prototype.getGlobalPosition = function (t, e) {
            return void 0 === t && (t = new m.g()), void 0 === e && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t
        }
        var ke = n('./node_modules/@pixi/graphics/dist/esm/graphics.js')
        var Ne = n('./node_modules/@pixi/mesh/dist/esm/mesh.js')
        var Me = n('./node_modules/@pixi/mesh-extras/dist/esm/mesh-extras.js')
        var je = n('./node_modules/@pixi/runner/dist/esm/runner.js')
        let De = function (t, e) {
            return (De = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        var Le = (function (t) {
            function e(e, n) {
                void 0 === n && (n = !0)
                const r = t.call(this, e[0] instanceof w.db ? e[0] : e[0].texture) || this
                return r._textures = null, r._durations = null, r._autoUpdate = n, r._isConnectedToTicker = !1, r.animationSpeed = 1, r.loop = !0, r.updateAnchor = !1, r.onComplete = null, r.onFrameChange = null, r.onLoop = null, r._currentTime = 0, r._playing = !1, r._previousFrame = null, r.textures = e, r
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                De(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype.stop = function () {
                this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (y.a.shared.remove(this.update, this), this._isConnectedToTicker = !1))
            }, e.prototype.play = function () {
                this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (y.a.shared.add(this.update, this, y.c.HIGH), this._isConnectedToTicker = !0))
            }, e.prototype.gotoAndStop = function (t) {
                this.stop()
                const e = this.currentFrame
                this._currentTime = t, e !== this.currentFrame && this.updateTexture()
            }, e.prototype.gotoAndPlay = function (t) {
                const e = this.currentFrame
                this._currentTime = t, e !== this.currentFrame && this.updateTexture(), this.play()
            }, e.prototype.update = function (t) {
                if (this._playing) {
                    const e = this.animationSpeed * t
                    let n = this.currentFrame
                    if (this._durations !== null) {
                        let r = this._currentTime % 1 * this._durations[this.currentFrame]
                        for (r += e / 60 * 1e3; r < 0;) this._currentTime--, r += this._durations[this.currentFrame]
                        const i = Math.sign(this.animationSpeed * t)
                        for (this._currentTime = Math.floor(this._currentTime); r >= this._durations[this.currentFrame];) r -= this._durations[this.currentFrame] * i, this._currentTime += i
                        this._currentTime += r / this._durations[this.currentFrame]
                    } else { this._currentTime += e
                    }
                    this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n || this.animationSpeed < 0 && this.currentFrame > n) && this.onLoop(), this.updateTexture())
                }
            }, e.prototype.updateTexture = function () {
                const t = this.currentFrame
                this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame))
            }, e.prototype.destroy = function (e) {
                this.stop(), t.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null
            }, e.fromFrames = function (t) {
                for (var n = [], r = 0; r < t.length; ++r) n.push(w.db.from(t[r]))
                return new e(n)
            }, e.fromImages = function (t) {
                for (var n = [], r = 0; r < t.length; ++r) n.push(w.db.from(t[r]))
                return new e(n)
            }, Object.defineProperty(e.prototype, 'totalFrames', {
                get() {
                    return this._textures.length
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'textures', {
                get() {
                    return this._textures
                },
                set(t) {
                    if (t[0] instanceof w.db) { this._textures = t, this._durations = null
                    }
                    else {
                        this._textures = [], this._durations = []
                        for (let e = 0; e < t.length; e++) this._textures.push(t[e].texture), this._durations.push(t[e].time)
                    }
                    this._previousFrame = null, this.gotoAndStop(0), this.updateTexture()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'currentFrame', {
                get() {
                    let t = Math.floor(this._currentTime) % this._textures.length
                    return t < 0 && (t += this._textures.length), t
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'playing', {
                get() {
                    return this._playing
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'autoUpdate', {
                get() {
                    return this._autoUpdate
                },
                set(t) {
                    t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (y.a.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (y.a.shared.add(this.update, this), this._isConnectedToTicker = !0))
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(Ae.a))
        var Fe = n('./node_modules/@pixi/text/dist/esm/text.js')
        /*!
             * pixi.js - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * pixi.js is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        w.S.registerPlugin('accessibility', p), w.S.registerPlugin('extract', C), w.S.registerPlugin('interaction', S), w.S.registerPlugin('particle', Tt.b), w.S.registerPlugin('prepare', St.c), w.S.registerPlugin('batch', w.l), w.S.registerPlugin('tilingSprite', Ot.b), k.b.registerPlugin(Pt.c), k.b.registerPlugin(X), k.b.registerPlugin(at), k.b.registerPlugin(xt), k.b.registerPlugin(wt.b), O.registerPlugin(y.b), O.registerPlugin(k.a)
        var Be = '6.2.0'
        var Ue = {
            AlphaFilter: At,
            BlurFilter: ee,
            BlurFilterPass: te,
            ColorMatrixFilter: re,
            DisplacementFilter: oe,
            FXAAFilter: se,
            NoiseFilter: Re
        }
    },
    './node_modules/process/browser.js': function (t, e) {
        let n; let r; const i = t.exports = {}

        function o() {
            throw new Error('setTimeout has not been defined')
        }

        function a() {
            throw new Error('clearTimeout has not been defined')
        }

        function s(t) {
            if (n === setTimeout) return setTimeout(t, 0)
            if ((n === o || !n) && setTimeout) return n = setTimeout, setTimeout(t, 0)
            try {
                return n(t, 0)
            } catch (e) {
                try {
                    return n.call(null, t, 0)
                } catch (e) {
                    return n.call(this, t, 0)
                }
            }
        }!(function () {
            try {
                n = typeof setTimeout == 'function' ? setTimeout : o
            } catch (t) {
                n = o
            }
            try {
                r = typeof clearTimeout == 'function' ? clearTimeout : a
            } catch (t) {
                r = a
            }
        }())
        let u; let c = []
        let l = !1
        let h = -1

        function f() {
            l && u && (l = !1, u.length ? c = u.concat(c) : h = -1, c.length && d())
        }

        function d() {
            if (!l) {
                const t = s(f)
                l = !0
                for (let e = c.length; e;) {
                    for (u = c, c = []; ++h < e;) u && u[h].run()
                    h = -1, e = c.length
                }
                u = null, l = !1,
                (function (t) {
                    if (r === clearTimeout) return clearTimeout(t)
                    if ((r === a || !r) && clearTimeout) return r = clearTimeout, clearTimeout(t)
                    try {
                        r(t)
                    } catch (e) {
                        try {
                            return r.call(null, t)
                        } catch (e) {
                            return r.call(this, t)
                        }
                    }
                }(t))
            }
        }

        function p(t, e) {
            this.fun = t, this.array = e
        }

        function m() {}
        i.nextTick = function (t) {
            const e = Array.from({ length: arguments.length - 1 })
            if (arguments.length > 1) {
                for (let n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
            }
            c.push(new p(t, e)), c.length !== 1 || l || s(d)
        }, p.prototype.run = function () {
            this.fun.apply(null, this.array)
        }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = m, i.addListener = m, i.once = m, i.off = m, i.removeListener = m, i.removeAllListeners = m, i.emit = m, i.prependListener = m, i.prependOnceListener = m, i.listeners = function (t) {
            return []
        }, i.binding = function (t) {
            throw new Error('process.binding is not supported')
        }, i.cwd = function () {
            return '/'
        }, i.chdir = function (t) {
            throw new Error('process.chdir is not supported')
        }, i.umask = function () {
            return 0
        }
    },
    './node_modules/promise-polyfill/src/allSettled.js': function (t, e, n) {
        'use strict'
        e.a = function (t) {
            return new this((e, n) => {
                if (!t || void 0 === t.length) return n(new TypeError(`${typeof t} ${t} is not iterable(cannot read property Symbol(Symbol.iterator))`))
                const r = Array.prototype.slice.call(t)
                if (r.length === 0) return e([])
                let i = r.length

                function o(t, n) {
                    if (n && (typeof n == 'object' || typeof n == 'function')) {
                        const a = n.then
                        if (typeof a == 'function') { return void a.call(n, (e) => {
                            o(t, e)
                        }, (n) => {
                            r[t] = {
                                status: 'rejected',
                                reason: n
                            }, --i == 0 && e(r)
                        })
                        }
                    }
                    r[t] = {
                        status: 'fulfilled',
                        value: n
                    }, --i == 0 && e(r)
                }
                for (let a = 0; a < r.length; a++) o(a, r[a])
            })
        }
    },
    './node_modules/promise-polyfill/src/finally.js': function (t, e, n) {
        'use strict'
        e.a = function (t) {
            const e = this.constructor
            return this.then((n) => {
                return e.resolve(t()).then(() => {
                    return n
                })
            }, (n) => {
                return e.resolve(t()).then(() => {
                    return e.reject(n)
                })
            })
        }
    },
    './node_modules/promise-polyfill/src/index.js': function (t, e, n) {
        'use strict';
        (function (t) {
            const r = n('./node_modules/promise-polyfill/src/finally.js')
            const i = n('./node_modules/promise-polyfill/src/allSettled.js')
            const o = setTimeout
            const a = void 0 !== t ? t : null

            function s(t) {
                return Boolean(t && void 0 !== t.length)
            }

            function u() {}

            function c(t) {
                if (!(this instanceof c)) throw new TypeError('Promises must be constructed via new')
                if (typeof t != 'function') throw new TypeError('not a function')
                this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], m(t, this)
            }

            function l(t, e) {
                for (; t._state === 3;) t = t._value
                t._state !== 0
                    ? (t._handled = !0, c._immediateFn(() => {
                            const n = t._state === 1 ? e.onFulfilled : e.onRejected
                            if (n !== null) {
                                let r
                                try {
                                    r = n(t._value)
                                } catch (t) {
                                    return void f(e.promise, t)
                                }
                                h(e.promise, r)
                            } else { (t._state === 1 ? h : f)(e.promise, t._value)
                            }
                        }))
                    : t._deferreds.push(e)
            }

            function h(t, e) {
                try {
                    if (e === t) throw new TypeError('A promise cannot be resolved with itself.')
                    if (e && (typeof e == 'object' || typeof e == 'function')) {
                        const n = e.then
                        if (e instanceof c) return t._state = 3, t._value = e, void d(t)
                        if (typeof n == 'function') { return void m((r = n, i = e, function () {
                            r.apply(i, arguments)
                        }), t)
                        }
                    }
                    t._state = 1, t._value = e, d(t)
                } catch (e) {
                    f(t, e)
                }
                let r, i
            }

            function f(t, e) {
                t._state = 2, t._value = e, d(t)
            }

            function d(t) {
                t._state === 2 && t._deferreds.length === 0 && c._immediateFn(() => {
                    t._handled || c._unhandledRejectionFn(t._value)
                })
                for (let e = 0, n = t._deferreds.length; e < n; e++) l(t, t._deferreds[e])
                t._deferreds = null
            }

            function p(t, e, n) {
                this.onFulfilled = typeof t == 'function' ? t : null, this.onRejected = typeof e == 'function' ? e : null, this.promise = n
            }

            function m(t, e) {
                let n = !1
                try {
                    t((t) => {
                        n || (n = !0, h(e, t))
                    }, (t) => {
                        n || (n = !0, f(e, t))
                    })
                } catch (t) {
                    if (n) return
                    n = !0, f(e, t)
                }
            }
            c.prototype.catch = function (t) {
                return this.then(null, t)
            }, c.prototype.then = function (t, e) {
                const n = new this.constructor(u)
                return l(this, new p(t, e, n)), n
            }, c.prototype.finally = r.a, c.all = function (t) {
                return new c((e, n) => {
                    if (!s(t)) return n(new TypeError('Promise.all accepts an array'))
                    const r = Array.prototype.slice.call(t)
                    if (r.length === 0) return e([])
                    let i = r.length

                    function o(t, a) {
                        try {
                            if (a && (typeof a == 'object' || typeof a == 'function')) {
                                const s = a.then
                                if (typeof s == 'function') { return void s.call(a, (e) => {
                                    o(t, e)
                                }, n)
                                }
                            }
                            r[t] = a, --i == 0 && e(r)
                        } catch (t) {
                            n(t)
                        }
                    }
                    for (let a = 0; a < r.length; a++) o(a, r[a])
                })
            }, c.allSettled = i.a, c.resolve = function (t) {
                return t && typeof t == 'object' && t.constructor === c
                    ? t
                    : new c((e) => {
                        e(t)
                    })
            }, c.reject = function (t) {
                return new c((e, n) => {
                    n(t)
                })
            }, c.race = function (t) {
                return new c((e, n) => {
                    if (!s(t)) return n(new TypeError('Promise.race accepts an array'))
                    for (let r = 0, i = t.length; r < i; r++) c.resolve(t[r]).then(e, n)
                })
            }, c._immediateFn = typeof a == 'function' && function (t) {
                a(t)
            } || function (t) {
                o(t, 0)
            }, c._unhandledRejectionFn = function (t) {
                typeof console != 'undefined' && console && console.warn('Possible Unhandled Promise Rejection:', t)
            }, e.a = c
        }).call(this, n('./node_modules/node-libs-browser/node_modules/timers-browserify/main.js').setImmediate)
    },
    './node_modules/punycode/punycode.js': function (t, e, n) {
        (function (t, r) {
            let i /*! https://mths.be/punycode v1.4.1 by @mathias */
            !(function (o) {
                e && e.nodeType, t && t.nodeType
                const a = typeof r == 'object' && r
                a.global !== a && a.window !== a && a.self
                let s; const u = 2147483647
                let c = /^xn--/
                let l = /[^\x20-\x7E]/
                let h = /[\x2E\u3002\uFF0E\uFF61]/g
                let f = {
                    'overflow': 'Overflow: input needs wider integers to process',
                    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                    'invalid-input': 'Invalid input'
                }
                let d = Math.floor
                let p = String.fromCharCode

                function m(t) {
                    throw new RangeError(f[t])
                }

                function y(t, e) {
                    for (var n = t.length, r = []; n--;) r[n] = e(t[n])
                    return r
                }

                function v(t, e) {
                    const n = t.split('@')
                    let r = ''
                    return n.length > 1 && (r = `${n[0]}@`, t = n[1]), r + y((t = t.replace(h, '.')).split('.'), e).join('.')
                }

                function _(t) {
                    for (var e, n, r = [], i = 0, o = t.length; i < o;)(e = t.charCodeAt(i++)) >= 55296 && e <= 56319 && i < o ? (64512 & (n = t.charCodeAt(i++))) == 56320 ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), i--) : r.push(e)
                    return r
                }

                function g(t) {
                    return y(t, (t) => {
                        let e = ''
                        return t > 65535 && (e += p((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e += p(t)
                    }).join('')
                }

                function b(t, e) {
                    return t + 22 + 75 * (t < 26) - ((e != 0) << 5)
                }

                function E(t, e, n) {
                    let r = 0
                    for (t = n ? d(t / 700) : t >> 1, t += d(t / e); t > 455; r += 36) t = d(t / 35)
                    return d(r + 36 * t / (t + 38))
                }

                function x(t) {
                    let e; let n; let r; let i; let o; let a; let s; let c; let l; let h; let f; const p = []
                    let y = t.length
                    let v = 0
                    let _ = 128
                    let b = 72
                    for ((n = t.lastIndexOf('-')) < 0 && (n = 0), r = 0; r < n; ++r) t.charCodeAt(r) >= 128 && m('not-basic'), p.push(t.charCodeAt(r))
                    for (i = n > 0 ? n + 1 : 0; i < y;) {
                        for (o = v, a = 1, s = 36; i >= y && m('invalid-input'), ((c = (f = t.charCodeAt(i++)) - 48 < 10 ? f - 22 : f - 65 < 26 ? f - 65 : f - 97 < 26 ? f - 97 : 36) >= 36 || c > d((u - v) / a)) && m('overflow'), v += c * a, !(c < (l = s <= b ? 1 : s >= b + 26 ? 26 : s - b)); s += 36) a > d(u / (h = 36 - l)) && m('overflow'), a *= h
                        b = E(v - o, e = p.length + 1, o == 0), d(v / e) > u - _ && m('overflow'), _ += d(v / e), v %= e, p.splice(v++, 0, _)
                    }
                    return g(p)
                }

                function T(t) {
                    let e; let n; let r; let i; let o; let a; let s; let c; let l; let h; let f; let y; let v; let g; let x; const T = []
                    for (y = (t = _(t)).length, e = 128, n = 0, o = 72, a = 0; a < y; ++a)(f = t[a]) < 128 && T.push(p(f))
                    for (r = i = T.length, i && T.push('-'); r < y;) {
                        for (s = u, a = 0; a < y; ++a)(f = t[a]) >= e && f < s && (s = f)
                        for (s - e > d((u - n) / (v = r + 1)) && m('overflow'), n += (s - e) * v, e = s, a = 0; a < y; ++a) {
                            if ((f = t[a]) < e && ++n > u && m('overflow'), f == e) {
                                for (c = n, l = 36; !(c < (h = l <= o ? 1 : l >= o + 26 ? 26 : l - o)); l += 36) x = c - h, g = 36 - h, T.push(p(b(h + x % g, 0))), c = d(x / g)
                                T.push(p(b(c, 0))), o = E(n, v, r == i), n = 0, ++r
                            }
                        }++n, ++e
                    }
                    return T.join('')
                }
                s = {
                    version: '1.4.1',
                    ucs2: {
                        decode: _,
                        encode: g
                    },
                    decode: x,
                    encode: T,
                    toASCII(t) {
                        return v(t, (t) => {
                            return l.test(t) ? `xn--${  T(t)}` : t
                        })
                    },
                    toUnicode(t) {
                        return v(t, (t) => {
                            return c.test(t) ? x(t.slice(4).toLowerCase()) : t
                        })
                    }
                }, void 0 === (i = (function () {
                    return s
                }.call(e, n, e, t))) || (t.exports = i)
            }())
        }).call(this, n('./node_modules/webpack/buildin/module.js')(t), n('./node_modules/webpack/buildin/global.js'))
    },
    './node_modules/qs/lib/formats.js': function (t, e, n) {
        'use strict'
        const r = String.prototype.replace
        const i = /%20/g
        t.exports = {
            default: 'RFC3986',
            formatters: {
                RFC1738(t) {
                    return r.call(t, i, '+')
                },
                RFC3986(t) {
                    return t
                }
            },
            RFC1738: 'RFC1738',
            RFC3986: 'RFC3986'
        }
    },
    './node_modules/qs/lib/index.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/qs/lib/stringify.js')
        const i = n('./node_modules/qs/lib/parse.js')
        const o = n('./node_modules/qs/lib/formats.js')
        t.exports = {
            formats: o,
            parse: i,
            stringify: r
        }
    },
    './node_modules/qs/lib/parse.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/qs/lib/utils.js')
        const i = Object.prototype.hasOwnProperty
        const o = {
            allowDots: !1,
            allowPrototypes: !1,
            arrayLimit: 20,
            decoder: r.decode,
            delimiter: '&',
            depth: 5,
            parameterLimit: 1e3,
            plainObjects: !1,
            strictNullHandling: !1
        }
        const a = function (t, e, n) {
            if (t) {
                const r = n.allowDots ? t.replace(/\.([^.[]+)/g, '[$1]') : t
                let o = /(\[[^[\]]*\])/g
                let a = /(\[[^[\]]*\])/.exec(r)
                let s = a ? r.slice(0, a.index) : r
                let u = []
                if (s) {
                    if (!n.plainObjects && i.call(Object.prototype, s) && !n.allowPrototypes) return
                    u.push(s)
                }
                for (let c = 0; (a = o.exec(r)) !== null && c < n.depth;) {
                    if (c += 1, !n.plainObjects && i.call(Object.prototype, a[1].slice(1, -1)) && !n.allowPrototypes) return
                    u.push(a[1])
                }
                return a && u.push(`[${r.slice(a.index)}]`),
                (function (t, e, n) {
                    for (var r = e, i = t.length - 1; i >= 0; --i) {
                        var o; const a = t[i]
                        if (a === '[]') { o = (o = []).concat(r)
                        }
                        else {
                            o = n.plainObjects ? Object.create(null) : {}
                            let s = a.charAt(0) === '[' && a.charAt(a.length - 1) === ']' ? a.slice(1, -1) : a
                            var u = Number.parseInt(s, 10)
                            !isNaN(u) && a !== s && String(u) === s && u >= 0 && n.parseArrays && u <= n.arrayLimit ? (o = [])[u] = r : o[s] = r
                        }
                        r = o
                    }
                    return r
                }(u, e, n))
            }
        }
        t.exports = function (t, e) {
            const n = e ? r.assign({}, e) : {}
            if (n.decoder !== null && void 0 !== n.decoder && typeof n.decoder != 'function') throw new TypeError('Decoder has to be a function.')
            if (n.ignoreQueryPrefix = !0 === n.ignoreQueryPrefix, n.delimiter = typeof n.delimiter == 'string' || r.isRegExp(n.delimiter) ? n.delimiter : o.delimiter, n.depth = typeof n.depth == 'number' ? n.depth : o.depth, n.arrayLimit = typeof n.arrayLimit == 'number' ? n.arrayLimit : o.arrayLimit, n.parseArrays = !1 !== n.parseArrays, n.decoder = typeof n.decoder == 'function' ? n.decoder : o.decoder, n.allowDots = typeof n.allowDots == 'boolean' ? n.allowDots : o.allowDots, n.plainObjects = typeof n.plainObjects == 'boolean' ? n.plainObjects : o.plainObjects, n.allowPrototypes = typeof n.allowPrototypes == 'boolean' ? n.allowPrototypes : o.allowPrototypes, n.parameterLimit = typeof n.parameterLimit == 'number' ? n.parameterLimit : o.parameterLimit, n.strictNullHandling = typeof n.strictNullHandling == 'boolean' ? n.strictNullHandling : o.strictNullHandling, t === '' || t == null) return n.plainObjects ? Object.create(null) : {}
            for (var s = typeof t == 'string'
                    ? (function (t, e) {
                            for (var n = {}, r = e.ignoreQueryPrefix ? t.replace(/^\?/, '') : t, a = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit, s = r.split(e.delimiter, a), u = 0; u < s.length; ++u) {
                                var c; var l; const h = s[u]
                                const f = h.indexOf(']=')
                                const d = f === -1 ? h.indexOf('=') : f + 1; d === -1 ? (c = e.decoder(h, o.decoder), l = e.strictNullHandling ? null : '') : (c = e.decoder(h.slice(0, d), o.decoder), l = e.decoder(h.slice(d + 1), o.decoder)), i.call(n, c) ? n[c] = [].concat(n[c]).concat(l) : n[c] = l
                            }
                            return n
                        }(t, n))
                    : t, u = n.plainObjects ? Object.create(null) : {}, c = Object.keys(s), l = 0; l < c.length; ++l) {
                const h = c[l]
                const f = a(h, s[h], n)
                u = r.merge(u, f, n)
            }
            return r.compact(u)
        }
    },
    './node_modules/qs/lib/stringify.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/qs/lib/utils.js')
        const i = n('./node_modules/qs/lib/formats.js')
        const o = {
            brackets(t) {
                return `${t }[]`
            },
            indices(t, e) {
                return `${t }[${ e }]`
            },
            repeat(t) {
                return t
            }
        }
        const a = Date.prototype.toISOString
        const s = {
            delimiter: '&',
            encode: !0,
            encoder: r.encode,
            encodeValuesOnly: !1,
            serializeDate(t) {
                return a.call(t)
            },
            skipNulls: !1,
            strictNullHandling: !1
        }
        const u = function t(e, n, i, o, a, u, c, l, h, f, d, p) {
            let m = e
            if (typeof c == 'function') { m = c(n, m)
            }
            else if (m instanceof Date) { m = f(m)
            }
            else if (m === null) {
                if (o) return u && !p ? u(n, s.encoder) : n
                m = ''
            }
            if (typeof m == 'string' || typeof m == 'number' || typeof m == 'boolean' || r.isBuffer(m)) return u ? [`${d(p ? n : u(n, s.encoder))}=${d(u(m, s.encoder))}`] : [`${d(n)}=${d(String(m))}`]
            let y; let v = []
            if (void 0 === m) return v
            if (Array.isArray(c)) { y = c
            }
            else {
                const _ = Object.keys(m)
                y = l ? _.sort(l) : _
            }
            for (let g = 0; g < y.length; ++g) {
                const b = y[g]
                a && m[b] === null || (v = Array.isArray(m) ? v.concat(t(m[b], i(n, b), i, o, a, u, c, l, h, f, d, p)) : v.concat(t(m[b], n + (h ? `.${b}` : `[${b}]`), i, o, a, u, c, l, h, f, d, p)))
            }
            return v
        }
        t.exports = function (t, e) {
            let n = t
            const a = e ? r.assign({}, e) : {}
            if (a.encoder !== null && void 0 !== a.encoder && typeof a.encoder != 'function') throw new TypeError('Encoder has to be a function.')
            const c = void 0 === a.delimiter ? s.delimiter : a.delimiter
            const l = typeof a.strictNullHandling == 'boolean' ? a.strictNullHandling : s.strictNullHandling
            const h = typeof a.skipNulls == 'boolean' ? a.skipNulls : s.skipNulls
            const f = typeof a.encode == 'boolean' ? a.encode : s.encode
            const d = typeof a.encoder == 'function' ? a.encoder : s.encoder
            const p = typeof a.sort == 'function' ? a.sort : null
            const m = void 0 !== a.allowDots && a.allowDots
            const y = typeof a.serializeDate == 'function' ? a.serializeDate : s.serializeDate
            const v = typeof a.encodeValuesOnly == 'boolean' ? a.encodeValuesOnly : s.encodeValuesOnly
            if (void 0 === a.format) a.format = i.default
            else if (!Object.prototype.hasOwnProperty.call(i.formatters, a.format)) throw new TypeError('Unknown format option provided.')
            let _; let g; const b = i.formatters[a.format]
            typeof a.filter == 'function' ? n = (g = a.filter)('', n) : Array.isArray(a.filter) && (_ = g = a.filter)
            let E; let x = []
            if (typeof n != 'object' || n === null) return ''
            E = a.arrayFormat in o ? a.arrayFormat : 'indices' in a ? a.indices ? 'indices' : 'repeat' : 'indices'
            const T = o[E]
            _ || (_ = Object.keys(n)), p && _.sort(p)
            for (let S = 0; S < _.length; ++S) {
                const w = _[S]
                h && n[w] === null || (x = x.concat(u(n[w], w, T, l, h, f ? d : null, g, p, m, y, b, v)))
            }
            const O = x.join(c)
            const P = !0 === a.addQueryPrefix ? '?' : ''
            return O.length > 0 ? P + O : ''
        }
    },
    './node_modules/qs/lib/utils.js': function (t, e, n) {
        'use strict'
        const r = Object.prototype.hasOwnProperty
        const i = (function () {
            for (var t = [], e = 0; e < 256; ++e) t.push(`%${  ((e < 16 ? '0' : '') + e.toString(16)).toUpperCase()}`)
            return t
        }())
        const o = function (t, e) {
            for (var n = e && e.plainObjects ? Object.create(null) : {}, r = 0; r < t.length; ++r) void 0 !== t[r] && (n[r] = t[r])
            return n
        }
        t.exports = {
            arrayToObject: o,
            assign(t, e) {
                return Object.keys(e).reduce((t, n) => {
                    return t[n] = e[n], t
                }, t)
            },
            compact(t) {
                for (var e = [{
                        obj: {
                            o: t
                        },
                        prop: 'o'
                    }], n = [], r = 0; r < e.length; ++r) {
                    for (let i = e[r], o = i.obj[i.prop], a = Object.keys(o), s = 0; s < a.length; ++s) {
                        const u = a[s]
                        var c = o[u]
                        'object' == typeof c && c !== null && !n.includes(c) && (e.push({
                            obj: o,
                            prop: u
                        }), n.push(c))
                    }
                }
                return (function (t) {
                    for (var e; t.length;) {
                        const n = t.pop()
                        if (e = n.obj[n.prop], Array.isArray(e)) {
                            for (var r = [], i = 0; i < e.length; ++i) void 0 !== e[i] && r.push(e[i])
                            n.obj[n.prop] = r
                        }
                    }
                    return e
                }(e))
            },
            decode(t) {
                try {
                    return decodeURIComponent(t.replace(/\+/g, ' '))
                } catch (e) {
                    return t
                }
            },
            encode(t) {
                if (t.length === 0) return t
                for (var e = typeof t == 'string' ? t : String(t), n = '', r = 0; r < e.length; ++r) {
                    let o = e.charCodeAt(r)
                    o === 45 || o === 46 || o === 95 || o === 126 || o >= 48 && o <= 57 || o >= 65 && o <= 90 || o >= 97 && o <= 122 ? n += e.charAt(r) : o < 128 ? n += i[o] : o < 2048 ? n += i[192 | o >> 6] + i[128 | 63 & o] : o < 55296 || o >= 57344 ? n += i[224 | o >> 12] + i[128 | o >> 6 & 63] + i[128 | 63 & o] : (r += 1, o = 65536 + ((1023 & o) << 10 | 1023 & e.charCodeAt(r)), n += i[240 | o >> 18] + i[128 | o >> 12 & 63] + i[128 | o >> 6 & 63] + i[128 | 63 & o])
                }
                return n
            },
            isBuffer(t) {
                return t != null && !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
            },
            isRegExp(t) {
                return Object.prototype.toString.call(t) === '[object RegExp]'
            },
            merge: function t(e, n, i) {
                if (!n) return e
                if (typeof n != 'object') {
                    if (Array.isArray(e)) { e.push(n)
                    }
                    else {
                        if (typeof e != 'object') return [e, n];
                        (i.plainObjects || i.allowPrototypes || !r.call(Object.prototype, n)) && (e[n] = !0)
                    }
                    return e
                }
                if (typeof e != 'object') return [e].concat(n)
                let a = e
                return Array.isArray(e) && !Array.isArray(n) && (a = o(e, i)), Array.isArray(e) && Array.isArray(n)
                    ? (n.forEach((n, o) => {
                            r.call(e, o) ? e[o] && typeof e[o] == 'object' ? e[o] = t(e[o], n, i) : e.push(n) : e[o] = n
                        }), e)
                    : Object.keys(n).reduce((e, o) => {
                            const a = n[o]
                            return r.call(e, o) ? e[o] = t(e[o], a, i) : e[o] = a, e
                        }, a)
            }
        }
    },
    './node_modules/querystring-es3/decode.js': function (t, e, n) {
        'use strict'

        function r(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }
        t.exports = function (t, e, n, o) {
            e = e || '&', n = n || '='
            const a = {}
            if (typeof t != 'string' || t.length === 0) return a
            const s = /\+/g
            t = t.split(e)
            let u = 1e3
            o && typeof o.maxKeys == 'number' && (u = o.maxKeys)
            let c = t.length
            u > 0 && c > u && (c = u)
            for (let l = 0; l < c; ++l) {
                var h; var f; var d; var p; const m = t[l].replace(s, '%20')
                const y = m.indexOf(n)
                y >= 0 ? (h = m.substr(0, y), f = m.substr(y + 1)) : (h = m, f = ''), d = decodeURIComponent(h), p = decodeURIComponent(f), r(a, d) ? i(a[d]) ? a[d].push(p) : a[d] = [a[d], p] : a[d] = p
            }
            return a
        }
        var i = Array.isArray || function (t) {
            return Object.prototype.toString.call(t) === '[object Array]'
        }
    },
    './node_modules/querystring-es3/encode.js': function (t, e, n) {
        'use strict'
        const r = function (t) {
            switch (typeof t) {
                case 'string':
                    return t
                case 'boolean':
                    return t ? 'true' : 'false'
                case 'number':
                    return isFinite(t) ? t : ''
                default:
                    return ''
            }
        }
        t.exports = function (t, e, n, s) {
            return e = e || '&', n = n || '=', t === null && (t = void 0), typeof t == 'object'
                ? o(a(t), (a) => {
                        const s = encodeURIComponent(r(a)) + n
                        return i(t[a])
                            ? o(t[a], (t) => {
                                    return s + encodeURIComponent(r(t))
                                }).join(e)
                            : s + encodeURIComponent(r(t[a]))
                    }).join(e)
                : s ? encodeURIComponent(r(s)) + n + encodeURIComponent(r(t)) : ''
        }
        var i = Array.isArray || function (t) {
            return Object.prototype.toString.call(t) === '[object Array]'
        }

        function o(t, e) {
            if (t.map) return t.map(e)
            for (var n = [], r = 0; r < t.length; r++) n.push(e(t[r], r))
            return n
        }
        var a = Object.keys || function (t) {
            const e = []
            for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e.push(n)
            return e
        }
    },
    './node_modules/querystring-es3/index.js': function (t, e, n) {
        'use strict'
        e.decode = e.parse = n('./node_modules/querystring-es3/decode.js'), e.encode = e.stringify = n('./node_modules/querystring-es3/encode.js')
    },
    './node_modules/ramda/es/always.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = new Object(r.a)((t) => {
            return function () {
                return t
            }
        })
        e.a = i
    },
    './node_modules/ramda/es/clone.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/type.js')

        function i(t, e, n, o) {
            let a; const s = function (r) {
                for (var a = e.length, s = 0; s < a;) {
                    if (t === e[s]) return n[s]
                    s += 1
                }
                for (const u in e[s + 1] = t, n[s + 1] = r, t) r[u] = o ? i(t[u], e, n, !0) : t[u]
                return r
            }
            switch (new Object(r.a)(t)) {
                case 'Object':
                    return s({})
                case 'Array':
                    return s([])
                case 'Date':
                    return new Date(t.valueOf())
                case 'RegExp':
                    return a = t, new RegExp(a.source, (a.global ? 'g' : '') + (a.ignoreCase ? 'i' : '') + (a.multiline ? 'm' : '') + (a.sticky ? 'y' : '') + (a.unicode ? 'u' : ''))
                default:
                    return t
            }
        }
        const o = n('./node_modules/ramda/es/internal/_curry1.js')
        const a = new Object(o.a)((t) => {
            return t != null && typeof t.clone == 'function' ? t.clone() : i(t, [], [], !0)
        })
        e.a = a
    },
    './node_modules/ramda/es/curryN.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_arity.js')
        const i = n('./node_modules/ramda/es/internal/_curry1.js')
        const o = n('./node_modules/ramda/es/internal/_curry2.js')
        const a = n('./node_modules/ramda/es/internal/_curryN.js')
        const s = new Object(o.a)((t, e) => {
            return t === 1 ? new Object(i.a)(e) : new Object(r.a)(t, new Object(a.a)(t, [], e))
        })
        e.a = s
    },
    './node_modules/ramda/es/equals.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry2.js')

        function i(t) {
            for (var e, n = []; !(e = t.next()).done;) n.push(e.value)
            return n
        }
        const o = n('./node_modules/ramda/es/internal/_includesWith.js')
        const a = n('./node_modules/ramda/es/internal/_has.js')
        const s = typeof Object.is == 'function'
            ? Object.is
            : function (t, e) {
                return t === e ? t !== 0 || 1 / t == 1 / e : t != t && e != e
            }
        const u = n('./node_modules/ramda/es/keys.js')
        const c = n('./node_modules/ramda/es/type.js')

        function l(t, e, n, r) {
            const a = i(t)
            const s = i(e)

            function u(t, e) {
                return h(t, e, n.slice(), r.slice())
            }
            return !new Object(o.a)((t, e) => {
                return !new Object(o.a)(u, e, t)
            }, s, a)
        }

        function h(t, e, n, r) {
            if (s(t, e)) return !0
            let i; let o; const f = new Object(c.a)(t)
            if (f !== new Object(c.a)(e)) return !1
            if (t == null || e == null) return !1
            if (typeof t['fantasy-land/equals'] == 'function' || typeof e['fantasy-land/equals'] == 'function') return typeof t['fantasy-land/equals'] == 'function' && t['fantasy-land/equals'](e) && typeof e['fantasy-land/equals'] == 'function' && e['fantasy-land/equals'](t)
            if (typeof t.equals == 'function' || typeof e.equals == 'function') return typeof t.equals == 'function' && t.equals(e) && typeof e.equals == 'function' && e.equals(t)
            switch (f) {
                case 'Arguments':
                case 'Array':
                case 'Object':
                    if (typeof t.constructor == 'function' && (i = t.constructor, (o = String(i).match(/^function (\w*)/)) == null ? '' : o[1]) === 'Promise') return t === e
                    break
                case 'Boolean':
                case 'Number':
                case 'String':
                    if (typeof t != typeof e || !s(t.valueOf(), e.valueOf())) return !1
                    break
                case 'Date':
                    if (!s(t.valueOf(), e.valueOf())) return !1
                    break
                case 'Error':
                    return t.name === e.name && t.message === e.message
                case 'RegExp':
                    if (t.source !== e.source || t.global !== e.global || t.ignoreCase !== e.ignoreCase || t.multiline !== e.multiline || t.sticky !== e.sticky || t.unicode !== e.unicode) return !1
            }
            for (var d = n.length - 1; d >= 0;) {
                if (n[d] === t) return r[d] === e
                d -= 1
            }
            switch (f) {
                case 'Map':
                    return t.size === e.size && l(t.entries(), e.entries(), n.concat([t]), r.concat([e]))
                case 'Set':
                    return t.size === e.size && l(t.values(), e.values(), n.concat([t]), r.concat([e]))
                case 'Arguments':
                case 'Array':
                case 'Object':
                case 'Boolean':
                case 'Number':
                case 'String':
                case 'Date':
                case 'Error':
                case 'RegExp':
                case 'Int8Array':
                case 'Uint8Array':
                case 'Uint8ClampedArray':
                case 'Int16Array':
                case 'Uint16Array':
                case 'Int32Array':
                case 'Uint32Array':
                case 'Float32Array':
                case 'Float64Array':
                case 'ArrayBuffer':
                    break
                default:
                    return !1
            }
            const p = new Object(u.a)(t)
            if (p.length !== new Object(u.a)(e).length) return !1
            const m = n.concat([t])
            const y = r.concat([e])
            for (d = p.length - 1; d >= 0;) {
                const v = p[d]
                if (!new Object(a.a)(v, e) || !h(e[v], t[v], m, y)) return !1
                d -= 1
            }
            return !0
        }
        const f = new Object(r.a)((t, e) => {
            return h(t, e, [], [])
        })
        e.a = f
    },
    './node_modules/ramda/es/flatten.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = n('./node_modules/ramda/es/internal/_isArrayLike.js')

        function o(t) {
            return function e(n) {
                for (var r, o, a, s = [], u = 0, c = n.length; u < c;) {
                    if (new Object(i.a)(n[u])) {
                        for (a = 0, o = (r = t ? e(n[u]) : n[u]).length; a < o;) s[s.length] = r[a], a += 1
                    }
                    else { s[s.length] = n[u]
                    }
                    u += 1
                }
                return s
            }
        }
        const a = new Object(r.a)(o(!0))
        e.a = a
    },
    './node_modules/ramda/es/internal/_arity.js': function (t, e, n) {
        'use strict'

        function r(t, e) {
            switch (t) {
                case 0:
                    return function () {
                        return e.apply(this, arguments)
                    }
                case 1:
                    return function (t) {
                        return e.apply(this, arguments)
                    }
                case 2:
                    return function (t, n) {
                        return e.apply(this, arguments)
                    }
                case 3:
                    return function (t, n, r) {
                        return e.apply(this, arguments)
                    }
                case 4:
                    return function (t, n, r, i) {
                        return e.apply(this, arguments)
                    }
                case 5:
                    return function (t, n, r, i, o) {
                        return e.apply(this, arguments)
                    }
                case 6:
                    return function (t, n, r, i, o, a) {
                        return e.apply(this, arguments)
                    }
                case 7:
                    return function (t, n, r, i, o, a, s) {
                        return e.apply(this, arguments)
                    }
                case 8:
                    return function (t, n, r, i, o, a, s, u) {
                        return e.apply(this, arguments)
                    }
                case 9:
                    return function (t, n, r, i, o, a, s, u, c) {
                        return e.apply(this, arguments)
                    }
                case 10:
                    return function (t, n, r, i, o, a, s, u, c, l) {
                        return e.apply(this, arguments)
                    }
                default:
                    throw new Error('First argument to _arity must be a non-negative integer no greater than ten')
            }
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './node_modules/ramda/es/internal/_curry1.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return i
        })
        const r = n('./node_modules/ramda/es/internal/_isPlaceholder.js')

        function i(t) {
            return function e(n) {
                return arguments.length === 0 || new Object(r.a)(n) ? e : t.apply(this, arguments)
            }
        }
    },
    './node_modules/ramda/es/internal/_curry2.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return o
        })
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = n('./node_modules/ramda/es/internal/_isPlaceholder.js')

        function o(t) {
            return function e(n, o) {
                switch (arguments.length) {
                    case 0:
                        return e
                    case 1:
                        return new Object(i.a)(n)
                            ? e
                            : new Object(r.a)((e) => {
                                    return t(n, e)
                                })
                    default:
                        return new Object(i.a)(n) && new Object(i.a)(o)
                            ? e
                            : new Object(i.a)(n)
                                ? new Object(r.a)((e) => {
                                        return t(e, o)
                                    })
                                : new Object(i.a)(o)
                                    ? new Object(r.a)((e) => {
                                            return t(n, e)
                                        })
                                    : t(n, o)
                }
            }
        }
    },
    './node_modules/ramda/es/internal/_curry3.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return a
        })
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = n('./node_modules/ramda/es/internal/_curry2.js')
        const o = n('./node_modules/ramda/es/internal/_isPlaceholder.js')

        function a(t) {
            return function e(n, a, s) {
                switch (arguments.length) {
                    case 0:
                        return e
                    case 1:
                        return new Object(o.a)(n)
                            ? e
                            : new Object(i.a)((e, r) => {
                                    return t(n, e, r)
                                })
                    case 2:
                        return new Object(o.a)(n) && new Object(o.a)(a)
                            ? e
                            : new Object(o.a)(n)
                                ? new Object(i.a)((e, n) => {
                                        return t(e, a, n)
                                    })
                                : new Object(o.a)(a)
                                    ? new Object(i.a)((e, r) => {
                                            return t(n, e, r)
                                        })
                                    : new Object(r.a)((e) => {
                                            return t(n, a, e)
                                        })
                    default:
                        return new Object(o.a)(n) && new Object(o.a)(a) && new Object(o.a)(s)
                            ? e
                            : new Object(o.a)(n) && new Object(o.a)(a)
                                ? new Object(i.a)((e, n) => {
                                        return t(e, n, s)
                                    })
                                : new Object(o.a)(n) && new Object(o.a)(s)
                                    ? new Object(i.a)((e, n) => {
                                            return t(e, a, n)
                                        })
                                    : new Object(o.a)(a) && new Object(o.a)(s)
                                        ? new Object(i.a)((e, r) => {
                                                return t(n, e, r)
                                            })
                                        : new Object(o.a)(n)
                                            ? new Object(r.a)((e) => {
                                                    return t(e, a, s)
                                                })
                                            : new Object(o.a)(a)
                                                ? new Object(r.a)((e) => {
                                                        return t(n, e, s)
                                                    })
                                                : new Object(o.a)(s)
                                                    ? new Object(r.a)((e) => {
                                                            return t(n, a, e)
                                                        })
                                                    : t(n, a, s)
                }
            }
        }
    },
    './node_modules/ramda/es/internal/_curryN.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return o
        })
        const r = n('./node_modules/ramda/es/internal/_arity.js')
        const i = n('./node_modules/ramda/es/internal/_isPlaceholder.js')

        function o(t, e, n) {
            return function () {
                for (var a = [], s = 0, u = t, c = 0; c < e.length || s < arguments.length;) {
                    var l
                    c < e.length && (!new Object(i.a)(e[c]) || s >= arguments.length) ? l = e[c] : (l = arguments[s], s += 1), a[c] = l, new Object(i.a)(l) || (u -= 1), c += 1
                }
                return u <= 0 ? n.apply(this, a) : new Object(r.a)(u, o(t, a, n))
            }
        }
    },
    './node_modules/ramda/es/internal/_dispatchable.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return o
        })
        const r = n('./node_modules/ramda/es/internal/_isArray.js')

        function i(t) {
            return t != null && typeof t['@@transducer/step'] == 'function'
        }

        function o(t, e, n) {
            return function () {
                if (arguments.length === 0) return n()
                const o = Array.prototype.slice.call(arguments, 0)
                const a = o.pop()
                if (!new Object(r.a)(a)) {
                    for (let s = 0; s < t.length;) {
                        if (typeof a[t[s]] == 'function') return a[t[s]].apply(a, o)
                        s += 1
                    }
                    if (i(a)) {
                        const u = e.apply(null, o)
                        return u(a)
                    }
                }
                return n.apply(this, arguments)
            }
        }
    },
    './node_modules/ramda/es/internal/_has.js': function (t, e, n) {
        'use strict'

        function r(t, e) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './node_modules/ramda/es/internal/_includes.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return i
        })
        const r = n('./node_modules/ramda/es/equals.js')

        function i(t, e) {
            return (function (t, e, n) {
                let i, o
                if (typeof t.indexOf == 'function') { switch (typeof e) {
                    case 'number':
                        if (e === 0) {
                            for (i = 1 / e; n < t.length;) {
                                if ((o = t[n]) === 0 && 1 / o === i) return n
                                n += 1
                            }
                            return -1
                        }
                        if (e != e) {
                            for (; n < t.length;) {
                                if (typeof (o = t[n]) == 'number' && o != o) return n
                                n += 1
                            }
                            return -1
                        }
                        return t.indexOf(e, n)
                    case 'string':
                    case 'boolean':
                    case 'function':
                    case 'undefined':
                        return t.indexOf(e, n)
                    case 'object':
                        if (e === null) return t.indexOf(e, n)
                }
                }
                for (; n < t.length;) {
                    if (new Object(r.a)(t[n], e)) return n
                    n += 1
                }
                return -1
            }(e, t, 0)) >= 0
        }
    },
    './node_modules/ramda/es/internal/_includesWith.js': function (t, e, n) {
        'use strict'

        function r(t, e, n) {
            for (let r = 0, i = n.length; r < i;) {
                if (t(e, n[r])) return !0
                r += 1
            }
            return !1
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './node_modules/ramda/es/internal/_isArguments.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_has.js')
        const i = Object.prototype.toString
        const o = (function () {
            return i.call(arguments) === '[object Arguments]'
                ? function (t) {
                    return i.call(t) === '[object Arguments]'
                }
                : function (t) {
                    return new Object(r.a)('callee', t)
                }
        }())
        e.a = o
    },
    './node_modules/ramda/es/internal/_isArray.js': function (t, e, n) {
        'use strict'
        e.a = Array.isArray || function (t) {
            return t != null && t.length >= 0 && Object.prototype.toString.call(t) === '[object Array]'
        }
    },
    './node_modules/ramda/es/internal/_isArrayLike.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = n('./node_modules/ramda/es/internal/_isArray.js')
        const o = n('./node_modules/ramda/es/internal/_isString.js')
        const a = new Object(r.a)((t) => {
            return !!new Object(i.a)(t) || !!t && (typeof t == 'object' && (!new Object(o.a)(t) && (t.nodeType === 1 ? !!t.length : t.length === 0 || t.length > 0 && (t.hasOwnProperty(0) && t.hasOwnProperty(t.length - 1)))))
        })
        e.a = a
    },
    './node_modules/ramda/es/internal/_isObject.js': function (t, e, n) {
        'use strict'

        function r(t) {
            return Object.prototype.toString.call(t) === '[object Object]'
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './node_modules/ramda/es/internal/_isPlaceholder.js': function (t, e, n) {
        'use strict'

        function r(t) {
            return t != null && typeof t == 'object' && !0 === t['@@functional/placeholder']
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './node_modules/ramda/es/internal/_isString.js': function (t, e, n) {
        'use strict'

        function r(t) {
            return Object.prototype.toString.call(t) === '[object String]'
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './node_modules/ramda/es/internal/_map.js': function (t, e, n) {
        'use strict'

        function r(t, e) {
            for (var n = 0, r = e.length, i = new Array(r); n < r;) i[n] = t(e[n]), n += 1
            return i
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './node_modules/ramda/es/internal/_reduce.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return h
        })
        const r = n('./node_modules/ramda/es/internal/_isArrayLike.js')
        const i = (function () {
            function t(t) {
                this.f = t
            }
            return t.prototype['@@transducer/init'] = function () {
                throw new Error('init not implemented on XWrap')
            }, t.prototype['@@transducer/result'] = function (t) {
                return t
            }, t.prototype['@@transducer/step'] = function (t, e) {
                return this.f(t, e)
            }, t
        }())
        const o = n('./node_modules/ramda/es/internal/_arity.js')
        const a = n('./node_modules/ramda/es/internal/_curry2.js')
        const s = new Object(a.a)((t, e) => {
            return new Object(o.a)(t.length, function () {
                return t.apply(e, arguments)
            })
        })

        function u(t, e, n) {
            for (let r = n.next(); !r.done;) {
                if ((e = t['@@transducer/step'](e, r.value)) && e['@@transducer/reduced']) {
                    e = e['@@transducer/value']
                    break
                }
                r = n.next()
            }
            return t['@@transducer/result'](e)
        }

        function c(t, e, n, r) {
            return t['@@transducer/result'](n[r](s(t['@@transducer/step'], t), e))
        }
        const l = typeof Symbol != 'undefined' ? Symbol.iterator : '@@iterator'

        function h(t, e, n) {
            if (typeof t == 'function' && (t = (function (t) {
                return new i(t)
            }(t))), new Object(r.a)(n)) { return (function (t, e, n) {
                for (let r = 0, i = n.length; r < i;) {
                    if ((e = t['@@transducer/step'](e, n[r])) && e['@@transducer/reduced']) {
                        e = e['@@transducer/value']
                        break
                    }
                    r += 1
                }
                return t['@@transducer/result'](e)
            }(t, e, n))
            }
            if (typeof n['fantasy-land/reduce'] == 'function') return c(t, e, n, 'fantasy-land/reduce')
            if (n[l] != null) return u(t, e, n[l]())
            if (typeof n.next == 'function') return u(t, e, n)
            if (typeof n.reduce == 'function') return c(t, e, n, 'reduce')
            throw new TypeError('reduce: list must be array or iterable')
        }
    },
    './node_modules/ramda/es/internal/_xfBase.js': function (t, e, n) {
        'use strict'
        e.a = {
            init() {
                return this.xf['@@transducer/init']()
            },
            result(t) {
                return this.xf['@@transducer/result'](t)
            }
        }
    },
    './node_modules/ramda/es/isEmpty.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = n('./node_modules/ramda/es/internal/_isArguments.js')
        const o = n('./node_modules/ramda/es/internal/_isArray.js')
        const a = n('./node_modules/ramda/es/internal/_isObject.js')
        const s = n('./node_modules/ramda/es/internal/_isString.js')
        const u = new Object(r.a)((t) => {
            return t != null && typeof t['fantasy-land/empty'] == 'function'
                ? t['fantasy-land/empty']()
                : t != null && t.constructor != null && typeof t.constructor['fantasy-land/empty'] == 'function'
                    ? t.constructor['fantasy-land/empty']()
                    : t != null && typeof t.empty == 'function'
                        ? t.empty()
                        : t != null && t.constructor != null && typeof t.constructor.empty == 'function'
                            ? t.constructor.empty()
                            : new Object(o.a)(t)
                                ? []
                                : new Object(s.a)(t)
                                    ? ''
: new Object(a.a)(t)
                                        ? {}
                                        : new Object(i.a)(t)
                                            ? (function () {
                                                    return arguments
                                                }())
: void 0
        })
        const c = n('./node_modules/ramda/es/equals.js')
        const l = new Object(r.a)((t) => {
            return t != null && new Object(c.a)(t, u(t))
        })
        e.a = l
    },
    './node_modules/ramda/es/isNil.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = new Object(r.a)((t) => {
            return t == null
        })
        e.a = i
    },
    './node_modules/ramda/es/keys.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = n('./node_modules/ramda/es/internal/_has.js')
        const o = n('./node_modules/ramda/es/internal/_isArguments.js')
        const a = !{
            toString: null
        }.propertyIsEnumerable('toString')
        const s = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']
        const u = (function () {
            return arguments.propertyIsEnumerable('length')
        }())
        const c = function (t, e) {
            for (let n = 0; n < t.length;) {
                if (t[n] === e) return !0
                n += 1
            }
            return !1
        }
        const l = typeof Object.keys != 'function' || u
            ? new Object(r.a)((t) => {
                    if (Object(t) !== t) return []
                    let e; let n; const r = []
                    var l = u && new Object(o.a)(t)
                    for (e in t) !new Object(i.a)(e, t) || l && e === 'length' || (r[r.length] = e)
                    if (a) {
                        for (n = s.length - 1; n >= 0;) e = s[n], new Object(i.a)(e, t) && !c(r, e) && (r[r.length] = e), n -= 1
                    }
                    return r
                })
            : new Object(r.a)((t) => {
                    return Object(t) !== t ? [] : Object.keys(t)
                })
        e.a = l
    },
    './node_modules/ramda/es/mergeDeepLeft.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry2.js')
        const i = n('./node_modules/ramda/es/mergeDeepWithKey.js')
        const o = new Object(r.a)((t, e) => {
            return new Object(i.a)((t, e, n) => {
                return e
            }, t, e)
        })
        e.a = o
    },
    './node_modules/ramda/es/mergeDeepRight.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry2.js')
        const i = n('./node_modules/ramda/es/mergeDeepWithKey.js')
        const o = new Object(r.a)((t, e) => {
            return new Object(i.a)((t, e, n) => {
                return n
            }, t, e)
        })
        e.a = o
    },
    './node_modules/ramda/es/mergeDeepWithKey.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry3.js')
        const i = n('./node_modules/ramda/es/internal/_isObject.js')
        const o = n('./node_modules/ramda/es/internal/_has.js')
        const a = new Object(r.a)((t, e, n) => {
            let r; let i = {}
            for (r in e) new Object(o.a)(r, e) && (i[r] = new Object(o.a)(r, n) ? t(r, e[r], n[r]) : e[r])
            for (r in n) new Object(o.a)(r, n) && !new Object(o.a)(r, i) && (i[r] = n[r])
            return i
        })
        const s = new Object(r.a)(function t(e, n, r) {
            return a((n, r, o) => {
                return new Object(i.a)(r) && new Object(i.a)(o) ? t(e, r, o) : e(n, r, o)
            }, n, r)
        })
        e.a = s
    },
    './node_modules/ramda/es/path.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry2.js')
        const i = new Object(r.a)((t, e) => {
            for (var n = e, r = 0; r < t.length;) {
                if (n == null) return
                n = n[t[r]], r += 1
            }
            return n
        })
        e.a = i
    },
    './node_modules/ramda/es/reject.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry2.js')
        const i = n('./node_modules/ramda/es/internal/_dispatchable.js')
        const o = n('./node_modules/ramda/es/internal/_isObject.js')
        const a = n('./node_modules/ramda/es/internal/_reduce.js')
        const s = n('./node_modules/ramda/es/internal/_xfBase.js')
        const u = (function () {
            function t(t, e) {
                this.xf = e, this.f = t
            }
            return t.prototype['@@transducer/init'] = s.a.init, t.prototype['@@transducer/result'] = s.a.result, t.prototype['@@transducer/step'] = function (t, e) {
                return this.f(e) ? this.xf['@@transducer/step'](t, e) : t
            }, t
        }())
        const c = new Object(r.a)((t, e) => {
            return new u(t, e)
        })
        const l = n('./node_modules/ramda/es/keys.js')
        const h = new Object(r.a)(new Object(i.a)(['filter'], c, (t, e) => {
            return new Object(o.a)(e)
                ? new Object(a.a)((n, r) => {
                        return t(e[r]) && (n[r] = e[r]), n
                    }, {}, new Object(l.a)(e))
                : (function (t, e) {
                        for (var n = 0, r = e.length, i = []; n < r;) t(e[n]) && (i[i.length] = e[n]), n += 1
                        return i
                    }(t, e))
        }))
        const f = new Object(r.a)((t, e) => {
            return h((n = t, function () {
                return !n.apply(this, arguments)
            }), e)
            let n
        })
        e.a = f
    },
    './node_modules/ramda/es/times.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry2.js')
        const i = new Object(r.a)((t, e) => {
            let n; const r = Number(e)
            var i = 0
            if (r < 0 || isNaN(r)) throw new RangeError('n must be a non-negative number')
            for (n = new Array(r); i < r;) n[i] = t(i), i += 1
            return n
        })
        e.a = i
    },
    './node_modules/ramda/es/type.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_curry1.js')
        const i = new Object(r.a)((t) => {
            return t === null ? 'Null' : void 0 === t ? 'Undefined' : Object.prototype.toString.call(t).slice(8, -1)
        })
        e.a = i
    },
    './node_modules/ramda/es/without.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/internal/_includes.js')
        const i = n('./node_modules/ramda/es/internal/_curry2.js')
        const o = n('./node_modules/ramda/es/internal/_curry1.js')
        const a = n('./node_modules/ramda/es/curryN.js')
        const s = new Object(o.a)((t) => {
            return new Object(a.a)(t.length, function (e, n) {
                var r = Array.prototype.slice.call(arguments, 0)
                        return r[0] = n, r[1] = e, t.apply(this, r)
            })
        })
        const u = n('./node_modules/ramda/es/reject.js')
        const c = new Object(i.a)((t, e) => {
            return new Object(u.a)(s(r.a)(t), e)
        })
        e.a = c
    },
    './node_modules/seamless-immutable/seamless-immutable.development.js': function (t, e, n) {
        let r
        !(function () {
            'use strict'
            const i = (function t(e) {
                let n; let r = 'function' == typeof Symbol && Symbol.for && Symbol.for('react.element');
                var i = {
                    use_static: !1
                };

                function o(t) {
                    let e = Object.getPrototypeOf(t)
                    return e ? Object.create(e) : {}
                }

                function a(t, e, n) {
                    Object.defineProperty(t, e, {
                        enumerable: !1,
                        configurable: !1,
                        writable: !1,
                        value: n
                    })
                }

                function s(t, e) {
                    a(t, e, () => {
                        throw new m('The ' + e + ' method cannot be invoked on an Immutable data structure.')
                    })
                }

                function u(t) {
                    return typeof t != 'object' || (t === null || Boolean(Object.getOwnPropertyDescriptor(t, '__immutable_invariants_hold')))
                }

                function c(t, e) {
                    return t === e || t != t && e != e
                }

                function l(t) {
                    return !(t === null || typeof t != 'object' || Array.isArray(t) || t instanceof Date)
                }
                'object' != typeof (n = e) || Array.isArray(n) || n === null || void 0 !== e.use_static && (i.use_static = Boolean(e.use_static))
                var h = ['setPrototypeOf']
                        var f = h.concat(['push', 'pop', 'sort', 'splice', 'shift', 'unshift', 'reverse'])
                        var d = ['keys'].concat(['map', 'filter', 'slice', 'concat', 'reduce', 'reduceRight'])
                        var p = h.concat(['setDate', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'setYear'])

                function m(t) {
                    this.name = 'MyError', this.message = t, this.stack = (new Error()).stack
                }

                function y(t, e) {
                    for (const n in a(t, '__immutable_invariants_hold', !0), e) e.hasOwnProperty(n) && s(t, e[n])
                    return Object.freeze(t), t
                }

                function v(t, e) {
                    let n = t[e]
                    a(t, e, function () {
                        return V(n.apply(t, arguments))
                    })
                }

                function _(t, e, n) {
                    let r = n && n.deep
                    if (t in this && (r && this[t] !== e && l(e) && l(this[t]) && (e = V.merge(this[t], e, {
                        deep: !0,
                        mode: 'replace'
                    })), c(this[t], e))) { return this
}
                    let i = w.call(this)
                    return i[t] = V(e), E(i)
                }
                m.prototype = new Error(), m.prototype.constructor = Error
                var g = V([])

                function b(t, e, n) {
                    let r = t[0]
                    if (t.length === 1) return _.call(this, r, e, n)
                    var i; let o = t.slice(1)
                            var a = this[r]
                    if (typeof a == 'object' && a !== null) { i = V.setIn(a, o, e)
}
                    else {
                        let s = o[0]
                        i = s !== '' && isFinite(s) ? b.call(g, o, e) : j.call(M, o, e)
                    }
                    if (r in this && a === i) return this
                    var u = w.call(this)
                    return u[r] = i, E(u)
                }

                function E(t) {
                    for (const e in d) {
                        if (d.hasOwnProperty(e)) v(t, d[e])
                    }
                    i.use_static || (a(t, 'flatMap', T), a(t, 'asObject', O), a(t, 'asMutable', w), a(t, 'set', _), a(t, 'setIn', b), a(t, 'update', L), a(t, 'updateIn', B), a(t, 'getIn', U))
                    for (let n = 0, r = t.length; n < r; n++) t[n] = V(t[n])
                    return y(t, f)
                }

                function x() {
                    return new Date(this.getTime())
                }

                function T(t) {
                    if (arguments.length === 0) return this
                    var e; let n = []
                            var r = this.length
                    for (e = 0; e < r; e++) {
                        let i = t(this[e], e, this)
                        Array.isArray(i) ? n.push.apply(n, i) : n.push(i)
                    }
                    return E(n)
                }

                function S(t) {
                    if (void 0 === t && arguments.length === 0) return this
                    if (typeof t != 'function') {
                        let e = Array.isArray(t) ? t.slice() : Array.prototype.slice.call(arguments)
                        e.forEach((t, e, n) => {
                            "number" == typeof t && (n[e] = t.toString())
                        }), t = function (t, n) {
                            return e.includes(n)
                        }
                    }
                    let n = o(this)
                    for (const r in this) this.hasOwnProperty(r) && !1 === t(this[r], r) && (n[r] = this[r])
                    return H(n)
                }

                function w(t) {
                    let e; let n; let r = []
                    if (t && t.deep) {
                        for (e = 0, n = this.length; e < n; e++) r.push(P(this[e]))
}
                    else {
                        for (e = 0, n = this.length; e < n; e++) r.push(this[e])
}
                    return r
                }

                function O(t) {
                    'function' != typeof t && (t = function (t) {
                        return t
                    })
                    var e; let n = {}
                            var r = this.length
                    for (e = 0; e < r; e++) {
                        let i = t(this[e], e, this)
                                var o = i[0]
                                var a = i[1]
                        n[o] = a
                    }
                    return H(n)
                }

                function P(t) {
                    return !t || typeof t != 'object' || !Object.getOwnPropertyDescriptor(t, '__immutable_invariants_hold') || t instanceof Date
                        ? t
                        : V.asMutable(t, {
                                deep: !0
                            })
                }

                function R(t, e) {
                    for (const n in t) Object.getOwnPropertyDescriptor(t, n) && (e[n] = t[n])
                    return e
                }

                function A(t, e) {
                    if (arguments.length === 0) return this
                    if (t === null || typeof t != 'object') throw new TypeError(`Immutable#merge can only be invoked with objects or arrays, not ${  JSON.stringify(t)}`)
                    var n; let r; let i = Array.isArray(t)
                            var a = e && e.deep
                            var s = e && e.mode || 'merge';
                    var u = e && e.merger

                    function h(t, r, i) {
                        let s; let h = V(r[i])
                                var f = u && u(t[i], h, e)
                                var d = t[i]
                        void 0 === n && void 0 === f && t.hasOwnProperty(i) && c(h, d) || (c(d, s = void 0 !== f ? f : a && l(d) && l(h) ? V.merge(d, h, e) : h) && t.hasOwnProperty(i) || (void 0 === n && (n = R(t, o(t))), n[i] = s))
                    }

                    function f(t, e) {
                        for (const r in t) e.hasOwnProperty(r) || (void 0 === n && (n = R(t, o(t))), delete n[r])
                    }
                    if (i) {
                        for (let d = 0, p = t.length; d < p; d++) {
                            var m = t[d]
                                for (r in m) m.hasOwnProperty(r) && h(void 0 !== n ? n : this, m, r)
                        }
                    } else {
                        for (r in t) Object.getOwnPropertyDescriptor(t, r) && h(this, t, r)
                        "replace" === s && f(this, t)
                    }
                    return void 0 === n ? this : H(n)
                }

                function I(t, e) {
                    let n = e && e.deep
                    if (arguments.length === 0) return this
                    if (t === null || typeof t != 'object') throw new TypeError(`Immutable#replace can only be invoked with objects or arrays, not ${  JSON.stringify(t)}`)
                    return V.merge(this, t, {
                        deep: n,
                        mode: 'replace'
                    })
                }
                let C; let k; let N; var M = V({})

                function j(t, e, n) {
                    if (!Array.isArray(t) || t.length === 0) throw new TypeError('The first argument to Immutable#setIn must be an array containing at least one "key" string.')
                    var r = t[0]
                    if (t.length === 1) return D.call(this, r, e, n)
                    var i; let a = t.slice(1)
                            var s = this[r]
                    if (i = this.hasOwnProperty(r) && typeof s == 'object' && s !== null ? V.setIn(s, a, e) : j.call(M, a, e), this.hasOwnProperty(r) && s === i) return this
                    var u = R(this, o(this))
                    return u[r] = i, H(u)
                }

                function D(t, e, n) {
                    let r = n && n.deep
                    if (this.hasOwnProperty(t) && (r && this[t] !== e && l(e) && l(this[t]) && (e = V.merge(this[t], e, {
                        deep: !0,
                        mode: 'replace'
                    })), c(this[t], e))) { return this
}
                    let i = R(this, o(this))
                    return i[t] = V(e), H(i)
                }

                function L(t, e) {
                    let n = Array.prototype.slice.call(arguments, 2)
                            var r = this[t]
                    return V.set(this, t, e.apply(r, [r].concat(n)))
                }

                function F(t, e) {
                    for (var n = 0, r = e.length; t != null && n < r; n++) t = t[e[n]]
                    return n && n == r ? t : void 0
                }

                function B(t, e) {
                    let n = Array.prototype.slice.call(arguments, 2)
                            var r = F(this, t)
                    return V.setIn(this, t, e.apply(r, [r].concat(n)))
                }

                function U(t, e) {
                    let n = F(this, t)
                    return void 0 === n ? e : n
                }

                function G(t) {
                    let e; let n = o(this)
                    if (t && t.deep) {
                        for (e in this) this.hasOwnProperty(e) && (n[e] = P(this[e]))
}
                    else {
                        for (e in this) this.hasOwnProperty(e) && (n[e] = this[e])
}
                    return n
                }

                function X() {
                    return {}
                }

                function H(t) {
                    return i.use_static || (a(t, 'merge', A), a(t, 'replace', I), a(t, 'without', S), a(t, 'asMutable', G), a(t, 'set', D), a(t, 'setIn', j), a(t, 'update', L), a(t, 'updateIn', B), a(t, 'getIn', U)), y(t, h)
                }

                function V(t, e, n) {
                    if (u(t) || (function (t) {
                        return 'object' == typeof t && t !== null && (t.$$typeof === 60103 || t.$$typeof === r)
                    }(t)) || (function (t) {
                        return 'undefined' != typeof File && t instanceof File
                    }(t)) || (function (t) {
                        return 'undefined' != typeof Blob && t instanceof Blob
                    }(t)) || (function (t) {
                        return t instanceof Error
                    }(t))) { return t
}
                    if (function (t) {
                        return typeof t == 'object' && typeof t.then == 'function'
                    }(t)) { return t.then(V)
}
                    if (Array.isArray(t)) return E(t.slice())
                    if (t instanceof Date) return o = new Date(t.getTime()), i.use_static || a(o, 'asMutable', x), y(o, p)
                    var o; let s = e && e.prototype
                            var c = (s && s !== Object.prototype
                        ? function () {
                            return Object.create(s)
                        }
                        : X)()
                    if (n == null && (n = 64), n <= 0) throw new m('Attempt to construct Immutable from a deeply nested object was detected. Have you tried to wrap an object with circular references (e.g. React element)? See https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected for details.')
                    for (const l in n -= 1, t) Object.getOwnPropertyDescriptor(t, l) && (c[l] = V(t[l], void 0, n))
                    return H(c)
                }

                function W(t) {
                    return function () {
                        let e = [].slice.call(arguments)
                                var n = e.shift()
                        return t.apply(n, e)
                    }
                }

                function Y(t, e) {
                    return function () {
                        let n = [].slice.call(arguments)
                                var r = n.shift()
                        return Array.isArray(r) ? e.apply(r, n) : t.apply(r, n)
                    }
                }
                return V.from = V, V.isImmutable = u, V.ImmutableError = m, V.merge = W(A), V.replace = W(I), V.without = W(S), V.asMutable = (C = G, k = w, N = x, function () {
                    let t = [].slice.call(arguments)
                            var e = t.shift()
                    return Array.isArray(e) ? k.apply(e, t) : e instanceof Date ? N.apply(e, t) : C.apply(e, t)
                }), V.set = Y(D, _), V.setIn = Y(j, b), V.update = W(L), V.updateIn = W(B), V.getIn = W(U), V.flatMap = W(T), V.asObject = W(O), i.use_static || (V.static = t({
                    use_static: !0
                })), Object.freeze(V), V
            }())
            void 0 === (r = (function () {
                return i
            }.call(e, n, e, t))) || (t.exports = r)
        }())
    },
    './node_modules/seedrandom/index.js': function (t, e, n) {
        const r = n('./node_modules/seedrandom/lib/alea.js')
        const i = n('./node_modules/seedrandom/lib/xor128.js')
        const o = n('./node_modules/seedrandom/lib/xorwow.js')
        const a = n('./node_modules/seedrandom/lib/xorshift7.js')
        const s = n('./node_modules/seedrandom/lib/xor4096.js')
        const u = n('./node_modules/seedrandom/lib/tychei.js')
        const c = n('./node_modules/seedrandom/seedrandom.js')
        c.alea = r, c.xor128 = i, c.xorwow = o, c.xorshift7 = a, c.xor4096 = s, c.tychei = u, t.exports = c
    },
    './node_modules/seedrandom/lib/alea.js': function (t, e, n) {
        (function (t) {
            let r
            !(function (t, i, o) {
                function a(t) {
                    let e; const n = this
                    let r = (e = 4022871197, function (t) {
                        t = String(t)
                        for (let n = 0; n < t.length; n++) {
                            let r = 0.02519603282416938 * (e += t.charCodeAt(n))
                            r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e)
                        }
                        return 2.3283064365386963e-10 * (e >>> 0)
                    })
                    n.next = function () {
                        const t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c
                        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t)
                    }, n.c = 1, n.s0 = r(' '), n.s1 = r(' '), n.s2 = r(' '), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null
                }

                function s(t, e) {
                    return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e
                }

                function u(t, e) {
                    const n = new a(t)
                    let r = e && e.state
                    let i = n.next
                    return i.int32 = function () {
                        return 4294967296 * n.next() | 0
                    }, i.double = function () {
                        return i() + 11102230246251565e-32 * (2097152 * i() | 0)
                    }, i.quick = i, r && (typeof r == 'object' && s(r, n), i.state = function () {
                        return s(n, {})
                    }), i
                }
                i && i.exports
                    ? i.exports = u
                    : n('./node_modules/webpack/buildin/amd-define.js') && n('./node_modules/webpack/buildin/amd-options.js')
                        ? void 0 === (r = (function () {
                            return u
                        }.call(e, n, e, i))) || (i.exports = r)
                        : this.alea = u
            }(0, t, n('./node_modules/webpack/buildin/amd-define.js')))
        }).call(this, n('./node_modules/webpack/buildin/module.js')(t))
    },
    './node_modules/seedrandom/lib/tychei.js': function (t, e, n) {
        (function (t) {
            let r
            !(function (t, i, o) {
                function a(t) {
                    const e = this
                    let n = ''
                    e.next = function () {
                        let t = e.b
                        let n = e.c
                        let r = e.d
                        let i = e.a
                        return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ i, i = i - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ i, e.a = i - t | 0
                    }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t
                    for (let r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next()
                }

                function s(t, e) {
                    return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e
                }

                function u(t, e) {
                    const n = new a(t)
                    let r = e && e.state
                    let i = function () {
                        return (n.next() >>> 0) / 4294967296
                    }
                    return i.double = function () {
                        do {
                            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (t === 0)
                        return t
                    }, i.int32 = n.next, i.quick = i, r && (typeof r == 'object' && s(r, n), i.state = function () {
                        return s(n, {})
                    }), i
                }
                i && i.exports
                    ? i.exports = u
                    : n('./node_modules/webpack/buildin/amd-define.js') && n('./node_modules/webpack/buildin/amd-options.js')
                        ? void 0 === (r = (function () {
                            return u
                        }.call(e, n, e, i))) || (i.exports = r)
                        : this.tychei = u
            }(0, t, n('./node_modules/webpack/buildin/amd-define.js')))
        }).call(this, n('./node_modules/webpack/buildin/module.js')(t))
    },
    './node_modules/seedrandom/lib/xor128.js': function (t, e, n) {
        (function (t) {
            let r
            !(function (t, i, o) {
                function a(t) {
                    const e = this
                    let n = ''
                    e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
                        const t = e.x ^ e.x << 11
                        return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8
                    }, t === (0 | t) ? e.x = t : n += t
                    for (let r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next()
                }

                function s(t, e) {
                    return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e
                }

                function u(t, e) {
                    const n = new a(t)
                    let r = e && e.state
                    let i = function () {
                        return (n.next() >>> 0) / 4294967296
                    }
                    return i.double = function () {
                        do {
                            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (t === 0)
                        return t
                    }, i.int32 = n.next, i.quick = i, r && (typeof r == 'object' && s(r, n), i.state = function () {
                        return s(n, {})
                    }), i
                }
                i && i.exports
                    ? i.exports = u
                    : n('./node_modules/webpack/buildin/amd-define.js') && n('./node_modules/webpack/buildin/amd-options.js')
                        ? void 0 === (r = (function () {
                            return u
                        }.call(e, n, e, i))) || (i.exports = r)
                        : this.xor128 = u
            }(0, t, n('./node_modules/webpack/buildin/amd-define.js')))
        }).call(this, n('./node_modules/webpack/buildin/module.js')(t))
    },
    './node_modules/seedrandom/lib/xor4096.js': function (t, e, n) {
        (function (t) {
            let r
            !(function (t, i, o) {
                function a(t) {
                    const e = this
                    e.next = function () {
                        let t; let n; let r = e.w
                        let i = e.X
                        let o = e.i
                        return e.w = r = r + 1640531527 | 0, n = i[o + 34 & 127], t = i[o = o + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = i[o] = n ^ t, e.i = o, n + (r ^ r >>> 16) | 0
                    },
                    (function (t, e) {
                        let n; let r; let i; let o; let a; const s = []
                        var u = 128
                        for (e === (0 | e) ? (r = e, e = null) : (e += '\0', r = 0, u = Math.max(u, e.length)), i = 0, o = -32; o < u; ++o) e && (r ^= e.charCodeAt((o + 32) % e.length)), o === 0 && (a = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, o >= 0 && (a = a + 1640531527 | 0, i = (n = s[127 & o] ^= r + a) == 0 ? i + 1 : 0)
                        for (i >= 128 && (s[127 & (e && e.length || 0)] = -1), i = 127, o = 512; o > 0; --o) r = s[i + 34 & 127], n = s[i = i + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[i] = r ^ n
                        t.w = a, t.X = s, t.i = i
                    }(e, t))
                }

                function s(t, e) {
                    return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e
                }

                function u(t, e) {
                    t == null && (t = +new Date())
                    const n = new a(t)
                    let r = e && e.state
                    let i = function () {
                        return (n.next() >>> 0) / 4294967296
                    }
                    return i.double = function () {
                        do {
                            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (t === 0)
                        return t
                    }, i.int32 = n.next, i.quick = i, r && (r.X && s(r, n), i.state = function () {
                        return s(n, {})
                    }), i
                }
                i && i.exports
                    ? i.exports = u
                    : n('./node_modules/webpack/buildin/amd-define.js') && n('./node_modules/webpack/buildin/amd-options.js')
                        ? void 0 === (r = (function () {
                            return u
                        }.call(e, n, e, i))) || (i.exports = r)
                        : this.xor4096 = u
            }(0, t, n('./node_modules/webpack/buildin/amd-define.js')))
        }).call(this, n('./node_modules/webpack/buildin/module.js')(t))
    },
    './node_modules/seedrandom/lib/xorshift7.js': function (t, e, n) {
        (function (t) {
            let r
            !(function (t, i, o) {
                function a(t) {
                    const e = this
                    e.next = function () {
                        let t; let n; const r = e.x
                        let i = e.i
                        return t = r[i], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[i + 1 & 7]) ^ t >>> 10, n ^= (t = r[i + 3 & 7]) ^ t >>> 3, n ^= (t = r[i + 4 & 7]) ^ t << 7, t = r[i + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[i] = n, e.i = i + 1 & 7, n
                    },
                    (function (t, e) {
                        let n; const r = []
                        if (e === (0 | e)) { r[0] = e
                        }
                        else {
                            for (e = `${  e}`, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13
                        }
                        for (; r.length < 8;) r.push(0)
                        for (n = 0; n < 8 && r[n] === 0; ++n);
                        for (n == 8 ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next()
                    }(e, t))
                }

                function s(t, e) {
                    return e.x = t.x.slice(), e.i = t.i, e
                }

                function u(t, e) {
                    t == null && (t = +new Date())
                    const n = new a(t)
                    let r = e && e.state
                    let i = function () {
                        return (n.next() >>> 0) / 4294967296
                    }
                    return i.double = function () {
                        do {
                            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (t === 0)
                        return t
                    }, i.int32 = n.next, i.quick = i, r && (r.x && s(r, n), i.state = function () {
                        return s(n, {})
                    }), i
                }
                i && i.exports
                    ? i.exports = u
                    : n('./node_modules/webpack/buildin/amd-define.js') && n('./node_modules/webpack/buildin/amd-options.js')
                        ? void 0 === (r = (function () {
                            return u
                        }.call(e, n, e, i))) || (i.exports = r)
                        : this.xorshift7 = u
            }(0, t, n('./node_modules/webpack/buildin/amd-define.js')))
        }).call(this, n('./node_modules/webpack/buildin/module.js')(t))
    },
    './node_modules/seedrandom/lib/xorwow.js': function (t, e, n) {
        (function (t) {
            let r
            !(function (t, i, o) {
                function a(t) {
                    const e = this
                    let n = ''
                    e.next = function () {
                        const t = e.x ^ e.x >>> 2
                        return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0
                    }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t
                    for (let r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next()
                }

                function s(t, e) {
                    return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e
                }

                function u(t, e) {
                    const n = new a(t)
                    let r = e && e.state
                    let i = function () {
                        return (n.next() >>> 0) / 4294967296
                    }
                    return i.double = function () {
                        do {
                            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                        } while (t === 0)
                        return t
                    }, i.int32 = n.next, i.quick = i, r && (typeof r == 'object' && s(r, n), i.state = function () {
                        return s(n, {})
                    }), i
                }
                i && i.exports
                    ? i.exports = u
                    : n('./node_modules/webpack/buildin/amd-define.js') && n('./node_modules/webpack/buildin/amd-options.js')
                        ? void 0 === (r = (function () {
                            return u
                        }.call(e, n, e, i))) || (i.exports = r)
                        : this.xorwow = u
            }(0, t, n('./node_modules/webpack/buildin/amd-define.js')))
        }).call(this, n('./node_modules/webpack/buildin/module.js')(t))
    },
    './node_modules/seedrandom/seedrandom.js': function (t, e, n) {
        let r
        !(function (i, o, a) {
            let s; const u = a.pow(256, 6)
            let c = a.pow(2, 52)
            let l = 2 * c

            function h(t, e, n) {
                const r = []
                let h = p((function t(e, n) {
                    let r; let i = []
                                var o = typeof e
                    if (n && o == 'object') {
                        for (r in e) { try {
                                    i.push(t(e[r], n - 1))
                                } catch (t) {}
}
                    }
                    return i.length ? i : o == 'string' ? e : `${e }\0`
                }((e = e == 1
? {
                    entropy: !0
                }
                    : e || {}).entropy
                    ? [t, m(o)]
                    : t == null
? (function () {
                        try {
                            var t
                                return s && (t = s.randomBytes) ? t = t(256) : (t = new Uint8Array(256), (i.crypto || i.msCrypto).getRandomValues(t)), m(t)
                        } catch (t) {
                            var e = i.navigator;
                                    var n = e && e.plugins
                                return [+new Date(), i, n, i.screen, m(o)]
                        }
                    }())
: t, 3)), r)
                let y = new f(r)
                let v = function () {
                    for (var t = y.g(6), e = u, n = 0; t < c;) t = 256 * (t + n), e *= 256, n = y.g(1)
                    for (; t >= l;) t /= 2, e /= 2, n >>>= 1
                    return (t + n) / e
                }
                return v.int32 = function () {
                    return 0 | y.g(4)
                }, v.quick = function () {
                    return y.g(4) / 4294967296
                }, v.double = v, p(m(y.S), o), (e.pass || n || function (t, e, n, r) {
                    return r && (r.S && d(r, y), t.state = function () {
                        return d(y, {})
                    }), n ? (a.random = t, e) : t
                })(v, h, 'global' in e ? e.global : this == a, e.state)
            }

            function f(t) {
                let e; let n = t.length
                let r = this
                let i = 0
                let o = r.i = r.j = 0
                let a = r.S = []
                for (n || (t = [n++]); i < 256;) a[i] = i++
                for (i = 0; i < 256; i++) a[i] = a[o = 255 & o + t[i % n] + (e = a[i])], a[o] = e;
                (r.g = function (t) {
                    for (var e, n = 0, i = r.i, o = r.j, a = r.S; t--;) e = a[i = 255 & i + 1], n = 256 * n + a[255 & (a[i] = a[o = 255 & o + e]) + (a[o] = e)]
                    return r.i = i, r.j = o, n
                })(256)
            }

            function d(t, e) {
                return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
            }

            function p(t, e) {
                for (var n, r = `${t}`, i = 0; i < r.length;) e[255 & i] = 255 & (n ^= 19 * e[255 & i]) + r.charCodeAt(i++)
                return m(e)
            }

            function m(t) {
                return String.fromCharCode.apply(0, t)
            }
            if (p(a.random(), o), t.exports) {
                t.exports = h
                try {
                    s = n(0)
                } catch (t) {}
            } else { void 0 === (r = (function () {
                return h
            }.call(e, n, e, t))) || (t.exports = r)
            }
        }(typeof self != 'undefined' ? self : this, [], Math))
    },
    './node_modules/setimmediate/setImmediate.js': function (t, e, n) {
        (function (t, e) {
            !(function (t, n) {
                'use strict'
                if (!t.setImmediate) {
                    let r; let i; let o; let a; let s; let u = 1
                    var c = {}
                    var l = !1
                    let h = t.document
                    let f = Object.getPrototypeOf && Object.getPrototypeOf(t)
                    f = f && f.setTimeout ? f : t, {}.toString.call(t.process) === '[object process]'
                        ? r = function (t) {
                            e.nextTick(() => {
                                p(t)
                            })
                        }
                        : !(function () {
                                if (t.postMessage && !t.importScripts) {
                                    let e = !0
                                    let n = t.onmessage
                                    return t.onmessage = function () {
                                        e = !1
                                    }, t.postMessage('', '*'), t.onmessage = n, e
                                }
                            }())
                                ? t.MessageChannel
                                    ? ((o = new MessageChannel()).port1.onmessage = function (t) {
                                            p(t.data)
                                        }, r = function (t) {
                                            o.port2.postMessage(t)
                                        })
                                    : h && 'onreadystatechange' in h.createElement('script')
                                        ? (i = h.documentElement, r = function (t) {
                                                let e = h.createElement('script')
                                                e.onreadystatechange = function () {
                                                    p(t), e.onreadystatechange = null, i.removeChild(e), e = null
                                                }, i.appendChild(e)
                                            })
                                        : r = function (t) {
                                            setTimeout(p, 0, t)
                                        }
                                : (a = `setImmediate$${Math.random()}$`, s = function (e) {
                                        e.source === t && typeof e.data == 'string' && e.data.indexOf(a) === 0 && p(+e.data.slice(a.length))
                                    }, t.addEventListener ? t.addEventListener('message', s, !1) : t.attachEvent('onmessage', s), r = function (e) {
                                        t.postMessage(a + e, '*')
                                    }), f.setImmediate = function (t) {
                        typeof t != 'function' && (t = new Function(`${t}`))
                        for (var e = Array.from({ length: arguments.length - 1 }), n = 0; n < e.length; n++) e[n] = arguments[n + 1]
                        const i = {
                            callback: t,
                            args: e
                        }
                        return c[u] = i, r(u), u++
                    }, f.clearImmediate = d
                }

                function d(t) {
                    delete c[t]
                }

                function p(t) {
                    if (l) { setTimeout(p, 0, t)
                    }
                    else {
                        const e = c[t]
                        if (e) {
                            l = !0
                            try {
                                !(function (t) {
                                    const e = t.callback
                                    var n = t.args
                                    switch (n.length) {
                                        case 0:
                                            e()
                                            break
                                        case 1:
                                            e(n[0])
                                            break
                                        case 2:
                                            e(n[0], n[1])
                                            break
                                        case 3:
                                            e(n[0], n[1], n[2])
                                            break
                                        default:
                                            e.apply(void 0, n)
                                    }
                                }(e))
                            } finally {
                                d(t), l = !1
                            }
                        }
                    }
                }
            }(typeof self == 'undefined' ? void 0 === t ? this : t : self))
        }).call(this, n('./node_modules/webpack/buildin/global.js'), n('./node_modules/process/browser.js'))
    },
    './node_modules/url/url.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/punycode/punycode.js')
        const i = n('./node_modules/url/util.js')

        function o() {
            this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
        }
        e.parse = g, e.resolve = function (t, e) {
            return g(t, !1, !0).resolve(e)
        }, e.resolveObject = function (t, e) {
            return t ? g(t, !1, !0).resolveObject(e) : e
        }, e.format = function (t) {
            i.isString(t) && (t = g(t))
            return t instanceof o ? t.format() : o.prototype.format.call(t)
        }, e.Url = o
        const a = /^([a-z0-9.+-]+:)/i
        const s = /:\d*$/
        const u = /^(\/\/?(?!\/)[^?\s]*)(\?\S*)?$/
        const c = ['{', '}', '|', '\\', '^', '`'].concat(['<', '>', '"', '`', ' ', '\r', '\n', '\t'])
        const l = ['\''].concat(c)
        const h = ['%', '/', '?', ';', '#'].concat(l)
        const f = ['/', '?', '#']
        const d = /^[+\w-]{0,63}$/i
        const p = /^([+\w-]{0,63})(.*)$/i
        const m = {
            'javascript': !0,
            'javascript:': !0
        }
        const y = {
            'javascript': !0,
            'javascript:': !0
        }
        const v = {
            'http': !0,
            'https': !0,
            'ftp': !0,
            'gopher': !0,
            'file': !0,
            'http:': !0,
            'https:': !0,
            'ftp:': !0,
            'gopher:': !0,
            'file:': !0
        }
        const _ = n('./node_modules/querystring-es3/index.js')

        function g(t, e, n) {
            if (t && i.isObject(t) && t instanceof o) return t
            const r = new o()
            return r.parse(t, e, n), r
        }
        o.prototype.parse = function (t, e, n) {
            if (!i.isString(t)) throw new TypeError(`Parameter 'url' must be a string, not ${typeof t}`)
            const o = t.indexOf('?')
            const s = o !== -1 && o < t.indexOf('#') ? '?' : '#'
            const c = t.split(s)
            c[0] = c[0].replace(/\\/g, '/')
            let g = t = c.join(s)
            if (g = g.trim(), !n && t.split('#').length === 1) {
                const b = u.exec(g)
                if (b) return this.path = g, this.href = g, this.pathname = b[1], b[2] ? (this.search = b[2], this.query = e ? _.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = '', this.query = {}), this
            }
            let E = a.exec(g)
            if (E) {
                var x = (E = E[0]).toLowerCase()
                this.protocol = x, g = g.substr(E.length)
            }
            if (n || E || g.match(/^\/\/[^@/]+@[^@/]+/)) {
                var T = g.substr(0, 2) === '//'
                !T || E && y[E] || (g = g.substr(2), this.slashes = !0)
            }
            if (!y[E] && (T || E && !v[E])) {
                for (var S, w, O = -1, P = 0; P < f.length; P++) {
                    (R = g.indexOf(f[P])) !== -1 && (O === -1 || R < O) && (O = R)
                } (w = O === -1 ? g.lastIndexOf('@') : g.lastIndexOf('@', O)) !== -1 && (S = g.slice(0, w), g = g.slice(w + 1), this.auth = decodeURIComponent(S)), O = -1
                for (P = 0; P < h.length; P++) {
                    var R; (R = g.indexOf(h[P])) !== -1 && (O === -1 || R < O) && (O = R)
                } O === -1 && (O = g.length), this.host = g.slice(0, O), g = g.slice(O), this.parseHost(), this.hostname = this.hostname || ''
                const A = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'
                if (!A) {
                    for (var I = this.hostname.split(/\./), C = (P = 0, I.length); P < C; P++) {
                        const k = I[P]
                        if (k && !k.match(d)) {
                            for (var N = '', M = 0, j = k.length; M < j; M++) k.charCodeAt(M) > 127 ? N += 'x' : N += k[M]
                            if (!N.match(d)) {
                                const D = I.slice(0, P)
                                let L = I.slice(P + 1)
                                let F = k.match(p)
                                F && (D.push(F[1]), L.unshift(F[2])), L.length && (g = `/${L.join('.')}${g}`), this.hostname = D.join('.')
                                break
                            }
                        }
                    }
                }
                this.hostname.length > 255 ? this.hostname = '' : this.hostname = this.hostname.toLowerCase(), A || (this.hostname = r.toASCII(this.hostname))
                var B = this.port ? `:${this.port}` : ''
                let U = this.hostname || ''
                this.host = U + B, this.href += this.host, A && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), g[0] !== '/' && (g = `/${g}`))
            }
            if (!m[x]) {
                for (P = 0, C = l.length; P < C; P++) {
                    const G = l[P]
                    if (g.includes(G)) {
                        let X = encodeURIComponent(G)
                        X === G && (X = escape(G)), g = g.split(G).join(X)
                    }
                }
            }
            const H = g.indexOf('#'); H !== -1 && (this.hash = g.substr(H), g = g.slice(0, H))
            const V = g.indexOf('?')
            if (V !== -1 ? (this.search = g.substr(V), this.query = g.substr(V + 1), e && (this.query = _.parse(this.query)), g = g.slice(0, V)) : e && (this.search = '', this.query = {}), g && (this.pathname = g), v[x] && this.hostname && !this.pathname && (this.pathname = '/'), this.pathname || this.search) {
                B = this.pathname || ''
                const W = this.search || ''
                this.path = B + W
            }
            return this.href = this.format(), this
        }, o.prototype.format = function () {
            let t = this.auth || ''
            t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ':'), t += '@')
            let e = this.protocol || ''
            let n = this.pathname || ''
            let r = this.hash || ''
            let o = !1
            let a = ''
            this.host ? o = t + this.host : this.hostname && (o = t + (!this.hostname.includes(':') ? this.hostname : `[${this.hostname}]`), this.port && (o += `:${this.port}`)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (a = _.stringify(this.query))
            let s = this.search || a && `?${a}` || ''
            return e && e.substr(-1) !== ':' && (e += ':'), this.slashes || (!e || v[e]) && !1 !== o ? (o = `//${o || ''}`, n && n.charAt(0) !== '/' && (n = `/${n}`)) : o || (o = ''), r && r.charAt(0) !== '#' && (r = `#${r}`), s && s.charAt(0) !== '?' && (s = `?${s}`), e + o + (n = n.replace(/[?#]/g, (t) => {
                return encodeURIComponent(t)
            })) + (s = s.replace('#', '%23')) + r
        }, o.prototype.resolve = function (t) {
            return this.resolveObject(g(t, !1, !0)).format()
        }, o.prototype.resolveObject = function (t) {
            if (i.isString(t)) {
                const e = new o()
                e.parse(t, !1, !0), t = e
            }
            for (var n = new o(), r = Object.keys(this), a = 0; a < r.length; a++) {
                const s = r[a]
                n[s] = this[s]
            }
            if (n.hash = t.hash, t.href === '') return n.href = n.format(), n
            if (t.slashes && !t.protocol) {
                for (let u = Object.keys(t), c = 0; c < u.length; c++) {
                    const l = u[c]
                    l !== 'protocol' && (n[l] = t[l])
                }
                return v[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = '/'), n.href = n.format(), n
            }
            if (t.protocol && t.protocol !== n.protocol) {
                if (!v[t.protocol]) {
                    for (let h = Object.keys(t), f = 0; f < h.length; f++) {
                        const d = h[f]
                        n[d] = t[d]
                    }
                    return n.href = n.format(), n
                }
                if (n.protocol = t.protocol, t.host || y[t.protocol]) { n.pathname = t.pathname
                }
                else {
                    for (var p = (t.pathname || '').split('/'); p.length && !(t.host = p.shift()););
                    t.host || (t.host = ''), t.hostname || (t.hostname = ''), p[0] !== '' && p.unshift(''), p.length < 2 && p.unshift(''), n.pathname = p.join('/')
                }
                if (n.search = t.search, n.query = t.query, n.host = t.host || '', n.auth = t.auth, n.hostname = t.hostname || t.host, n.port = t.port, n.pathname || n.search) {
                    const m = n.pathname || ''
                    let _ = n.search || ''
                    n.path = m + _
                }
                return n.slashes = n.slashes || t.slashes, n.href = n.format(), n
            }
            const g = n.pathname && n.pathname.charAt(0) === '/'
            const b = t.host || t.pathname && t.pathname.charAt(0) === '/'
            let E = b || g || n.host && t.pathname
            const x = E
            let T = n.pathname && n.pathname.split('/') || []
            const S = (p = t.pathname && t.pathname.split('/') || [], n.protocol && !v[n.protocol])
            if (S && (n.hostname = '', n.port = null, n.host && (T[0] === '' ? T[0] = n.host : T.unshift(n.host)), n.host = '', t.protocol && (t.hostname = null, t.port = null, t.host && (p[0] === '' ? p[0] = t.host : p.unshift(t.host)), t.host = null), E = E && (p[0] === '' || T[0] === '')), b) { n.host = t.host || t.host === '' ? t.host : n.host, n.hostname = t.hostname || t.hostname === '' ? t.hostname : n.hostname, n.search = t.search, n.query = t.query, T = p
            }
            else if (p.length) { T || (T = []), T.pop(), T = T.concat(p), n.search = t.search, n.query = t.query
            }
            else if (!i.isNullOrUndefined(t.search)) {
                if (S) n.hostname = n.host = T.shift(), (A = !!(n.host && n.host.indexOf('@') > 0) && n.host.split('@')) && (n.auth = A.shift(), n.host = n.hostname = A.shift())
                return n.search = t.search, n.query = t.query, i.isNull(n.pathname) && i.isNull(n.search) || (n.path = (n.pathname ? n.pathname : '') + (n.search ? n.search : '')), n.href = n.format(), n
            }
            if (!T.length) return n.pathname = null, n.search ? n.path = `/${n.search}` : n.path = null, n.href = n.format(), n
            for (var w = T.slice(-1)[0], O = (n.host || t.host || T.length > 1) && (w === '.' || w === '..') || w === '', P = 0, R = T.length; R >= 0; R--) (w = T[R]) === '.' ? T.splice(R, 1) : w === '..' ? (T.splice(R, 1), P++) : P && (T.splice(R, 1), P--)
            if (!E && !x) {
                for (; P--; P) T.unshift('..')
            }
            !E || T[0] === '' || T[0] && T[0].charAt(0) === '/' || T.unshift(''), O && T.join('/').substr(-1) !== '/' && T.push('')
            let A; const I = T[0] === '' || T[0] && T[0].charAt(0) === '/'
            S && (n.hostname = n.host = I ? '' : T.length ? T.shift() : '', (A = !!(n.host && n.host.indexOf('@') > 0) && n.host.split('@')) && (n.auth = A.shift(), n.host = n.hostname = A.shift()))
            return (E = E || n.host && T.length) && !I && T.unshift(''), T.length ? n.pathname = T.join('/') : (n.pathname = null, n.path = null), i.isNull(n.pathname) && i.isNull(n.search) || (n.path = (n.pathname ? n.pathname : '') + (n.search ? n.search : '')), n.auth = t.auth || n.auth, n.slashes = n.slashes || t.slashes, n.href = n.format(), n
        }, o.prototype.parseHost = function () {
            let t = this.host
            let e = s.exec(t)
            e && ((e = e[0]) !== ':' && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
        }
    },
    './node_modules/url/util.js': function (t, e, n) {
        'use strict'
        t.exports = {
            isString(t) {
                return typeof t == 'string'
            },
            isObject(t) {
                return typeof t == 'object' && t !== null
            },
            isNull(t) {
                return t === null
            },
            isNullOrUndefined(t) {
                return t == null
            }
        }
    },
    './node_modules/webpack/buildin/amd-define.js': function (t, e) {
        t.exports = function () {
            throw new Error('define cannot be used indirect')
        }
    },
    './node_modules/webpack/buildin/amd-options.js': function (t, e) {
        (function (e) {
            t.exports = e
        }).call(this, {})
    },
    './node_modules/webpack/buildin/global.js': function (t, e) {
        let n
        n = (function () {
            return this
        }())
        try {
            n = n || new Function('return this')()
        } catch (t) {
            typeof window == 'object' && (n = window)
        }
        t.exports = n
    },
    './node_modules/webpack/buildin/module.js': function (t, e) {
        t.exports = function (t) {
            return t.webpackPolyfill || (t.deprecate = function () {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, 'loaded', {
                enumerable: !0,
                get() {
                    return t.l
                }
            }), Object.defineProperty(t, 'id', {
                enumerable: !0,
                get() {
                    return t.i
                }
            }), t.webpackPolyfill = 1), t
        }
    },
    './src/config.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/ramda/es/mergeDeepLeft.js')
        const i = n('./src/core/config/index.js')
        const o = n('./src/core/utils/constants.js')

        function a(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const s = [13, 14, 15]
        const u = {
            sceneParticles: {
                coin: {
                    emitter: {
                        sourceType: o.c.MOVIE_CLIP,
                        maxParticles: 1e3,
                        randomFrameStart: !0,
                        rate: {
                            amount: [1, 1],
                            interval: [0.15]
                        },
                        initializers: {
                            velocity: {
                                speed: [1],
                                angle: [360, 360]
                            },
                            mass: [0.1, 0.2],
                            life: [10, 12],
                            radius: [600]
                        },
                        behaviors: {
                            gravity: [1],
                            scale: {
                                from: [0.3, 0.8],
                                to: [0.6, 1.1]
                            }
                        }
                    }
                },
                banknote: {
                    emitter: {
                        emitterGuideType: o.b.RECTANGLE,
                        sourceType: o.c.MOVIE_CLIP,
                        maxParticles: 200,
                        rate: {
                            amount: [1, 1],
                            interval: [0.4]
                        },
                        initializers: {
                            velocity: {
                                speed: [1],
                                angle: [360, 360]
                            },
                            mass: [0.5, 0.8],
                            life: [10, 12],
                            radius: [600]
                        },
                        behaviors: {
                            gravity: [1],
                            scale: {
                                from: [0.6, 1],
                                to: [0.8, 1.2]
                            },
                            rotation: {
                                from: [0],
                                to: [14]
                            }
                        }
                    }
                }
            },
            centerWinCoins: {
                coin: {
                    emitter: {
                        sourceType: o.c.MOVIE_CLIP,
                        maxParticles: 1e3,
                        randomFrameStart: !0,
                        rate: {
                            amount: [1, 1],
                            interval: [0.04]
                        },
                        initializers: {
                            velocity: {
                                speed: 12,
                                angle: [345, 375]
                            },
                            mass: [0.3, 1.2],
                            life: [3, 3],
                            radius: [360]
                        },
                        behaviors: {
                            gravity: [10],
                            scale: {
                                from: [0.4, 0.2],
                                to: [0.6, 0.3]
                            }
                        }
                    }
                },
                banknote: {
                    emitter: {
                        sourceType: o.c.MOVIE_CLIP,
                        randomFrameStart: !0,
                        maxParticles: 1e3,
                        rate: {
                            amount: [1, 1],
                            interval: [0.07]
                        },
                        initializers: {
                            velocity: {
                                speed: 7,
                                angle: [315, 405]
                            },
                            mass: [0.1, 0.7],
                            life: [3, 3],
                            radius: [360]
                        },
                        behaviors: {
                            gravity: [1.5],
                            scale: {
                                from: [0.4, 0.2],
                                to: [0.6, 0.3]
                            }
                        }
                    }
                }
            },
            branding: {},
            renderer: {
                width: 1280,
                height: 850
            },
            paytable: {
                optional: [{
                    index: 9,
                    condition: 'hasFeatureBuy'
                }],
                screens: 8,
                particles: {
                    coin: {
                        emitter: {
                            sourceType: o.c.MOVIE_CLIP,
                            maxParticles: 1e3,
                            randomFrameStart: !0,
                            rate: {
                                amount: [1, 1],
                                interval: [0.15]
                            },
                            initializers: {
                                velocity: {
                                    speed: [1],
                                    angle: [360, 360]
                                },
                                mass: [0.1, 0.2],
                                life: [10, 12],
                                radius: [600]
                            },
                            behaviors: {
                                gravity: [1],
                                scale: {
                                    from: [0.4, 0.8],
                                    to: [0.6, 1]
                                }
                            }
                        }
                    }
                },
                targetParticlesPage: 0,
                spine: {
                    tileSpine: 'sevenTiles',
                    spineContainers: ['FreeSpins', 'WinSpins', 'WildSpins'],
                    initialSkinIndex: 13,
                    loopStates: 'idle'
                }
            },
            reels: {
                count: 5,
                type: 'spinning',
                tiles: {
                    total: 5,
                    visible: 3,
                    offsetTop: 1,
                    offsetBottom: 1,
                    blur: a(a(a(a(a({
                        enabled: !0,
                        default: {
                            x: 0,
                            y: 2,
                            quality: 8
                        }
                    }, 12, {
                        x: 0,
                        y: 0,
                        quality: 0
                    }), 11, {
                        x: 0,
                        y: 0,
                        quality: 0
                    }), 13, {
                        x: 0,
                        y: 0,
                        quality: 0
                    }), 14, {
                        x: 0,
                        y: 0,
                        quality: 0
                    }), 15, {
                        x: 0,
                        y: 0,
                        quality: 0
                    })
                },
                spin: {
                    spinStopTweenDuration: 1.65,
                    minDistance: 5,
                    speed: 18,
                    delay: {
                        atStart: 0,
                        atEnd: 5
                    },
                    easeStart: {
                        offset: 1,
                        speed: 6,
                        easings: ['power2.in']
                    },
                    easeEnd: {
                        offset: 0.08,
                        speed: 1.2,
                        easings: ['power1.out', 'power1.inOut']
                    },
                    instantStop: {
                        speedUpReels: {
                            enabled: !0,
                            speedFactor: 5,
                            switchDuration: 0,
                            keepEaseEndSpeed: !0
                        }
                    }
                },
                move: {}
            },
            scale: {
                XHD: {
                    default: 1
                },
                HD: {
                    default: 1
                },
                MD: {
                    default: 0.6
                },
                SD: {
                    default: 0.4
                },
                XSD: {
                    default: 0.4
                }
            },
            headerBanners: {
                default: {
                    count: 4,
                    pace: 4
                }
            },
            freeSpinsStatus: {
                counter: {
                    font: 'freeSpinsCounter',
                    alignType: 'CENTER'
                },
                skew: {
                    x: 0,
                    y: -0.15
                }
            },
            wins: {
                delays: {
                    betweenShows: 0,
                    beforeHide: 0.5
                },
                tiles: {
                    renderTexture: {
                        enabled: !1
                    },
                    spineShowLabel: 'win'
                },
                lines: {
                    delays: {
                        beforeShow: 0,
                        afterShow: 0
                    }
                }
            },
            anticipation: {
                jackpot: {
                    tileId: 100,
                    minTiles: 2,
                    maxTiles: 1 / 0,
                    minDuration: 8,
                    maxDuration: 16,
                    reels: [0, 2, 4]
                },
                freeSpins: {
                    tileIds: [13, 14, 15],
                    minTiles: 2,
                    maxTiles: 1 / 0,
                    minDuration: 8,
                    maxDuration: 16,
                    reels: [4]
                },
                freeSpinsMini: {
                    tileId: 13,
                    minTiles: 1,
                    maxTiles: 1,
                    minDuration: 7,
                    maxDuration: 7,
                    reels: [1, 2]
                }
            },
            freeSpinsPassEffects: {
                tileId: 13,
                onShow: {},
                onHide: {},
                reelEndEvent: '',
                moveEvent: '',
                reels: [0, 2, 4]
            },
            freeSpins: {
                preConfFreeSpins: {
                    spin: {
                        start: {
                            speed: 18
                        },
                        stop: {
                            extraDistance: 5
                        }
                    }
                },
                preConfWinSpins: {
                    spin: {
                        start: {
                            speed: 19
                        },
                        stop: {
                            extraDistance: 10
                        }
                    }
                },
                preConfWildSpins: {
                    spin: {
                        start: {
                            speed: 20
                        },
                        stop: {
                            extraDistance: 20
                        }
                    }
                }
            },
            jackpots: {
                delayBeforeWin: 1.2,
                delayBeforeDestroy: 7,
                delayAfterWin: 2.2
            },
            jackpotWin: {
                labels: {
                    tileWin: 'spawn'
                }
            },
            wildPassEffects: {
                tileId: 11,
                onShow: {},
                onHide: {},
                reelEndEvent: '',
                moveEvent: ''
            },
            wildPassEffectsSpecial: {
                tileId: 11,
                onShow: {},
                onHide: {},
                reelEndEvent: '',
                moveEvent: ''
            },
            expandPassEffects: {
                tileId: 12,
                onShow: {},
                onHide: {},
                reelEndEvent: '',
                moveEvent: ''
            },
            wildPopupTiles: {
                tileId: 11,
                shouldLoop: !0,
                attachable: !0
            },
            freeSpinsPopupTiles: {
                tileId: s,
                skinPrefix: 'tile',
                shouldLoop: !0,
                minTiles: 1,
                maxTiles: 3,
                reels: [0, 2, 4],
                winOnMaxTiles: !0
            },
            freeSpinsSpawn: {
                delayThreshold: 0.4,
                wildRatioThreshold: 5,
                reels: [1, 2, 3],
                reelThreshold: 3,
                tileThreshold: 3
            },
            loadingScreen: {
                tileSpine: 'sevenTiles',
                spineContainers: ['FreeSpins', 'WinSpins', 'WildSpins'],
                initialSkinIndex: 13,
                loopStates: 'idle'
            },
            sceneTransition: {
                fadeOutTime: 0.5,
                fadeInTime: 0.5
            },
            sceneEffects: {
                types: ['normal', 'freeSpins', 'winSpins', 'wildSpins']
            },
            slotPaytable: {
                idle: {
                    delay: {
                        min: 8,
                        max: 16
                    },
                    labels: ['idle1', 'idle2']
                },
                wildTileId: 11,
                tilePayouts: [5, 4, 3],
                textSettings: {
                    fontName: 'multiplierFont'
                }
            },
            bonusSplashScreen: {
                spineAnim: 'sevenStartScreen',
                counter: {
                    font: 'sumFont',
                    alignType: 'CENTER'
                },
                idToLabel: a(a(a({}, 13, 'freeSpins'), 14, 'winSpins'), 15, 'wildSpins'),
                labelToId: {
                    freeSpins: 11,
                    winSpins: 14,
                    wildSpins: 15
                }
            },
            fatWild: {
                attachable: !0,
                shouldLoop: !0
            },
            expandingWildPopups: {
                replaceOnDestroy: !1,
                attachable: !0,
                tileId: 12
            },
            sceneIdles: {
                normal: {
                    front: {
                        delay: {
                            min: 2,
                            max: 4
                        },
                        constantLoops: []
                    },
                    back: {
                        delay: {
                            min: 2,
                            max: 5
                        },
                        constantLoops: []
                    }
                },
                special: {
                    front: {
                        delay: {
                            min: 1,
                            max: 2
                        },
                        constantLoops: []
                    },
                    back: {
                        delay: {
                            min: 1,
                            max: 3
                        },
                        constantLoops: []
                    }
                }
            },
            extraWin: {
                spineAnimName: 'sevenStartScreen',
                slot: {
                    show: 0.2,
                    hide: 0.8
                },
                rumble: {
                    intensity: {
                        x: 1,
                        y: 1
                    },
                    deceleration: {
                        duration: 0.05
                    },
                    randomize: !1,
                    duration: 1.1
                },
                backgrounds: ['bigWin', 'superWin', 'megaWin', 'totalWin'],
                bangupSpeed: 7,
                sum: {
                    ignoreRatio: !1,
                    overscale: !1
                },
                totalWinSumDelay: 0.8,
                dynamicLabels: !1,
                labelShowDelay: {
                    bigWin: 1.1,
                    superWin: 1.1,
                    megaWin: 1.1,
                    maxWin: 0.887,
                    epicWin: 0.1,
                    jackpotWin: 1.1,
                    totalWin: 0.887
                },
                labelLoopDelay: {
                    bigWin: 1.75,
                    superWin: 1.75,
                    megaWin: 1.75,
                    maxWin: 1.75,
                    jackpotWin: 0.01,
                    totalWin: 1.2
                },
                pulseSum: {
                    scaleBy: 1.12,
                    initialScale: {
                        x: 1,
                        y: 1
                    },
                    animation: {
                        ease: 'power2.inOut',
                        duration: 1,
                        repeat: -1,
                        yoyo: !0
                    },
                    returnAnimation: {
                        ease: 'power2.in',
                        duration: 1
                    }
                },
                speedUp: {
                    timeScale: 2,
                    durationMultiplier: {
                        bigWin: 0.4,
                        superWin: 0.6,
                        megaWin: 0.6,
                        maxWin: 0.6,
                        totalWin: 0,
                        jackpotWin: 0.4
                    }
                },
                totalWinDuration: 3,
                multiplierDuration: 2,
                hideDelay: {
                    bigWin: {
                        default: 3.5,
                        custom: {}
                    },
                    normalWin: {
                        default: 2,
                        custom: {}
                    },
                    superWin: {
                        default: 3.5,
                        custom: {}
                    },
                    megaWin: {
                        default: 3.5,
                        custom: {}
                    },
                    maxWin: {
                        default: 3.5,
                        custom: {}
                    },
                    epicWin: {
                        default: 3.5,
                        custom: {}
                    },
                    jackpotWin: {
                        default: 3.5,
                        custom: {}
                    },
                    totalWin: {
                        default: 2.5,
                        custom: {}
                    }
                },
                easings: ['power2.out'],
                round: !1
            },
            alphaTransitions: {
                show: {
                    alpha: 1
                },
                hide: {
                    alpha: 0
                },
                duration: 0.1,
                default: ['background', 'sceneIdleSpecialBack', 'sceneIdleBack', 'sceneHitBack', 'reelMaster', 'foreground', 'sceneIdleFront', 'sceneIdleSpecialFront', 'slotPaytable', 'headerBanners', 'logo', 'jackpotPopupTiles', 'fatWildContainer', 'fade', 'freeSpinsPopupTiles', 'expandingWildPopups', 'fatWild', 'wildPopupTiles', 'freeSpinsSpawn', 'freeSpinsStatus', 'winLines', 'winTiles', 'slotWays']
            },
            viewportTracker: {
                landscapeThreshold: 1.2
            }
        }
        e.a = new Object(r.a)(u, i.a)
    },
    './src/core/App.js': function (t, e, n) {
        'use strict';
        (function (t) {
            const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
            const i = (n('./node_modules/@games/pixi-animate/lib/index.js'), n('./node_modules/pixi-spine/lib/all.es.js'), n('./src/core/fixes/index.js'), n('./node_modules/@games/dope/src/Dopamine.js'))
            const o = n('./src/core/utils/EventsHub.js')
            const a = n('./src/core/server/Server.js')
            const s = n('./src/config.js')
            const u = n('./src/core/loader/index.js')
            const c = n('./src/core/utils/CombinedTicker.js')
            const l = n('./src/core/Game.js')
            const h = n('./src/core/Renderer.js')
            const f = n('./src/features/index.js')
            const d = n('./src/texts/index.js')
            const p = n('./src/core/utils/Status.js')
            const m = n('./src/core/utils/misc.js')
            const y = n('./src/core/server/GameData.js')

            function v(t, e) {
                const n = Object.keys(t)
                if (Object.getOwnPropertySymbols) {
                    let r = Object.getOwnPropertySymbols(t)
                    e && (r = r.filter((e) => {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    })), n.push.apply(n, r)
                }
                return n
            }

            function _(t, e, n) {
                return e in t
                    ? Object.defineProperty(t, e, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        })
                    : t[e] = n, t
            }

            function g(t, e, n, r, i, o, a) {
                try {
                    var s = t[o](a)
                    var u = s.value
                } catch (t) {
                    return void n(t)
                }
                s.done ? e(u) : Promise.resolve(u).then(r, i)
            }

            function b(t) {
                return function () {
                    const e = this
                    const n = arguments
                    return new Promise((r, i) => {
                        const o = t.apply(e, n)

                        function a(t) {
                            g(o, r, i, a, s, 'next', t)
                        }

                        function s(t) {
                            g(o, r, i, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }
            }

            function E(t, e) {
                for (let n = 0; n < e.length; n++) {
                    const r = e[n]
                    r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
                }
            }
            window.PIXI = t
            const x = (function () {
                function t(e, n) {
                    !(function (t, e) {
                        if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                    }(this, t)), r.utils.skipHello(), this.stage = new r.Container(), this.renderer = new h.a(s.a.renderer, this.stage), this.ticker = new c.a(this.renderer), this._client = new a.a(n), this._holdLoadingScreen = Promise.resolve(), this.container = document.createElement('div'), this.container.className = 'game', this.settings = null, this.game = null, this.container.appendChild(this.renderer.view), this._updateConfig(e)
                }
                let e, n, p, g, x, T, S
                return e = t, (n = [{
                    key: 'holdLoadingScreen',
                    value() {
                        let t = this
                        this._holdLoadingScreen = new Promise((e) => {
                            t._holdResolve = e
                        })
                    }
                }, {
                    key: 'releaseLoadingScreen',
                    value() {
                        this._holdResolve && this._holdResolve()
                    }
                }, {
                    key: 'init',
                    value: (S = b(regeneratorRuntime.mark(function t() {
                        let e, n, r, a, c
                        return regeneratorRuntime.wrap(function (t) {
                            for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, u.b.loadManifest();
                                    case 2:
                                        return e = this._validateLanguage(s.a.lang), this.setLanguage(e), t.next = 6, this._client.settings();
                                    case 6:
                                        n = t.sent, r = n.result, a = r && r.game.skin ? r.game.skin : s.a.skin ? s.a.skin : null, this._applySkin(a), (c = this._validateLanguage(s.a.lang)) !== e && this.setLanguage(c), r && (i.a.set(s.a.hideCurrency ? {
                                            symbol: ""
                                        } : r.user.currency), void 0 === s.a.isStateful && (s.a.isStateful = Boolean(r.game.stateful)), void 0 === s.a.hasFeatureBuy && (s.a.hasFeatureBuy = Boolean(r.game.hasFeatureBuy)), s.a.hasChoices = Boolean(r.game.hasChoices), this.settings = r, y.a.init(r)), o.a.emit(o.a.events.INIT);
                                    case 14:
                                    case "end":
                                        return t.stop()
                                }
}
                        }, t, this)
                    })), function () {
                        return S.apply(this, arguments)
                    })
                }, {
                    key: 'preload',
                    value: (T = b(regeneratorRuntime.mark(function t() {
                        let e
                        return regeneratorRuntime.wrap(function (t) {
                            for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (this.settings) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return", Promise.resolve());
                                    case 2:
                                        return o.a.emit(o.a.events.LOAD_GAME_START), t.next = 5, u.b.loadFeature("loader");
                                    case 5:
                                        return e = u.b.loadFeature("main", {
                                            onProgress: function(t) {
                                                o.a.emit(o.a.events.LOAD_GAME_PROGRESS, {
                                                    progress: t / 100
                                                })
                                            }
                                        }), this._showLoader(), t.next = 9, e;
                                    case 9:
                                        return t.abrupt("return", this._initGame());
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
}
                        }, t, this)
                    })), function () {
                        return T.apply(this, arguments)
                    })
                }, {
                    key: 'setLanguage',
                    value(t) {
                        i.c.setLanguage(t, d.a, s.a.defaultLang)
                    }
                }, {
                    key: '_showLoader',
                    value() {
                        this.loadingScreen = new f.a.LoadingScreen({
                            animation: u.a.LoadingScreen.loadingScreen,
                            config: s.a.loadingScreen
                        }), this.stage.addChild(this.loadingScreen)
                    }
                }, {
                    key: '_hideLoader',
                    value: (x = b(regeneratorRuntime.mark(function t() {
                        return regeneratorRuntime.wrap(function (t) {
                            for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, this._holdLoadingScreen;
                                    case 2:
                                        return t.next = 4, this.loadingScreen.onComplete();
                                    case 4:
                                        o.a.emit(o.a.events.LOAD_GAME_COMPLETE), s.a.paytableOnLoad && this._removeLoadingScreen();
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
}
                        }, t, this)
                    })), function () {
                        return x.apply(this, arguments)
                    })
                }, {
                    key: '_initGame',
                    value: (g = b(regeneratorRuntime.mark(function t(e) {
                        let n, r, i, a
                        return regeneratorRuntime.wrap(function (t) {
                            for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return this.game = new(e || l.a), this.stage.addChildAt(this.game, 0), t.next = 4, this.game.init(this._client, this.settings, this.renderer);
                                    case 4:
                                        if (n = this.game.getStakes(), r = n.selected, i = r.value, a = r.index, o.a.emit(o.a.events.STAKE_CHANGE, {
                                                value: i,
                                                index: a
                                            }), e) {
                                            t.next = 9;
                                            break
                                        }
                                        return t.next = 9, this._hideLoader();
                                    case 9:
                                        this.game.ready(!!e), o.a.emit(o.a.events.GAME_READY);
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
}
                        }, t, this)
                    })), function (t) {
                        return g.apply(this, arguments)
                    })
                }, {
                    key: 'start',
                    value() {
                        this.renderer.resume()
                    }
                }, {
                    key: 'startGame',
                    value() {
                        this.game.scenario.features.paytable.isLoading || (this.loadingScreen && !s.a.paytableOnLoad && this._removeLoadingScreen(), this.game.hidePaytable(!s.a.paytableOnLoad), this.game.start())
                    }
                }, {
                    key: 'helpPath',
                    get() {
                        let t; let e; let n; let r = (t = this.settings) === null || void 0 === t || (e = t.user) === null || void 0 === e || (n = e.country) === null || void 0 === n ? void 0 : n.toLowerCase()
                                var o = u.b.getAssetsVariant('help').find((t) => {
                            return t.id === 'help_'.concat(i.c.code, '_').concat(r)
                        })
                        return o || (o = u.b.getAssetsVariant('help').find((t) => {
                            return t.id === 'help_'.concat(i.c.code)
                        })), o
                            ? o.src
                            : u.b.getAssetsVariant('help').find((t) => {
                                return t.id.includes(s.a.defaultLang)
                            }).src
                    }
                }, {
                    key: 'rtp',
                    get() {
                        return this.settings
                            ? this.settings.game.rtp
                            : {
                                    game: {
                                        default: ''
                                    }
                                }
                    }
                }, {
                    key: 'size',
                    set(t) {
                        this.renderer.resize(t)
                    }
                }, {
                    key: '_updateConfig',
                    value(t) {
                        Object.assign(s.a, (function (t) {
                            for (let e = 1; e < arguments.length; e++) {
                                var n = arguments[e] != null ? arguments[e] : {}
                                    e % 2
? v(new Object(n), !0).forEach(function(e) {
                                        _(t, e, n[e])
                                    })
: Object.getOwnPropertyDescriptors
? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
: v(new Object(n)).forEach(function(e) {
                                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                                    })
                            }
                            return t
                        }({}, t))), t.hideCurrency && (s.a.hideCurrency = t.hideCurrency), t.skipJackpotWin && (s.a.jackpotWin.duration = 0.01), t.paytableDynamicPayouts && (s.a.paytable.paytableDynamicPayouts = t.paytableDynamicPayouts), t.minRoundDurationStrict && (s.a.reels.spin.minSpinDurationEnabled = t.minRoundDurationStrict), s.a.static = t.static, new Object(m.i)()
                    }
                }, {
                    key: '_validateLanguage',
                    value(t) {
                        let e = s.a.supported.languages[s.a.skin]
                                var n = e && e.length ? e : s.a.supported.languages.default
                                var r = s.a.langsFallback[t] || t.split('-')[0]
                                var i = [].concat(t).concat(r).concat(s.a.defaultLang).find((t) => {
                            return n.includes(t)
                        })
                        return t !== s.a.defaultLang && i === s.a.defaultLang && console.warn(''.concat(t, ' language is not supported, defaults to ').concat(s.a.defaultLang)), i
                    }
                }, {
                    key: '_applySkin',
                    value(t) {
                        s.a.supported.skins.includes(t) || (t = 'default'), s.a.skin = t
                    }
                }, {
                    key: '_removeLoadingScreen',
                    value() {
                        this.stage.removeChild(this.loadingScreen), this.loadingScreen.removeAllListeners(), this.loadingScreen.destroy(), delete this.loadingScreen
                    }
                }]) && E(e.prototype, n), p && E(e, p), t
            }())
            x.Status = p.a, e.a = x
        }).call(this, n('./node_modules/pixi.js/dist/esm/pixi.js'))
    },
    './src/core/Game.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return dt
        })
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = n('./src/core/loader/index.js')

        function o(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const a = (function () {
            function t(e, n) {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.container = e, this.settings = n
            }
            let e, n, a
            return e = t, (n = [{
                key: 'load',
                value (t) {
                    return this[t] ? console.warn('Feature '.concat(t, ' was already loaded, check for redundant calls')) : i.b.loadFeature(t)
                }
            }, {
                key: 'add',
                value (t) {
                    var e = this
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                                var i = n.container
                                var o = void 0 === i ? this.container : i
                    Object.keys(t).forEach((n) => {
                        if (e[n]) { console.error('Feature with name "'.concat(n, '" has already been added, check for redundant calls'));
}
                        else {
                            var i = t[n]
                                    i.name = n, o && i instanceof r.DisplayObject && o.addChild(i), Object.defineProperty(e, n, {
                                get: function () {
                                    return i
                                }
                            })
                        }
                    })
                }
            }, {
                key: 'arrange',
                value (t) {
                    var e = this
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.container
                                var r = t.map((t) => {
                        return e[t]
                    })
                        n.children = n.children.sort((t, e) => {
                        return r.includes(t) || r.includes(e) ? r.includes(t) ? r.includes(e) ? r.indexOf(t) - r.indexOf(e) : 1 : -1 : 0
                    })
                }
            }, {
                key: 'remove',
                value (t) {
                    var e = this
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.container
                    Array.isArray(t) || (t = [t]), Object.keys(t).forEach((r) => {
                        if (e[r]) { console.error('Feature "'.concat(r, "\" doesn't exist"));
}
                        else {
                            var i = t[r]
                                    i.stopTick(!0), i.destroy(), n.removeChild(i)
                        }
                    })
                }
            }]) && o(e.prototype, n), a && o(e, a), t
        }())
        let s = n('./src/core/utils/Status.js')
        let u = n('./src/core/server/SpinData.js')
        let c = n('./src/core/utils/EventsHub.js')
        let l = n('./src/states.js')
        let h = n('./src/core/utils/index.js')
        let f = n('./src/core/features/sound/SoundRouter.js')
        let d = n('./src/features/index.js')
        let p = n('./src/config.js')

        function m(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const y = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.router = new f.a(), this.sounds = this.router.sounds, this._lineIndex = 1
            }
            let e, n, r
            return e = t, (n = [{
                key: 'init',
                value (t) {
                    this._features = t, this._attachGameListeners()
                }
            }, {
                key: 'lastReelIndex',
                get () {
                    return p.a.reels.count - 1
                }
            }, {
                key: 'lastTileIndex',
                get () {
                    return p.a.reels.tiles.visible - 1
                }
            }, {
                key: 'isInFreeSpins',
                get () {
                    return s.a.get(s.a.TYPES.IN_FREE_SPINS)
                }
            }, {
                key: 'isInRespin',
                get () {
                    return s.a.get(s.a.TYPES.IN_RESPIN)
                }
            }, {
                key: 'hasWin',
                get () {
                    return u.a.hasWin
                }
            }, {
                key: 'hasExtraWin',
                get () {
                    return u.a.hasExtraWin && this.roundHasCelebrations
                }
            }, {
                key: 'hasError',
                get () {
                    return u.a.hasError
                }
            }, {
                key: 'hasNextSpin',
                get () {
                    return u.a.hasNext
                }
            }, {
                key: 'gameData',
                get () {
                    return u.a.currentSpin && u.a.currentSpin.game || {}
                }
            }, {
                key: 'win',
                get () {
                    return this.gameData.win && this.gameData.win.lines || 0
                }
            }, {
                key: 'stake',
                get () {
                    return this.gameData.stake
                }
            }, {
                key: 'isWinAboveStake',
                get () {
                    return this.win > this.stake && this.roundHasCelebrations
                }
            }, {
                key: 'hasFsWin',
                get () {
                    var t
                    return ((t = this.gameData.scatters) === null || void 0 === t ? void 0 : t.length) >= 3
                }
            }, {
                key: 'roundHasCelebrations',
                get () {
                    var t
                    if (!this.hasWin) return !1
                    var e = ((t = this.gameData.win) === null || void 0 === t ? void 0 : t.lines) || 0
                    return u.a.roundHasCelebrations(e + this._features.winBar.value)
                }
            }, {
                key: 'hasNearMiss',
                get () {
                    var t = this.gameData.scatters
                    return t && t.length >= 2 && t[t.length - 1].reel !== this.reelsCount - 1
                }
            }, {
                key: '_attachGameListeners',
                value () {
                    var t = this
                    this._features.freeSpinsStatus.on(d.a.VaryingFreeSpinsStatus.events.HIDE_START, this._onFreeSpinsStatusHideStartTool, this), this._features.winBar.on(d.a.WinBar.events.UPDATE_START, this._onWinBarUpdateStartTool, this), this._features.expandPassEffects.on(d.a.PassingEffects.events.SHOW_START, this._onExpandPassEffectsShowStartTool, this), this._features.freeSpinsPopupTiles.on(d.a.FreeSpinsPopupTiles.events.WIN, this._onFreeSpinsPopupTilesWinTool, this), this._features.intro.on(d.a.Cover.events.HIDE_END, this._onIntroHideEndTool, this), this._features.fsSpawnWildSymbols.on(d.a.FreeSpinsSpawn.events.WILD_SPAWN, this._onFsSpawnWildSymbolsWildSpawnTool, this), this._features.wildPassEffects.on(d.a.PassingEffects.events.SHOW_START, this._onWildPassEffectsShowStartTool, this), this._features.wildPassEffectsSpecial.on(d.a.PassingEffects.events.SHOW_START, this._onWildPassEffectsSpecialShowStartTool, this), this._features.freeSpinsPassEffects.on(d.a.PassingEffects.events.SHOW_START, this._onFreeSpinsPassEffectsShowStartTool, this), this._features.wins.on(d.a.WaysWins.events.LOOP_START, this._onWinsLoopStartTool, this), this._features.freeSpinsPopupTiles.on(d.a.SpinePopupTiles.events.PLAY_ANIM_START, this._onFreeSpinsPopupTilesPlayAnimStartTool, this), this._features.wins.on(d.a.WaysWins.events.SHOW_ALL_START, this._onWinsShowAllStartTool, this), this._features.wildPopupTiles.on(d.a.SpinePopupTiles.events.TILE_ADD, this._onWildPopupTilesTileAddTool, this), this._features.freeSpinsStartScreen.on(d.a.BonusSplashScreen.events.SHOW_START, this._onFreeSpinsStartScreenShowStartTool, this), this._features.freeSpinsStartScreen.on(d.a.BonusSplashScreen.events.BUTTON_CLICKED, this._onFreeSpinsStartScreenButtonClickedTool, this), this._features.freeSpinsStartScreen.on(d.a.BonusSplashScreen.events.SHOW_END, this._onFreeSpinsStartScreenShowEndTool, this), this._features.extraWin.on(d.a.ExtraWin.events.HIDE_START, this._onExtraWinHideStartTool, this), this._features.extraWin.on(d.a.ExtraWin.events.BANGUP_START, this._onExtraWinBangupStartTool, this), this._features.extraWin.on(d.a.ExtraWin.events.LABEL_SHOW_END, this._onExtraWinLabelShowEndTool, this), this._features.expandingWildPopups.on(d.a.SpinePopupTiles.events.DEACTIVATE_START, this._onExpandingWildPopupsDeactivateStartTool, this), this._features.expandingWildPopups.on(d.a.SpinePopupTiles.events.ACTIVATE_START, this._onExpandingWildPopupsActivateStartTool, this), this._features.freeSpinsAnticipation.on(d.a.Anticipation.events.START, this._onFreeSpinsAnticipationStartTool, this), this._features.freeSpinsAnticipation.on(d.a.Anticipation.events.FINISH, this._onFreeSpinsAnticipationFinishTool, this), this._features.reelMaster.on(d.a.SpinningReelMaster.events.ANIMATION_SPINNING, this._onReelMasterAnimationSpinningTool, this), this._features.extraWin.on(d.a.ExtraWin.events.BANGUP_END, this._onExtraWinBangupEndTool, this), this._features.extraWin.on(d.a.ExtraWin.events.LABEL_SHOW_START, this._onExtraWinLabelShowStartTool, this), this._features.reelMaster.on(d.a.SpinningReelMaster.events.SPIN_START, this._onReelMasterSpinStartTool, this), this._features.winBar.on(d.a.WinBar.events.UPDATE_END, this._onWinBarUpdateEndTool, this), this._features.reelMaster.on(d.a.SpinningReelMaster.events.SPIN_END, this._onReelMasterSpinEndTool, this), this._features.freeSpinsPopupTiles.on(d.a.PopupTiles.events.TILE_ADD, this._onFreeSpinsPopupTilesTileAddTool, this), this._features.paytable.on(d.a.Paytable.events.HIDE_START, this._onPaytableHideStartTool, this), this._features.paytable.on(d.a.Paytable.events.SLIDE_SCREEN, this._onPaytableSlideScreenTool, this), this._features.intro.on(d.a.Cover.events.SHOW_START, this._onIntroShowStartTool, this), this._features.reelMaster.on(d.a.ReelMaster.events.ANIMATION_SPIN_STARTING, (e) => {
                        var n = e.index
                                return t._onReelStarting(n)
                    }), this._features.reelMaster.on(d.a.ReelMaster.events.ANIMATION_SPIN_ENDING, (e) => {
                        var n = e.index
                                return t._onReelEnding(n)
                    }), this._features.wins.on(d.a.Wins.events.SHOW_LINE, (e) => {
                        var n = e.inLoop
                                return t._onLineShow(n)
                    }), this._features.jackpotAnticipation.on(d.a.Anticipation.events.START, (e) => {
                        var n = e.reelIndex
                                return t._onJackpotAnticipationStart(n)
                    }), this._features.jackpotAnticipation.on(d.a.Anticipation.events.FINISH, () => {
                        return t._onJackpotAnticipationEnd()
                    }), this._features.jackpotPopupTiles.on(d.a.PopupTiles.events.TILE_ADD, (e) => {
                        var n = e.reel;
                                    var r = e.index;
                                    var i = e.total
                                return t._onJpHit({
                            reel: n,
                            index: r,
                            total: i
                        })
                    }), this._features.jackpots.on(d.a.Jackpots.events.SIRENS, () => {
                        return t._onSirensStart()
                    })
                }
            }, {
                key: '_onReelStarting',
                value (t) {
                    0 === t && (this._reset(), this.isInFreeSpins && !this.sounds.fsLoop.playing() && this.sounds.fsLoop.play().loop(!0))
                }
            }, {
                key: '_onReelEnding',
                value (t) {
                    this.sounds.reelStop.play().limitInterval(0.02)
                }
            }, {
                key: '_onLineShow',
                value (t) {
                    var e = (p.a.soundTool || {}).lineThreshold
                                var n = void 0 === e ? 1 : e
                                var r = Math.ceil(this._lineIndex / n)
                    !t && this.sounds[n === 1 ? 'winLines' : 'winLines'.concat(r)].play().limitInterval(0.01), this._lineIndex++
                }
            }, {
                key: '_onJackpotAnticipationStart',
                value (t) {
                    this.sounds.anticipation.playing() && this.sounds.anticipation.volume > 0 || (this.sounds.anticipation.play().volume(0).loop(!0).fadeIn(0.3), this.sounds.reelSpinLoop.fadeOut(0.2, !1))
                }
            }, {
                key: '_onJackpotAnticipationEnd',
                value () {
                    this.sounds.anticipation.fadeOut(0.3), this.win <= this.stake ? this.sounds.backgrLoop.fadeIn(0.3) : this.sounds.reelSpinLoop.fadeIn(0.3)
                }
            }, {
                key: '_onJpHit',
                value (t) {
                    var e; let n = t.reel
                                var r = t.index
                                var i = t.total
                                var o = (e = this.gameData.jackpotTiles) === null || void 0 === e
? void 0
: e.filter(function(t) {
                                    return t.reel === n && t.index === r
                                });
                    var a = !(o != null && o.length) || (o == null
? void 0
                        : o.some((t) => {
                                return t.reel === n && t.index === r && !t.screen
                            }))
                    this.sounds[''.concat(a ? 'jpSpawn' : 'jpHit').concat(i)].play()
                }
            }, {
                key: '_onSirensStart',
                value () {
                    this.sounds.jackSiren.play()
                }
            }, {
                key: '_reset',
                value () {
                    this._lineIndex = 1
                }
            }, {
                key: '_onFreeSpinsStatusHideStartTool',
                value (t) {
                    this.sounds.fsLoop.fadeOut(1.7, !0), this.sounds.fsLoop2.fadeOut(1.7, !0), this.sounds.fsLoop3.fadeOut(1.7, !0), this.sounds.backgrLoop.volume() > 0 && this.sounds.backgrLoop.fadeTo(4, 1)
                }
            }, {
                key: '_onWinBarUpdateStartTool',
                value (t) {
                    !0 === this.isWinAboveStake && !1 === this.hasExtraWin && !1 === this.sounds.totalWin.playing() && !1 === t.isInstant && (this.sounds.bangupStart.play(), this.sounds.bangupLoop.fadeTo(0.1, 1))
                }
            }, {
                key: '_onExpandPassEffectsShowStartTool',
                value (t) {
                    this.sounds.specialWildPass.play()
                }
            }, {
                key: '_onFreeSpinsPopupTilesWinTool',
                value (t) {
                    this.sounds.fsWin.play(), this.sounds.reelSpinLoop.fadeTo(1, 0), this.sounds.backgrLoop.fadeTo(1, 0)
                }
            }, {
                key: '_onIntroHideEndTool',
                value (t) {
                    this.sounds.reelSpinLoop.play().loop(!0).volume(0), this.sounds.backgrLoop.play().loop(!0).volume(1), this.sounds.bangupLoop.play().loop(!0).volume(0), this.sounds.reelSpinMechLoop.play().loop(!0).volume(0)
                }
            }, {
                key: '_onFsSpawnWildSymbolsWildSpawnTool',
                value (t) {
                    this.sounds.addWild.play()
                }
            }, {
                key: '_onWildPassEffectsShowStartTool',
                value (t) {
                    this.sounds.wildPass.play()
                }
            }, {
                key: '_onWildPassEffectsSpecialShowStartTool',
                value (t) {
                    this.sounds.specialWildPass.play()
                }
            }, {
                key: '_onFreeSpinsPassEffectsShowStartTool',
                value (t) {
                    this.sounds.fsPass.play()
                }
            }, {
                key: '_onWinsLoopStartTool',
                value (t) {
                    !0 === this.isWinAboveStake && !1 === this.hasExtraWin && this.sounds.winLines.play().limitInterval(1.5), !1 !== this.isWinAboveStake && !1 !== this.roundHasCelebrations || this.sounds.smallWin.play()
                }
            }, {
                key: '_onFreeSpinsPopupTilesPlayAnimStartTool',
                value (t) {
                    "anticipationWin" === t.label && this.sounds.fsWin.play()
                }
            }, {
                key: '_onWinsShowAllStartTool',
                value (t) {
                    !0 === this.isInFreeSpins && !0 === this.hasExtraWin && this.sounds.fsLoop.volume() > 0 && this.sounds.fsLoop.fadeTo(0.3, 0.4), !0 === this.isInFreeSpins && !0 === this.hasExtraWin && this.sounds.fsLoop2.volume() > 0 && this.sounds.fsLoop2.fadeTo(0.3, 0.4), !0 === this.isInFreeSpins && !0 === this.hasExtraWin && this.sounds.fsLoop3.volume() > 0 && this.sounds.fsLoop3.fadeTo(0.3, 0.4), !1 === this.hasExtraWin && this.sounds.winLines.play().limitInterval(1.5), !0 === this.hasExtraWin && !0 === this.roundHasCelebrations && this.sounds.winLinesExtraWin.play().limitInterval(5)
                }
            }, {
                key: '_onWildPopupTilesTileAddTool',
                value (t) {
                    this.sounds.wildHit1.play().limitInterval(0.1)
                }
            }, {
                key: '_onFreeSpinsStartScreenShowStartTool',
                value (t) {
                    this.sounds.reelSpinLoop.fadeTo(2, 0), this.sounds.backgrLoop.fadeTo(2, 0), this.sounds.fsSplash1.play(), !0 === this.sounds.fsLoop.playing() && this.sounds.fsLoop.volume() > 0 && (this.sounds.fsLoop.fadeTo(1, 0.5), this.sounds.fsSplash2.play()), !0 === this.sounds.fsLoop2.playing() && (this.sounds.fsLoop2.fadeTo(1, 0.5), this.sounds.fsSplash3.play())
                }
            }, {
                key: '_onFreeSpinsStartScreenButtonClickedTool',
                value (t) {
                    this.sounds.freeSpinsStart.play(), this.sounds.fsPreloaderLoop.fadeOut(0.3, !0), !0 === this.sounds.fsLoop2.playing() && (this.sounds.fsLoop2.fadeOut(0.1, !0), this.sounds.fsLoop3.play().volume(0).loop(!0).fadeIn(2)), !0 === this.sounds.fsLoop.playing() && this.sounds.fsLoop.volume() < 1 && this.sounds.fsLoop.volume() > 0 && (this.sounds.fsLoop.fadeTo(0.3, 0), this.sounds.fsLoop2.play().volume(0).loop(!0).fadeIn(2))
                }
            }, {
                key: '_onFreeSpinsStartScreenShowEndTool',
                value (t) {
                    !1 === this.sounds.fsLoop.playing() && this.sounds.fsPreloaderLoop.play().loop(!0)
                }
            }, {
                key: '_onExtraWinHideStartTool',
                value (t) {
                    this.sounds.bigWinLoop.fadeOut(0.1, !0), this.sounds.megaWinLoop.fadeOut(0.1, !0), this.sounds.superWinLoop.fadeOut(0.1, !0), !0 === this.sounds.fsLoop2.playing() && this.sounds.fsLoop2.fadeIn(2.5), !0 === this.isInFreeSpins && this.sounds.fsLoop.volume() > 0 && this.sounds.fsLoop.fadeTo(2.5, 1), !0 === this.sounds.fsLoop3.playing() && this.sounds.fsLoop3.fadeIn(2.5), !1 === this.isInFreeSpins && this.sounds.backgrLoop.fadeTo(4, 1), t.label === 'totalWin' && this.sounds.backgrLoop.fadeTo(4, 1)
                }
            }, {
                key: '_onExtraWinBangupStartTool',
                value (t) {
                    this.sounds.reelSpinLoop.fadeTo(1, 0), t.label !== 'totalWin' && this.sounds.extraWinWait.play(), !0 === this.sounds.fsLoop3.playing() && this.sounds.fsLoop3.fadeTo(0.5, 1e-5), this.sounds.fsLoop.volume() > 0 && this.sounds.fsLoop.fadeTo(0.5, 1e-4), !0 === this.sounds.fsLoop2.playing() && this.sounds.fsLoop2.fadeTo(0.5, 1e-4)
                }
            }, {
                key: '_onExtraWinLabelShowEndTool',
                value (t) {
                    this.sounds.extraWinWait.fadeTo(0.2, 0), t.label === 'megaWin' && !1 === this._features.extraWin.isSkipped && !1 === this.sounds.megaWinEnd.playing() && this.sounds.megaWinLoop.play().loop(!0), t.label === 'bigWin' && !1 === this._features.extraWin.isSkipped && !1 === this.sounds.bigWinEnd.playing() && this.sounds.bigWinLoop.play().loop(!0), t.label === 'superWin' && !1 === this._features.extraWin.isSkipped && !1 === this.sounds.superWinEnd.playing() && this.sounds.superWinLoop.play().loop(!0)
                }
            }, {
                key: '_onExpandingWildPopupsDeactivateStartTool',
                value (t) {
                    this.sounds.wildExpand.play()
                }
            }, {
                key: '_onExpandingWildPopupsActivateStartTool',
                value (t) {
                    this.sounds.wildExpandHit.play()
                }
            }, {
                key: '_onFreeSpinsAnticipationStartTool',
                value (t) {
                    !1 === this.sounds.anticipation.playing() && !1 === this.isInFreeSpins && (this.sounds.anticipation.play(), this.sounds.reelSpinLoop.fadeTo(0.1, 0)), !1 === this.sounds.anticipation.playing() && !0 === this.isInFreeSpins && this.sounds.anticipation.play(), !1 === this.sounds.anticipation.playing() && !0 === this.isInFreeSpins && this.sounds.fsLoop.volume() > 0 && this.sounds.fsLoop.fadeTo(0.1, 1e-5), !1 === this.sounds.anticipation.playing() && !0 === this.isInFreeSpins && this.sounds.fsLoop2.volume() > 0 && this.sounds.fsLoop2.fadeTo(0.1, 1e-5), !1 === this.sounds.anticipation.playing() && !0 === this.isInFreeSpins && this.sounds.fsLoop3.volume() > 0 && this.sounds.fsLoop3.fadeTo(0.1, 1e-5)
                }
            }, {
                key: '_onFreeSpinsAnticipationFinishTool',
                value (t) {
                    !0 === this.hasWin && !1 === this.isInFreeSpins && this.sounds.reelSpinLoop.fadeTo(0.5, 1), !1 === this.isInFreeSpins && this.sounds.anticipation.fadeOut(0.3, !0), !0 === this.isInFreeSpins && this.sounds.anticipation.fadeOut(0.3, !0), !0 === this.isInFreeSpins && this.sounds.fsLoop.volume() > 0 && this.sounds.fsLoop.fadeTo(0.5, 1), !0 === this.isInFreeSpins && this.sounds.fsLoop2.volume() > 0 && this.sounds.fsLoop2.fadeTo(0.5, 1), !0 === this.isInFreeSpins && this.sounds.fsLoop3.volume() > 0 && this.sounds.fsLoop3.fadeTo(0.5, 1)
                }
            }, {
                key: '_onReelMasterAnimationSpinningTool',
                value (t) {
                    this.sounds.reelSpinMechLoop.fadeTo(0.1, 1)
                }
            }, {
                key: '_onExtraWinBangupEndTool',
                value (t) {
                    this.sounds.megaWinLoop.fadeOut(0.1, !0), this.sounds.bigWinLoop.fadeOut(0.1, !0), this.sounds.superWinLoop.fadeOut(0.1, !0), this.sounds.extraWinWait.fadeOut(0.1, !0), t.label === 'bigWin' && this.sounds.bigWinEnd.play(), t.label === 'superWin' && this.sounds.superWinEnd.play(), t.label === 'megaWin' && this.sounds.megaWinEnd.play()
                }
            }, {
                key: '_onExtraWinLabelShowStartTool',
                value (t) {
                    this.sounds.extraWinWait.fadeTo(1, 0.4), t.label === 'bigWin' && this.sounds.bigWinStart.play(), t.label === 'superWin' && this.sounds.superWinStart.play(), t.label === 'megaWin' && this.sounds.megaWinStart.play(), t.label === 'totalWin' && (this.sounds.totalWin.play(), this.sounds.fsLoop.fadeOut(1.7, !0), this.sounds.fsLoop2.fadeOut(1.7, !0), this.sounds.fsLoop3.fadeOut(1.7, !0))
                }
            }, {
                key: '_onReelMasterSpinStartTool',
                value (t) {
                    !1 === this.isInFreeSpins && (this.sounds.reelSpinLoop.fadeTo(0.2, 1), this.sounds.backgrLoop.fadeTo(0.2, 0))
                }
            }, {
                key: '_onWinBarUpdateEndTool',
                value (t) {
                    !0 === this.isWinAboveStake && this.sounds.bangupLoop.fadeTo(0.1, 0), !0 === this.hasWin && !1 === this.isWinAboveStake && !1 === this.isInFreeSpins && !1 === this.hasFsWin && (this.sounds.reelSpinLoop.fadeTo(11, 0), this.sounds.backgrLoop.fadeTo(11, 1)), !0 === this.isWinAboveStake && !1 === this.hasExtraWin && !1 === this.isInFreeSpins && (this.sounds.backgrLoop.fadeTo(11, 1), this.sounds.reelSpinLoop.fadeTo(11, 0)), !0 === this.isWinAboveStake && !1 === this.hasExtraWin && !1 === t.isInstant && this.sounds.winNormal.play()
                }
            }, {
                key: '_onReelMasterSpinEndTool',
                value (t) {
                    this.sounds.reelSpinMechLoop.fadeTo(0.1, 0), !1 === this.hasWin && !1 === this.hasNextSpin && !1 === this.isInFreeSpins && this.sounds.reelSpinLoop.fadeTo(11, 0), !1 === this.hasWin && !1 === this.isInFreeSpins && this.sounds.backgrLoop.fadeTo(11, 1)
                }
            }, {
                key: '_onFreeSpinsPopupTilesTileAddTool',
                value (t) {
                    1 === t.total && this.sounds.fsHit1.play().limitInterval(0.1), t.total === 3 && this.sounds.fsHit3.play().limitInterval(0.1), t.total === 2 && this.sounds.fsHit2.play().limitInterval(0.1)
                }
            }, {
                key: '_onPaytableHideStartTool',
                value (t) {
                    this.sounds.playButton.play()
                }
            }, {
                key: '_onPaytableSlideScreenTool',
                value (t) {
                    this.sounds.payTablePages.play()
                }
            }, {
                key: '_onIntroShowStartTool',
                value (t) {
                    this.sounds.introEnterGame.play()
                }
            }]) && m(e.prototype, n), r && m(e, r), t
        }())
        let v = n('./src/core/server/GameData.js')
        let _ = n('./src/core/utils/CombinedTicker.js')

        function g(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function b(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? g(new Object(n), !0).forEach((e) => {
                            E(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : g(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function E(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function x(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return T(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return T(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function T(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function S(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function w(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        S(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        S(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function O(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const P = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.features = null, this.inRound = !1, this._cycleCounter = 1
            }
            let e, n, r, i, o, f, d, p
            return e = t, (n = [{
                key: 'state',
                get () {
                    return s.a.get(s.a.TYPES.STATE)
                }
            }, {
                key: 'init',
                value: (p = w(regeneratorRuntime.mark(function t(e, n) {
                    let r
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        r = e.game, this.features = new a(n, r), this.addFeatures({
                                            soundEngine: new y
                                        });
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return p.apply(this, arguments)
                })
            }, {
                key: 'ready',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                    this.setStake(this.features.stake.value, !1), this.onReady(t)
                }
            }, {
                key: 'spinStart',
                value: (d = w(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (!this.inRound) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return", console.warn("Attempting to spin during game round. Please investigate"));
                                    case 2:
                                        return s.a.set(s.a.TYPES.GAME_ENABLED, !1), s.a.set(s.a.TYPES.PLAY_START_TIME, _.a.elapsedTime), this.inRound = !0, this.reset(), t.abrupt("return", this.changeState(l.a.PLAY_START, e));
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return d.apply(this, arguments)
                })
            }, {
                key: 'changeState',
                value: (f = w(regeneratorRuntime.mark(function t(e) {
                    let n, r, i
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (s.a.set(s.a.TYPES.STATE, e), c.a.emit(c.a.events.STATE_CHANGED, {
                                                state: e
                                            }), e !== l.a.READY || s.a.get(s.a.TYPES.IN_FREE_SPINS) || s.a.get(s.a.TYPES.IN_RESPIN) || (this.inRound = !1), n = s.a.get(s.a.TYPES.MIN_ROUND_DURATION), !(e === l.a.FINISH && n > 0)) {
                                            t.next = 10;
                                            break
                                        }
                                        if (r = (_.a.elapsedTime - s.a.get(s.a.TYPES.PLAY_START_TIME)) / 1e3, !((i = n - r + .02) > 0)) {
                                            t.next = 10;
                                            break
                                        }
                                        return t.next = 10, Object(h.d)(i);
                                    case 10:
                                        console.log("# ".concat(e)), e === l.a.FINISH && (console.log("------------------------- Cycle: ".concat(this._cycleCounter, " --- RoundID: ").concat(s.a.get(s.a.TYPES.ROUND_ID))), this._cycleCounter++);
                                    case 12:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return f.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value (t) {}
            }, {
                key: 'reset',
                value () {}
            }, {
                key: 'addFeatures',
                value (t, e) {
                    this.features.add(t, e)
                }
            }, {
                key: 'setStake',
                value (t, e, n) {
                    var r = this.features.stake.setValue(t, e)
                    return this.reset(), this.features.statefulControl.setCurrBonusId(n), this._onStakeChange(t), this._showState(r.value), r
                }
            }, {
                key: '_showState',
                value (t) {
                    var e = this.features
                                var n = e.statefulControl
                                var r = e.reelMaster
                    if (n.enabled) {
                        var i = n.getData(t)
                        i.reelsBuffer.forEach((t, e) => {
                            var n = x(t, 2)[1];
                                        var i = r.reels[e]
                                    n.forEach(function(t, e) {
                                        return i.replaceTile(e, t, !0)
                                    })
                        }), this._onShowState(i)
                    }
                }
            }, {
                key: '_onShowState',
                value (t) {}
            }, {
                key: '_onStakeChange',
                value (t) {}
            }, {
                key: '_updateSpinData',
                value: (o = w(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (!e) {
                                            t.next = 5;
                                            break
                                        }
                                        u.a.update(e), s.a.set(s.a.TYPES.GAME_ENABLED, !0), t.next = 14;
                                        break;
                                    case 5:
                                        if (!u.a.hasNext) {
                                            t.next = 9;
                                            break
                                        }
                                        u.a.nextSpin(), t.next = 14;
                                        break;
                                    case 9:
                                        return t.t0 = u.a, t.next = 12, this._requestSpin();
                                    case 12:
                                        t.t1 = t.sent, t.t0.update.call(t.t0, t.t1);
                                    case 14:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_requestSpin',
                value: (i = w(regeneratorRuntime.mark(function t() {
                    let e, n, r
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = null, n = this.features.stake.value, t.prev = 2, t.next = 5, this.features.client.spin(n);
                                    case 5:
                                        e = t.sent, s.a.set(s.a.TYPES.GAME_ENABLED, !0), s.a.set(s.a.TYPES.SPIN_MODE, e.game.spinMode || ""), t.next = 14;
                                        break;
                                    case 10:
                                        t.prev = 10, t.t0 = t.catch(2), r = this.features.statefulControl.enabled ? this.features.statefulControl.getData(this.features.stake.value) : v.a.settings.game, e = {
                                            game: b({}, r),
                                            hasError: !0
                                        };
                                    case 14:
                                        return t.abrupt("return", e);
                                    case 15:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this, [
                        [2, 10]
                    ])
                })), function () {
                    return i.apply(this, arguments)
                })
            }]) && O(e.prototype, n), r && O(e, r), t
        }())
        let R = n('./node_modules/@games/dope/src/Dopamine.js')
        let A = n('./src/core/features/reels/engines/SpinningReelMaster.js')
        let I = n('./src/core/utils/misc.js')

        function C(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const k = {
            seconds: 3,
            thresholds: {
                low: 30,
                normal: 45
            },
            onChange() {}
        }
        const N = new (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.average = 60, this._ticker = null, this._counter = 0, this._history = null
            }
            let e, n, r
            return e = t, (n = [{
                key: 'trackAverage',
                value(t) {
                    let e = this
                                var n = new Object(I.b)(k, t)
                                var r = n.seconds
                                var i = n.thresholds
                                var o = n.onChange
                                var a = 60 * r
                    this._history = new Array(a), this._history.fill(this.average), this._ticker = _.a.Ticker, this._ticker.add(() => {
                        return e._onTick(i, a, o)
                    })
                }
            }, {
                key: '_onTick',
                value(t, e, n) {
                    let r = Math.floor(this._update(this._ticker.FPS, e))
                    if (this.average !== r) {
                        this.average = r
                        var i = t.low
                                    var o = t.normal
                                    var a = this._ticker.isLowFPS
                        this.average < i && (a = !0), this.average > o && (a = !1), this._ticker.isLowFPS !== a && (this._ticker.isLowFPS = a, n(a))
                    }
                }
            }, {
                key: '_update',
                value(t, e) {
                    return this._counter++, this._counter %= e, this._history[this._counter] = t, this._history.reduce((t, e) => {
                        return t + e
                    }, 0) / e
                }
            }]) && C(e.prototype, n), r && C(e, r), t
        }())()
        const M = n('./node_modules/ramda/es/flatten.js')
        const j = n('./node_modules/ramda/es/clone.js')
        const D = n('./src/utils/index.js')
        const L = n('./node_modules/@games/gsap/all.js')

        function F(t) {
            return (F = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function B(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || G(t, e) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function U(t) {
            return (function (t) {
                if (Array.isArray(t)) return X(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || G(t) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function G(t, e) {
            if (t) {
                if (typeof t == 'string') return X(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                return n === 'Object' && t.constructor && (n = t.constructor.name), n === 'Map' || n === 'Set' ? Array.from(t) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? X(t, e) : void 0
            }
        }

        function X(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function H(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function V(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? H(new Object(n), !0).forEach((e) => {
                            W(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : H(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function W(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function Y(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function z(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Y(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Y(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function q(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function K(t, e, n) {
            return e = $(e),
            (function (t, e) {
                if (e && (F(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], $(t).constructor)
                : e.apply(t, n)))
        }

        function Z(t, e, n) {
            return (Z = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = $(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function $(t) {
            return ($ = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function J(t, e) {
            return (J = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Q = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = K(this, e))._spinMode = 'Normal', t
            }
            let n, o, a, f, m, y, v, _
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && J(t, e)
            }(e, t)), n = e, (o = [{
                key: 'init',
                value: (_ = z(regeneratorRuntime.mark(function t(n, o, a) {
                    let s; let u; let c = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return Z($(e.prototype), "init", this).call(this, n, o, a), s = n.game, this.addFeatures({
                                        reelMaster: new A.a(V(V({}, s), {}, {
                                            config: p.a.reels
                                        })),
                                        throbber: new d.a.Throbber({
                                            animation: i.a.Throbber.throbber,
                                            config: p.a.throbber,
                                            container: o
                                        })
                                    }), this.addFeatures({
                                        paytable: new d.a.Paytable({
                                            animation: i.a.Paytable.paytableMc,
                                            onLoadStart: function() {
                                                c.features.throbber.activate()
                                            },
                                            onLoadEnd: function() {
                                                c.features.throbber.deactivate()
                                            },
                                            settings: s,
                                            config: p.a.paytable
                                        })
                                    }), p.a.hasPaytable && this.features.paytable.initDrag(), u = this.features.reelMaster, this.addFeatures({
                                        background: new d.a.SceneEffects({
                                            scenes: i.a.Background,
                                            name: "Background",
                                            config: p.a.sceneEffects
                                        }),
                                        foreground: new d.a.SceneEffects({
                                            scenes: i.a.Foreground,
                                            name: "Foreground",
                                            config: p.a.sceneEffects
                                        }),
                                        slotWays: new d.a.Cover({
                                            animation: i.a.SlotWays.slotWays
                                        }),
                                        intro: new d.a.Cover({
                                            animation: i.a.GameIntro.gameIntro
                                        }),
                                        logo: new d.a.Cover({
                                            animation: i.a.Logo.mainLogo
                                        }),
                                        headerBanners: new d.a.HeaderBanners({
                                            animation: i.a.HeaderBanners.headerBanners,
                                            config: p.a.headerBanners,
                                            lang: R.c.code
                                        }),
                                        statefulControl: new d.a.StatefulControl(n),
                                        centerCoins: new d.a.ParticlesContainer({
                                            source: i.a.CenterCoins.coin,
                                            guide: (new i.a.CenterCoins.emitterGuide).guide,
                                            config: p.a.centerWinCoins.coin
                                        }),
                                        centerBanknotes: new d.a.ParticlesContainer({
                                            source: i.a.SceneParticles.banknote,
                                            guide: (new i.a.CenterCoins.emitterGuide2).guide,
                                            config: p.a.centerWinCoins.banknote
                                        }),
                                        coins: new d.a.ParticlesContainer({
                                            source: i.a.SceneParticles.coin,
                                            guide: (new i.a.SceneParticles.emitterGuide2).guide,
                                            config: p.a.sceneParticles
                                        }),
                                        banknote: new d.a.ParticlesContainer({
                                            reelMaster: u,
                                            source: i.a.SceneParticles.banknote,
                                            guide: (new i.a.SceneParticles.emitterGuide3).guide,
                                            config: p.a.sceneParticles.banknote
                                        }),
                                        freeSpinsStatus: new d.a.VaryingFreeSpinsStatus({
                                            animation: i.a.FreeSpinsStatus.freeSpinsStatusMc,
                                            config: p.a.freeSpinsStatus
                                        }),
                                        freeSpinsStartScreen: new d.a.BonusSplashScreen({
                                            animation: i.a.SevensSplash.sevensSplash,
                                            config: p.a.bonusSplashScreen
                                        }),
                                        winTiles: new d.a.WinTiles({
                                            reelMaster: u,
                                            source: {
                                                cover: d.a.WinTile,
                                                animation: i.a.WinLines
                                            },
                                            config: p.a.wins.tiles,
                                            useRenderTexture: !0
                                        }),
                                        winLines: new d.a.WinLinesImage(s.lines, u.anim.markers.children, u.tileGuide, {
                                            config: p.a.wins.lines
                                        }),
                                        winBar: new d.a.WinBar,
                                        extraWinBgContainer: new r.Container,
                                        extraWinCoins: new d.a.ParticlesContainer({
                                            reelMaster: u,
                                            source: i.a.SceneParticles.coin,
                                            guide: (new i.a.SceneParticles.emitterGuide1).guide,
                                            config: p.a.sceneParticles.coin
                                        }),
                                        extraWinBanknotes: new d.a.ParticlesContainer({
                                            reelMaster: u,
                                            source: i.a.SceneParticles.banknote,
                                            guide: (new i.a.SceneParticles.emitterGuide2).guide,
                                            config: p.a.sceneParticles.banknote
                                        }),
                                        fsSpawnWildSymbols: new d.a.FreeSpinsSpawn({
                                            reelMaster: u,
                                            source: {
                                                animation: i.g.wildSymbol,
                                                animation2: i.g.expandingWildSymbol,
                                                cover: d.a.SpinePopupCover
                                            },
                                            config: p.a.freeSpinsSpawn,
                                            mask: u.featuresMask
                                        }),
                                        rumble: new d.a.Rumble({
                                            target: o,
                                            config: p.a.rumble
                                        }),
                                        fade: new d.a.Fade({
                                            animation: i.a.Fade.fade
                                        }),
                                        freeSpinsAnticipation: new d.a.Anticipation({
                                            name: "FreeSpinsAnticipation",
                                            source: {
                                                animation: i.a.Anticipation.anticipationFront
                                            },
                                            reelMaster: u,
                                            config: p.a.anticipation.freeSpins
                                        }),
                                        freeSpinsAnticipationBack: new d.a.Anticipation({
                                            name: "FreeSpinsAnticipationBack",
                                            source: {
                                                animation: i.a.Anticipation.anticipationBack
                                            },
                                            reelMaster: u,
                                            config: p.a.anticipation.freeSpins
                                        }),
                                        jackpotAnticipation: new d.a.Anticipation({
                                            name: "JackpotAnticipation",
                                            source: {
                                                animation: i.a.Anticipation.anticipationJackpotFront
                                            },
                                            reelMaster: u,
                                            config: p.a.anticipation.jackpot
                                        }),
                                        jackpotAnticipationBack: new d.a.Anticipation({
                                            name: "JackpotAnticipationBack",
                                            source: {
                                                animation: i.a.Anticipation.anticipationJackpotBack
                                            },
                                            reelMaster: u,
                                            config: p.a.anticipation.jackpot
                                        }),
                                        freeSpinsAnticipationMini: new d.a.MiniAnticipation({
                                            name: "FreeSpinsAnticipationMini",
                                            source: {
                                                animation: i.a.Anticipation.anticipationFront
                                            },
                                            reelMaster: u,
                                            config: p.a.anticipation.freeSpinsMini
                                        }),
                                        freeSpinsPassEffects: new d.a.PassingEffects({
                                            name: "FreeSpinsPassEffects",
                                            source: {
                                                animation: i.a.PassingEffects.passEffectTile13
                                            },
                                            config: p.a.freeSpinsPassEffects,
                                            reelMaster: u,
                                            mask: u.featuresMask
                                        }),
                                        wildPassEffects: new d.a.PassingEffects({
                                            name: "WildPassEffects",
                                            source: {
                                                animation: i.a.PassingEffects.passEffectTile11
                                            },
                                            config: p.a.wildPassEffects,
                                            reelMaster: u,
                                            mask: u.featuresMask
                                        }),
                                        wildPassEffectsSpecial: new d.a.PassingEffects({
                                            name: "WildPassEffectsSpecial",
                                            source: {
                                                animation: i.a.PassingEffects.wildPassEffectTile11
                                            },
                                            config: p.a.wildPassEffectsSpecial,
                                            reelMaster: u,
                                            mask: u.featuresMask
                                        }),
                                        expandPassEffects: new d.a.PassingEffects({
                                            name: "ExpandPassEffects",
                                            source: {
                                                animation: i.a.PassingEffects.wildPassEffectTile12
                                            },
                                            config: p.a.expandPassEffects,
                                            reelMaster: u,
                                            mask: u.featuresMask
                                        }),
                                        sceneCelebration: new d.a.Cover({
                                            animation: i.a.SceneCelebration.sceneCelebration
                                        }),
                                        sceneTransition: new d.a.Cover({
                                            animation: i.a.SceneTransition.sceneTransition
                                        }),
                                        sceneHit: new d.a.Cover({
                                            animation: i.a.SceneHit.sceneHit
                                        }),
                                        sceneHitBack: new d.a.Cover({
                                            animation: i.a.SceneHit.sceneHitBack
                                        }),
                                        slotPaytable: new d.a.SlotPaytable({
                                            animation: i.a.SlotPaytable.slotPaytableMc,
                                            settings: n.game.tiles,
                                            config: p.a.slotPaytable
                                        }),
                                        fatWildContainer: new r.Container,
                                        fatWild: new d.a.FatWildLocked({
                                            source: {
                                                animation: i.a.ExpandingWild.expandingWild
                                            },
                                            config: p.a.fatWild,
                                            reelMaster: u
                                        }),
                                        sceneIdleFront: new d.a.SceneIdle({
                                            animation: i.a.SceneIdle.sceneIdleFront,
                                            config: p.a.sceneIdles.normal.front
                                        }),
                                        sceneIdleBack: new d.a.SceneIdle({
                                            animation: i.a.SceneIdle.sceneIdleBack,
                                            config: p.a.sceneIdles.normal.back
                                        }),
                                        sceneIdleSpecialFront: new d.a.SceneIdle({
                                            animation: i.a.SceneIdle.sceneIdleSpecialFront,
                                            config: p.a.sceneIdles.special.front
                                        }),
                                        sceneIdleSpecialBack: new d.a.SceneIdle({
                                            animation: i.a.SceneIdle.sceneIdleSpecialBack,
                                            config: p.a.sceneIdles.special.back
                                        })
                                    }), this.addFeatures({
                                        jackpotPopupTiles: new d.a.PopupTiles({
                                            name: "JackpotPopupTiles",
                                            source: {
                                                animation: i.a.PopupTiles.popupTile100
                                            },
                                            reelMaster: u,
                                            config: p.a.jackpotPopupTiles,
                                            anticipations: [this.features.freeSpinsAnticipation]
                                        }),
                                        expandingWildPopups: new d.a.SpinePopupTiles({
                                            name: "expandingWildPopups",
                                            reelMaster: u,
                                            source: {
                                                animation: i.g.expandingWildSymbol,
                                                cover: d.a.SpinePopupCover
                                            },
                                            config: p.a.expandingWildPopups,
                                            anticipations: [this.features.freeSpinsAnticipation, this.features.jackpotAnticipation]
                                        }),
                                        freeSpinsPopupTiles: new d.a.FreeSpinsPopupTiles({
                                            name: "FreeSpinsPopupTiles",
                                            source: {
                                                animation: i.g.sevenTiles,
                                                cover: d.a.SpinePopupCover
                                            },
                                            reelMaster: u,
                                            config: p.a.freeSpinsPopupTiles,
                                            anticipations: [this.features.jackpotAnticipation]
                                        }),
                                        wildPopupTiles: new d.a.LockPopupTiles({
                                            name: "WildPopupTiles",
                                            source: {
                                                animation: i.g.wildSymbol,
                                                cover: d.a.SpinePopupCover
                                            },
                                            reelMaster: u,
                                            config: p.a.wildPopupTiles,
                                            anticipations: [this.features.freeSpinsAnticipation, this.features.jackpotAnticipation]
                                        }),
                                        wins: new d.a.WaysWins({
                                            reelMaster: u,
                                            tiles: this.features.winTiles,
                                            config: p.a.wins
                                        }),
                                        sceneController: new d.a.SceneController({
                                            config: p.a.sceneIdles,
                                            idles: {
                                                normal: [this.features.sceneIdleFront, this.features.sceneIdleBack],
                                                special: [this.features.sceneIdleSpecialFront, this.features.sceneIdleSpecialBack]
                                            },
                                            scenes: {
                                                background: this.features.background,
                                                foreground: this.features.foreground
                                            }
                                        }),
                                        extraWin: new d.a.ExtraWin({
                                            thresholds: s.extraWin,
                                            animation: i.a.ExtraWin.extraWin,
                                            bgAnim: i.a.ExtraWinBg,
                                            config: p.a.extraWin,
                                            counterConstructor: d.a.Counter,
                                            bgContainer: this.features.extraWinBgContainer
                                        }),
                                        inactiveWildsContainer: new r.Container,
                                        inactiveExpandingWildsContainer: new r.Container
                                    }), this.addFeatures({
                                        viewportTracker: new d.a.ViewportTracker({
                                            slotWays: this.features.slotWays,
                                            winBar: this.features.winBar,
                                            renderer: a,
                                            config: p.a.viewportTracker
                                        }),
                                        jackpots: new d.a.Jackpots({
                                            features: {
                                                jackpotPopupTiles: this.features.jackpotPopupTiles,
                                                wins: this.features.wins,
                                                rumble: this.features.rumble,
                                                fade: this.features.fade
                                            },
                                            config: p.a.jackpotWin
                                        })
                                    }), this.features.extraWin.addParticles({
                                        coins: [this.features.extraWinCoins],
                                        banknotes: [this.features.extraWinBanknotes]
                                    }), this.features.soundEngine.init(this.features), this.features.fatWildContainer.addChild(this.features.fatWild.inactiveContainer), this.features.fatWildContainer.mask = u.featuresMask, this.features.inactiveWildsContainer.addChild(this.features.wildPopupTiles.inactiveContainer), this.features.inactiveWildsContainer.mask = u.featuresMask, this.features.inactiveExpandingWildsContainer.addChild(this.features.expandingWildPopups.inactiveContainer), this.features.inactiveExpandingWildsContainer.mask = u.featuresMask, this._attachGameListeners(), this.features.arrange(["background", "sceneIdleSpecialBack", "sceneIdleBack", "sceneHitBack", "sceneTransition", "freeSpinsAnticipationBack", "jackpotAnticipationBack", "reelMaster", "foreground", "sceneIdleFront", "sceneIdleSpecialFront", "slotPaytable", "headerBanners", "inactiveWildsContainer", "fatWildContainer", "inactiveExpandingWildsContainer", "fade", "jackpotPopupTiles", "freeSpinsPopupTiles", "freeSpinsAnticipation", "jackpotAnticipation", "sceneHit", "sceneCelebration", "freeSpinsPassEffects", "wildPassEffects", "wildPassEffectsSpecial", "expandPassEffects", "wildPopupTiles", "expandingWildPopups", "fatWild", "fsSpawnWildSymbols", "freeSpinsStatus", "winLines", "winTiles", "logo", "slotWays", "freeSpinsStartScreen", "extraWinBgContainer", "extraWinBanknotes", "extraWinCoins", "extraWin", "centerBanknotes", "centerCoins", "coins", "banknote", "intro", "paytable", "throbber"]), t.next = 21, this.changeState(l.a.INIT);
                                case 21:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t, e, n) {
                    return _.apply(this, arguments)
                })
            }, {
                key: 'onReady',
                value: (v = z(regeneratorRuntime.mark(function t(e) {
                    let n = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    if (!e) {
                                        t.next = 5;
                                        break
                                    }
                                    return t.next = 3, this.changeState(l.a.READY);
                                case 3:
                                    t.next = 7;
                                    break;
                                case 5:
                                    return t.next = 7, this.changeState(l.a.INTRO);
                                case 7:
                                    c.a.emit(c.a.events.GAME_STARTED), N.trackAverage({
                                        onChange: function(t) {
                                            return n._onAverageFpsChange(t)
                                        }
                                    });
                                case 9:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return v.apply(this, arguments)
                })
            }, {
                key: 'changeState',
                value: (y = z(regeneratorRuntime.mark(function t(n, r) {
                    let i; let o; let a; let f; let m; let y; let v; let _; let g; let b; let E; let x; let T; let S; let w; let O; let P; let R; let A; let I; let C; let k; let N; let j; let L; let F; let B; let G; let X; let H; let V; let W; let Y; let z; let q; let K; let J; let Q; let tt; let et; let nt; let rt; let it; let ot; let at; let st; let ut; let ct; let lt; let ht; let ft; let dt; let pt; let mt; let yt; let vt; let _t; let gt; let bt; let Et; let xt; let Tt; let St; let wt; let Ot; let Pt; let Rt; let At; let It; let Ct; let kt; let Nt; let Mt; let jt; let Dt; let Lt; let Ft; let Bt; let Ut; let Gt; let Xt; let Ht; let Vt; let Wt; let Yt; let zt; let qt; let Kt; let Zt; let $t; let Jt; let Qt; let te; let ee; let ne; let re; let ie; let oe; let ae = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, Z($(e.prototype), "changeState", this).call(this, n);
                                case 2:
                                    o = null === (i = u.a.currentSpin) || void 0 === i ? void 0 : i.game, t.t0 = n, t.next = t.t0 === l.a.INTRO ? 6 : t.t0 === l.a.READY ? 18 : t.t0 === l.a.PLAY_START ? 21 : t.t0 === l.a.PLAY_DATA ? 45 : t.t0 === l.a.PLAY_STOP ? 47 : t.t0 === l.a.PLAY_END ? 52 : t.t0 === l.a.WILD_EXPAND ? 59 : t.t0 === l.a.WIN_LINES ? 102 : t.t0 === l.a.WIN_LINES_EW ? 126 : t.t0 === l.a.WIN_LINES_SUM ? 168 : t.t0 === l.a.WIN_LINES_NO_WIN ? 197 : t.t0 === l.a.FREE_SPINS_START ? 198 : t.t0 === l.a.FREE_SPINS_BONUS ? 241 : t.t0 === l.a.TOTAL_WIN ? 275 : t.t0 === l.a.JACKPOT_WIN ? 330 : t.t0 === l.a.FINISH ? 347 : 355;
                                    break;
                                case 6:
                                    return s.a.set(s.a.TYPES.GAME_ENABLED, !1), t.next = 9, this.features.intro.show();
                                case 9:
                                    return t.next = 11, this.features.intro.hide();
                                case 11:
                                    return this.features.sceneController.startIdles("normal"), this.features.slotPaytable.show(), this.features.logo.show(), this.features.slotWays.show(), this.features.remove(this.features.intro), s.a.set(s.a.TYPES.GAME_ENABLED, !0), t.abrupt("return", this.changeState(l.a.READY));
                                case 18:
                                    return this.features.freeSpinsPassEffects.disable(), s.a.get(s.a.TYPES.IN_FREE_SPINS) && (this.reset(), this.changeState(l.a.PLAY_START)), t.abrupt("return");
                                case 21:
                                    if (s.a.get(s.a.TYPES.AUTO_PLAY) && c.a.emit(c.a.events.AUTOPLAY_SPIN), this.features.wildPassEffectsSpecial.reset(), this.features.expandPassEffects.reset(), this.features.wildPassEffects.reset(), this.features.freeSpinsPassEffects.reset(), s.a.get(s.a.TYPES.IN_FREE_SPINS) || this.features.winBar.reset(), this.features.winBar.value || Object(h.d)(p.a.wins.delays.beforeHide).then((function() {
                                            ae.features.slotWays.skip(), ae.features.slotWays.show(), ae.features.slotWays.renderable = !0
                                        })), this._preConfigSpin(), this._preConfigMaxWildReels(), a = "WildSpins" === this._spinMode, f = "WinSpins" === this._spinMode, a ? (this.features.expandPassEffects.enable(), this.features.wildPassEffectsSpecial.enable()) : f && (this.features.wildPassEffects.enable(), this.features.expandPassEffects.enable()), this.features.freeSpinsPassEffects.enable(), m = this.features.fatWild.lockedReels, y = this._getWildLockedReel(), m.length && this.features.reelMaster.lockReels([].concat(U(m), U(y))), this.features.reelMaster.start(), s.a.get(s.a.TYPES.IN_FREE_SPINS) && (this.features.freeSpinsStatus.decrement(), c.a.emit(c.a.events.FEATURE_UPDATE, {
                                            featureType: "freeSpins",
                                            name: "freeSpins"
                                        })), null == o || !o.freeSpins) {
                                        t.next = 42;
                                        break
                                    }
                                    return t.next = 42, this.features.fsSpawnWildSymbols.activate();
                                case 42:
                                    return t.next = 44, this._updateSpinData(r);
                                case 44:
                                    return t.abrupt("return", this.changeState(l.a.PLAY_DATA));
                                case 45:
                                    return u.a.hasError || (v = o.spinMode, _ = o.lockedTiles, g = void 0 === _ ? [] : _, b = o.randomWilds, E = void 0 === b ? [] : b, x = "WildSpins" === v, T = g.filter((function(t) {
                                        return t.tileId === p.a.wildPopupTiles.tileId
                                    })), S = x ? "lock" : "popup", w = T.filter((function(t) {
                                        return !E.some((function(e) {
                                            return Object(D.c)(t, e)
                                        }))
                                    })), this.features.freeSpinsAnticipation.prepare(o.reelsBuffer), this.features.freeSpinsAnticipationBack.prepare(o.reelsBuffer), this.features.freeSpinsAnticipationMini.prepare(o.reelsBuffer), this.features.jackpotAnticipation.prepare(o.reelsBuffer), this.features.jackpotAnticipationBack.prepare(o.reelsBuffer), this.features.wildPopupTiles.skipTiles = w, this.features.wildPopupTiles.observeReels({
                                        attachToReels: !0,
                                        animLabel: S,
                                        isWildSpins: x
                                    }), x && this.features.wildPopupTiles.detach(w), this.features.freeSpinsPassEffects.prepare(o.reelsBuffer), this.features.freeSpinsPopupTiles.prepare(o.reelsBuffer), this.features.freeSpinsPopupTiles.observeReels({
                                        attachToReels: !0,
                                        animLabel: "popup"
                                    }), this.features.expandingWildPopups.observeReels({
                                        attachToReels: !0,
                                        animLabel: "popup"
                                    }), this.features.expandingWildPopups.skipTiles = T, this.features.jackpots.observeReels({
                                        attachToReels: !0
                                    })), t.abrupt("return", this.changeState(l.a.PLAY_STOP));
                                case 47:
                                    return O = o.reelsBuffer, P = this._getLockedBuffer(O.asMutable({
                                        deep: !0
                                    })), t.next = 51, this.features.reelMaster.stop(P);
                                case 51:
                                    return t.abrupt("return", this.changeState(l.a.PLAY_END));
                                case 52:
                                    if (!u.a.hasError) {
                                        t.next = 54;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.FINISH));
                                case 54:
                                    if (!s.a.get(s.a.TYPES.IN_FREE_SPINS)) {
                                        t.next = 56;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.WILD_EXPAND));
                                case 56:
                                    return u.a.hasWin && this.features.headerBanners.hide(), this._shouldShowAds() && this.features.headerBanners.displayRandom(), t.abrupt("return", this.changeState(l.a.WILD_EXPAND));
                                case 59:
                                    if (A = o.fatTiles, I = void 0 === A ? [] : A, C = o.spinMode, k = o.lockedTiles, N = void 0 === k ? [] : k, j = o.randomWilds, L = void 0 === j ? [] : j, F = o.expandingWilds, B = void 0 === F ? [] : F, G = "WildSpins" === C, X = (null === (R = u.a.main) || void 0 === R ? void 0 : R.game) || {}, H = X.freeSpins, W = (V = void 0 === H ? [] : H)[V.length - 1] === o, Y = !!I.length && !this.features.fatWild.allTiles.length, z = Y || this.features.fatWild.allTiles.some((function(t) {
                                            return I.some((function(e) {
                                                return !Object(D.c)(t, e)
                                            }))
                                        })), q = N.filter((function(t) {
                                            return t.tileId === p.a.wildPopupTiles.tileId
                                        })), K = N.filter((function(t) {
                                            return null == I ? void 0 : I.some((function(e) {
                                                return t.reel === e.reel
                                            }))
                                        })), J = s.a.get(s.a.TYPES.IN_FREE_SPINS), L.length && G && this.features.wildPopupTiles.detach(), N.length && G && L.length && (this.features.wildPopupTiles.setLockTiles(!0), this._replaceTilesUnder(q)), z) {
                                        t.next = 72;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.WIN_LINES));
                                case 72:
                                    if (this.features.expandingWildPopups.allTiles.length || J) {
                                        t.next = 79;
                                        break
                                    }
                                    return t.next = 75, Promise.all([this.features.wildPopupTiles.whenAllActive(), this.features.freeSpinsPopupTiles.whenAllActive()]);
                                case 75:
                                    return t.next = 77, this.features.expandingWildPopups.activate(B, {
                                        animLabel: "popup"
                                    });
                                case 77:
                                    t.next = 81;
                                    break;
                                case 79:
                                    return t.next = 81, Promise.all([this.features.expandingWildPopups.whenAllActive(), this.features.wildPopupTiles.whenAllActive(), this.features.freeSpinsPopupTiles.whenAllActive()]);
                                case 81:
                                    if (this.features.expandingWildPopups.deactivate(), !G || !K.length) {
                                        t.next = 87;
                                        break
                                    }
                                    return t.next = 85, Promise.all([this.features.wildPopupTiles.remove(K), this.features.fatWild.activate(I)]);
                                case 85:
                                    t.next = 89;
                                    break;
                                case 87:
                                    return t.next = 89, this.features.fatWild.activate(I);
                                case 89:
                                    if (G && !W) {
                                        t.next = 95;
                                        break
                                    }
                                    this.features.fatWild.allTiles.filter((function(t) {
                                        return t.isLocked
                                    })).forEach((function(t) {
                                        return t.anim.lockEffect.promises.gotoAndPlay("init")
                                    })), this.features.fatWild.attach(), t.next = 101;
                                    break;
                                case 95:
                                    return (Q = this.features.fatWild.allTiles.filter((function(t) {
                                        return !t.isLocked
                                    }))).forEach((function(t) {
                                        return t.anim.lockEffect.promises.gotoAndPlay("show")
                                    })), this.features.fatWild.setLockTiles(!0), t.next = 100, this.features.fatWild.play("lock", Q);
                                case 100:
                                    this.features.fatWild.play("loop", void 0, {
                                        repeat: -1
                                    });
                                case 101:
                                    return t.abrupt("return", this.changeState(l.a.WIN_LINES));
                                case 102:
                                    if (u.a.hasWin) {
                                        t.next = 104;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.WIN_LINES_NO_WIN));
                                case 104:
                                    return et = this.features.viewportTracker.orientation === this.features.viewportTracker.orientationTypes.LANDSCAPE, nt = o.fatTiles, rt = void 0 === nt ? [] : nt, it = o.randomWilds, ot = void 0 === it ? [] : it, at = o.lockedTiles, st = void 0 === at ? [] : at, ut = Object(M.a)(rt.map((function(t) {
                                        return Object(h.k)(t.height, (function(e) {
                                            return {
                                                reel: t.reel,
                                                index: e,
                                                tileId: t.tileId
                                            }
                                        }))
                                    }))), ct = null === (tt = o.activator) || void 0 === tt ? void 0 : tt.features.find((function(t) {
                                        return t.includes("FreeSpins")
                                    })), lt = [].concat(U(st), U(ot)).filter((function(t) {
                                        return t.tileId === p.a.wildPopupTiles.tileId
                                    })), t.next = 111, Promise.all([this.features.wildPopupTiles.whenAllActive(), this.features.jackpotPopupTiles.whenAllActive(), this.features.freeSpinsPopupTiles.whenAllActive()]);
                                case 111:
                                    return this.features.jackpotPopupTiles.remove(), et && this.features.slotWays.hide(), ct || this.features.freeSpinsPopupTiles.remove(), this.features.wins.setSpecialPositions(lt), this.features.wins.setSkippedPositions(ut), this.features.slotPaytable.selectTiles(o.winLines), this.features.fade.show(), ht = function(t) {
                                        return ae._onTilesShow(t)
                                    }, t.next = 121, Object(h.d)(p.a.wins.lines.delays.beforeShow);
                                case 121:
                                    return t.next = 123, this.features.wins.showAllWays(o.winLines, {
                                        onTilesShow: ht
                                    });
                                case 123:
                                    return t.next = 125, Object(h.d)(p.a.wins.lines.delays.afterShow);
                                case 125:
                                    return t.abrupt("return", this.changeState(l.a.WIN_LINES_EW));
                                case 126:
                                    if (ft = o.win.lines, dt = void 0 === ft ? 0 : ft, pt = o.stake, mt = o.winsMultipliers, this.features.extraWin.roundHasCelebrations = u.a.roundHasCelebrations(dt + this.features.winBar.value), u.a.hasExtraWin && this.features.extraWin.roundHasCelebrations) {
                                        t.next = 130;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.WIN_LINES_SUM));
                                case 130:
                                    if (yt = p.a.extraWin, vt = yt.showDelay, _t = yt.hideDelay, gt = this.features.extraWin.getTypeBasedOnMultiplier(mt.lines), bt = "WildSpins" === (null == o ? void 0 : o.spinMode), Et = bt ? "idleLock" : "idle", !o.winLines.length) {
                                        t.next = 149;
                                        break
                                    }
                                    return this.features.fade.show(), xt = function(t) {
                                        return ae._onTilesShow(t)
                                    }, t.next = 139, Object(h.d)(p.a.wins.lines.delays.beforeShow);
                                case 139:
                                    return t.next = 141, this.features.wins.showAllWays(o.winLines, {
                                        onTilesShow: xt
                                    });
                                case 141:
                                    return t.next = 143, this.features.wins.deactivate();
                                case 143:
                                    return t.next = 145, this.features.wins.showAllWays(o.winLines, {
                                        onTilesShow: xt
                                    });
                                case 145:
                                    this.features.wildPopupTiles.moveToInactive(), this.features.wildPopupTiles.play(Et), this.features.wildPopupTiles.skip(), this.features.wins.deactivate();
                                case 149:
                                    return this.features.fatWild.moveToInactive(), this.features.fade.show(), this.features.fatWild.play("init"), this.features.extraWin.roundHasCelebrations = u.a.roundHasCelebrations(dt + this.features.winBar.value), this.features.jackpotPopupTiles.remove(), t.next = 156, Object(h.d)(this.features.extraWin.getDelay(vt, d.a.ExtraWin.types.BIG_WIN));
                                case 156:
                                    return this.features.extraWin.activateParticles(), this.features.extraWin.playSum({
                                        value: pt,
                                        stake: pt,
                                        label: gt
                                    }), this.features.extraWin.showEwLabel(gt), t.next = 161, this.features.extraWin.bangup({
                                        from: pt,
                                        to: dt,
                                        stake: pt
                                    });
                                case 161:
                                    return t.next = 163, Object(h.d)(this.features.extraWin.getDelay(_t));
                                case 163:
                                    return this.features.extraWin.deactivateParticles(), this.features.wildPopupTiles.play(Et, void 0, {
                                        repeat: -1
                                    }), t.next = 167, this.features.extraWin.hide();
                                case 167:
                                    return t.abrupt("return", this.changeState(l.a.WIN_LINES_SUM));
                                case 168:
                                    if (u.a.hasWin) {
                                        t.next = 170;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.WIN_LINES_NO_WIN));
                                case 170:
                                    return Tt = o.win, St = Tt.lines, wt = Tt.multiplier, Ot = void 0 === wt ? 0 : wt, Pt = Tt.instantWin, Rt = void 0 === Pt ? 0 : Pt, At = o.stake, It = o.winLines, Ct = St + Ot + Rt, kt = s.a.get(s.a.TYPES.IN_FREE_SPINS), s.a.set(s.a.TYPES.RESULT_READY, !0), t.next = 176, Promise.all([this.features.jackpotPopupTiles.whenAllActive(), this.features.freeSpinsPopupTiles.whenAllActive()]);
                                case 176:
                                    return this.features.freeSpinsPopupTiles.remove(), this.features.jackpotPopupTiles.remove(), this.features.fatWild.play("init"), kt || this.features.wins.deactivate(), Nt = function(t) {
                                        return ae._onTilesShow(t)
                                    }, t.next = 183, Object(h.d)(p.a.wins.lines.delays.beforeShow);
                                case 183:
                                    if (this.features.wins.startLoop(It, {
                                            silent: !0,
                                            onTilesShow: Nt
                                        }), !(Ct > At) || u.a.hasExtraWin && this.features.extraWin.roundHasCelebrations) {
                                        t.next = 193;
                                        break
                                    }
                                    return this.features.centerCoins.activate(), this.features.centerBanknotes.activate(), t.next = 189, this.features.winBar.activate(Ct, At);
                                case 189:
                                    this.features.centerCoins.deactivate(), this.features.centerBanknotes.deactivate(), t.next = 194;
                                    break;
                                case 193:
                                    this.features.winBar.activate(Ct, At, !0);
                                case 194:
                                    return this.features.fatWild.play("loop", void 0, {
                                        repeat: -1
                                    }), s.a.set(s.a.TYPES.RESULT_READY, !1), t.abrupt("return", this.changeState(l.a.WIN_LINES_NO_WIN));
                                case 197:
                                    return t.abrupt("return", this.changeState(l.a.FREE_SPINS_START));
                                case 198:
                                    if (o.freeSpins && !s.a.get(s.a.TYPES.IN_FREE_SPINS)) {
                                        t.next = 200;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.FREE_SPINS_BONUS));
                                case 200:
                                    return Mt = o.freeSpins, jt = o.initialSpins, Dt = jt || Mt.length, Lt = p.a.freeSpinsStatus.delays, Ft = this._getActivatorMode(o), Bt = this.features.viewportTracker.orientation === this.features.viewportTracker.orientationTypes.LANDSCAPE, this.features.wins.deactivate(), this.features.wildPopupTiles.moveToInactive(), this.features.fatWild.moveToInactive(), t.next = 210, this.features.freeSpinsPopupTiles.whenAllActive();
                                case 210:
                                    return this._spinMode = "FreeSpins", Bt && this.features.wins.value && this.features.slotWays.hide(), this.features.fade.hide(), s.a.set(s.a.TYPES.IS_WHOLE_GAME_STAGE_USED, !0), this.features.wins.deactivate(), this.features.wildPopupTiles.remove(), this.features.freeSpinsPopupTiles.remove(), this.features.jackpotPopupTiles.remove(), this.features.fatWild.play("init"), t.next = 221, this.features.freeSpinsStartScreen.show({
                                        mode: "freeSpins"
                                    });
                                case 221:
                                    return t.next = 223, this.features.freeSpinsStartScreen.showStart();
                                case 223:
                                    return c.a.emit(c.a.events.FEATURE_START, {
                                        featureType: "freeSpins",
                                        name: "freeSpins"
                                    }), this.features.freeSpinsStartScreen.start(), this.features.freeSpinsStartScreen.hide(), t.next = 228, this.features.sceneTransition.show();
                                case 228:
                                    return this.features.sceneTransition.play("swap"), this.features.logo.hide(), this.features.freeSpinsStatus.activate({
                                        spins: Dt,
                                        mode: p.a.bonusSplashScreen.idToLabel[Ft]
                                    }), this.features.slotPaytable.changeScene(Ft), this.features.sceneController.changeScene("freeSpins"), "wildSpins" === p.a.bonusSplashScreen.idToLabel[Ft] && (this.features.sceneController.stopIdles(), this.features.sceneController.startIdles("special")), t.next = 236, this.features.freeSpinsStartScreen.hide();
                                case 236:
                                    return s.a.set(s.a.TYPES.IN_FREE_SPINS, !0), s.a.set(s.a.TYPES.IS_WHOLE_GAME_STAGE_USED, !1), t.next = 240, Object(h.d)(Lt.afterUpdate);
                                case 240:
                                    return t.abrupt("return", this.changeState(l.a.FREE_SPINS_BONUS));
                                case 241:
                                    if (Ut = "Normal" !== o.spinMode && o.initialSpins, Gt = o.additionalSpins || o.bonusSpins || Ut, u.a.hasNext && Gt) {
                                        t.next = 245;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.TOTAL_WIN));
                                case 245:
                                    return Xt = o.activator.features.find((function(t) {
                                        return t.includes("Spins")
                                    })), Ht = Object(D.d)(Xt), Vt = this._getActivatorMode(o), Wt = "wildSpins" === Ht, Yt = p.a.freeSpinsStatus, zt = Yt.counter, qt = Yt.delays, Kt = Wt ? "special" : "normal", this._spinMode = Xt, this.features.wins.deactivate(), this.features.jackpotPopupTiles.remove(), this.features.wins.deactivate(), t.next = 257, this.features.freeSpinsPopupTiles.whenAllActive();
                                case 257:
                                    return this.features.freeSpinsPopupTiles.remove(), t.next = 260, this.features.freeSpinsStartScreen.show({
                                        mode: Ht
                                    });
                                case 260:
                                    return t.next = 262, this.features.freeSpinsStartScreen.showStart();
                                case 262:
                                    return c.a.emit(c.a.events.FEATURE_START, {
                                        featureType: Ht,
                                        name: "freeSpins"
                                    }), t.next = 265, this.features.freeSpinsStartScreen.start();
                                case 265:
                                    return this.features.sceneController.changeScene(Ht), this.features.sceneController.stopIdles(), this.features.sceneController.startIdles(Kt), this.features.fade.hide(), t.next = 271, Promise.all([this.features.freeSpinsStartScreen.hide(), this.features.sceneTransition.show(), this.features.sceneTransition.play("swap"), this.features.freeSpinsStatus.update({
                                        spins: Gt,
                                        duration: zt.bangup.duration,
                                        mode: Ht
                                    })]);
                                case 271:
                                    return this.features.slotPaytable.changeScene(Vt), t.next = 274, Object(h.d)(qt.afterUpdate);
                                case 274:
                                    return t.abrupt("return", this.changeState(l.a.TOTAL_WIN));
                                case 275:
                                    if (s.a.get(s.a.TYPES.IN_FREE_SPINS) && !u.a.hasNext) {
                                        t.next = 277;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.JACKPOT_WIN));
                                case 277:
                                    return $t = null === (Zt = u.a.currentSpin) || void 0 === Zt ? void 0 : Zt.game, Jt = "WildSpins" === (null == $t ? void 0 : $t.spinMode), Qt = Jt ? "idleLock" : "idle", te = u.a.main.game.win.total, ee = p.a.extraWin, ne = ee.showDelay, re = ee.hideDelay, this.features.extraWin.roundHasCelebrations = u.a.roundHasCelebrations(te), t.next = 285, Object(h.d)(this.features.extraWin.getDelay(ne, d.a.ExtraWin.types.TOTAL_WIN));
                                case 285:
                                    return s.a.set(s.a.TYPES.IN_FREE_SPINS, !1), this.features.wildPopupTiles.setSkippedPositions([]), this.features.wildPassEffectsSpecial.disable(), this.features.expandPassEffects.disable(), this.features.wildPassEffects.disable(), this.features.wins.deactivate(), this.features.winBar.reset(), this.features.fatWild.moveToInactive(), this.features.reelMaster.unlockReels([].concat(U(this.features.fatWild.lockedReels), U(this._getWildLockedReel()))), this.features.reelMaster.controller.reels.forEach((function(t) {
                                        return t._reset()
                                    })), this.features.fatWild.setLockTiles(!1), this.features.wildPopupTiles.setLockTiles(!1), this.features.fsSpawnWildSymbols.remove(), c.a.emit(c.a.events.FEATURE_END, {
                                        featureType: "freeSpins",
                                        name: "freeSpins"
                                    }), s.a.set(s.a.TYPES.IS_WHOLE_GAME_STAGE_USED, !0), te > $t.stake && this.features.extraWin.activateParticles(), this.features.extraWin.showBackground(d.a.ExtraWin.types.TOTAL_WIN), this.features.extraWin.showLabel(d.a.ExtraWin.types.TOTAL_WIN), this.features.extraWin.showLabelSum(d.a.ExtraWin.types.TOTAL_WIN), this.features.extraWin.playSum({
                                        value: te,
                                        anim: "showBottom"
                                    }), this.features.extraWin.stopPulse(), t.next = 308, this.features.extraWin.bangup({
                                        from: te,
                                        to: te,
                                        stake: $t.stake,
                                        duration: p.a.extraWin.totalWinDuration
                                    });
                                case 308:
                                    return t.next = 310, Object(h.d)(this.features.extraWin.getDelay(re));
                                case 310:
                                    return this.features.wildPopupTiles.play(Qt, void 0, {
                                        repeat: -1
                                    }), this.features.wildPopupTiles.moveToInactive(), this.features.extraWin.deactivateParticles(), t.next = 315, this.features.extraWin.hide();
                                case 315:
                                    return t.next = 317, this.features.freeSpinsStatus.deactivate();
                                case 317:
                                    return this._spinMode = "Normal", this.features.wildPopupTiles.attach(), this.features.background.change("normal"), this.features.foreground.change("normal"), u.a.hasJackpotWin || this.features.fade.hide(), this.features.slotPaytable.reset(!1), this.features.fatWild.attach(), this.features.logo.show(), this.features.winBar.set(te, 0, !0), this.features.viewportTracker.orientation === this.features.viewportTracker.orientationTypes.LANDSCAPE && this.features.slotWays.hide(), s.a.set(s.a.TYPES.IS_WHOLE_GAME_STAGE_USED, !1), t.abrupt("return", this.changeState(l.a.JACKPOT_WIN));
                                case 330:
                                    if (u.a.hasJackpotWin && !s.a.get(s.a.TYPES.IN_FREE_SPINS)) {
                                        t.next = 332;
                                        break
                                    }
                                    return t.abrupt("return", this.changeState(l.a.FINISH));
                                case 332:
                                    return ie = u.a.main.game, this.features.wins.deactivate(), this.features.freeSpinsPopupTiles.remove(), this.features.wildPopupTiles.remove(), this.features.fatWild.moveToInactive(), this.features.expandingWildPopups.moveToInactive(), this._reorderElements(this.features.fatWild, this.features.jackpotPopupTiles), this.features.fade.show(), t.next = 342, this.features.jackpots.activate(ie.jackpotTiles);
                                case 342:
                                    return t.next = 344, this.features.jackpotPopupTiles.whenAllActive();
                                case 344:
                                    return t.next = 346, this.features.jackpotPopupTiles.play("win");
                                case 346:
                                    return t.abrupt("return", this.changeState(l.a.FINISH));
                                case 347:
                                    if (this.features.statefulControl.updateData(this.features.stake.value), this.features.jackpots.reset(), this.hasBonus(o) && c.a.emit(c.a.events.AUTOPLAY_BONUS), !s.a.get(s.a.TYPES.IN_FREE_SPINS) && !s.a.get(s.a.TYPES.AUTO_PLAY)) {
                                        t.next = 354;
                                        break
                                    }
                                    return oe = u.a.hasWin ? p.a.autoplay.nextSpinDelay.win : p.a.autoplay.nextSpinDelay.noWin, t.next = 354, Object(h.d)(oe);
                                case 354:
                                    return t.abrupt("return", this.changeState(l.a.READY));
                                case 355:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t, e) {
                    return y.apply(this, arguments)
                })
            }, {
                key: 'hasBonus',
                value() {
                    let t = u.a.currentSpin.game
                    return (t == null ? void 0 : t.freeSpins) || s.a.get(s.a.TYPES.IN_FREE_SPINS)
                }
            }, {
                key: 'reset',
                value() {
                    let t, n
                    Z($(e.prototype), 'reset', this).call(this)
                    var r = s.a.get(s.a.TYPES.IN_FREE_SPINS)
                            var i = ((t = u.a.currentSpin) === null || void 0 === t || (n = t.game) === null || void 0 === n ? void 0 : n.spinMode) === 'WildSpins' ? 'idleLock' : 'idle'
                    this.features.slotPaytable.reset(r), this.features.wildPassEffectsSpecial.disable(), this.features.wildPassEffects.disable(), this.features.expandPassEffects.disable(), this.features.freeSpinsPopupTiles.remove(), this.features.jackpotPopupTiles.remove(), this.features.fatWild.moveToInactive(), this.features.expandingWildPopups.attach(), this.features.expandingWildPopups.moveToInactive(), this.features.wins.deactivate(), this._reorderElements(this.features.wildPopupTiles, this.features.expandPassEffects), this.features.wildPopupTiles.allTiles.filter((t) => {
                        return t.isLocked
                    }).length || this.features.wildPopupTiles.moveToInactive(), this.features.fade.hide(), this.features.wildPopupTiles.play(i, void 0, {
                        repeat: -1
                    })
                }
            }, {
                key: 'skip',
                value: (m = z(regeneratorRuntime.mark(function t(n) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    Z($(e.prototype), "skip", this).call(this, n), t.t0 = this.state, t.next = t.t0 === l.a.PLAY_STOP ? 4 : t.t0 === l.a.WIN_LINES_SUM ? 6 : t.t0 === l.a.FREE_SPINS_START ? 8 : t.t0 === l.a.FREE_SPINS_BONUS ? 10 : t.t0 === l.a.JACKPOT_WIN || t.t0 === l.a.WIN_LINES_EW || t.t0 === l.a.TOTAL_WIN ? 12 : 14;
                                    break;
                                case 4:
                                    return this.features.reelMaster.stopInstant(u.a.currentSpin.game.reelsBuffer.asMutable({
                                        deep: !0
                                    })), t.abrupt("break", 14);
                                case 6:
                                    return this.features.winBar.skip(), t.abrupt("break", 14);
                                case 8:
                                    return this.features.freeSpinsStartScreen.skip(), t.abrupt("break", 14);
                                case 10:
                                    return this.features.freeSpinsStatus.skip(), t.abrupt("break", 14);
                                case 12:
                                    return this.features.extraWin.skip(), t.abrupt("break", 14);
                                case 14:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return m.apply(this, arguments)
                })
            }, {
                key: '_preConfigSpin',
                value() {
                    let t = this
                    s.a.get(s.a.TYPES.IN_FREE_SPINS) && this.features.reelMaster.reels.forEach((e) => {
                        var n = e.index;
                                var r = t.features.reelMaster.getReelConfig(n).distance;
                                var i = p.a.freeSpins['preConf'.concat(t._spinMode)].spin
                            t.features.reelMaster.preConfigStart(V(V({}, i.start), {}, {
                            delay: n * (i.start.delay || p.a.reels.spin.delay.atStart)
                        }), n), t.features.reelMaster.preConfigStop({
                            distance: r + n * i.stop.extraDistance
                        }, n)
                    })
                }
            }, {
                key: '_onTilesShow',
                value: (f = z(regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; let o; let a; let s; let c; let l; let h; let f = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    r = e.skipped, i = e.positions, o = null === (n = u.a.currentSpin) || void 0 === n ? void 0 : n.game, a = o.spinMode, s = "WildSpins" === a, c = this.features.fatWild.allTiles.filter((function(t) {
                                        return r.some((function(e) {
                                            return Object(D.c)(t, e)
                                        }))
                                    })), l = i.filter((function(t) {
                                        return t.tileId === p.a.wildPassEffects.tileId
                                    })), this.features.fatWild.moveToInactive(), this.features.wildPopupTiles.moveToInactive(), c.length && (this.features.fatWild.moveToActive(c), this.features.fatWild.play("win", c)), l.length && (h = s ? "wildWinLock" : "wildWin", this._reorderElements(this.features.wildPopupTiles, this.features.slotWays), this.features.wildPopupTiles.moveToActive(l), l.some((function(t) {
                                        return !f.features.wildPopupTiles.allTiles.some((function(e) {
                                            return Object(D.c)(t, e)
                                        }))
                                    })) ? (this.features.wildPopupTiles.activate(l, {
                                        animLabel: h,
                                        tileId: p.a.wildPassEffects.tileId
                                    }), s || this.features.wildPopupTiles.attach()) : this.features.wildPopupTiles.play(h, l));
                                case 10:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return f.apply(this, arguments)
                })
            }, {
                key: '_shouldShowAds',
                value() {
                    return this.features.headerBanners.getChance() && !u.a.hasWin && !u.a.hasJackpotWin && !this.hasBonus()
                }
            }, {
                key: '_onShowState',
                value(t) {
                    t.jackpotTiles && this.features.jackpotPopupTiles.activate(t.jackpotTiles)
                }
            }, {
                key: '_onStakeChange',
                value(t) {
                    this.features.winBar.reset()
                }
            }, {
                key: '_onAverageFpsChange',
                value(t) {} //* ***!IMPORTANT!****
            }, {
                key: '_attachGameListeners',
                value() {
                    let t = this
                    this.features.freeSpinsAnticipation.on(d.a.Anticipation.events.START, (e) => {
                        var n = e.reelIndex
                            t.features.fade.show({
                            reelIndex: n - 1
                        }), t.features.wildPopupTiles.moveToInactive(), t.features.expandingWildPopups.moveToInactive(), t.features.wildPopupTiles.skip(), t.features.expandingWildPopups.skip(), c.a.emit(c.a.events.FEATURE_START, {
                            featureType: 'anticipation',
                            name: 'freeSpinsAnticipation'
                        })
                    }), this.features.freeSpinsAnticipation.on(d.a.Anticipation.events.FINISH, () => {
                        var e; var n = (e = u.a.currentSpin) === null || void 0 === e ? void 0 : e.game
                            t.features.fade.hide(), n.freeSpins || t.features.wildPopupTiles.moveToActive(), t.features.expandingWildPopups.moveToActive(), c.a.emit(c.a.events.FEATURE_END, {
                            featureType: 'anticipation',
                            name: 'freeSpinsAnticipation'
                        })
                    }), this.features.jackpotAnticipation.on(d.a.Anticipation.events.START, (e) => {
                        var n = e.reelIndex
                            t.features.fade.show({
                            reelIndex: n - 1
                        }), t.features.wildPopupTiles.moveToInactive(), t.features.expandingWildPopups.moveToInactive(), t.features.wildPopupTiles.play('popup'), t.features.expandingWildPopups.play('popup'), t.features.wildPopupTiles.skip(), t.features.expandingWildPopups.skip(), c.a.emit(c.a.events.FEATURE_START, {
                            featureType: 'anticipation',
                            name: 'jackpotAnticipation'
                        })
                    }), this.features.reelMaster.on(d.a.ReelMaster.events.ANIMATION_SPIN_ENDING, (e) => {
                        e.index
                            var n; var r = ((n = u.a.currentSpin) === null || void 0 === n ? void 0 : n.game).lockedTiles;
                        (void 0 === r ? [] : r).filter(function(t) {
                                return t.tileId === p.a.wildPopupTiles.tileId
                            }).length && t._replaceTilesUnder(t.features.wildPopupTiles.allTiles)
                    }), this.features.jackpotAnticipation.on(d.a.Anticipation.events.FINISH, () => {
                        t.features.fade.hide(), t.features.wildPopupTiles.moveToActive(), t.features.expandingWildPopups.moveToActive(), c.a.emit(c.a.events.FEATURE_END, {
                            featureType: 'anticipation',
                            name: 'jackpotAnticipation'
                        })
                    }), this.features.freeSpinsPopupTiles.on(d.a.PopupTiles.events.TILE_ADD, (e) => {
                        var n = e.total
                            e.reel, e.index, 'init' !== e.animLabel && n >= p.a.freeSpinsPopupTiles.minTiles && (t.features.sceneHit.show({
                            removeAtEnd: !0
                        }), t.features.sceneHitBack.show({
                            removeAtEnd: !0
                        }), n >= p.a.freeSpinsPopupTiles.maxTiles && t.features.sceneCelebration.show({
                            removeAtEnd: !0
                        }))
                    })
                }
            }, {
                key: '_getWildLockedReel',
                value() {
                    let t = this
                    return this.features.reelMaster.reels.reduce((e, n) => {
                        return t.features.wildPopupTiles.allTiles.filter(function(t) {
                                return t.reel === n.index
                            }).length === p.a.reels.tiles.visible && e.push(n.index), e
                    }, [])
                }
            }, {
                key: '_getLockedBuffer',
                value(t) {
                    let e = [].concat(U(this.features.fatWild.lockedReels), U(this._getWildLockedReel()))
                    if (!e.length) return t
                    var n = this.features.reelMaster.getResultData().map((t) => {
                        return t.map(function(t) {
                                return t.id
                            })
                    })
                    return t.map((t, r) => {
                        var i = B(t, 3);
                                var o = i[0];
                                var a = i[1];
                                var s = i[2]
                            return [o, e.includes(r) ? n[r] : a, s]
                    })
                }
            }, {
                key: '_preConfigMaxWildReels',
                value() {
                    let t = this
                    if (this._spinMode === 'WildSpins') {
                        let e = this.features.reelMaster
                                var n = e.reels.map(function(t) {
                                    return Object(j.a)(e.getReelConfig(t.index))
                                });
                        var r = 0
                        e.reels.forEach((i) => {
                            var o = t._hasMaxWildsOnReel(i.index + 1);
                                    var a = i.index === n.length - 1 && o ? r - 1 : r;
                                    var s = n[a < 0 ? 0 : a]
                                e.preConfigStart(V({}, s), i.index), e.preConfigStop(V({}, s), i.index), o || ++r
                        })
                    }
                }
            }, {
                key: '_hasMaxWildsOnReel',
                value(t) {
                    let e = this.features.wildPopupTiles.allTiles.filter((e) => {
                        return e.reel === t && e.isLocked
                    }).length === p.a.reels.tiles.visible
                            var n = !!this.features.fatWild.allTiles.filter((e) => {
                        return e.reel === t && e.isLocked
                    }).length
                    return e || n
                }
            }, {
                key: '_replaceTilesUnder',
                value(t) {
                    let e = this
                    t.forEach((t) => {
                        return e.features.reelMaster.replaceTile(t.index, 0, t.reel)
                    })
                }
            }, {
                key: '_getActivatorMode',
                value(t) {
                    if (t == null || !t.activator) return null
                    var e = t.activator.features.find((t) => {
                        return t.includes("Mode")
                    })
                    return Number.parseInt(e.split('_')[1])
                }
            }, {
                key: '_changeSlotComponentsAlpha',
                value() {
                    let t = this
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                            var n = e.alpha
                            var r = void 0 === n ? 1 : n
                            var i = e.duration
                            var o = void 0 === i ? p.a.alphaTransitions.duration : i
                            var a = e.delay
                            var s = void 0 === a ? 0 : a
                            var u = e.featureList
                            var c = void 0 === u ? p.a.alphaTransitions.default : u
                            var l = c.filter(function(e) {
                                return t.features[e]
                            });
                    var h = l.map((e) => {
                        return t.features[e]
                    })
                    return L.a.to(h, {
                        alpha: r,
                        delay: s,
                        duration: o,
                        ease: 'none'
                    })
                }
            }, {
                key: '_reorderElements',
                value(t, e) {
                    let n = this;
                    [].concat(t).forEach((t) => {
                        var r = n.features.container.featuresInner || n.features.container;
                                var i = r.children.indexOf(t);
                                var o = Number.isInteger(e) ? e : r.children.indexOf(e)
                            if (i !== o) {
                            var a = i < o ? o - 1 : o
                                r.addChildAt(t, a)
                        }
                    })
                }
            }]) && q(n.prototype, o), a && q(n, a), e
        }(P))

        function tt(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const et = (function () {
            function t(e) {
                let n = e.defaultIndex
                var r = e.lastIndex
                var i = e.types
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this._index = typeof r == 'number' ? r : n, this._types = i.map((t) => {
                    return Number.parseFloat(t)
                }), this._value = this._types[this._index]
            }
            let e, n, r
            return e = t, (n = [{
                key: 'setValue',
                value (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                    return e || this._types.includes(t) ? (this._index = this._types.indexOf(t), this._value = t, {
                        value: t,
                        index: this._index,
                        types: this._types
                    })
                        : console.error('Stake \''.concat(t, '\' not in allowed stakes: ').concat(this._stakes))
                }
            }, {
                key: 'getInfo',
                value () {
                    return {
                        types: this._types,
                        selected: {
                            index: this._index,
                            value: this._value
                        }
                    }
                }
            }, {
                key: 'value',
                get () {
                    return this._value
                }
            }]) && tt(e.prototype, n), r && tt(e, r), t
        }())
        let nt = n('./src/core/loader/AssetCache.js')
        n('./src/core/config/index.js')

        function rt(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function it(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const ot = new (function () {
            function t() {
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), t.instance || (t.instance = this, this._renderer = null, this._camera = null), t.instance
            }
            let e, n, r, i, o
            return e = t, (n = [{
                key: 'init',
                value(t, e) {
                    this._renderer = t, this._camera = e
                }
            }, {
                key: 'changeBaseSize',
                value: (i = regeneratorRuntime.mark(function t(e, n, r) {
                    let i, o, a, s, u, l, h
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return i = e.width, o = e.height, a = n.scale, s = n.offsetX, u = n.offsetY, l = r.ease, h = r.duration, c.a.emit(c.a.events.CHANGE_BASE_SIZE), this._camera.origin = {
                                    width: i,
                                    height: o
                                }, this._camera.change({
                                    scale: a,
                                    offsetX: s,
                                    offsetY: u,
                                    ease: l,
                                    duration: h
                                }), t.next = 8, this._renderer.changeBaseSize({
                                    width: i,
                                    height: o,
                                    ease: l,
                                    duration: h
                                })
                                case 8:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                }), o = function () {
                    const t = this
                    let e = arguments
                    return new Promise((n, r) => {
                        const o = i.apply(t, e)

                        function a(t) {
                            rt(o, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            rt(o, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function (t, e, n) {
                    return o.apply(this, arguments)
                })
            }]) && it(e.prototype, n), r && it(e, r), t
        }())()

        function at(t) {
            return (at = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function st(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function ut(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        st(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        st(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function ct(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function lt(t, e, n) {
            return e = ht(e),
            (function (t, e) {
                if (e && (at(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], ht(t).constructor)
                : e.apply(t, n)))
        }

        function ht(t) {
            return (ht = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ft(t, e) {
            return (ft = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        var dt = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = lt(this, e)).name = 'game', t.scenario = new Q(), t.preSpinHandler = null, t._started = !1, t
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ft(t, e)
            }(e, t)), n = e, (r = [{
                key: 'init',
                value: (a = ut(regeneratorRuntime.mark(function t(e, n, r) {
                    let i, o
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return i = new et(n.user.stakes), o = (new nt.a.Game.Game()).features, this._overrideConfig(n), this.addChild(o), t.next = 6, this.scenario.init(n, o, r)
                                case 6:
                                ot.init(r, this.scenario.features.camera), this.scenario.addFeatures({
                                    stake: i,
                                    client: e
                                })
                                case 8:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t, e, n) {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'start',
                value(t) {
                    this._started || (this.scenario.ready(t), this._started = !0)
                }
            }, {
                key: 'showPaytable',
                value() {
                    const t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                    if (s.a.get(s.a.TYPES.PAYTABLE) || s.a.get(s.a.TYPES.STATE) !== l.a.READY && s.a.get(s.a.TYPES.STATE) !== l.a.INIT || s.a.get(s.a.TYPES.IN_FREE_SPINS) || s.a.get(s.a.TYPES.AUTO_PLAY)) return console.warn('Nope, try again later')
                    this.scenario.features.paytable.setStake(this.scenario.features.stake.value), this.scenario.features.paytable.show(t)
                }
            }, {
                key: 'hidePaytable',
                value(t) {
                    this.scenario.features.paytable.isLoading || this.scenario.features.paytable.hide(t)
                }
            }, {
                key: 'setPaytableIndex',
                value(t) {
                    return this.scenario.features.paytable.slideTo(t)
                }
            }, {
                key: 'attachPreSpinHandler',
                value(t) {
                    typeof t == 'function' ? this.preSpinHandler = t : console.error('attachPreSpinHandler: supplied handler is not a function')
                }
            }, {
                key: 'spinStart',
                value: (o = ut(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, this._preSpin()
                                case 2:
                                return t.next = 4, this.scenario.spinStart(e)
                                case 4:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'ready',
                value(t) {
                    if (t) return this.start(t)
                    p.a.paytableOnLoad ? this.showPaytable(!0) : s.a.set(s.a.TYPES.START_SCREEN, !0)
                }
            }, {
                key: 'setStake',
                value(t, e, n) {
                    return this.scenario.setStake(t, e, n)
                }
            }, {
                key: 'getStakes',
                value() {
                    return this.scenario.features.stake.getInfo()
                }
            }, {
                key: 'paytableToggle',
                value(t) {
                    t ? this.hidePaytable() : this.showPaytable()
                }
            }, {
                key: 'skip',
                value(t) {
                    this.scenario.skip(t)
                }
            }, {
                key: 'autoPlayStart',
                value() {
                    s.a.set(s.a.TYPES.AUTO_PLAY, !0)
                }
            }, {
                key: 'autoPlayStop',
                value() {
                    s.a.set(s.a.TYPES.AUTO_PLAY, !1)
                }
            }, {
                key: 'resumeJackpot',
                value() {
                    const t = this.scenario.features.jackpots
                    t && t.resume()
                }
            }, {
                key: 'jackpotWheelHide',
                value() {
                    const t = this.scenario.features.jackpots
                    t && t.wheelHide()
                }
            }, {
                key: 'jackpotWheelHideAll',
                value() {
                    const t = this.scenario.features.jackpots
                    t && t.wheelHideAll()
                }
            }, {
                key: 'jackpotWheelStart',
                value() {
                    const t = this.scenario.features.jackpots
                    t && t.wheelStart()
                }
            }, {
                key: 'enable',
                value() {
                    s.a.set(s.a.TYPES.GAME_ENABLED, !0)
                }
            }, {
                key: 'disable',
                value() {
                    s.a.set(s.a.TYPES.GAME_ENABLED, !1)
                }
            }, {
                key: '_preSpin',
                value() {
                    const t = this
                    return this.preSpinHandler
                        ? new Promise((e, n) => {
                            try {
                                t.preSpinHandler(e)
                            } catch (t) {
                                n(t)
                            }
                        })
                        : Promise.resolve()
                }
            }, {
                key: '_overrideConfig',
                value(t) {}
            }]) && ct(n.prototype, r), i && ct(n, i), e
        }(r.Container))
    },
    './src/core/Platform.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/eventemitter3/index.js')
        const i = n.n(r)
        const o = n('./node_modules/browser-detect/dist/browser-detect.es5.js')
        const a = n('./src/config.js')

        function s(t) {
            return (s = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function u(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function c(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? u(new Object(n), !0).forEach((e) => {
                            l(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : u(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function l(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function h(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function f(t, e, n) {
            return e = d(e),
            (function (t, e) {
                if (e && (s(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], d(t).constructor)
                : e.apply(t, n)))
        }

        function d(t) {
            return (d = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function p(t, e) {
            return (p = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const m = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = f(this, e))._browser = new Object(o.a)(), t._orientation = t._getCurrentOrientation(), t._resolution = t._getCurrentResolution(), t._performance = void 0, window.addEventListener(t.events.RESIZE, () => {
                    t._orientation = t._getCurrentOrientation()
                }), t
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && p(t, e)
            }(e, t)), n = e, (r = [{
                key: 'events',
                get() {
                    return {
                        RESIZE: 'resize',
                        ORIENTATION_CHANGE: 'orientation_change',
                        RESOLUTION_CHANGE: 'resolution_change',
                        PERFORMANCE_CHANGE: 'performance_change'
                    }
                }
            }, {
                key: 'resolution',
                get() {
                    let t = a.a.forceResolution
                    return t || this._resolution
                }
            }, {
                key: 'resolutionScale',
                get() {
                    return a.a.scale[this.resolution] && a.a.scale[this.resolution].default || 1
                }
            }, {
                key: 'orientation',
                get() {
                    return this._orientation
                }
            }, {
                key: 'browser',
                get() {
                    return this._browser
                }
            }, {
                key: 'dimension',
                get() {
                    let t = window.screen
                    return t.width - t.height > 0 ? 'width' : 'height'
                }
            }, {
                key: 'orientationQueries',
                get() {
                    return {
                        LANDSCAPE: '(orientation: landscape)',
                        PORTRAIT: '(orientation: portrait)'
                    }
                }
            }, {
                key: 'resolutionQueries',
                get() {
                    return this._buildResolutionQueries()
                }
            }, {
                key: 'matchMediaQueries',
                value(t) {
                    let e = window.matchMedia
                    return Object.keys(t).reduce((n, r) => {
                        return e(t[r]).matches ? r : n
                    }, '')
                }
            }, {
                key: '_getCurrentResolution',
                value() {
                    let t = this.matchMediaQueries(this.resolutionQueries)
                    return t !== this._resolution && this.emit(this.events.RESOLUTION_CHANGE, {
                        resolution: t
                    }), t
                }
            }, {
                key: '_getCurrentOrientation',
                value() {
                    let t = this.matchMediaQueries(this.orientationQueries)
                    return t !== this._orientation && this.emit(this.events.ORIENTATION_CHANGE, {
                        orientation: t
                    }), t
                }
            }, {
                key: '_buildResolutionQueries',
                value() {
                    let t = this
                            var e = a.a.platform.resolutionThresholds
                    return Object.keys(e).reduce((n, r) => {
                        var i = e[r]
                            return c(c({}, n), {}, l({}, r, 'screen and ('.concat(i[0], '-device-').concat(t.dimension, ': ').concat(i[1], ')')))
                    }, {})
                }
            }]) && h(n.prototype, r), i && h(n, i), e
        }(i.a))
        e.a = new m()
    },
    './src/core/Renderer.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return G
        })
        let r; const i = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const o = n('./node_modules/@pixi/canvas-renderer/dist/esm/canvas-renderer.js')
        const a = n('./node_modules/@pixi/canvas-mesh/dist/esm/canvas-mesh.js')
        const s = n('./node_modules/@pixi/core/dist/esm/core.js')
        const u = n('./node_modules/@pixi/math/dist/esm/math.js')
        const c = n('./node_modules/@pixi/graphics/dist/esm/graphics.js')
        const l = (function () {
            function t() {}
            return t.offsetPolygon = function (e, n) {
                let r = []
                            var i = e.length
                n = t.isPolygonClockwise(e) ? n : -1 * n
                for (let o = 0; o < i; o += 2) {
                    let a = o - 2
                    a < 0 && (a += i)
                    var s = (o + 2) % i
                                var u = e[o] - e[a]
                                var c = e[o + 1] - e[a + 1]
                                var l = Math.sqrt(u * u + c * c)
                    u /= l, c /= l
                    var h = -(c *= n)
                                var f = u *= n
                                var d = [e[a] + h, e[a + 1] + f]
                                var p = [e[o] + h, e[o + 1] + f]
                                var m = e[s] - e[o]
                                var y = e[s + 1] - e[o + 1]
                    m /= l = Math.sqrt(m * m + y * y), y /= l
                    var v = -(y *= n)
                                var _ = m *= n
                                var g = [e[o] + v, e[o + 1] + _]
                                var b = [e[s] + v, e[s + 1] + _]
                                var E = t.findIntersection(d[0], d[1], p[0], p[1], g[0], g[1], b[0], b[1])
                    E && r.push.apply(r, E)
                }
                return r
            }, t.findIntersection = function (t, e, n, r, i, o, a, s) {
                let u = (s - o) * (n - t) - (a - i) * (r - e)
                            var c = (a - i) * (e - o) - (s - o) * (t - i)
                if (u === 0) return c === 0 && (n - t) * (e - o) - (r - e) * (t - i) === 0 ? [(t + n) / 2, (e + r) / 2] : null
                var l = c / u
                return [t + l * (n - t), e + l * (r - e)]
            }, t.isPolygonClockwise = function (t) {
                for (var e = 0, n = 0; n < t.length - 2; n += 2) e += (t[n + 2] - t[n]) * (t[n + 3] + t[n + 1])
                return e > 0
            }, t
        }())
        const h = (function () {
            function t(t) {
                this._svgMatrix = null, this._tempMatrix = new u.d(), this.renderer = t
            }
            return t.prototype._calcCanvasStyle = function (t, e) {
                let n
                return t.texture && t.texture.baseTexture !== s.db.WHITE.baseTexture ? t.texture.valid ? (n = o.b.getTintedPattern(t.texture, e), this.setPatternTransform(n, t.matrix || u.d.IDENTITY)) : n = '#808080' : n = `#${  ('00000' + (0 | e).toString(16)).substr(-6)}`, n
            }, t.prototype.render = function (t) {
                let e = this.renderer
                            var n = e.context
                            var r = t.worldAlpha
                            var i = t.transform.worldTransform
                e.setContextTransform(i), e.setBlendMode(t.blendMode)
                for (var o, a, s = t.geometry.graphicsData, c = (t.tint >> 16 & 255) / 255, l = (t.tint >> 8 & 255) / 255, h = (255 & t.tint) / 255, f = 0; f < s.length; f++) {
                    let d = s[f]
                                var p = d.shape
                                var m = d.fillStyle
                                var y = d.lineStyle
                                var v = 0 | d.fillStyle.color
                                var _ = 0 | d.lineStyle.color
                    if (d.matrix && e.setContextTransform(i.copyTo(this._tempMatrix).append(d.matrix)), m.visible) {
                        let g = ((v >> 16 & 255) / 255 * c * 255 << 16) + ((v >> 8 & 255) / 255 * l * 255 << 8) + (255 & v) / 255 * h * 255
                        o = this._calcCanvasStyle(m, g)
                    }
                    if (y.visible) {
                        let b = ((_ >> 16 & 255) / 255 * c * 255 << 16) + ((_ >> 8 & 255) / 255 * l * 255 << 8) + (255 & _) / 255 * h * 255
                        a = this._calcCanvasStyle(y, b)
                    }
                    if (n.lineWidth = y.width, n.lineCap = y.cap, n.lineJoin = y.join, n.miterLimit = y.miterLimit, d.type === u.l.POLY) {
                        n.beginPath()
                        var E = (I = p).points
                                    var x = d.holes
                                    var T = void 0
                                    var S = void 0
                                    var w = void 0
                                    var O = void 0
                                    var P = void 0
                        n.moveTo(E[0], E[1])
                        for (var R = 2; R < E.length; R += 2) n.lineTo(E[R], E[R + 1])
                        if (I.closeStroke && n.closePath(), x.length > 0) {
                            P = [], T = 0, w = E[0], O = E[1]
                            for (R = 2; R + 2 < E.length; R += 2) T += (E[R] - w) * (E[R + 3] - O) - (E[R + 2] - w) * (E[R + 1] - O)
                            for (let A = 0; A < x.length; A++) {
                                if (E = x[A].shape.points) {
                                    S = 0, w = E[0], O = E[1]
                                            for (R = 2; R + 2 < E.length; R += 2) S += (E[R] - w) * (E[R + 3] - O) - (E[R + 2] - w) * (E[R + 1] - O)
                                            if (S * T < 0) {
                                        n.moveTo(E[0], E[1])
                                                for (R = 2; R < E.length; R += 2) n.lineTo(E[R], E[R + 1])
                                    } else {
                                        n.moveTo(E[E.length - 2], E[E.length - 1])
                                                for (R = E.length - 4; R >= 0; R -= 2) n.lineTo(E[R], E[R + 1])
                                    }
                                    x[A].shape.closeStroke && n.closePath(), P[A] = S * T < 0
                                }
                            }
                        }
                        m.visible && (n.globalAlpha = m.alpha * r, n.fillStyle = o, n.fill()), y.visible && this.paintPolygonStroke(I, y, a, x, P, r, n)
                    } else if (d.type === u.l.RECT) {
                        var I = p
                        if (m.visible && (n.globalAlpha = m.alpha * r, n.fillStyle = o, n.fillRect(I.x, I.y, I.width, I.height)), y.visible) {
                            var C = y.width * (0.5 - (1 - y.alignment))
                                        var k = I.width + 2 * C
                                        var N = I.height + 2 * C
                            n.globalAlpha = y.alpha * r, n.strokeStyle = a, n.strokeRect(I.x - C, I.y - C, k, N)
                        }
                    } else if (d.type === u.l.CIRC) {
                        I = p
                        if (n.beginPath(), n.arc(I.x, I.y, I.radius, 0, 2 * Math.PI), n.closePath(), m.visible && (n.globalAlpha = m.alpha * r, n.fillStyle = o, n.fill()), y.visible) {
                            if (y.alignment !== 0.5) {
                                C = y.width * (0.5 - (1 - y.alignment))
                                n.beginPath(), n.arc(I.x, I.y, I.radius + C, 0, 2 * Math.PI), n.closePath()
                            }
                            n.globalAlpha = y.alpha * r, n.strokeStyle = a, n.stroke()
                        }
                    } else if (d.type === u.l.ELIP) {
                        I = p
                        if ((V = y.alignment === 1) || this.paintEllipse(I, m, y, o, r, n), y.visible) {
                            if (y.alignment !== 0.5) {
                                C = y.width * (0.5 - (1 - y.alignment))
                                var M = 2 * (I.width + C)
                                            var j = 2 * (I.height + C)
                                            var D = I.x - M / 2
                                            var L = I.y - j / 2
                                            var F = M / 2 * 0.5522848;
                                var B = j / 2 * 0.5522848;
                                var U = D + M
                                            var G = L + j
                                            var X = D + M / 2
                                            var H = L + j / 2
                                n.beginPath(), n.moveTo(D, H), n.bezierCurveTo(D, H - B, X - F, L, X, L), n.bezierCurveTo(X + F, L, U, H - B, U, H), n.bezierCurveTo(U, H + B, X + F, G, X, G), n.bezierCurveTo(X - F, G, D, H + B, D, H), n.closePath()
                            }
                            n.globalAlpha = y.alpha * r, n.strokeStyle = a, n.stroke()
                        }
                        V && this.paintEllipse(I, m, y, o, r, n)
                    } else if (d.type === u.l.RREC) {
                        var V
                        I = p
                        if ((V = y.alignment === 1) || this.paintRoundedRectangle(I, m, y, o, r, n), y.visible) {
                            if (y.alignment !== 0.5) {
                                k = I.width, N = I.height, C = y.width * (0.5 - (1 - y.alignment))
                                var W = I.x - C
                                            var Y = I.y - C
                                            var z = I.width + 2 * C
                                            var q = I.height + 2 * C
                                            var K = C * (y.alignment >= 1 ? Math.min(z / k, q / N) : Math.min(k / z, N / q))
                                            var Z = I.radius + K
                                            var $ = Math.min(z, q) / 2
                                Z = Z > $ ? $ : Z, n.beginPath(), n.moveTo(W, Y + Z), n.lineTo(W, Y + q - Z), n.quadraticCurveTo(W, Y + q, W + Z, Y + q), n.lineTo(W + z - Z, Y + q), n.quadraticCurveTo(W + z, Y + q, W + z, Y + q - Z), n.lineTo(W + z, Y + Z), n.quadraticCurveTo(W + z, Y, W + z - Z, Y), n.lineTo(W + Z, Y), n.quadraticCurveTo(W, Y, W, Y + Z), n.closePath()
                            }
                            n.globalAlpha = y.alpha * r, n.strokeStyle = a, n.stroke()
                        }
                        V && this.paintRoundedRectangle(I, m, y, o, r, n)
                    }
                }
            }, t.prototype.paintPolygonStroke = function (t, e, n, r, i, o, a) {
                if (e.alignment !== 0.5) {
                    let s = e.width * (0.5 - (1 - e.alignment))
                                var u = l.offsetPolygon(t.points, s)
                                var c = void 0
                    a.beginPath(), a.moveTo(u[0], u[1])
                    for (var h = 2; h < u.length; h += 2) a.lineTo(u[h], u[h + 1])
                    t.closeStroke && a.closePath()
                    for (let f = 0; f < r.length; f++) {
                        if (c = r[f].shape.points, u = l.offsetPolygon(c, s), i[f]) {
                            a.moveTo(u[0], u[1])
                            for (h = 2; h < u.length; h += 2) a.lineTo(u[h], u[h + 1])
                        } else {
                            a.moveTo(u[u.length - 2], u[u.length - 1])
                            for (h = u.length - 4; h >= 0; h -= 2) a.lineTo(u[h], u[h + 1])
                        }
                        r[f].shape.closeStroke && a.closePath()
                    }
                }
                a.globalAlpha = e.alpha * o, a.strokeStyle = n, a.stroke()
            }, t.prototype.paintEllipse = function (t, e, n, r, i, o) {
                let a = 2 * t.width
                            var s = 2 * t.height
                            var u = t.x - a / 2
                            var c = t.y - s / 2
                            var l = a / 2 * 0.5522848;
                var h = s / 2 * 0.5522848;
                var f = u + a
                            var d = c + s
                            var p = u + a / 2
                            var m = c + s / 2
                o.beginPath(), o.moveTo(u, m), o.bezierCurveTo(u, m - h, p - l, c, p, c), o.bezierCurveTo(p + l, c, f, m - h, f, m), o.bezierCurveTo(f, m + h, p + l, d, p, d), o.bezierCurveTo(p - l, d, u, m + h, u, m), o.closePath(), n.alignment === 0 && o.clip(), e.visible && (o.globalAlpha = e.alpha * i, o.fillStyle = r, o.fill())
            }, t.prototype.paintRoundedRectangle = function (t, e, n, r, i, o) {
                let a = t.x
                            var s = t.y
                            var u = t.width
                            var c = t.height
                            var l = t.radius
                            var h = Math.min(u, c) / 2
                l = l > h ? h : l, o.beginPath(), o.moveTo(a, s + l), o.lineTo(a, s + c - l), o.quadraticCurveTo(a, s + c, a + l, s + c), o.lineTo(a + u - l, s + c), o.quadraticCurveTo(a + u, s + c, a + u, s + c - l), o.lineTo(a + u, s + l), o.quadraticCurveTo(a + u, s, a + u - l, s), o.lineTo(a + l, s), o.quadraticCurveTo(a, s, a, s + l), o.closePath(), n.alignment === 0 && o.clip(), e.visible && (o.globalAlpha = e.alpha * i, o.fillStyle = r, o.fill())
            }, t.prototype.setPatternTransform = function (t, e) {
                if (!1 !== this._svgMatrix) {
                    if (!this._svgMatrix) {
                        let n = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
                        if (n && n.createSVGMatrix && (this._svgMatrix = n.createSVGMatrix()), !this._svgMatrix || !t.setTransform) return void (this._svgMatrix = !1)
                    }
                    this._svgMatrix.a = e.a, this._svgMatrix.b = e.b, this._svgMatrix.c = e.c, this._svgMatrix.d = e.d, this._svgMatrix.e = e.tx, this._svgMatrix.f = e.ty, t.setTransform(this._svgMatrix.inverse())
                }
            }, t.prototype.destroy = function () {
                this.renderer = null, this._svgMatrix = null, this._tempMatrix = null
            }, t
        }())
        const f = new u.d()
        c.c.prototype.generateCanvasTexture = function (t, e) {
            void 0 === e && (e = 1)
            const n = this.getLocalBounds()
            const i = s.P.create({
                width: n.width,
                height: n.height,
                scaleMode: t,
                resolution: e
            })
            r || (r = new o.a()), this.transform.updateLocalTransform(), this.transform.localTransform.copyTo(f), f.invert(), f.tx -= n.x, f.ty -= n.y, r.render(this, {
                renderTexture: i,
                clear: !0,
                transform: f
            })
            const a = s.db.from(i.baseTexture._canvasRenderTarget.canvas, {
                scaleMode: t
            })
            return a.baseTexture.setResolution(e), a
        }, c.c.prototype.cachedGraphicsData = [], c.c.prototype._renderCanvas = function (t) {
            !0 !== this.isMask && (this.finishPoly(), t.plugins.graphics.render(this))
        }
        const d = n('./node_modules/@pixi/constants/dist/esm/constants.js')
        const p = n('./node_modules/@pixi/sprite/dist/esm/sprite.js')
        const m = new u.d()
        const y = (function () {
            function t(t) {
                this.renderer = t
            }
            return t.prototype.render = function (t) {
                const e = t._texture
                var n = this.renderer
                var r = n.context
                if (e.valid) {
                    const i = e._frame.width
                    var a = e._frame.height
                    var s = t.transform.worldTransform
                    var c = 0
                    var l = 0
                    var h = e.baseTexture.getDrawableSource()
                    if (!(e.orig.width <= 0 || e.orig.height <= 0) && e.valid && h) {
                        n.setBlendMode(t.blendMode, !0), n.context.globalAlpha = t.worldAlpha
                        let f = e.baseTexture.scaleMode === d.p.LINEAR
                        n.smoothProperty && n.context[n.smoothProperty] !== f && (r[n.smoothProperty] = f), e.trim ? (c = e.trim.width / 2 + e.trim.x - t.anchor.x * e.orig.width, l = e.trim.height / 2 + e.trim.y - t.anchor.y * e.orig.height) : (c = (0.5 - t.anchor.x) * e.orig.width, l = (0.5 - t.anchor.y) * e.orig.height), e.rotate && (s.copyTo(m), s = m, u.n.matrixAppendRotationInv(s, e.rotate, c, l), c = 0, l = 0), c -= i / 2, l -= a / 2, n.setContextTransform(s, t.roundPixels, 1), t.roundPixels && (c |= 0, l |= 0)
                        let p = e.baseTexture.resolution
                        var y = n._outerBlend
                        y && (r.save(), r.beginPath(), r.rect(c * n.resolution, l * n.resolution, i * n.resolution, a * n.resolution), r.clip()), t.tint !== 16777215 ? (t._cachedTint === t.tint && t._tintedCanvas.tintId === t._texture._updateID || (t._cachedTint = t.tint, t._tintedCanvas = o.b.getTintedCanvas(t, t.tint)), r.drawImage(t._tintedCanvas, 0, 0, Math.floor(i * p), Math.floor(a * p), Math.floor(c * n.resolution), Math.floor(l * n.resolution), Math.floor(i * n.resolution), Math.floor(a * n.resolution))) : r.drawImage(h, e._frame.x * p, e._frame.y * p, Math.floor(i * p), Math.floor(a * p), Math.floor(c * n.resolution), Math.floor(l * n.resolution), Math.floor(i * n.resolution), Math.floor(a * n.resolution)), y && r.restore(), n.setBlendMode(d.b.NORMAL)
                    }
                }
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        p.a.prototype._tintedCanvas = null, p.a.prototype._renderCanvas = function (t) {
            t.plugins.sprite.render(this)
        }
        const v = n('./node_modules/@pixi/utils/dist/esm/utils.js')
        const _ = new u.j()
        const g = (function () {
            function t(t) {
                this.renderer = t
            }
            return t.prototype.image = function (t, e, n) {
                let r = new Image()
                return r.src = this.base64(t, e, n), r
            }, t.prototype.base64 = function (t, e, n) {
                return this.canvas(t).toDataURL(e, n)
            }, t.prototype.canvas = function (t) {
                let e; let n; let r; let i; let o = this.renderer
                t && (i = t instanceof s.P ? t : o.generateTexture(t)), i ? (e = i.baseTexture._canvasRenderTarget.context, n = i.baseTexture._canvasRenderTarget.resolution, r = i.frame) : (e = o.rootContext, n = o.resolution, (r = _).width = this.renderer.width, r.height = this.renderer.height)
                var a = Math.floor(r.width * n + 1e-4)
                            var u = Math.floor(r.height * n + 1e-4)
                            var c = new v.CanvasRenderTarget(a, u, 1)
                            var l = e.getImageData(r.x * n, r.y * n, a, u)
                return c.context.putImageData(l, 0, 0), c.canvas
            }, t.prototype.pixels = function (t) {
                let e; let n; let r; let i; let o = this.renderer
                t && (i = t instanceof s.P ? t : o.generateTexture(t)), i ? (e = i.baseTexture._canvasRenderTarget.context, n = i.baseTexture._canvasRenderTarget.resolution, r = i.frame) : (e = o.rootContext, n = o.resolution, (r = _).width = o.width, r.height = o.height)
                var a = r.x * n
                            var u = r.y * n
                            var c = r.width * n
                            var l = r.height * n
                return e.getImageData(a, u, c, l).data
            }, t.prototype.destroy = function () {
                this.renderer = null
            }, t
        }())
        const b = n('./node_modules/@pixi/prepare/dist/esm/prepare.js')
        let E = function (t, e) {
            return (E = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            })(t, e)
        }
        /*!
             * @pixi/canvas-extract - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/canvas-extract is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        function x(t, e) {
            const n = t
            if (e instanceof s.h) {
                const r = e.source
                const i = r.width === 0 ? n.canvas.width : Math.min(n.canvas.width, r.width)
                const o = r.height === 0 ? n.canvas.height : Math.min(n.canvas.height, r.height)
                return n.ctx.drawImage(r, 0, 0, i, o, 0, 0, n.canvas.width, n.canvas.height), !0
            }
            return !1
        }
        const T = (function (t) {
            function e(e) {
                let n = t.call(this, e) || this
                return n.uploadHookHelper = n, n.canvas = document.createElement('canvas'), n.canvas.width = 16, n.canvas.height = 16, n.ctx = n.canvas.getContext('2d'), n.registerUploadHook(x), n
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                E(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype.destroy = function () {
                t.prototype.destroy.call(this), this.ctx = null, this.canvas = null
            }, e
        }(b.a))
        let S = n('./node_modules/@pixi/sprite-tiling/dist/esm/sprite-tiling.js')
        let w = new u.d()
        let O = new u.d()
        let P = [new u.g(), new u.g(), new u.g(), new u.g()]
        S.a.prototype._renderCanvas = function (t) {
            const e = this._texture
            if (e.baseTexture.valid) {
                const n = t.context
                const r = this.worldTransform
                const i = e.baseTexture
                const a = i.getDrawableSource()
                const s = i.resolution
                if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
                    this._textureID = this._texture._updateID
                    const u = new v.CanvasRenderTarget(e._frame.width, e._frame.height, s)
                    this.tint !== 16777215 ? (this._tintedCanvas = o.b.getTintedCanvas(this, this.tint), u.context.drawImage(this._tintedCanvas, 0, 0)) : u.context.drawImage(a, -e._frame.x * s, -e._frame.y * s), this._cachedTint = this.tint, this._canvasPattern = u.context.createPattern(u.canvas, 'repeat')
                }
                n.globalAlpha = this.worldAlpha, t.setBlendMode(this.blendMode), this.tileTransform.updateLocalTransform()
                const c = this.tileTransform.localTransform
                const l = this._width
                const h = this._height
                w.identity(), O.copyFrom(c), this.uvRespectAnchor || O.translate(-this.anchor.x * l, -this.anchor.y * h), w.prepend(O), w.prepend(r), t.setContextTransform(w), n.fillStyle = this._canvasPattern
                const f = this.anchor.x * -l
                const d = this.anchor.y * -h
                P[0].set(f, d), P[1].set(f + l, d), P[2].set(f + l, d + h), P[3].set(f, d + h)
                for (var p = 0; p < 4; p++) O.applyInverse(P[p], P[p])
                n.beginPath(), n.moveTo(P[0].x, P[0].y)
                for (p = 1; p < 4; p++) n.lineTo(P[p].x, P[p].y)
                n.closePath(), n.fill()
            }
        },
        /*!
                 * @pixi/canvas-particle-container - v6.2.0
                 * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                 *
                 * @pixi/canvas-particle-container is licensed under the MIT License.
                 * http://www.opensource.org/licenses/mit-license
                 */
        n('./node_modules/@pixi/particle-container/dist/esm/particle-container.js').a.prototype.renderCanvas = function (t) {
            if (this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable) {
                const e = t.context
                const n = this.worldTransform
                let r = !0
                let i = 0
                let o = 0
                let a = 0
                let s = 0
                t.setBlendMode(this.blendMode), e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform()
                for (let u = 0; u < this.children.length; ++u) {
                    const c = this.children[u]
                    if (c.visible && c._texture.valid) {
                        const l = c._texture.frame
                        if (e.globalAlpha = this.worldAlpha * c.alpha, c.rotation % (2 * Math.PI) == 0) { r && (t.setContextTransform(n, !1, 1), r = !1), i = c.anchor.x * (-l.width * c.scale.x) + c.position.x + 0.5, o = c.anchor.y * (-l.height * c.scale.y) + c.position.y + 0.5, a = l.width * c.scale.x, s = l.height * c.scale.y
                        }
                        else {
                            r || (r = !0), c.displayObjectUpdateTransform()
                            const h = c.worldTransform
                            t.setContextTransform(h, this.roundPixels, 1), i = c.anchor.x * -l.width + 0.5, o = c.anchor.y * -l.height + 0.5, a = l.width, s = l.height
                        }
                        const f = c._texture.baseTexture.resolution
                        e.drawImage(c._texture.baseTexture.getDrawableSource(), l.x * f, l.y * f, l.width * f, l.height * f, i * t.resolution, o * t.resolution, a * t.resolution, s * t.resolution)
                    }
                }
            }
        }
        const R = n('./node_modules/@pixi/display/dist/esm/display.js')
        /*!
             * @pixi/canvas-display - v6.2.0
             * Compiled Mon, 01 Nov 2021 16:52:10 UTC
             *
             * @pixi/canvas-display is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
        R.b.prototype._renderCanvas = function (t) {}, R.b.prototype.renderCanvas = function (t) {
            if (this.visible && !(this.worldAlpha <= 0) && this.renderable) {
                this._mask && t.maskManager.pushMask(this._mask), this._renderCanvas(t)
                for (let e = 0, n = this.children.length; e < n; ++e) this.children[e].renderCanvas(t)
                this._mask && t.maskManager.popMask(t)
            }
        }, R.c.prototype.renderCanvas = function (t) {},
        /*!
                 * @pixi/canvas-text - v6.2.0
                 * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                 *
                 * @pixi/canvas-text is licensed under the MIT License.
                 * http://www.opensource.org/licenses/mit-license
                 */
        n('./node_modules/@pixi/text/dist/esm/text.js').b.prototype._renderCanvas = function (t) {
            this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0), this.updateText(!0), p.a.prototype._renderCanvas.call(this, t)
        },
        /*!
                 * pixi.js-legacy - v6.2.0
                 * Compiled Mon, 01 Nov 2021 16:52:10 UTC
                 *
                 * pixi.js-legacy is licensed under the MIT License.
                 * http://www.opensource.org/licenses/mit-license
                 */
        o.a.registerPlugin('accessibility', i.AccessibilityManager), o.a.registerPlugin('extract', g), o.a.registerPlugin('graphics', h), o.a.registerPlugin('interaction', i.InteractionManager), o.a.registerPlugin('mesh', a.a), o.a.registerPlugin('prepare', T), o.a.registerPlugin('sprite', y)
        const A = n('./node_modules/eventemitter3/index.js')
        const I = n.n(A)
        const C = n('./src/core/utils/Cache.js')
        const k = n('./node_modules/@games/gsap/gsap-core.js')
        const N = n('./node_modules/@games/gsap/all.js')
        const M = n('./src/config.js')

        function j(t) {
            return (j = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function D(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function L(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function F(t, e, n) {
            return e = B(e),
            (function (t, e) {
                if (e && (j(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], B(t).constructor)
                : e.apply(t, n)))
        }

        function B(t) {
            return (B = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function U(t, e) {
            return (U = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        i.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !0
        var G = (function (t) {
            function e(t, n) {
                let r
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), r = F(this, e), t.autoResize = !1, t.resolution = window.devicePixelRatio, r._config = t, r._engine = new Object(i.autoDetectRenderer)(t), r._gameStage = n, r._paused = !0, r._canvas = r._engine.view, r._canvas.id = 'stage', r._activeStageProps = {
                    width: 0,
                    height: 0,
                    overlay: {
                        bottom: 0,
                        top: 0,
                        left: 0,
                        right: 0
                    }
                }, r._activeBaseSize = {
                    width: r._config.width,
                    height: r._config.height
                }, r._positionTween = null, r._scaleTween = null, new Object(C.c)(r._engine), r._engine.plugins && r._engine.plugins.accessibility && r._engine.plugins.accessibility.destroy(), r
            }
            let n, r, o, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && U(t, e)
            }(e, t)), n = e, (r = [{
                key: 'baseSize',
                get() {
                    return this._activeBaseSize
                }
            }, {
                key: 'pause',
                value() {
                    this._paused = !0
                }
            }, {
                key: 'resume',
                value() {
                    this._paused = !1
                }
            }, {
                key: 'changeBaseSize',
                value: (a = regeneratorRuntime.mark(function t(e) {
                    let n, r, i, o, a, s, u, c, l
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (n = e.width, r = void 0 === n ? this._activeBaseSize.width : n, i = e.height, o = void 0 === i ? this._activeBaseSize.height : i, a = e.duration, s = void 0 === a ? 0 : a, u = e.ease, c = void 0 === u ? k.b.easeNone : u, this._baseSizeChanged({
                                    width: r,
                                    height: o
                                })) {
                                    t.next = 3
                                        break
                                }
                                return t.abrupt('return');
                            case 3:
                                if (this._finishActiveTweens(), l = this._getResizeConfig(), s = !0 === M.a.static ? 0 : s, this._positionTween = N.b.to(this._gameStage, {
                                    duration: s,
                                    x: l.gameStageX,
                                    y: l.gameStageY,
                                    ease: c
                                }), this._scaleTween = N.b.to(this._gameStage.scale, {
                                    duration: s,
                                    x: l.scaleFactor,
                                    y: l.scaleFactor,
                                    ease: c
                                }), M.a.static) {
                                    t.next = 11
                                        break
                                }
                                return t.next = 11, Promise.all([this._positionTween.then(), this._scaleTween.then()])
                                case 11:
                                this._positionTween = null, this._scaleTween = null, this.render()
                                case 14:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                }), s = function () {
                    const t = this
                    let e = arguments
                    return new Promise((n, r) => {
                        const i = a.apply(t, e)

                        function o(t) {
                            D(i, n, r, o, s, 'next', t)
                        }

                        function s(t) {
                            D(i, n, r, o, s, 'throw', t)
                        }
                        o(void 0)
                    })
                }, function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'resize',
                value(t) {
                    if (this._stageChanged(t)) {
                        this._finishActiveTweens()
                        let e = this._getResizeConfig()
                        this._gameStage.scale.set(e.scaleFactor), this._gameStage.x = e.gameStageX, this._gameStage.y = e.gameStageY, this._engine.resize(this._activeStageProps.width, this._activeStageProps.height), this.render(), this.emit('resize')
                    }
                }
            }, {
                key: 'render',
                value() {
                    this._paused || this._engine.render(this._gameStage)
                }
            }, {
                key: 'view',
                get() {
                    return this._canvas
                }
            }, {
                key: 'getVisibleArea',
                value() {
                    const t = -(this._engine.screen.width / this._gameStage.scale.x - this._config.width) / 2
                    var e = -(this._engine.screen.height / this._gameStage.scale.y - this._config.height) / 2
                    return {
                        topLeftX: t,
                        topLeftY: e,
                        bottomRightX: this._config.width - t,
                        bottomRightY: this._config.height - e
                    }
                }
            }, {
                key: '_stageChanged',
                value(t) {
                    return (this._activeStageProps.width !== t.width || this._activeStageProps.height !== t.height || this._activeStageProps.overlay.bottom !== t.overlay.bottom || this._activeStageProps.overlay.top !== t.overlay.top || this._activeStageProps.overlay.right !== t.overlay.right || this._activeStageProps.overlay.left !== t.overlay.left) && (this._activeStageProps.width = t.width, this._activeStageProps.height = t.height, this._activeStageProps.overlay.bottom = t.overlay.bottom, this._activeStageProps.overlay.top = t.overlay.top, this._activeStageProps.overlay.right = t.overlay.right, this._activeStageProps.overlay.left = t.overlay.left, this._config.centerInScreen && (this._activeStageProps.overlay.right = Math.max(t.overlay.right, t.overlay.left), this._activeStageProps.overlay.left = this._activeStageProps.overlay.right), !0)
                }
            }, {
                key: '_baseSizeChanged',
                value(t) {
                    return (this._activeBaseSize.width !== t.width || this._activeBaseSize.height !== t.height) && (this._activeBaseSize.width = t.width, this._activeBaseSize.height = t.height, !0)
                }
            }, {
                key: '_getResizeConfig',
                value() {
                    const t = this._activeStageProps.height - this._activeStageProps.overlay.top - this._activeStageProps.overlay.bottom
                    var e = this._activeStageProps.width - this._activeStageProps.overlay.left - this._activeStageProps.overlay.right
                    var n = 1
                    n = e / t >= this._activeBaseSize.width / this._activeBaseSize.height ? t / this._activeBaseSize.height : e / this._activeBaseSize.width
                    let r = this._activeBaseSize.width * n
                    var i = this._activeBaseSize.height * n
                    return {
                        scaleFactor: n,
                        gameStageX: Math.round(this._activeStageProps.overlay.left + (e - r) / 2),
                        gameStageY: Math.round(this._activeStageProps.overlay.top + (t - i) / 2)
                    }
                }
            }, {
                key: '_scaleSize',
                value(t, e) {
                    return {
                        width: Math.round(t.width * e),
                        height: Math.round(t.height * e),
                        overlay: {
                            top: Math.round(t.overlay.top * e),
                            bottom: Math.round(t.overlay.bottom * e),
                            left: Math.round(t.overlay.left * e),
                            right: Math.round(t.overlay.right * e)
                        }
                    }
                }
            }, {
                key: '_finishActiveTweens',
                value() {
                    this._positionTween && this._positionTween.progress(1), this._scaleTween && this._scaleTween.progress(1), this._positionTween = null, this._scaleTween = null
                }
            }]) && L(n.prototype, r), o && L(n, o), e
        }(I.a))
    },
    './src/core/config/index.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/@games/gsap/EasePack.js')
        const i = n('./node_modules/@games/gsap/gsap-core.js')
        const o = n('./src/core/utils/constants.js')
        const a = {
            bangupSpeed: 1,
            totalWinDuration: 5,
            sum: {
                currency: !0,
                hideDecimals: !1,
                font: 'sumFont',
                alignType: 'CENTER',
                ignoreRatio: !1,
                overscale: !0
            },
            pulseSum: {
                scaleBy: 0.9,
                animation: {
                    ease: 'power2.inOut',
                    duration: 1,
                    repeat: -1,
                    yoyo: !0
                },
                returnAnimation: {
                    ease: 'power2.in',
                    duration: 1
                }
            },
            dynamicLabels: !0,
            showDelay: {
                normalWin: {
                    default: 0.5,
                    custom: {}
                },
                bigWin: {
                    default: 0.5,
                    custom: {}
                },
                superWin: {
                    default: 0.5,
                    custom: {}
                },
                megaWin: {
                    default: 0.5,
                    custom: {}
                },
                epicWin: {
                    default: 0.5,
                    custom: {}
                },
                jackpotWin: {
                    default: 0.5,
                    custom: {}
                },
                totalWin: {
                    default: 1,
                    custom: {}
                }
            },
            hideDelay: {
                normalWin: {
                    default: 1,
                    custom: {}
                },
                bigWin: {
                    default: 2.5,
                    custom: {}
                },
                superWin: {
                    default: 3.5,
                    custom: {}
                },
                megaWin: {
                    default: 5,
                    custom: {}
                },
                epicWin: {
                    default: 7,
                    custom: {}
                },
                jackpotWin: {
                    default: 7,
                    custom: {}
                },
                totalWin: {
                    default: 0,
                    custom: {}
                }
            },
            easings: [r.a.ease.config(0.1, 0.1, !1), r.a.ease.config(0.1, 0.4, !1), i.c.easeIn, i.c.easeInOut, r.a.ease.config(0.1, 0.7, !1), r.a.ease.config(0.3, 0.1, !1), r.a.ease.config(0.3, 0.4, !1), r.a.ease.config(0.3, 0.7, !1), i.c.easeIn, i.c.easeInOut],
            coins: {
                emitter: {
                    sourceType: o.c.MOVIE_CLIP,
                    maxParticles: 5e3,
                    rate: {
                        amount: [8, 10],
                        interval: [0.1]
                    },
                    initializers: {
                        velocity: {
                            speed: 8,
                            angle: [400, 320]
                        },
                        mass: [0.05, 0.5],
                        life: [10, 12],
                        radius: [800]
                    },
                    behaviors: {
                        gravity: [2],
                        scale: {
                            from: [0.3, 0.7],
                            to: [1, 1.5]
                        }
                    }
                },
                minDuration: 0.5,
                delays: {}
            }
        }
        const s = {
            activationEvent: 'animation_ending',
            counter: {
                font: 'sumFont',
                alignType: 'CENTER',
                round: !0,
                isZeroVisible: !1,
                isInitiallyVisible: !1,
                fitInBounds: !1,
                letterSpacing: -5,
                bangup: {
                    duration: 0,
                    easing: 'none'
                },
                thresholds: [{
                    range: [1, 2500],
                    animLabel: 'count'
                }, {
                    range: [2501, 1 / 0],
                    animLabel: 'countBig'
                }]
            }
        }

        function u(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function c(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? u(new Object(n), !0).forEach((e) => {
                            l(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : u(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function l(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const h = c(c({}, a), {}, {
            sum: c(c({}, a.sum), {}, {
                skip: {
                    thresholds: [{
                        value: 5,
                        skipToThreshold: !0,
                        skipDelay: 1.2
                    }, {
                        value: 10,
                        skipToThreshold: !0,
                        skipDelay: 1.2
                    }, {
                        value: 15,
                        skipToThreshold: !0,
                        skipDelay: 1.2
                    }, {
                        value: 30,
                        skipToThreshold: !1,
                        stepMultiplier: [35, 40, 45, 50],
                        stepDeviation: [2, 3, 4, 5],
                        skipDelay: [0.5, 0.5, 1]
                    }],
                    skipOnLabelChange: !0
                }
            }),
            pulseSum: {
                scaleBy: 0.9,
                animation: {
                    ease: 'power2.easeIn',
                    duration: 0.1,
                    yoyo: !1
                },
                returnAnimation: {
                    ease: 'power2.easeOut',
                    duration: 0.3
                }
            }
        })
        const f = {
            counter: {
                bangup: {
                    duration: 1,
                    easing: i.b.easeNone
                },
                round: !0,
                font: 'sumFont',
                alignType: 'CENTER'
            },
            delays: {
                afterUpdate: 0.5
            }
        }
        const d = {
            screens: 5,
            initialScreen: 0,
            arrangement: 'horizontal',
            maxDrag: 0.3,
            slideDuration: 0.5,
            ease: i.c.easeInOut,
            transitionLeverage: 350,
            drawLines: !0,
            type: 'lines',
            templates: {
                lines: 'x{{val}}',
                cluster: '{{val}}+'
            },
            paytableDynamicPayouts: !1,
            useExternalPaytableModal: !1,
            isMinimal: !1
        }
        const p = {
            count: 5,
            type: 'spinning',
            useGlobalTileSizes: !1,
            useOwnMask: !1,
            unblurEndScreen: !1,
            dim: {
                tint: 0,
                alpha: 0.5,
                blendMode: n('./node_modules/pixi.js/dist/esm/pixi.js').BLEND_MODES.MULTIPLY
            },
            tiles: {
                total: 6,
                visible: 3,
                offsetTop: 1,
                offsetBottom: 2,
                blur: {
                    enabled: !0,
                    default: {
                        x: 0,
                        y: 4,
                        quality: 8
                    },
                    19: {
                        x: 0,
                        y: 0,
                        quality: 0
                    },
                    100: {
                        x: 0,
                        y: 0,
                        quality: 0
                    }
                },
                stacked: {},
                sizes: [3],
                dataParser: null,
                buildTiles: !0,
                ignoreSizes: {},
                animSource: 'animate',
                guides: {}
            },
            spin: {
                minSpinDurationEnabled: !1,
                spinStopTweenDuration: 1.8,
                minDistance: 7,
                speed: 16,
                delay: {
                    atStart: 1,
                    atEnd: 3
                },
                easeStart: {
                    offset: 0.08,
                    speed: 0.4,
                    easings: ['power1.out', 'power1.in']
                },
                easeEnd: {
                    offset: 0.08,
                    speed: 0.4,
                    easings: ['power1.out', 'power1.in']
                },
                instantStop: {
                    speedUpReels: {
                        enabled: !0,
                        speedFactor: 5,
                        overwrite: 'auto',
                        switchDuration: 0,
                        keepEaseEndSpeed: !0
                    }
                },
                autoExpandTilesCount: 1
            }
        }
        const m = [{
            threshold: {
                width: 1 / 0,
                ratio: 1 / 0
            },
            offsetX: 0,
            offsetY: 0,
            scale: 1,
            duration: 0.5
        }]

        function y(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function v(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? y(new Object(n), !0).forEach((e) => {
                            _(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : y(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function _(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const g = v(v({}, d), {}, {
            paytableDynamicPayouts: !0,
            isMinimal: !0,
            paysScreen: 4,
            arrowKeysDeltas: {
                up: 60,
                down: -60
            },
            smoothSlide: {
                speed: 2500,
                ease: 'back.out(0.2)'
            },
            splash: {
                namespace: 'PaytableScreen1',
                name: 'paytableScreen1'
            },
            offsets: {
                height: 0,
                top: 0,
                bottom: 0
            },
            arrangement: 'vertical',
            screens: [1, 2, 3, 4, 5],
            mobileScrollSpeed: 1
        })

        function b(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function E(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? b(new Object(n), !0).forEach((e) => {
                            x(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : b(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function x(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        e.a = E(E({}, {
            version: 'v0.0.22 master#ad38d70',
            supported: {
                skins: ['default'],
                languages: {
                    default: ['bg', 'cs', 'da', 'de', 'el', 'en', 'en-SC', 'en-US', 'es', 'es-PE', 'fi', 'fr', 'hi', 'hr', 'hu', 'hy', 'id', 'it', 'ja', 'ka', 'ko', 'lt', 'lv', 'ms', 'nl', 'no', 'pl', 'pt', 'pt-BR', 'ro', 'ru', 'sk', 'sl', 'sv', 'th', 'tr', 'vi', 'zh', 'zh-TW']
                }
            }
        }), {}, x(x({
            branding: {
                client: 'red-tiger',
                studio: null,
                powered: null,
                collaborator: null,
                background: '#000000'
            },
            namespace: 'com.casino.game',
            client: 'RedTiger',
            baseLang: 'en',
            lang: 'en',
            langsFallback: {
                'pt-BR': [],
                'es-PE': [],
                'zh-TW': [],
                'fr-CA': [],
                'en-US': []
            },
            customUI: [],
            gaffSkipStateValidation: !1,
            addedAnticipation: !1,
            hasFreeSpins: !1,
            hasPaytable: !0,
            hasAutoplay: !0,
            hasInternalJackpot: !1,
            hasBottomBar: !0,
            hasChoices: !1,
            useGameSumFont: !0,
            autoStart: !1,
            paytableOnLoad: !0,
            expanded: !1,
            hasFeatureEvents: !0,
            hasSuperQuickSpins: !1,
            cdn: 'dist/',
            basePath: './',
            timestamp: '',
            size: {
                scale: {
                    width: 'auto',
                    height: 'auto',
                    mode: 'responsive',
                    constrain: !1
                }
            },
            renderer: {
                width: 1168,
                height: 820,
                autoResize: !1,
                resolution: window.devicePixelRatio,
                centerInScreen: !1
            },
            dynamicRenderer: {
                default: {
                    renderer: {
                        width: 1168,
                        height: 820
                    },
                    camera: {
                        offsetY: 0
                    },
                    tween: {
                        ease: i.b.easeNone,
                        duration: 0.5
                    }
                }
            },
            randomSeed: 'd0pe',
            video: {
                supportedFormats: ['mp4', 'webm']
            },
            centerCoins: {
                emitter: {
                    sourceType: o.c.MOVIE_CLIP,
                    maxParticles: 1e3,
                    randomFrameStart: !0,
                    rate: {
                        amount: [1, 1],
                        interval: [0.04]
                    },
                    initializers: {
                        velocity: {
                            speed: 10,
                            angle: [345, 375]
                        },
                        mass: [0.5, 2],
                        life: [3, 3],
                        radius: [360]
                    },
                    behaviors: {
                        gravity: [10],
                        scale: {
                            from: [0.24, 0.32],
                            to: [0.24, 0.32]
                        }
                    }
                }
            },
            freeSpinsPopupTiles: {
                tileId: 19,
                attachable: !0
            },
            jackpotPopupTiles: {
                tileId: 100,
                attachable: !0
            },
            freeSpinsPassingEffects: {
                tileId: 19,
                onShow: {
                    repeat: -1
                },
                onHide: {}
            },
            rumble: {
                intensity: {
                    x: 1,
                    y: 1
                },
                duration: {
                    x: 1,
                    y: 1
                },
                randomize: {
                    x: !0,
                    y: !0
                },
                interval: {
                    x: 0.02,
                    y: 0.02
                },
                acceleration: {
                    x: {
                        duration: 0,
                        ease: 'none'
                    },
                    y: {
                        duration: 0,
                        ease: 'none'
                    }
                },
                deceleration: {
                    x: {
                        duration: 0,
                        ease: 'none'
                    },
                    y: {
                        duration: 0,
                        ease: 'none'
                    }
                }
            },
            scale: {
                XHD: {
                    default: 1
                },
                HD: {
                    default: 1
                },
                MD: {
                    default: 0.6
                },
                SD: {
                    default: 0.4
                },
                XSD: {
                    default: 0.4
                }
            },
            forceResolution: null,
            anticipation: {
                freeSpins: {
                    tileId: 19,
                    minTiles: 2,
                    maxTiles: 3,
                    minDuration: 10,
                    maxDuration: 15,
                    reels: [0, 1, 2, 3, 4]
                },
                jackpot: {
                    tileId: 100,
                    minTiles: 2,
                    maxTiles: 3,
                    minDuration: 10,
                    maxDuration: 15,
                    reels: [0, 2, 4]
                }
            },
            sceneEffects: {
                types: ['normal', 'freeSpins'],
                stopTickChildren: !1,
                transition: {
                    fadeIn: {
                        duration: 0.5,
                        ease: 'power1.out'
                    },
                    fadeOut: {
                        duration: 0.5,
                        ease: 'power1.in'
                    }
                }
            },
            totalWin: {
                bangup: {
                    duration: 5
                }
            },
            jackpotWin: {
                bangup: {
                    duration: 10
                },
                rumble: {
                    duration: 4.2
                },
                delays: {
                    spawn: {
                        beforeShow: 1,
                        betweenTiles: 0.5
                    }
                },
                labels: {
                    tileWin: 'show',
                    tileIdle: 'loop'
                },
                winTilesThreshold: 3
            },
            restrictRoundCelebrations: !1,
            roundCelebrationThreshold: 0,
            extraWin: a,
            megaWaysCounter: s,
            skipStepExtraWin: h,
            freeSpinsBonusScreen: {
                counter: {
                    font: 'sumFont',
                    alignType: 'CENTER'
                },
                delays: {
                    beforeHide: 1
                }
            },
            freeSpinsStartScreen: {
                counter: {
                    font: 'sumFont',
                    alignType: 'CENTER'
                },
                countUpdate: {
                    interval: {
                        min: 0.05,
                        max: 0.4
                    }
                },
                delays: {
                    afterHide: 1
                }
            },
            freeSpinsStatus: f,
            headerBanners: {
                default: {
                    count: 6,
                    prefix: 'banner',
                    showChance: 30,
                    initial: 1,
                    showTime: 8,
                    weights: {},
                    waitHideAnimation: !0
                }
            },
            paytable: d,
            scrollablePaytable: g,
            platform: {
                resolutionThresholds: {
                    XHD: ['min', '1920px'],
                    HD: ['max', '1920px'],
                    MD: ['max', '1280px'],
                    SD: ['max', '670px'],
                    XSD: ['max', '300px']
                },
                monoSounds: ['MD', 'SD', 'XSD']
            },
            reels: p,
            wins: {
                winBar: {
                    skipMplr: 1,
                    bangupSpeed: 1.3
                },
                lines: {
                    delays: {
                        betweenLines: 0.1,
                        singleLoop: 1,
                        afterShow: 0.5
                    },
                    topOffset: 100,
                    lineOffset: 20,
                    endToEnd: !0,
                    layers: [{
                        image: 'lineFillTop',
                        width: 4,
                        alignment: 1
                    }, {
                        image: 'lineFillBottom',
                        width: 4,
                        alignment: 0
                    }, {
                        image: 'lineFill',
                        width: 2,
                        alignment: 0.5
                    }],
                    filter: {
                        enabled: !0,
                        padding: 10,
                        strength: 0.1,
                        quality: 1,
                        resolution: 2
                    }
                },
                ways: {
                    delays: {
                        betweenShows: 0
                    }
                },
                tiles: {
                    renderTexture: {
                        enabled: !0
                    }
                },
                delays: {
                    afterEnd: 1
                },
                clusters: {
                    delays: {
                        betweenShows: 0
                    },
                    frames: {
                        fadeDuration: 0.5,
                        edges: {
                            enabled: !0
                        }
                    },
                    labels: {
                        polygonPrecision: 1,
                        label: {
                            counter: {
                                font: 'sumFont',
                                alignType: 'CENTER',
                                currency: !0,
                                bangup: {
                                    duration: 0,
                                    easing: 'power2.out'
                                }
                            }
                        }
                    }
                }
            },
            centerWinBar: {
                counter: {
                    bangup: {
                        speed: 5
                    },
                    currency: !0,
                    hideDecimals: !1,
                    font: 'sumFont',
                    alignType: 'CENTER',
                    fitBounds: {},
                    ignoreRatio: !1,
                    overscale: !0
                },
                delays: {
                    beforeShow: 0.5,
                    beforeHide: 0.5
                }
            },
            camera: m,
            autoplay: {
                nextSpinDelay: {
                    win: 1,
                    noWin: 0.2
                }
            },
            cascade: {
                move: {
                    speed: 1e3,
                    ease: 'power2.in',
                    easeEnd: {
                        offset: -3,
                        speed: 15,
                        easings: ['none', 'none']
                    },
                    delays: {
                        beforeSetStart: 0.2,
                        betweenBlocks: 0.05,
                        betweenBlockSets: 0.2,
                        afterEnd: 0
                    }
                },
                drop: {
                    speed: 1e3,
                    ease: 'power2.in',
                    easeEnd: {
                        offset: -3,
                        speed: 15,
                        easings: ['none', 'none']
                    },
                    delays: {
                        beforeSetStart: 0.2,
                        betweenBlocks: 0.05,
                        betweenBlockSets: 0.2,
                        afterEnd: 0
                    }
                },
                destroy: {
                    delays: {
                        beforeSetStart: 0.2,
                        betweenBlocks: 0.05,
                        afterEnd: 0
                    },
                    replaceTile: !1
                }
            },
            throbber: {
                color: '0x07072B',
                alpha: 0.6
            },
            winWaysBar: {
                labelSpacing: {
                    left: 2,
                    right: 2
                },
                alignType: 'CENTER',
                fit: {
                    ignoreRatio: !1,
                    overscale: !1
                },
                sum: {
                    currency: !0,
                    font: 'sumFont'
                },
                waysCount: {
                    round: !0,
                    font: 'sumFont'
                },
                shadow: {
                    enabled: !1,
                    emptySpace: 0
                }
            },
            royalWheel: {
                targetPointerOffset: 0,
                spin: {
                    start: {
                        distance: 360,
                        speed: 100,
                        tweenOptions: {
                            ease: 'power3.in'
                        }
                    },
                    loop: {
                        speed: 350,
                        spinCount: {
                            min: 2,
                            max: 2
                        },
                        tweenOptions: {
                            ease: 'none'
                        }
                    },
                    end: {
                        sectorDeviation: {
                            enabled: !0,
                            offset: 3
                        },
                        speed: 100,
                        spinCount: {
                            min: 3,
                            max: 3
                        },
                        tweenOptions: {
                            ease: 'power3.out'
                        }
                    },
                    idle: {
                        speed: 5,
                        tweenOptions: {
                            ease: 'none'
                        },
                        startAfterShow: !0
                    }
                },
                sector: {
                    counter: {
                        round: !0,
                        font: 'sumFont',
                        alignType: 'CENTER',
                        letterSpacing: -40,
                        scale: 0.7,
                        defaultScale: 1
                    }
                },
                delays: {
                    beforeShow: 0.5,
                    afterShow: 0.5,
                    beforeHide: 0.5,
                    afterHide: 0.5
                }
            },
            gambleWheel: {
                targetPointerOffset: 0,
                spin: {
                    start: {
                        distance: 200,
                        speed: 100,
                        tweenOptions: {
                            ease: 'power3.in'
                        }
                    },
                    loop: {
                        speed: 350,
                        count: {
                            min: 1,
                            max: 2
                        },
                        tweenOptions: {
                            ease: 'none'
                        }
                    },
                    end: {
                        sectorDeviation: {
                            enabled: !1,
                            offset: 3
                        },
                        speed: 100,
                        tweenOptions: {
                            ease: 'power3.out'
                        }
                    },
                    idle: {
                        speed: 5,
                        tweenOptions: {
                            ease: 'none'
                        },
                        startAfterShow: !0
                    }
                },
                sector: {
                    radius: 425,
                    valueToType: {
                        0: 'loss',
                        1: 'win'
                    },
                    types: {
                        win: {
                            init: {
                                background: {
                                    color: '0x009966',
                                    alpha: 1
                                }
                            },
                            select: {
                                background: {
                                    color: '0x009966',
                                    alpha: 1
                                }
                            },
                            deselect: {
                                background: {
                                    color: '0x009966',
                                    alpha: 1
                                }
                            },
                            win: {
                                background: {
                                    color: '0x009966',
                                    alpha: 1
                                }
                            },
                            noWin: {
                                background: {
                                    color: '0x256651',
                                    alpha: 1
                                }
                            },
                            noWinHide: {
                                background: {
                                    color: '0x256651',
                                    alpha: 1
                                }
                            }
                        },
                        loss: {
                            init: {
                                background: {
                                    color: '0xCC3300',
                                    alpha: 1
                                }
                            },
                            select: {
                                background: {
                                    color: '0xCC3300',
                                    alpha: 1
                                }
                            },
                            deselect: {
                                background: {
                                    color: '0xCC3300',
                                    alpha: 1
                                }
                            },
                            win: {
                                background: {
                                    color: '0xCC3300',
                                    alpha: 1
                                }
                            },
                            noWin: {
                                background: {
                                    color: '0xa53e1c',
                                    alpha: 1
                                }
                            },
                            noWinHide: {
                                background: {
                                    color: '0xa53e1c',
                                    alpha: 1
                                }
                            }
                        }
                    }
                },
                delays: {
                    beforeShow: 0.5,
                    afterShow: 0.5,
                    beforeHide: 0.5,
                    afterHide: 0.5
                }
            },
            winExchange: {
                exchange: {
                    splash: {
                        counters: {
                            spins: {
                                containerName: 'spins',
                                counter: {
                                    font: 'sumFont',
                                    alignType: 'RIGHT'
                                }
                            },
                            amount: {
                                containerName: 'amount',
                                counter: {
                                    currency: !0,
                                    hideDecimals: !1,
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            },
                            exchange: {
                                containerName: 'exchange',
                                counter: {
                                    currency: !0,
                                    hideDecimals: !1,
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            }
                        }
                    },
                    feature: {
                        counters: {
                            spins: {
                                containerName: 'spins',
                                counter: {
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            },
                            amount: {
                                containerName: 'amount',
                                counter: {
                                    currency: !0,
                                    hideDecimals: !1,
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            },
                            exchange: {
                                containerName: 'exchange',
                                counter: {
                                    currency: !0,
                                    hideDecimals: !1,
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            }
                        }
                    },
                    choices: {
                        buttons: {
                            collect: {
                                type: 'secondary',
                                size: 'large'
                            },
                            exchange: {
                                type: 'primary',
                                size: 'large'
                            }
                        }
                    }
                },
                gamble: {
                    splash: {
                        counters: {
                            spins: {
                                containerName: 'spins',
                                counter: {
                                    font: 'sumFont',
                                    alignType: 'RIGHT'
                                }
                            },
                            amount: {
                                containerName: 'amount',
                                counter: {
                                    currency: !0,
                                    hideDecimals: !1,
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            }
                        }
                    },
                    wheel: {
                        targetPointerOffset: 0,
                        spin: {
                            start: {
                                distance: 200,
                                speed: 100,
                                tweenOptions: {
                                    ease: 'power3.in'
                                }
                            },
                            loop: {
                                speed: 350,
                                count: {
                                    min: 1,
                                    max: 2
                                },
                                tweenOptions: {
                                    ease: 'none'
                                }
                            },
                            end: {
                                sectorDeviation: {
                                    enabled: !1,
                                    offset: 3
                                },
                                speed: 100,
                                tweenOptions: {
                                    ease: 'power3.out'
                                }
                            },
                            idle: {
                                speed: 5,
                                tweenOptions: {
                                    ease: 'none'
                                },
                                startAfterShow: !0
                            }
                        },
                        sector: {
                            radius: 425,
                            valueToType: {
                                0: 'loss',
                                1: 'win'
                            },
                            types: {
                                win: {
                                    init: {
                                        background: {
                                            color: '0x009966',
                                            alpha: 1
                                        }
                                    },
                                    select: {
                                        background: {
                                            color: '0x009966',
                                            alpha: 1
                                        }
                                    },
                                    deselect: {
                                        background: {
                                            color: '0x009966',
                                            alpha: 1
                                        }
                                    },
                                    win: {
                                        background: {
                                            color: '0x009966',
                                            alpha: 1
                                        }
                                    },
                                    noWin: {
                                        background: {
                                            color: '0x256651',
                                            alpha: 1
                                        }
                                    },
                                    noWinHide: {
                                        background: {
                                            color: '0x256651',
                                            alpha: 1
                                        }
                                    }
                                },
                                loss: {
                                    init: {
                                        background: {
                                            color: '0xCC3300',
                                            alpha: 1
                                        }
                                    },
                                    select: {
                                        background: {
                                            color: '0xCC3300',
                                            alpha: 1
                                        }
                                    },
                                    deselect: {
                                        background: {
                                            color: '0xCC3300',
                                            alpha: 1
                                        }
                                    },
                                    win: {
                                        background: {
                                            color: '0xCC3300',
                                            alpha: 1
                                        }
                                    },
                                    noWin: {
                                        background: {
                                            color: '0xa53e1c',
                                            alpha: 1
                                        }
                                    },
                                    noWinHide: {
                                        background: {
                                            color: '0xa53e1c',
                                            alpha: 1
                                        }
                                    }
                                }
                            }
                        },
                        delays: {
                            beforeShow: 0.5,
                            afterShow: 0.5,
                            beforeHide: 0.5,
                            afterHide: 0.5
                        }
                    },
                    status: {
                        counters: {
                            win: {
                                containerName: 'gamble.win',
                                counter: {
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            },
                            amount: {
                                containerName: 'amount',
                                counter: {
                                    currency: !0,
                                    hideDecimals: !1,
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            },
                            noWin: {
                                containerName: 'gamble.noWin',
                                counter: {
                                    font: 'sumFont',
                                    alignType: 'CENTER'
                                }
                            }
                        }
                    },
                    choices: {
                        buttons: {
                            collect: {
                                type: 'secondary',
                                size: 'large'
                            },
                            gamble: {
                                type: 'primary',
                                size: 'large'
                            }
                        }
                    },
                    delays: {
                        win: 1,
                        noWin: 0.5
                    }
                },
                delays: {
                    beforeStart: 0.5,
                    beforEnd: 0.5,
                    afterEnd: 0.5
                }
            }
        }, 'scrollablePaytable', g), 'featureBuy', {
            excludeDataFromPrevRounds: !1
        }))
    },
    './src/core/features/ParticlesContainer.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return x
        })
        const r = n('./src/core/utils/particles.js')
        const i = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const o = n('./src/core/utils/constants.js')
        const a = n('./src/core/utils/CombinedTicker.js')

        function s(t) {
            return (s = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const u = ['duration', 'force']
        const c = ['instant']
        const l = ['life']

        function h(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function f(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function d(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        f(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        f(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function p(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function m(t, e, n) {
            return e = y(e),
            (function (t, e) {
                if (e && (s(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], y(t).constructor)
                : e.apply(t, n)))
        }

        function y(t) {
            return (y = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function v(t, e) {
            return (v = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function _(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function g(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? _(new Object(n), !0).forEach((e) => {
                            b(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : _(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function b(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const E = g({}, o.a)
        var x = (function (t) {
            function e(t) {
                let n; const r = t.source
                let i = t.guide
                let o = t.config
                let a = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = m(this, e)).isEmitting = !1, n.isActive = !1, n.mask = a, n._emitterGuide = i, n._particlesSource = r, n._emittersData = [], n._config = o, n
            }
            let n, i, o, s, f, y
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && v(t, e)
            }(e, t)), n = e, i = [{
                key: 'activate',
                value: (y = d(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i; let o; let s; let c; let l; const f = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (e = f.length > 0 && void 0 !== f[0] ? f[0] : {}, n = e.duration, r = e.force, i = void 0 !== r && r, o = h(e, u), i || this._canActivate()) {
                                    t.next = 3
                                            break
                                }
                                return t.abrupt('return');
                            case 3:
                                if (s = this._createEmitter(g(g({}, o), {}, {
                                    life: n
                                })), c = s.emitter, l = s.container, this.addChild(l), this._emittersData.push({
                                    emitter: c,
                                    container: l
                                }), c.emit(), this.isActive = !0, this.isEmitting = !0, this.emit(E.ACTIVATE_START), !n || a.a.Ticker.isLowFPS) {
                                    t.next = 17
                                            break
                                }
                                return t.next = 13, this._waitForParticlesDead({
                                    container: l
                                })
                                    case 13:
                                this._remove(l), this._updateEmittersData(o), this.isEmitting = !1, this.isActive = !1
                                    case 17:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return y.apply(this, arguments)
                })
            }, {
                key: 'deactivate',
                value: (f = d(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; const i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (e = i.length > 0 && void 0 !== i[0] ? i[0] : {}, n = e.instant, r = h(e, c), this._emittersData.length) {
                                    t.next = 3
                                            break
                                }
                                return t.abrupt('return');
                            case 3:
                                return this.emit(E.DEACTIVATE_START), this.isEmitting = !1, t.next = 7, this._destroyAll(n)
                                    case 7:
                                this._updateEmittersData(r), this.isActive = !1
                                    case 9:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return f.apply(this, arguments)
                })
            }, {
                key: 'reset',
                value() {
                    this._destroyAll(!0), this._emittersData = [], this.isActive = !1, this.isEmitting = !1
                }
            }, {
                key: '_createEmitter',
                value(t) {
                    const e = t.life
                    var n = (h(t, l), new Object(r.a)(g(g({}, this._config.emitter), {}, {
                        emitterGuide: this._emitterGuide,
                        source: this._particlesSource
                    })))
                    var i = n.emitter
                    var o = n.container
                    return i.life = e, {
                        emitter: i,
                        container: o
                    }
                }
            }, {
                key: '_updateEmittersData',
                value(t) {
                    this._emittersData = this._emittersData.filter((t) => {
                        return !t.emitter.dead
                    })
                }
            }, {
                key: '_canActivate',
                value() {
                    return !this._emittersData.some((t) => {
                        let e = t.emitter
                        return e.life === 1 / 0 && !e.dead
                    }) && !a.a.Ticker.isLowFPS
                }
            }, {
                key: '_destroyAll',
                value(t) {
                    const e = this
                    return Promise.all(this._emittersData.map((n) => {
                        return e._destroyEmitter(n, t)
                    }))
                }
            }, {
                key: '_destroyEmitter',
                value: (s = d(regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; const o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (n = e.emitter, r = e.container, i = o.length > 1 && void 0 !== o[1] && o[1], n.destroy(), i) {
                                    t.next = 6
                                            break
                                }
                                return t.next = 6, this._waitForParticlesDead({
                                    container: r
                                })
                                    case 6:
                                this._remove(r)
                                    case 7:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_waitForParticlesDead',
                value(t) {
                    const e = t.container
                    return new Promise((t) => {
                        e.once('destroyed', () => {
                            return t()
                        })
                    })
                }
            }, {
                key: '_remove',
                value(t) {
                    t.destroy()
                }
            }], o = [{
                key: 'events',
                get() {
                    return E
                }
            }], i && p(n.prototype, i), o && p(n, o), e
        }(i.Container))
    },
    './src/core/features/covers/Cover.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return E
        })
        const r = n('./src/core/utils/index.js')
        const i = n('./src/core/utils/constants.js')
        const o = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const a = n('./src/core/utils/Cache.js')
        const s = n('./src/core/utils/CombinedTicker.js')

        function u(t) {
            return (u = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function c(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function l(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        c(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        c(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function h(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function f(t, e, n) {
            return e = p(e),
            (function (t, e) {
                if (e && (u(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], p(t).constructor)
                : e.apply(t, n)))
        }

        function d(t, e, n) {
            return (d = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = p(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function p(t) {
            return (p = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function m(t, e) {
            return (m = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function y(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function v(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? y(new Object(n), !0).forEach((e) => {
                            _(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : y(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function _(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const g = {
            INIT: 'init',
            SHOW: 'show',
            HIDE: 'hide'
        }
        const b = v(v({}, i.a), {}, {
            PLAY_ANIM_START: 'cover_play_anim_start',
            PLAY_ANIM_END: 'cover_play_anim_end'
        })
        var E = (function (t) {
            function e(t) {
                let n; const r = t.name
                let i = void 0 === r ? 'Cover' : r
                let o = t.animation
                let a = t.config
                let s = void 0 === a ? {} : a
                let u = t.mask
                let c = void 0 === u ? null : u
                let l = t.data
                let h = void 0 === l ? {} : l
                let d = t.stopTickChildren
                let p = t.rtMode
                let m = void 0 !== p && p
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = f(this, e)).name = i, n.mask = c, n._data = h, n._config = s, n._rtMode = m, n._isShown = !1, n._isShowing = !1, n._isHiding = !1, n._loopsCount = null, n._rtSprite = null, n._rtTickUpdater = null, n._anim = null, n._createAnim(o), n._init({
                    stopTickChildren: m || d || s.stopTickChildren
                }), n
            }
            let n, i, u, c, y, _, E, x, T, S
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && m(t, e)
            }(e, t)), n = e, i = [{
                key: 'rtMode',
                get() {
                    return this._rtMode
                }
            }, {
                key: 'data',
                get() {
                    return this._data
                }
            }, {
                key: 'anim',
                get() {
                    return this._anim
                }
            }, {
                key: 'isShown',
                get() {
                    return this._isShown
                }
            }, {
                key: 'isShowing',
                get() {
                    return this._isShowing
                }
            }, {
                key: 'isPlaying',
                get() {
                    return !this._anim.paused
                }
            }, {
                key: 'isHiding',
                get() {
                    return this._isHiding
                }
            }, {
                key: 'show',
                value: (S = l(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; const s = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if ((n = s.length > 0 && void 0 !== s[0] ? s[0] : {}).force || !this._isShowing && !this._isShown) {
                                    t.next = 3
                                            break
                                }
                                return t.abrupt('return');
                            case 3:
                                return r = n.animLabel, i = void 0 === r ? e.animLabels.SHOW : r, o = n.removeAtEnd, a = void 0 !== o && o, this._isShowing = !0, this._rtMode || this._anim.parent || this.addChild(this._anim), this.emit(e.events.SHOW_START, {
                                    label: i
                                }), t.next = 9, this.play(i, n)
                                    case 9:
                                this._isShowing = !1, this._isShown = !0, this.emit(e.events.SHOW_END, {
                                    label: i
                                }), a && this.remove()
                                    case 13:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return S.apply(this, arguments)
                })
            }, {
                key: 'hide',
                value: (T = l(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s; let u; const c = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if ((n = c.length > 0 && void 0 !== c[0] ? c[0] : {}).force || (this._isShown || this._isShowing) && !this._isHiding) {
                                    t.next = 3
                                            break
                                }
                                return t.abrupt('return');
                            case 3:
                                return r = n.animLabel, i = void 0 === r ? e.animLabels.HIDE : r, o = n.stopTickChildren, a = void 0 !== o && o, s = n.removeAtEnd, u = void 0 === s || s, this._isHiding = !0, this.emit(e.events.HIDE_START, {
                                    label: i
                                }), t.next = 8, this.play(i, v({
                                    stopTickChildren: a
                                }, n))
                                    case 8:
                                this._isHiding = !1, this._isShown = !1, this.emit(e.events.HIDE_END, {
                                    label: i
                                }), u && this.remove()
                                    case 12:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return T.apply(this, arguments)
                })
            }, {
                key: 'play',
                value: (x = l(regeneratorRuntime.mark(function t(n) {
                    let r; let i; let o; const a = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (r = a.length > 1 && void 0 !== a[1] ? a[1] : {}, this._isValid(n)) {
                                    t.next = 3
                                            break
                                }
                                return t.abrupt('return');
                            case 3:
                                return i = r.stopTickChildren, o = void 0 !== i && i, this._rtMode || this._anim.parent || this.addChild(this._anim), this.emit(e.events.PLAY_ANIM_START, {
                                    label: n
                                }), t.next = 8, this._playAnimation(n, r)
                                    case 8:
                                o && this._anim.stopTick(!0), this.emit(e.events.PLAY_ANIM_END, {
                                    label: n
                                })
                                    case 10:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t) {
                    return x.apply(this, arguments)
                })
            }, {
                key: 'stop',
                value: (E = l(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; const i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return e = i.length > 0 && void 0 !== i[0] ? i[0] : {}, n = e.stopTickChildren, r = void 0 === n || n, t.next = 4, this._exec(function(t) {
                                            t.promises.stop(), r && t.stopTick(!0)
                                        });
                            case 4:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return E.apply(this, arguments)
                })
            }, {
                key: 'finish',
                value: (_ = l(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; const i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (e = i.length > 0 && void 0 !== i[0] ? i[0] : {}, !this._anim.paused) {
                                    t.next = 3
                                            break
                                }
                                return t.abrupt('return');
                            case 3:
                                return n = e.stopTickChildren, r = void 0 === n || n, t.next = 6, this._exec(function(t) {
                                            return t.promises.finish()
                                        });
                            case 6:
                                r && this._anim.stopTick(!0)
                                    case 7:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return _.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value: (y = l(regeneratorRuntime.mark(function t() {
                    let e, n, r, i, o
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                e = this.anim, n = e.currentLabel, r = e.totalFrames, i = this._getNextLabel(n), o = (i == null ? void 0 : i.position) - 1 || r - 1, this.anim.promises.stop(), this.anim.promises.gotoAndStop(o)
                                    case 5:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return y.apply(this, arguments)
                })
            }, {
                key: 'remove',
                value() {
                    this.removeChild(this._anim), this._removeTickUpdater(), this._reset()
                }
            }, {
                key: 'destroy',
                value() {
                    let t; const n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    var r = n.children
                    var i = void 0 === r || r
                    var o = n.destroyAnim
                    var a = void 0 === o || o
                    this._rtSprite && (this._rtSprite.destroy(!0), this._rtSprite = null), a && ((t = this._anim) === null || void 0 === t || t.destroy()), d(p(e.prototype), 'destroy', this).call(this, {
                        children: i
                    }), this._removeTickUpdater(), this._rtTickUpdater = null, this._anim = null, this._data = null, this._config = null
                }
            }, {
                key: 'generateRenderTexture',
                value(t) {
                    const e = t.padding
                    var n = new Object(a.e)(this._anim, e)
                    var r = n.texture
                    var i = n.pivot
                    var o = i.x
                    var s = i.y
                    var u = n.tickUpdater
                    return this.x += o, this.y += s, {
                        source: this._anim,
                        texture: r,
                        pivot: {
                            x: -o,
                            y: -s
                        },
                        tickUpdater: u
                    }
                }
            }, {
                key: 'applyTexture',
                value(t) {
                    const e = t.texture
                    var n = t.source
                    var r = t.pivot
                    var i = t.tickUpdater
                    var o = this._createRtSprite({
                        texture: e,
                        source: n,
                        pivot: r
                    })
                    this._rtTickUpdater = i, this.stop({
                        stopTickChildren: !0
                    }), this.removeChild(this._anim), this.addChild(o), this._rtSprite = o, this._rtMode = !0
                }
            }, {
                key: 'removeTexture',
                value() {
                    this._rtMode && (this._removeTickUpdater(), this.removeChild(this._rtSprite), this.addChild(this._anim), this._rtTickUpdater = null, this._rtMode = !1, this._restoreAnimation())
                }
            }, {
                key: '_playAnimation',
                value(t, e) {
                    return this._loopsCount = e.repeat, this._exec((n) => {
                        return n.promises.gotoAndPlay(t, e)
                    })
                }
            }, {
                key: '_restoreAnimation',
                value: (c = l(regeneratorRuntime.mark(function t() {
                    let e
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if ((e = this._rtSprite.animSource).paused) {
                                    t.next = 9
                                            break
                                }
                                return t.next = 4, this._anim.promises.gotoAndPlay(e.currentFrame)
                                    case 4:
                                return t.next = 6, this._anim.promises.stop()
                                    case 6:
                                this._anim.promises.gotoAndPlay(e.currentLabel, {
                                    repeat: this._loopsCount
                                }), t.next = 10
                                        break;
                            case 9:
                                this._anim.promises.gotoAndStop(e.currentFrame)
                                    case 10:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: '_removeTickUpdater',
                value() {
                    this._rtTickUpdater && s.a.Ticker.remove(this._rtTickUpdater)
                }
            }, {
                key: '_createAnim',
                value(t) {
                    try {
                        this._anim = new t()
                    } catch (t) {
                        console.error('"[Cover]('.concat(this.name, ')" ==> Failed to create movieClip!')), console.error(t)
                    }
                }
            }, {
                key: '_createRtSprite',
                value(t) {
                    const e = t.texture
                    var n = t.source
                    var r = t.pivot
                    var i = this._rtSprite
                    return i ? i.texture = e : i = new o.Sprite(e), i.animSource = n, i.pivot.set(r.x, r.y), i
                }
            }, {
                key: '_exec',
                value(t) {
                    return t(this._rtMode ? this._rtSprite.animSource : this._anim)
                }
            }, {
                key: '_init',
                value() {
                    const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    var n = t.stopTickChildren
                    var i = void 0 === n || n
                    if (this._anim.promises.gotoAndStop) {
                        const o = new Object(r.j)(this._anim, e.animLabels.INIT) ? e.animLabels.INIT : 0
                        this._anim.promises.gotoAndStop(o)
                    }
                    i && this._anim.stopTick(!0)
                }
            }, {
                key: '_isValid',
                value(t) {
                    return !(!this._hasFrame(this._anim, t) && !new Object(r.j)(this._anim, t) && (console.warn('"'.concat(this.name, '" ==> Missing animation state: ').concat(t)), 1))
                }
            }, {
                key: '_hasFrame',
                value(t, e) {
                    return !!Number.isInteger(e) && e >= 0 && e < t.totalFrames
                }
            }, {
                key: '_getNextLabel',
                value(t) {
                    const e = this.anim.labels
                    var n = e.find((e) => {
                        return e.label === t
                    })
                    var r = e.indexOf(n)
                    return e[r + 1]
                }
            }, {
                key: '_reset',
                value() {
                    this._isShown = !1, this._isShowing = !1, this._isHiding = !1, this._rtMode = !1
                }
            }], u = [{
                key: 'events',
                get() {
                    return b
                }
            }, {
                key: 'animLabels',
                get() {
                    return g
                }
            }], i && h(n.prototype, i), u && h(n, u), e
        }(o.Container))
    },
    './src/core/features/covers/SpineCover.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return h
        })
        const r = n('./src/core/features/covers/Cover.js')
        const i = n('./node_modules/pixi-spine/lib/all.es.js')
        const o = n('./src/core/utils/SpineUpdater.js')

        function a(t) {
            return (a = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function s(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function u(t, e, n) {
            return e = c(e),
            (function (t, e) {
                if (e && (a(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], c(t).constructor)
                : e.apply(t, n)))
        }

        function c(t) {
            return (c = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function l(t, e) {
            return (l = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        var h = (function (t) {
            function e(t) {
                let n
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = u(this, e, [t]))._attachChildListeners(), n
            }
            let n, r, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && l(t, e)
            }(e, t)), n = e, (r = [{
                key: 'isPlaying',
                get() {
                    return !!this._anim.state.getCurrent(0)
                }
            }, {
                key: 'play',
                value(t) {
                    const e = this
                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    if (!this._hasAnimation(this._anim, t)) return console.warn('['.concat(this.name, '] Missing animation: ').concat(t)), Promise.resolve()
                    let r = 0
                    var i = n.repeat
                    var o = void 0 === i ? 0 : i
                    return new Promise((n) => {
                        e._anim.parent || e.addChild(e._anim), e._anim.state.setAnimation(0, t, o), e._anim.state.addListener({
                            complete (t) {
                                o >= 0 ? ++r !== o && o !== 0 || (t.loop = !1, e._stopEntry(t), e._removeAnimListeners('complete'), n()) : (e._removeAnimListeners('complete'), n())
                            }
                        })
                    })
                }
            }, {
                key: 'stop',
                value() {
                    this._anim.state.tracks.forEach(this._stopEntry, this)
                }
            }, {
                key: 'finish',
                value() {
                    const t = this
                    return new Promise((e) => {
                        t._anim.state.addListener({
                            complete () {
                                t._anim.state.tracks.forEach(function(n, r, i) {
                                        var o = r === i.length - 1;
                                        t._stopEntry(n), o && t._removeAnimListeners("complete"), e()
                                    })
                            }
                        })
                    })
                }
            }, {
                key: 'skip',
                value() {
                    const t = this.anim.state.tracks[0]
                    t && (t.trackTime = t.trackEnd)
                }
            }, {
                key: 'getCurrentAnimation',
                value() {
                    return this.anim.state.tracks.length ? this.anim.state.tracks[0].animation.name : null
                }
            }, {
                key: '_stopEntry',
                value(t) {
                    t && this._anim.state.clearTrack(t.trackIndex)
                }
            }, {
                key: '_createAnim',
                value(t) {
                    try {
                        this._anim = new i.d(t), this._anim.autoUpdate = !1, this._anim.update(0)
                    } catch (t) {
                        console.error('[SpineCover]('.concat(this.name, ') Failed to create movieClip')), console.error(t)
                    }
                }
            }, {
                key: '_hasAnimation',
                value(t) {
                    const e = t.spineData.animations
                    if (!Array.isArray(e)) return !1
                    for (var n = e.map((t) => {
                            return t.name
                        }), r = arguments.length, i = Array.from({ length: r > 1 ? r - 1 : 0 }), o = 1; o < r; o++) i[o - 1] = arguments[o]
                    return i.every((t) => {
                        return n.includes(t)
                    })
                }
            }, {
                key: '_removeAnimListeners',
                value(t) {
                    this._anim.state.listeners = this._anim.state.listeners.filter((e) => {
                        return !e[t]
                    })
                }
            }, {
                key: '_attachChildListeners',
                value() {
                    this.on('childAdded', this._onChildAdded), this.on('childRemoved', this._onChildRemoved)
                }
            }, {
                key: '_onChildAdded',
                value(t) {
                    t instanceof i.d && o.a.add(t)
                }
            }, {
                key: '_onChildRemoved',
                value(t) {
                    t instanceof i.d && o.a.remove(t)
                }
            }]) && s(n.prototype, r), a && s(n, a), e
        }(r.a))
    },
    './src/core/features/reels/TilesGenerator.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return h
        })
        const r = n('./node_modules/ramda/es/isEmpty.js')
        const i = n('./node_modules/ramda/es/times.js')
        const o = n('./node_modules/ramda/es/always.js')
        const a = n('./node_modules/ramda/es/flatten.js')
        const s = n('./src/core/utils/index.js')

        function u(t) {
            return (function (t) {
                if (Array.isArray(t)) return c(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return c(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return c(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function c(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function l(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        var h = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this._cachedSpinnableTilesIds = {}, this.spinnableTilesIds = {}, this._isStacked = !1, this._stack = {}
            }
            let e, n, c
            return e = t, (n = [{
                key: 'isStacked',
                get() {
                    return this._isStacked
                }
            }, {
                key: 'enableStack',
                value(t) {
                    const e = t.stacked
                    var n = void 0 === e ? {} : e
                    var i = t.index
                    if (new Object(r.a)(n) || !n.tiles || new Object(r.a)(n.tiles)) return this._isStacked = !1, console.error('Invalid stacked configuration '.concat(n, '.'))
                    if (Number(i) !== i) return this._isStacked = !1, console.error('Invalid reel index '.concat(i, ' for enabling stack.'))
                    if (this._hasSpinnableTiles({
                        index: i
                    })) {
                        const o = new Object(s.m)(this.spinnableTilesIds[i])
                        this._stack[i] = {
                            enabled: !0,
                            cfg: new Object(s.c)(n),
                            stackSize: 0,
                            stackTileId: o,
                            prevTileId: o
                        }, this._isStacked = Object.values(this._stack).every((t) => {
                            return t.enabled
                        })
                    } else { this._isStacked = !1
                    }
                }
            }, {
                key: 'disableStack',
                value() {
                    this._isStacked = !1
                }
            }, {
                key: 'setSpinnableTiles',
                value(t) {
                    const e = t.index
                    var n = t.tiles
                    var r = t.cache
                    var i = void 0 !== r && r
                    return Number(e) !== e ? console.error('Invalid reel specified '.concat(e, ' for setting spinnable tile ids')) : Array.isArray(n) && n.length !== 0 ? (this.spinnableTilesIds[e] = new Object(s.c)(n), void (i && (this._cachedSpinnableTilesIds[e] = new Object(s.c)(n)))) : console.error('Invalid spinnable tiles argument for reel '.concat(e, ' ').concat(n))
                }
            }, {
                key: 'resetSpinnableTiles',
                value(t) {
                    const e = t.index
                    return Number(e) !== e ? console.error('Invalid reel specified '.concat(e, ' for resetting spinnable tile ids')) : this._cachedSpinnableTilesIds[e] ? void (this.spinnableTilesIds[e] = new Object(s.c)(this._cachedSpinnableTilesIds[e])) : console.error('Missing cached spinnable tile ids for reel '.concat(e, ', ').concat(this._cachedSpinnableTilesIds[e]))
                }
            }, {
                key: 'generateRandomTiles',
                value(t) {
                    let e = t.count
                    var n = t.index
                    if (this._hasSpinnableTiles({
                        index: n
                    })) {
                        if (this._isStacked) { return this._generateStackedTiles({
                            count: e,
                            index: n
                        })
                        }
                        for (var r = []; e > 0;) {
                            const i = new Object(s.m)(this.spinnableTilesIds[n], e)
                            r = r.concat(i), e -= i.length
                        }
                        return r
                    }
                }
            }, {
                key: 'generateRandomScreens',
                value(t) {
                    const e = this
                    var n = t.count
                    var r = t.index
                    var a = t.minTileSize
                    var c = t.maxTileSize
                    return new Object(i.a)(() => {
                        let t = new Object(s.i)(a, c)
                                var n = e.generateRandomTiles({
                            count: t,
                            index: r
                        })
                                var l = new Object(i.a)(new Object(o.a)(0), c - t)
                        return [].concat(u(n), u(l))
                    }, n)
                }
            }, {
                key: 'addToSpinnableTiles',
                value(t) {
                    const e = this
                    var n = t.tiles
                    var r = t.tileId
                    var i = t.frequency
                    var o = t.index
                    var u = t.cache
                    var c = void 0 !== u && u
                    if (this._hasSpinnableTiles({
                        index: o
                    })) { return (n || [{
                        tileId: r,
                        frequency: i
                    }]).forEach((t) => {
                        var n = t.tileId;
                                var r = t.frequency;
                                var i = r > 0 ? r : 1;
                                var u = e.spinnableTilesIds[o].filter(function(t) {
                                    return t !== n
                                });
                        if (i < 1) {
                            var c = Math.round(1 / i);
                                    var l = new Object(a.a)(u.map(function(t) {
                                        return Object(s.k)(c, (function() {
                                            return t
                                        }))
                                    }))
                                e.spinnableTilesIds[o] = l, e.spinnableTilesIds[o].push(n)
                        } else {
                            e.spinnableTilesIds[o] = u
                                for (let h = 0; h < i; h++) e.spinnableTilesIds[o].push(n)
                        }
                    }), c && (this._cachedSpinnableTilesIds[o] = this.spinnableTilesIds[o]), this.spinnableTilesIds[o]
                    }
                }
            }, {
                key: '_generateStackedTiles',
                value(t) {
                    const e = this
                    var n = t.count
                    var r = t.index
                    if (this._hasSpinnableTiles({
                        index: r
                    })) {
                        const o = []
                        return new Object(i.a)(() => {
                            if (e._shouldResetStack({
                                index: r,
                                tileId: e._stack[r].stackTileId
                            })) {
                                let t = e._stack[r].cfg.tiles[e._stack[r].stackTileId] && e._stack[r].cfg.tiles[e._stack[r].stackTileId].min > 1
                                        var n = e._stack[r].cfg.stackSingleTiles || t
                                    ? e.spinnableTilesIds[r]
                                    : e.spinnableTilesIds[r].filter((t) => {
                                            return t !== e._stack[r].stackTileId
                                        })
                                e._stack[r].prevTileId = e._stack[r].stackTileId, e._stack[r].stackTileId = new Object(s.m)(n), e._stack[r].stackSize = 0
                            }
                            o.unshift(e._stack[r].stackTileId), e._stack[r].stackSize += 1
                        }, n), o
                    }
                }
            }, {
                key: '_shouldResetStack',
                value(t) {
                    const e = t.index
                    var n = t.tileId
                    var r = {
                        min: 1,
                        max: 1
                    }
                    return this._stack[e].cfg.tiles[n] && (r.min = this._stack[e].cfg.tiles[n].min || 1, r.max = this._stack[e].cfg.tiles[n].max || 1), this._stack[e].stackSize === 1 && new Object(s.b)(this._stack[e].cfg.singleTileChance || 0) || this._stack[e].stackSize >= r.max || this._stack[e].stackSize >= new Object(s.i)(r.min, r.max)
                }
            }, {
                key: '_hasSpinnableTiles',
                value(t) {
                    const e = t.index
                    var n = Array.isArray(this.spinnableTilesIds[e]) && this.spinnableTilesIds[e].length > 0
                    return n || console.error('There are no spinnable tiles set for reel '.concat(e)), n
                }
            }]) && l(e.prototype, n), c && l(e, c), t
        }())
    },
    './src/core/features/reels/animations/Animation.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return h
        })
        const r = n('./node_modules/@games/dope/src/Dopamine.js')

        function i(t) {
            return (i = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function o(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function a(t, e, n) {
            return e = s(e),
            (function (t, e) {
                if (e && (i(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], s(t).constructor)
                : e.apply(t, n)))
        }

        function s(t) {
            return (s = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function u(t, e) {
            return (u = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const c = {
            ANIMATION_UPDATE: 'animation_update',
            ANIMATION_SPIN_STARTING: 'animation_starting',
            ANIMATION_SPINNING: 'animation_spinning',
            ANIMATION_STOPPING: 'animation_stopping',
            ANIMATION_SPIN_ENDING: 'animation_ending',
            ANIMATION_SPIN_END: 'animation_end'
        }
        const l = {}
        var h = (function (t) {
            function e(t) {
                let n; const r = t.renderer
                let i = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = a(this, e))._index = r.index, n._renderer = r, n._config = i, n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && u(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return c
                }
            }, {
                key: 'labels',
                get() {
                    return l
                }
            }], (r = [{
                key: 'renderer',
                get() {
                    return this._renderer
                }
            }, {
                key: 'index',
                get() {
                    return this._index
                }
            }, {
                key: 'config',
                get() {
                    return this._config
                }
            }, {
                key: 'start',
                value(t) {
                    throw new Error('Subclass MUST override "start(config)" with its OWN custom logic!')
                }
            }, {
                key: 'stop',
                value(t, e) {
                    throw new Error('Subclass MUST override "stop(data, config)" with its OWN custom logic!')
                }
            }]) && o(n.prototype, r), i && o(n, i), e
        }(r.b))
    },
    './src/core/features/reels/animations/SpinningAnimation.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return m
        })
        const r = n('./src/core/features/reels/animations/Animation.js')
        const i = n('./node_modules/@games/gsap/all.js')
        const o = n('./src/core/utils/Timer.js')

        function a(t) {
            return (a = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function s(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function u(t, e, n) {
            return e = c(e),
            (function (t, e) {
                if (e && (a(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], c(t).constructor)
                : e.apply(t, n)))
        }

        function c(t) {
            return (c = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function l(t, e) {
            return (l = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function h(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function f(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const d = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? h(new Object(n), !0).forEach((e) => {
                            f(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : h(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, r.a.events))
        let p = {
            NONE: 'none',
            EASE_START: 'easeStart',
            SPINNING: 'spinning',
            STOPPING: 'stopping',
            EASE_END: 'easeEnd'
        }
        var m = (function (t) {
            function e(t) {
                let n; const r = t.renderer
                let i = t.config
                let o = t.tileHeight
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = u(this, e, [{
                    renderer: r,
                    config: i
                }])).buffer = r.buffer, n._tileHeight = o, n._initialConfig = i, n.timeline = null, n.tween = null, n.isStarting = !1, n.isSpinning = !1, n.isStopping = !1, n.isLocked = !1, n._inInstantStop = !1, n._lastEvent = null, n._reelSpinningListener = null, n._timeScaleTween = null, n.LOOPING_DISTANCE = n._initialConfig.minDistance, n._reset(), n
            }
            let n, r, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && l(t, e)
            }(e, t)), n = e, a = [{
                key: 'events',
                get() {
                    return d
                }
            }, {
                key: 'labels',
                get() {
                    return p
                }
            }], (r = [{
                key: 'label',
                get() {
                    return this.timeline && this.timeline.currentLabel() || e.labels.NONE
                }
            }, {
                key: 'start',
                value() {
                    this.isStarting = !0, this._doStart()
                }
            }, {
                key: 'stop',
                value(t) {
                    let n = this
                    if (!this.isStarting) return console.error('I\'m not started yet, reel:', this._index)
                    if (this.isStopping) return console.error('I\'m already stopping, reel:', this._index)
                    this.isStopping = !0
                    let r = this._config.delay / this._config.speed + this.getEaseStartTime()
                    this._lastEvent === e.events.ANIMATION_SPIN_STARTING
                        ? (this._timer = new o.a(), this._timer.start(), this._reelSpinningListener = function () {
                                let e = n._timer.stop()
                                n._reelSpinningListener = null, n._onStop(r - e, t)
                            }, this.once(e.events.ANIMATION_SPINNING, this._reelSpinningListener, this))
                        : this._lastEvent === e.events.ANIMATION_SPINNING ? this._onStop(r, t) : console.error('Well this should never happen!', this._lastEvent), this._config.autoStopInstantly && this.stopInstant(t)
                }
            }, {
                key: 'stopInstant',
                value(t) {
                    if (!this.isStarting) return console.error('I\'m not started yet, reel:', this._index)
                    if (!this.isStopping) return console.error('I\'m not stopping yet, reel:', this._index)
                    this._reelSpinningListener && (this.off(e.events.ANIMATION_SPINNING, this._reelSpinningListener), this._reelSpinningListener = null, this._timer.stop())
                    let n = this._initialConfig.instantStop.speedUpReels
                    var r = n.enabled
                    switch (r && this.setTimeScale(n.speedFactor, n.switchDuration), this.timeline.currentLabel()) {
                        case e.labels.EASE_START:
                            this._dispatch(e.events.ANIMATION_SPINNING), this._onStop(0, t), r || this.timeline.seek(e.labels.EASE_END, !1)
                            break
                        case e.labels.SPINNING:
                            console.warn('Invalid reel with index '.concat(this._index, ' timeline label, please investigate: ').concat(JSON.stringify(this.timeline.labels), '.'))
                            break
                        case e.labels.STOPPING:
                            r || this.timeline.seek(e.labels.EASE_END, !1)
                            break
                        case e.labels.EASE_END:
                    }
                    this._inInstantStop = !0
                }
            }, {
                key: 'setTimeScale',
                value(t, e) {
                    if (!this._inInstantStop) {
                        let n = this._initialConfig.instantStop.speedUpReels.overwrite
                        this._timeScaleTween = i.b.to(this.timeline, {
                            duration: e,
                            timeScale: t,
                            overwrite: n
                        })
                    }
                }
            }, {
                key: 'lock',
                value() {
                    this.isLocked = !0
                }
            }, {
                key: 'unlock',
                value() {
                    this.isLocked = !1
                }
            }, {
                key: '_reset',
                value() {
                    let t = ['power1.out', 'power1.in']
                    var e = ['power1.out', 'power1.in']
                    this._initialConfig.easeStart.easings && (this._initialConfig.easeStart.easings.length === 0 || this._initialConfig.easeStart.easings.length > 2 ? console.error('Invalid easing start configuration '.concat(this._initialConfig.easeStart.easings)) : t = this._initialConfig.easeStart.easings), this._initialConfig.easeEnd.easings && (this._initialConfig.easeEnd.easings.length !== 2 ? console.error('Invalid easing end configuration '.concat(this._initialConfig.easeEnd.easings)) : e = this._initialConfig.easeEnd.easings), this.LOOPING_DISTANCE = this._initialConfig.minDistance, this._config = {
                        delay: this._index * this._initialConfig.delay.atStart,
                        speed: this._initialConfig.speed,
                        distance: this._initialConfig.minDistance + this._initialConfig.delay.atEnd * this._index,
                        easeStartOffset: this._initialConfig.easeStart.offset,
                        easeEndOffset: this._initialConfig.easeEnd.offset,
                        easeStartSpeed: this._initialConfig.easeStart.speed,
                        easeEndSpeed: this._initialConfig.easeEnd.speed,
                        easeStartEasings: t,
                        easeEndEasings: e,
                        autoExpandBuffer: !0,
                        autoStopInstantly: !1,
                        autoExpandTilesCount: Number.isInteger(this._initialConfig.autoExpandTilesCount) && this._initialConfig.autoExpandTilesCount > 0 ? this._initialConfig.autoExpandTilesCount : 1
                    }, this.timeline && (this.timeline.clear(), this.timeline.kill()), this.tween = null, this._lastEvent = null, this.isStarting = this.isSpinning = this.isStopping = !1, this._inInstantStop = !1, this.tween = {
                        pos: 0,
                        lastPos: 0
                    }, this._timeScaleTween && (this._timeScaleTween.kill(), this._timeScaleTween = null)
                }
            }, {
                key: '_doStart',
                value() {
                    this._renderer.offset && (this.tween.pos = this.tween.lastPos = 1 - this._renderer.offset / this._tileHeight), this.timeline = i.b.timeline({
                        delay: this._config.delay / this._config.speed
                    }), this._dispatch(e.events.ANIMATION_SPIN_STARTING), this._doEaseStart(), this.timeline.addLabel(e.labels.SPINNING, '+=0.0001').call(this._dispatch.bind(this), [e.events.ANIMATION_SPINNING]), this._doLoop(), this.isSpinning = !0
                }
            }, {
                key: '_doEaseStart',
                value() {
                    let t = this.getEaseStartTime() / this._config.easeStartEasings.length
                    this.timeline.addLabel(e.labels.EASE_START), this._config.easeStartEasings.length === 2
                        ? this.timeline.to(this.tween, {
                                duration: t,
                                pos: `-=${ this._config.easeStartOffset}`,
                                ease: this._config.easeStartEasings[0],
                                callbackScope: this,
                                onUpdate: this._onTween
                            }).to(this.tween, {
                                duration: t,
                                pos: `+=${ this._config.easeStartOffset}`,
                                ease: this._config.easeStartEasings[1],
                                callbackScope: this,
                                onUpdate: this._onTween
                            })
                        : this.timeline.to(this.tween, {
                                duration: t,
                                pos: `+=${ this._config.easeStartOffset}`,
                                ease: this._config.easeStartEasings[0],
                                callbackScope: this,
                                onUpdate: this._onTween
                            })
                }
            }, {
                key: '_doLoop',
                value() {
                    this.timeline.to(this.tween, {
                        duration: this.LOOPING_DISTANCE / this._config.speed,
                        pos: `+=${ this.LOOPING_DISTANCE}`,
                        ease: 'none',
                        onComplete: this._doLoop,
                        callbackScope: this,
                        onUpdate: this._onTween
                    }).to(this.tween, {
                        duration: this.LOOPING_DISTANCE / this._config.speed,
                        pos: `+=${ this.LOOPING_DISTANCE}`,
                        ease: 'none',
                        callbackScope: this,
                        onUpdate: this._onTween
                    })
                }
            }, {
                key: '_onStop',
                value(t, e) {
                    (Number(t) !== t || t < 0) && (console.warn(`The syncTime(${ t }) is wrong!!!!`), t = 0), this._config.distance += Math.ceil(t * this._config.speed), this.buffer.merge(e, this._config.distance), this._doStop()
                }
            }, {
                key: '_doStop',
                value() {
                    let t = this
                    var n = Math.ceil(this.tween.pos) + this._config.distance
                    var r = (this._getOffsetLeft() + this._config.distance) / this._config.speed
                    this._dispatch(e.events.ANIMATION_STOPPING), this.timeline.killTweensOf(this.tween), this.timeline.clear().addLabel(e.labels.STOPPING).to(this.tween, {
                        duration: r,
                        pos: n,
                        ease: 'none',
                        callbackScope: this,
                        onUpdate: this._onTween
                    }).addLabel(e.labels.EASE_END).call(this._dispatch.bind(this), [e.events.ANIMATION_SPIN_ENDING]).call(() => {
                        t._inInstantStop && t._initialConfig.instantStop.speedUpReels.enabled && t._initialConfig.instantStop.speedUpReels.keepEaseEndSpeed && t.timeline.timeScale(1)
                    }), this._doEaseEnd()
                }
            }, {
                key: '_doEaseEnd',
                value() {
                    let t = this.getEaseEndTime() / this._config.easeEndEasings.length
                    this.timeline.to(this.tween, {
                        duration: t,
                        pos: `+=${ this._config.easeEndOffset}`,
                        ease: this._config.easeEndEasings[0],
                        callbackScope: this,
                        onUpdate: this._onTween
                    }).to(this.tween, {
                        duration: t,
                        pos: `-=${ this._config.easeEndOffset}`,
                        ease: this._config.easeEndEasings[1],
                        callbackScope: this,
                        onUpdate: this._onTween,
                        onComplete: this._onSpinComplete
                    })
                }
            }, {
                key: '_onTween',
                value() {
                    let t = (this.tween.pos - this.tween.lastPos) * this._tileHeight
                    this._config.autoExpandBuffer && this._checkIsOutsideBuffer(t)
                    let e = Number.parseFloat((this._renderer.pos - t).toFixed(7))
                    this._renderer.moveTo(e, !1), this.tween.lastPos = this.tween.pos
                }
            }, {
                key: '_onSpinComplete',
                value() {
                    let t = this.buffer.targetPosition * this._tileHeight
                    Math.abs(this._renderer.lastPos - t) > 10 && console.warn('Reel '.concat(this.index, ' didn\'t stop at the correct position => ').concat(t, ', ').concat(this._renderer.lastPos)), this._renderer.moveToTile(this.buffer.targetPosition), this._reset(), this._dispatch(e.events.ANIMATION_SPIN_END)
                }
            }, {
                key: '_checkIsOutsideBuffer',
                value(t) {
                    if (this._renderer.pos - t < this._tileHeight) {
                        let e = this._config.autoExpandTilesCount + Math.ceil((t - this._renderer.pos) / this._tileHeight)
                        this.buffer.expandLeft(e)
                    }
                }
            }, {
                key: '_dispatch',
                value(t) {
                    this._lastEvent = t, this.emit(t, {
                        reel: this._renderer
                    })
                }
            }, {
                key: '_getOffsetLeft',
                value() {
                    let t = this.tween.pos % 1
                    return t ? 1 - t : 0
                }
            }, {
                key: 'getEaseStartTime',
                value() {
                    let t = this._config.easeStartOffset / this._config.easeStartSpeed
                    return Number.parseFloat(t.toFixed(7))
                }
            }, {
                key: 'getEaseEndTime',
                value() {
                    let t = Math.abs(this._config.easeEndOffset) / this._config.easeEndSpeed
                    return Number.parseFloat(t.toFixed(7))
                }
            }]) && s(n.prototype, r), a && s(n, a), e
        }(r.a))
    },
    './src/core/features/reels/buffers/Buffer.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return l
        })
        const r = n('./node_modules/@games/dope/src/Dopamine.js')

        function i(t) {
            return (i = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function o(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function a(t, e, n) {
            return e = s(e),
            (function (t, e) {
                if (e && (i(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], s(t).constructor)
                : e.apply(t, n)))
        }

        function s(t) {
            return (s = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function u(t, e) {
            return (u = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const c = {
            BUFFER_UPDATED: 'buffer_updated'
        }
        var l = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = a(this, e))._data = null, t
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && u(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return c
                }
            }], (r = [{
                key: 'data',
                get() {
                    return this._data
                }
            }, {
                key: 'update',
                value(t) {
                    throw new Error('Subclass MUST override "update(bufferData)" with its OWN custom logic!')
                }
            }, {
                key: 'changeEntry',
                value(t, e) {
                    throw new Error('Subclass MUST override "changeEntry(offset, id)" with its OWN custom logic!')
                }
            }, {
                key: 'fetchEntry',
                value(t) {
                    throw new Error('Subclass MUST override "fetchEntry(offset)" with its OWN custom logic!')
                }
            }, {
                key: 'fetchResultScreen',
                value() {
                    throw new Error('Subclass MUST override "fetchResultScreen()" with its OWN custom logic!')
                }
            }, {
                key: 'resetEntry',
                value(t) {
                    throw new Error('Subclass MUST override "resetEntry(offset)" with its OWN custom logic!')
                }
            }]) && o(n.prototype, r), i && o(n, i), e
        }(r.b))
    },
    './src/core/features/reels/controllers/Controller.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return m
        })
        const r = n('./node_modules/@games/dope/src/Dopamine.js')
        const i = n('./src/core/utils/index.js')
        const o = n('./src/core/utils/Status.js')
        const a = n('./src/core/utils/CombinedTicker.js')

        function s(t) {
            return (s = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function u(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function c(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        u(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        u(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function l(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function h(t, e, n) {
            return e = f(e),
            (function (t, e) {
                if (e && (s(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], f(t).constructor)
                : e.apply(t, n)))
        }

        function f(t) {
            return (f = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function d(t, e) {
            return (d = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const p = {
            SPIN_START: 'spin_start',
            SPIN_STOPPING: 'spin_stopping',
            SPIN_END: 'spin_end',
            SPIN_STOPPING_INSTANT: 'spin_stopping_instant'
        }
        var m = (function (t) {
            function e(t) {
                let n; const r = t.config
                let i = t.renderers
                let o = t.animationSource
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = h(this, e))._config = r, n._reels = [], n._renderers = [], n._preConfigs = {
                    start: {},
                    stop: {}
                }, n.createReels(r, i, o), n._reset(), n
            }
            let n, r, s, u, f, m
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && d(t, e)
            }(e, t)), n = e, r = [{
                key: 'reels',
                get() {
                    return this._reels
                }
            }, {
                key: 'preConfigs',
                get() {
                    return this._preConfigs
                }
            }, {
                key: 'createReels',
                value(t, e, n) {
                    const r = this
                    e.forEach((e) => {
                        return r._createReel(t, e, n)
                    })
                }
            }, {
                key: 'removeReel',
                value(t) {
                    this._reels = this._reels.filter((e) => {
                        return e.index !== t
                    }), this._renderers = this._renderers.filter((e) => {
                        return e.index !== t
                    }), delete this._preConfigs.start[t], delete this._preConfigs.stop[t]
                }
            }, {
                key: 'start',
                value: (m = c(regeneratorRuntime.mark(function t(n) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (!this.isSpinning) {
                                    t.next = 2
                                            break
                                }
                                return t.abrupt('return');
                            case 2:
                                return this.emit(e.events.SPIN_START), this._config.spin.minSpinDurationEnabled && console.time('spin'), t.next = 6, this._onStart(n)
                                    case 6:
                                this.isSpinning = !0
                                    case 7:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t) {
                    return m.apply(this, arguments)
                })
            }, {
                key: 'stop',
                value: (f = c(regeneratorRuntime.mark(function t(n, r) {
                    let o
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (!this._config.spin.minSpinDurationEnabled) {
                                    t.next = 4
                                            break
                                }
                                return o = this._calcSpinDelay(), t.next = 4, new Object(i.d)(o)
                                    case 4:
                                if (!this.isStopping) {
                                    t.next = 6
                                            break
                                }
                                return t.abrupt('return');
                            case 6:
                                return this.emit(e.events.SPIN_STOPPING), this.isStopping = !0, this._config.spin.minSpinDurationEnabled && console.time('stop_time'), t.next = 11, this._onStop(n, r)
                                    case 11:
                                this._reset(), this.emit(e.events.SPIN_END), this._config.spin.minSpinDurationEnabled && (console.timeEnd('stop_time'), console.timeEnd('spin'))
                                    case 14:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t, e) {
                    return f.apply(this, arguments)
                })
            }, {
                key: 'stopInstant',
                value: (u = c(regeneratorRuntime.mark(function t(n) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (this.isStopping) {
                                    t.next = 2
                                            break
                                }
                                return t.abrupt('return');
                            case 2:
                                if (!this.isInstantStopping) {
                                    t.next = 4
                                            break
                                }
                                return t.abrupt('return', console.info('Don\'t worry - we are stopping INSTANTLY already ;)'))
                                    case 4:
                                return this.emit(e.events.SPIN_STOPPING_INSTANT), this.isInstantStopping = !0, t.next = 8, this._onInstantStop(n)
                                    case 8:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t) {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'getReelConfig',
                value(t) {
                    return this._reels[t].config
                }
            }, {
                key: 'preConfigStart',
                value() {
                    const t = this
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    var n = arguments.length > 1 ? arguments[1] : void 0
                    var r = void 0 === n ? new Object(i.k)(this._reels.length) : [].concat(n)
                    r.forEach((n) => {
                        return t._preConfigs.start[n] = e
                    })
                }
            }, {
                key: 'preConfigStop',
                value() {
                    const t = this
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    var n = arguments.length > 1 ? arguments[1] : void 0
                    var r = void 0 === n ? new Object(i.k)(this._reels.length) : [].concat(n)
                    r.forEach((n) => {
                        return t._preConfigs.stop[n] = e
                    })
                }
            }, {
                key: 'setTimeScale',
                value(t, e, n) {
                    const r = this
                    if (!this.isSpinning) return console.warn('Obviously, you could control the reels time scale only during spinning')
                    Number(e) !== e && (e = 1), (void 0 === n ? new Object(i.k)(this._reels.length) : [].concat(n)).forEach((n) => {
                        return r._reels[n].setTimeScale(t, e)
                    })
                }
            }, {
                key: '_createReel',
                value(t, e, n) {
                    throw new Error('Subclass MUST override "_createReel(config, renderer, reelAnimationSource)" methods with its OWN custom logic!')
                }
            }, {
                key: '_onStart',
                value(t) {
                    return Promise.reject(new Error('Subclass MUST override "_onStart(config)" with its OWN custom logic!'))
                }
            }, {
                key: '_onStop',
                value(t, e) {
                    return Promise.reject(new Error('Subclass MUST override "_onStop(data, config)" with its OWN custom logic!'))
                }
            }, {
                key: '_onInstantStop',
                value(t) {
                    return Promise.resolve()
                }
            }, {
                key: '_reset',
                value() {
                    this.isSpinning = !1, this.isStopping = !1, this.isInstantStopping = !1, this._resetPreconfigs()
                }
            }, {
                key: '_resetPreconfigs',
                value(t) {
                    const e = this;
                    (void 0 === t ? new Object(i.k)(this._reels.length) : [].concat(t)).forEach((t) => {
                        e._preConfigs.start[t] = {}, e._preConfigs.stop[t] = {}
                    })
                }
            }, {
                key: '_calcSpinDelay',
                value() {
                    const t = (a.a.elapsedTime - o.a.get(o.a.TYPES.PLAY_START_TIME)) / 1e3
                    var e = o.a.get(o.a.TYPES.MIN_ROUND_DURATION)
                    return Math.max(e - t - this._config.spin.spinStopTweenDuration, 0)
                }
            }], s = [{
                key: 'events',
                get() {
                    return p
                }
            }], r && l(n.prototype, r), s && l(n, s), e
        }(r.b))
    },
    './src/core/features/reels/controllers/SpinningController.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return N
        })
        const r = n('./node_modules/ramda/es/internal/_curry2.js')
        const i = n('./node_modules/ramda/es/internal/_dispatchable.js')
        const o = n('./node_modules/ramda/es/internal/_map.js')
        const a = n('./node_modules/ramda/es/internal/_reduce.js')
        const s = n('./node_modules/ramda/es/internal/_xfBase.js')
        const u = (function () {
            function t(t, e) {
                this.xf = e, this.f = t
            }
            return t.prototype['@@transducer/init'] = s.a.init, t.prototype['@@transducer/result'] = s.a.result, t.prototype['@@transducer/step'] = function (t, e) {
                return this.xf['@@transducer/step'](t, this.f(e))
            }, t
        }())
        const c = new Object(r.a)((t, e) => {
            return new u(t, e)
        })
        const l = n('./node_modules/ramda/es/curryN.js')
        const h = n('./node_modules/ramda/es/keys.js')
        const f = new Object(r.a)(new Object(i.a)(['fantasy-land/map', 'map'], c, (t, e) => {
            switch (Object.prototype.toString.call(e)) {
                case '[object Function]':
                    return new Object(l.a)(e.length, function () {
                        return t.call(this, e.apply(this, arguments))
                    })
                case '[object Object]':
                    return new Object(a.a)((n, r) => {
                        return n[r] = t(e[r]), n
                    }, {}, new Object(h.a)(e))
                default:
                    return new Object(o.a)(t, e)
            }
        }))
        const d = n('./node_modules/ramda/es/path.js')
        const p = new Object(r.a)((t, e) => {
            return new Object(d.a)([t], e)
        })
        const m = new Object(r.a)((t, e) => {
            return f(p(t), e)
        })
        const y = n('./node_modules/ramda/es/equals.js')
        const v = n('./src/core/utils/index.js')
        const _ = n('./src/core/features/reels/controllers/Controller.js')
        const g = n('./src/core/features/reels/animations/SpinningAnimation.js')
        const b = n('./src/core/utils/EventsHub.js')

        function E(t) {
            return (E = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function x(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return T(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return T(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function T(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function S(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function w(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        S(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        S(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function O(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function P(t, e, n) {
            return e = R(e),
            (function (t, e) {
                if (e && (E(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], R(t).constructor)
                : e.apply(t, n)))
        }

        function R(t) {
            return (R = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function A(t, e) {
            return (A = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function I(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function C(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const k = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? I(new Object(n), !0).forEach((e) => {
                            C(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : I(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, _.a.events))
        var N = (function (t) {
            function e(t) {
                let n; const r = t.config
                let i = t.renderers
                let o = t.animationSource
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = P(this, e, [{
                    config: r,
                    renderers: i,
                    animationSource: o
                }])).totalSpinningReels = 0, n.mismatchedReels = [], n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && A(t, e)
            }(e, t)), n = e, r = [{
                key: 'reels',
                get() {
                    return this._reels
                }
            }, {
                key: 'lockedReels',
                get() {
                    return this._reels.filter((t) => {
                        return !0 === t.isLocked
                    })
                }
            }, {
                key: 'unlockedReels',
                get() {
                    return this._reels.filter((t) => {
                        return !1 === t.isLocked
                    })
                }
            }, {
                key: 'preConfigStart',
                value(t, e) {
                    let n = this;
                    (void 0 === e ? new Object(v.k)(this._reels.length) : [].concat(e)).forEach((e) => {
                        if (n._reels[e].isStarting) return console.error('Too late, reel '.concat(e, ' is starting so you can\'t change its config.'))
                        var r = n._reels[e].config
                        Number.isInteger(t.delay) && (r.delay = t.delay), Number.isInteger(t.speed) && (r.speed = t.speed), Number(t.easeStartOffset) === t.easeStartOffset && (r.easeStartOffset = t.easeStartOffset), Number(t.easeStartSpeed) === t.easeStartSpeed && (r.easeStartSpeed = t.easeStartSpeed), typeof t.autoExpandBuffer == 'boolean' && (r.autoExpandBuffer = t.autoExpandBuffer), Array.isArray(t.easeStartEasings) && t.easeStartEasings.length >= 1 && t.easeStartEasings.length <= 2 && (r.easeStartEasings = t.easeStartEasings), n._addCustomPreconfigStartProps(t, r)
                    })
                }
            }, {
                key: 'preConfigStop',
                value(t, e) {
                    let n = this;
                    (void 0 === e ? new Object(v.k)(this._reels.length) : [].concat(e)).forEach((e) => {
                        if (n._reels[e].isStopping) return console.error('Too late, reel '.concat(e, ' is stopping so you can\'t change its config.'))
                        var r = n._reels[e].config
                        Number.isInteger(t.distance) && (r.distance = t.distance), Number(t.easeEndOffset) === t.easeEndOffset && (r.easeEndOffset = t.easeEndOffset), Number(t.easeEndSpeed) === t.easeEndSpeed && (r.easeEndSpeed = t.easeEndSpeed), typeof t.autoStopInstantly == 'boolean' && (r.autoStopInstantly = t.autoStopInstantly), Array.isArray(t.easeEndEasings) && t.easeEndEasings.length === 2 && (r.easeEndEasings = t.easeEndEasings), n._addCustomPreconfigStopProps(t, r)
                    })
                }
            }, {
                key: 'startReel',
                value(t) {
                    ++this.totalSpinningReels, !t.isLocked && t.start()
                }
            }, {
                key: '_onStart',
                value: (a = w(regeneratorRuntime.mark(function t() {
                    const e = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                this.totalSpinningReels
? console.error('Trying to spin again during spinning')
: (this._reels.forEach(function(t) {
                                            return e.startReel(t)
                                        }), this.isSpinning = !0)
                                    case 1:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_onStop',
                value: (o = w(regeneratorRuntime.mark(function t(e) {
                    const n = this
                    return regeneratorRuntime.wrap((t) => {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return t.abrupt('return', new Promise(function(t, r) {
                                            n._reels.forEach((function(r) {
                                                if (r.isLocked) {
                                                    if (n._onReelSpinEnd({
                                                            index: r.index,
                                                            data: e[r.index]
                                                        }), n.totalSpinningReels > 0) return;
                                                    t()
                                                } else r.once(g.a.events.ANIMATION_SPIN_END, (function() {
                                                    n._onReelSpinEnd({
                                                        index: r.index,
                                                        data: e[r.index]
                                                    }), n.totalSpinningReels > 0 || t()
                                                })), r.stop(e[r.index])
                                            }))
                                        }))
                                    case 1:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'lock',
                value(t) {
                    let e = this
                    t.forEach((t) => {
                        let n = e.reels[t]
                        n ? n.lock() : console.error('Invalid reel index to lock: '.concat(t, '!'))
                    })
                }
            }, {
                key: 'unlock',
                value(t) {
                    let e = this
                    t.forEach((t) => {
                        let n = e.reels[t]
                        n ? n.unlock() : console.error('Invalid reel index to unlock: '.concat(t, '!'))
                    })
                }
            }, {
                key: '_onInstantStop',
                value(t) {
                    this._reels.forEach((e, n) => {
                        e.isStopping && e.stopInstant(t[n])
                    })
                }
            }, {
                key: '_onReelSpinEnd',
                value(t) {
                    let e = t.index
                    var n = t.data
                    var r = m('id', this._renderers[e].getResultData())
                    var i = n[1]
                    new Object(y.a)(i, r) || (this.mismatchedReels.push(C({}, e, {
                        screenTiles: r,
                        serverTiles: i
                    })), this.mismatchedReels.length === 1 && b.a.emit(b.a.events.ERROR, {
                        priority: 'high',
                        errorType: 'malfunction',
                        nonRecoverable: !0,
                        details: {}
                    })), this.totalSpinningReels -= 1, this.totalSpinningReels === 0 && (this.mismatchedReels.length && (this.mismatchedReels.forEach((t) => {
                        Object.entries(t).forEach((t) => {
                            var e = x(t, 2);
                                        var n = e[0];
                                        var r = e[1];
                                        var i = r.screenTiles;
                                        var o = r.serverTiles
                                    console.warn('The visible tiles of reel #'.concat(n, ' are not EQUAL to the expected server result.\n                Visible tiles: ').concat(i, ',\n                Server tiles:  ').concat(o, ',\n                This should be investigated!'))
                        })
                    }), console.error('Reel mismatch has occured!')), this.mismatchedReels = [])
                }
            }, {
                key: '_createReel',
                value(t, e, n) {
                    let r = new n({
                        renderer: e,
                        config: t.spin,
                        tileHeight: e.tileHeight
                    })
                    this._reels.push(r), this._renderers.push(e), this._preConfigs.start[e.index] = {}, this._preConfigs.stop[e.index] = {}, this._addBlurListeners(r)
                }
            }, {
                key: '_addBlurListeners',
                value(t) {
                    let e = this
                    t.on(g.a.events.ANIMATION_SPINNING, () => {
                        return e._renderers[t.index].enableBlur()
                    }), t.on(g.a.events.ANIMATION_SPIN_ENDING, () => {
                        return e._renderers[t.index].disableBlur()
                    })
                }
            }, {
                key: '_addCustomPreconfigStartProps',
                value(t, e) {}
            }, {
                key: '_addCustomPreconfigStopProps',
                value(t, e) {}
            }], i = [{
                key: 'events',
                get() {
                    return k
                }
            }], r && O(n.prototype, r), i && O(n, i), e
        }(_.a))
    },
    './src/core/features/reels/engines/ReelMaster.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return S
        })
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = n('./src/core/loader/index.js')
        const o = n('./src/core/utils/index.js')
        const a = n('./node_modules/ramda/es/flatten.js')
        const s = n('./src/core/features/reels/tiles/TileBuilder.js')
        const u = n('./src/core/features/reels/controllers/Controller.js')
        const c = n('./src/core/features/reels/animations/Animation.js')
        const l = n('./src/core/features/reels/renderers/Renderer.js')
        const h = n('./src/core/features/reels/buffers/Buffer.js')

        function f(t) {
            return (f = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function d(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function p(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? d(new Object(n), !0).forEach((e) => {
                            m(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : d(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function m(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function y(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function v(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        y(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        y(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function _(t) {
            return (function (t) {
                if (Array.isArray(t)) return g(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return g(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return g(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function g(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function b(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function E(t, e, n) {
            return e = x(e),
            (function (t, e) {
                if (e && (f(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], x(t).constructor)
                : e.apply(t, n)))
        }

        function x(t) {
            return (x = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function T(t, e) {
            return (T = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        var S = (function (t) {
            function e(t) {
                let n; let r; const o = t.data
                let a = t.tiles
                let s = t.reelRenderer
                let u = t.controller
                let c = t.reelAnimation
                let l = t.reelBufferSource
                let h = t.tilesGeneratorSource
                let f = t.config
                let d = t.reelMasterAnim
                let p = void 0 === d ? i.a.ReelMaster.ReelMaster : d
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), r = E(this, e), f.tiles.buildTiles && r._buildTiles({
                    tiles: a,
                    tilesConfig: f.tiles
                }), r._config = f, r._anim = new p(), r._markers = r._anim.markers.children, r._tilesGenerator = new h(), r._reels = r._createReels(r._markers, o, a, s, l, f), r._controller = new u({
                    config: f,
                    renderers: r._reels,
                    animationSource: c
                }), r.mask = r.featuresMask, r.interactiveChildren = !1, (n = r).addChild.apply(n, _(r._reels).concat([r._anim])), r._bubbleEvents(), r
            }
            let n, r, f, d, m, y
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && T(t, e)
            }(e, t)), n = e, r = [{
                key: 'spin',
                get() {
                    return this._controller
                }
            }, {
                key: 'tileGuide',
                get() {
                    return s.a.guides[this._config.tiles.visible]
                }
            }, {
                key: 'featuresMask',
                get() {
                    return this._anim.featuresMaskContainer.children[0]
                }
            }, {
                key: 'anim',
                get() {
                    return this._anim
                }
            }, {
                key: 'reels',
                get() {
                    return this._reels
                }
            }, {
                key: 'animations',
                get() {
                    return this._controller.reels
                }
            }, {
                key: 'controller',
                get() {
                    return this._controller
                }
            }, {
                key: 'preConfigs',
                get() {
                    return this._controller.preConfigs
                }
            }, {
                key: 'tilesGenerator',
                get() {
                    return this._tilesGenerator
                }
            }, {
                key: 'start',
                value: (y = v(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, this._controller.start()
                                case 2:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return y.apply(this, arguments)
                })
            }, {
                key: 'stop',
                value: (m = v(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, this._controller.stop(e)
                                case 2:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t) {
                    return m.apply(this, arguments)
                })
            }, {
                key: 'stopInstant',
                value: (d = v(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, this._controller.stopInstant(e)
                                case 2:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function (t) {
                    return d.apply(this, arguments)
                })
            }, {
                key: 'onceReels',
                value(t, e, n, r) {
                    const i = this
                    if (e && typeof e == 'function') {
                        if (r) {
                            let o = [].concat(r)
                                    var a = n ? this._controller.reels : this._reels
                            o.forEach((r) => {
                                a[r].once(t, function(t) {
                                        var o = i._composePayload(a[r], n, t);
                                        e(o)
                                    })
                            })
                        } else { this.onceAll(t, e, n)
}
                    }
                    else { console.error('Invalid event handler!')
                    }
                }
            }, {
                key: 'onceAll',
                value(t, e, n) {
                    const r = this;
                    (n ? this._controller.reels : this._reels).forEach((i) => {
                        return i.once(t, (t) => {
                            var o = r._composePayload(i, n, t)
                                e(o)
                        })
                    })
                }
            }, {
                key: 'getReelConfig',
                value(t) {
                    return this._controller.getReelConfig(t)
                }
            }, {
                key: 'getReelBounds',
                value(t) {
                    return this._reels[t] ? this._reels[t].getReelBounds() : console.error('Invalid reel index '.concat(t, ' when getting reel bounds.'))
                }
            }, {
                key: 'setTimeScale',
                value(t, e, n) {
                    this._controller.setTimeScale(t, e, n)
                }
            }, {
                key: 'resetTile',
                value(t, e) {
                    const n = this
                    new Object(a.a)([].concat(e)).map((t) => {
                        return n._reels[t]
                    }).forEach((e) => {
                        return e.resetTile(t)
                    })
                }
            }, {
                key: 'resetTiles',
                value(t) {
                    const e = this
                    t.map((t) => {
                        return e._reels[t]
                    }).forEach((t) => {
                        return t.resetTiles()
                    })
                }
            }, {
                key: 'replaceTilesArea',
                value(t) {
                    const e = this
                    var n = t.index
                    var r = t.offset
                    var i = t.width
                    var a = t.height
                    var s = t.id
                    var u = t.force
                    var c = void 0 !== u && u
                    var l = new Object(o.k)(i, (t) => {
                        return t + n
                    })
                    new Object(o.k)(a, (t) => {
                        return t + r
                    }).forEach((t) => {
                        return e.replaceTile(t, s, l, c)
                    })
                }
            }, {
                key: 'replaceTile',
                value(t, e, n) {
                    const r = this
                    var i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                    var o = new Object(a.a)([].concat(n)).map((t) => {
                        return r._reels[t]
                    })
                    o.forEach((n) => {
                        return n.replaceTile(t, e, i)
                    })
                }
            }, {
                key: 'getTilePosition',
                value(t) {
                    const e = t.reel
                    var n = t.index
                    return this._reels[e].getTileCellPosition(n)
                }
            }, {
                key: 'getTileCoords',
                value(t) {
                    const e = t.reel
                    var n = t.index
                    return this._reels[e].getTileCoordinates(n)
                }
            }, {
                key: 'getTileData',
                value(t, e) {
                    if (!this._reels[t]) throw new Error('there is no reel of index '.concat(t))
                    return this._reels[t].getTileData(e)
                }
            }, {
                key: 'getResultData',
                value(t) {
                    return Number.isInteger(t)
                        ? this._reels[t] ? this._reels[t].getResultData() : console.error('Invalid reel index '.concat(t, ' when getting result data.'))
                        : this._reels.map((t) => {
                                return t.getResultData()
                            })
                }
            }, {
                key: 'parseBuffer',
                value(t) {
                    return t
                }
            }, {
                key: 'preConfigStart',
                value(t, e) {
                    this._controller.preConfigStart(t, e)
                }
            }, {
                key: 'preConfigStop',
                value(t, e) {
                    this._controller.preConfigStop(t, e)
                }
            }, {
                key: 'enableBlur',
                value(t) {
                    const e = this;
                    (void 0 === t ? new Object(o.k)(this._reels.length) : [].concat(t)).forEach((t) => {
                        return e._reels[t].hasBlur && e._reels[t].enableBlur()
                    })
                }
            }, {
                key: 'disableBlur',
                value(t) {
                    const e = this;
                    (void 0 === t ? new Object(o.k)(this._reels.length) : [].concat(t)).forEach((t) => {
                        return e._reels[t].hasBlur && e._reels[t].disableBlur()
                    })
                }
            }, {
                key: '_createReels',
                value(t, e, n, r, i, o) {
                    const a = this
                    var s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0
                    return t.map((t, u) => {
                        return a._createReel(e[u], n, t, s + u, r, i, o)
                    })
                }
            }, {
                key: '_createReel',
                value(t, e, n, r, i, o, a) {
                    const s = new i()
                    return s.onCreated({
                        data: t,
                        tileTypes: e,
                        marker: n,
                        index: r,
                        config: a,
                        tileGuide: this.tileGuide,
                        bufferSource: o,
                        tilesGenerator: this._tilesGenerator
                    }), s
                }
            }, {
                key: '_buildTiles',
                value(t) {
                    const e = t.tiles
                    var n = t.tilesConfig
                    s.a.build({
                        tiles: e
                    }, n)
                }
            }, {
                key: '_bubbleEvents',
                value() {
                    const t = this
                    this._controller.reels.forEach((e) => {
                        return t._bubbleAnimationEvents(e)
                    }), this._reels.forEach((e) => {
                        t._bubbleRendererEvents(e), t._bubbleBufferEvents(e.buffer)
                    }), this._bubbleControllerEvents()
                }
            }, {
                key: '_bubbleAnimationEvents',
                value(t) {
                    throw new Error('Subclass MUST override "_bubbleAnimationEvents(animation)" with its OWN custom logic!')
                }
            }, {
                key: '_bubbleRendererEvents',
                value(t) {
                    throw new Error('Subclass MUST override "_bubbleRendererEvents(renderer)" with its OWN custom logic!')
                }
            }, {
                key: '_bubbleControllerEvents',
                value() {
                    throw new Error('Subclass MUST override "_bubbleControllerEvents()" with its OWN custom logic!')
                }
            }, {
                key: '_bubbleBufferEvents',
                value(t) {
                    throw new Error('Subclass MUST override "_bubbleBufferEvents(buffer)" with its OWN custom logic!')
                }
            }, {
                key: '_composePayload',
                value(t, e, n) {
                    const r = e
                        ? {
                                animation: t
                            }
                        : {
                                renderer: t,
                                label: this._controller.reels[t.index].label
                            };
                    return p(p({
                        reel: t,
                        index: t.index
                    }, r), n)
                }
            }], f = [{
                key: 'events',
                get() {
                    return p(p(p(p({}, c.a.events), l.a.events), u.a.events), h.a.events)
                }
            }, {
                key: 'labels',
                get() {
                    return p({}, c.a.labels)
                }
            }], r && b(n.prototype, r), f && b(n, f), e
        }(r.Container))
    },
    './src/core/features/reels/engines/SpinningReelMaster.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return Y
        })
        const r = n('./src/core/features/reels/engines/ReelMaster.js')
        const i = (n('./node_modules/pixi.js/dist/esm/pixi.js'), n('./src/core/features/reels/renderers/Renderer.js'))
        const o = n('./src/core/features/reels/buffers/Buffer.js')
        const a = n('./node_modules/ramda/es/flatten.js')

        function s(t) {
            return (s = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function u(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function c(t, e, n) {
            return e = l(e),
            (function (t, e) {
                if (e && (s(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], l(t).constructor)
                : e.apply(t, n)))
        }

        function l(t) {
            return (l = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function h(t, e) {
            return (h = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function f(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function d(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? f(new Object(n), !0).forEach((e) => {
                            p(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : f(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function p(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const m = d({}, o.a.events)
        const y = (function (t) {
            function e(t) {
                let n; let r = t.bufferData
                            var i = t.index
                            var o = t.tilesGenerator
                            var a = t.cfg
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = c(this, e)).index = i, n.currentPosition = null, n.targetPosition = null, n.middlePosition = null, n.mergeLeftPosition = null, n.mergeRightPosition = null, n.distance = null, n.size = null, n._cfg = a, n._tilesGenerator = o, n.init(r), n
            }
            let n, r, i
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && h(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get () {
                    return m
                }
            }], (r = [{
                key: 'init',
                value (t) {
                    var e = t[0].length;
                                var n = this.parseData({
                            data: t,
                            isReal: !0
                        }, this._cfg.customParser)
                            this.update(n, e, e)
                }
            }, {
                key: 'merge',
                value (t, e) {
                    var n = t[0].length;
                                var r = this.parseData({
                            data: t,
                            isReal: !0
                        }, this._cfg.customParser)
                            this.expandLeft(r.length, r), this.setTargetPosition(n), e && this.resizeDistance(e, r.length)
                }
            }, {
                key: 'fetchEntry',
                value (t) {
                    return this.data[t + this.currentPosition]
                }
            }, {
                key: 'changeEntry',
                value (t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                            t = t || 0, this._data[this.targetPosition + t] = d(d({}, this._data[this.targetPosition + t]), {}, n
? {
                        id: e,
                        replaced: null
                    }
: {
                        replaced: e
                    })
                }
            }, {
                key: 'fetchResultScreen',
                value () {
                    return this._data.slice(this.targetPosition, this.targetPosition + this._cfg.visible)
                }
            }, {
                key: 'resetEntry',
                value (t) {
                    this.changeEntry(t, null)
                }
            }, {
                key: 'setCurrentPosition',
                value (t, e) {
                    this.currentPosition = t, this._updatePositions(e)
                }
            }, {
                key: 'setTargetPosition',
                value (t, e) {
                    this.targetPosition = t, this._updatePositions(e)
                }
            }, {
                key: 'setTargetValue',
                value (t, e) {
                    e = e || 0, this._data[this.targetPosition + e].id = t
                }
            }, {
                key: 'cleanLeft',
                value () {
                    var t = this.currentPosition
                            this._data.splice(0, t), this.update(this._data, 0, this.targetPosition - t)
                }
            }, {
                key: 'expandLeft',
                value (t, e) {
                    e || (e = this._tilesGenerator.generateRandomTiles({
                        count: t,
                        index: this.index
                    }), e = this.parseData({
                        data: e,
                        isReal: !1
                    }, this._cfg.customParser))
                            var n = this._data
                            n.splice(0, 0, e), n = new Object(a.a)(n), this.update(n, this.currentPosition + t, this.targetPosition + t)
                }
            }, {
                key: 'expandDistance',
                value (t, e) {
                    if (!Number.isInteger(t) || !Number.isInteger(e)) return console.error('Wrong configuration =>', 'howMany:', t, ', fromPos:', e)
                            var n = this._tilesGenerator.generateRandomTiles({
                        count: t,
                        index: this.index
                    })
                            n = this.parseData({
                        data: n,
                        isReal: !1
                    }, this._cfg.customParser)
                            var r = this._data
                            r.splice(e, 0, n), r = new Object(a.a)(r), this.update(r, this.currentPosition + t, this.targetPosition), this.mergeLeftPosition = e, this.mergeRightPosition = e + t
                }
            }, {
                key: 'reduceDistance',
                value (t, e) {
                    if (!Number.isInteger(t) || !Number.isInteger(e)) return console.error('Wrong configuration =>', 'howMany:', t, ', fromPos:', e)
                            var n; var r = this.currentPosition - e;
                                var i = Math.round(t / 2)
                            n = r > i ? e - i : e - t + r, this._data.splice(n, t), this.update(this._data, this.currentPosition - t, this.targetPosition), this.mergeLeftPosition = this.mergeRightPosition = n
                }
            }, {
                key: 'resizeDistance',
                value (t, e) {
                    var n = t - this.distance
                            n > 0 ? this.expandDistance(n, e) : n < 0 ? this.reduceDistance(Math.abs(n), e) : this.mergeLeftPosition = this.mergeRightPosition = e
                }
            }, {
                key: 'update',
                value (t, e, n) {
                    this._data = t, this.size = t.length, this.currentPosition = e, this.targetPosition = n
                            var r = this.size - (this.currentPosition + this._cfg.total)
                            r > 50 && (this._data.splice(50 - r), this.size = this._data.length), this._updatePositions()
                }
            }, {
                key: '_updatePositions',
                value (t) {
                    this.middlePosition = this.targetPosition + Math.round((this.currentPosition - this.targetPosition) / 2), this.distance = this.currentPosition - this.targetPosition, t || this.emit(e.events.BUFFER_UPDATED, {
                        index: this.index
                    })
                }
            }, {
                key: 'parseData',
                value (t, e) {
                    var n = t.data;
                                var r = t.isReal;
                                var i = void 0 !== r && r;
                                var o = "function" == typeof e ? e : function(t) {
                                    return t
                                };
                                var s = Object(a.a)(n);
                                var u = i ? n[1].length : this._cfg.sizes[0]
                            return o(s.map(function(t) {
                                return {
                                    id: t,
                                    heightIndex: u,
                                    replaced: null
                                }
                            }), n, i)
                }
            }]) && u(n.prototype, r), i && u(n, i), e
        }(o.a))
        const v = n('./src/core/utils/index.js')
        const _ = n('./node_modules/ramda/es/isEmpty.js')
        const g = n('./src/core/features/reels/tiles/Tile.js')

        function b(t) {
            return (b = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function E(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return x(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return x(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function x(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function T(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function S(t, e, n) {
            return e = O(e),
            (function (t, e) {
                if (e && (b(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], O(t).constructor)
                : e.apply(t, n)))
        }

        function w(t, e, n) {
            return (w = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = O(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function O(t) {
            return (O = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function P(t, e) {
            return (P = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function R(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function A(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? R(new Object(n), !0).forEach((e) => {
                            I(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : R(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function I(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const C = A(A({}, i.a.events), {}, {
            RENDERER_TILE_ENTERING: 'renderer_tile_entering',
            RENDERER_TILE_LEAVING: 'renderer_tile_leaving'
        })
        const k = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = S(this, e))._tileGuide = null, t.offset = 0, t.tileIndex = null, t.pos = 0, t.lastPos = 0, t.blur = !1, t._tileHeight = 0, t.TOTAL_TILES = 0, t.TOTAL_TILES_SIZE = 0, t._tilesEntering = 0, t._hasBlur = !0, t._tilesGenerator = null, t
            }
            let n, r, i
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && P(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get () {
                    return C
                }
            }], (r = [{
                key: 'onCreated',
                value (t) {
                    var e = t.data;
                                var n = t.tileTypes;
                                var r = t.marker;
                                var i = t.index;
                                var o = t.config;
                                var a = t.tileGuide;
                                var s = t.bufferSource;
                                var u = void 0 === s ? y : s;
                                var c = t.tilesGenerator;
                                var l = r.children[0];
                                var h = l.getBounds()
                            o.useOwnMask ? this.mask = l : l.alpha = 0, this._index = i, this._tilesGenerator = c, this.position.set(r.x, r.y)
                            var f = this._createTilesConfig({
                        tileTypes: n,
                        config: o,
                        bounds: h
                    })
                            this._config = new Object(v.c)(o, {
                        tiles: f,
                        index: i
                    }, {
                        bounds: h
                    }), this._tiles = this._createTiles(this._config.tiles), this._tileGuide = a, this._tileHeight = this._tileGuide.height, this.TOTAL_TILES = null, this.TOTAL_TILES_SIZE = null, this._buffer = new u({
                        bufferData: e,
                        index: i,
                        tilesGenerator: this._tilesGenerator,
                        cfg: {
                            sizes: this._config.tiles.sizes,
                            total: this._config.tiles.total,
                            visible: this._config.tiles.visible
                        }
                    }), this._tilesGenerator.setSpinnableTiles({
                        index: i,
                        tiles: this._config.tiles.spinnable,
                        cache: !0
                    }), new Object(_.a)(this._config.tiles.stacked) || this._tilesGenerator.enableStack({
                        index: i,
                        stacked: this._config.tiles.stacked
                    }), this.buffer.on(y.events.BUFFER_UPDATED, this._reset, this), this._reset()
                }
            }, {
                key: 'moveTo',
                value (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                            this.pos = new Object(v.f)(t, this.TOTAL_TILES_SIZE), this._update(e), this._draw(), this._tilesEntering > 0 && this._emitTileEvents(), this._tilesEntering = 0
                }
            }, {
                key: 'moveToTile',
                value (t) {
                    this.moveTo(t * this._tileHeight, !1)
                }
            }, {
                key: 'updateTiles',
                value () {
                    for (let t = 0, e = Object.entries(this.tiles); t < e.length; t++) {
                        var n = E(e[t], 2);
                                    var r = n[0]
                                n[1], this.updateTile(Number.parseInt(r))
                    }
                }
            }, {
                key: 'updateTile',
                value (t) {
                    if (!this.tiles[t]) return console.warn('Sorry, but there is no tile with index ' + t + ' in my world!');
                    var e = this._getTileId(t + this.tileIndex);
                                var n = this.isStaked(e, t)
                            this._getTile(e, n, this.tiles[t])
                }
            }, {
                key: 'tileHeight',
                get () {
                    return this._tileHeight
                }
            }, {
                key: 'isStaked',
                value (t, e) {
                    return null
                }
            }, {
                key: 'getVisibleTiles',
                value () {
                    if (this.offset !== 0) return console.warn('Can\'t get the visible tiles durring spinning/dragging');
                    for (var t = [], e = 0; e < this._config.tiles.visible; e++) t.push(this._getTileId(this.tileIndex + e))
                            return t
                }
            }, {
                key: 'getTileCellPosition',
                value (t) {
                    return {
                        x: this.x,
                        y: this.y + t * this._tileGuide.height
                    }
                }
            }, {
                key: 'getTileCoordinates',
                value (t) {
                    var e = this.toGlobal(this.tiles[t].position)
                            return this.parent.parent.toLocal(A({}, e))
                }
            }, {
                key: 'enableBlur',
                value () {
                    w(O(e.prototype), 'enableBlur', this).call(this), this._hasBlur && (this.blur = !0, this.updateTiles())
                }
            }, {
                key: 'disableBlur',
                value () {
                    w(O(e.prototype), 'disableBlur', this).call(this), this._hasBlur && (this.blur = !1, this.updateTiles())
                }
            }, {
                key: 'getCurrentPosition',
                value () {
                    return this._buffer.currentPosition
                }
            }, {
                key: 'getTargetPosition',
                value () {
                    return this._buffer.targetPosition
                }
            }, {
                key: 'getDistanceToTarget',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                                var e = (this.getTargetPosition() + t) * this.tileHeight
                            return this.pos - e
                }
            }, {
                key: '_reset',
                value () {
                    this.TOTAL_TILES = this.buffer.size, this.TOTAL_TILES_SIZE = this._tileHeight * this.TOTAL_TILES, this.lastPos = this.buffer.currentPosition * this._tileHeight + this.offset, this.moveTo(this.lastPos, !0), this.emit(e.events.RENDERER_UPDATED, {
                        offset: this._config.spin.speed
                    })
                }
            }, {
                key: '_update',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                            this.offset = this.pos - Math.floor(this.pos / this._tileHeight) * this._tileHeight
                            var n = this._getTileIndex(this.pos)
                            if (n !== this.tileIndex) {
                        var r = this.tileIndex - n
                                this.tileIndex = n, this.updateTiles(), this.buffer.setCurrentPosition(this.tileIndex, !0), t || (this._tilesEntering = r)
                    }
                    var i = this.pos - this.lastPos
                            this.emit(e.events.RENDERER_MOVE, {
                        index: this._index,
                        pos: this.pos,
                        delta: i
                    }), this.lastPos = this.pos
                }
            }, {
                key: '_emitTileEvents',
                value () {
                    for (let t = this._tilesEntering - 1; t >= 0; t--) {
                        var n = this.getTileData(t);
                                    var r = this.getTileData(this.config.tiles.visible + t)
                                this.emit(e.events.RENDERER_TILE_ENTERING, {
                            tile: n,
                            tileIndex: t
                        }), this.emit(e.events.RENDERER_TILE_LEAVING, {
                            tile: r,
                            tileIndex: this.config.tiles.visible + t
                        })
                    }
                }
            }, {
                key: '_draw',
                value () {
                    for (let t = 0, n = Object.entries(this.tiles); t < n.length; t++) {
                        var r = E(n[t], 2);
                                    var i = r[0]
                                r[1].y = Number.parseInt(i) * this._tileHeight - this.offset
                    }
                    this.emit(e.events.RENDERER_DRAW, {
                        index: this._index
                    })
                }
            }, {
                key: '_getTileIndex',
                value (t) {
                    return Math.floor(t / this._tileHeight)
                }
            }, {
                key: '_getTileId',
                value (t) {
                    return t = new Object(v.f)(t, this.TOTAL_TILES), this.buffer.data[t]
                }
            }, {
                key: '_getTile',
                value (t, e, n) {
                    var r = this.blur ? 'blurred' : 'normal';
                    e = e || '', n.to(t, r, e)
                }
            }, {
                key: '_createTilesConfig',
                value (t) {
                    var e = t.tileTypes;
                                var n = t.config
                            return {
                        bounds: t.bounds,
                        ids: e.map(function(t) {
                                    return t.id
                                }).concat(0),
                        sizes: [n.tiles.visible],
                        spinnable: e.filter(function(t) {
                                    return "normal" === t.type
                                }).map(function(t) {
                                    return t.id
                                })
                    }
                }
            }, {
                key: '_createTiles',
                value (t) {
                    for (var e = {}, n = -t.offsetTop; n < t.visible + t.offsetBottom; n++) e[n] = new g.a(), e[n].index = n, this.addChild(e[n])
                            return e
                }
            }]) && T(n.prototype, r), i && T(n, i), e
        }(i.a))
        const N = n('./src/core/features/reels/controllers/SpinningController.js')
        const M = n('./src/core/features/reels/animations/SpinningAnimation.js')
        const j = n('./src/core/loader/index.js')
        const D = n('./src/core/features/reels/TilesGenerator.js')
        const L = n('./node_modules/ramda/es/mergeDeepLeft.js')

        function F(t) {
            return (F = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function B(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function U(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? B(new Object(n), !0).forEach((e) => {
                            G(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : B(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function G(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function X(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function H(t, e, n) {
            return e = V(e),
            (function (t, e) {
                if (e && (F(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], V(t).constructor)
                : e.apply(t, n)))
        }

        function V(t) {
            return (V = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function W(t, e) {
            return (W = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        var Y = (function (t) {
            function e(t) {
                const n = t.reelsBuffer
                let r = t.tiles
                let i = t.reelMasterAnim
                let o = t.reelRenderer
                let a = void 0 === o ? k : o
                let s = t.controller
                let u = void 0 === s ? N.a : s
                let c = t.reelAnimation
                let l = void 0 === c ? M.a : c
                let h = t.reelBufferSource
                let f = void 0 === h ? y : h
                let d = t.tilesGeneratorSource
                let p = void 0 === d ? D.a : d
                let m = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), H(this, e, [{
                    data: n,
                    tiles: r,
                    reelMasterAnim: i,
                    reelRenderer: a,
                    controller: u,
                    reelAnimation: l,
                    reelBufferSource: f,
                    tilesGeneratorSource: p,
                    config: m
                }])
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && W(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return U(U(U(U({}, M.a.events), k.events), N.a.events), y.events)
                }
            }, {
                key: 'labels',
                get() {
                    return U({}, M.a.labels)
                }
            }], (r = [{
                key: 'lockedReels',
                get() {
                    return this.controller.lockedReels
                }
            }, {
                key: 'unlockedReels',
                get() {
                    return this.controller.unlockedReels
                }
            }, {
                key: 'getCurrentPosition',
                value(t) {
                    return this._reels[t] ? this._reels[t].getCurrentPosition() : console.error('Invalid reel index '.concat(t, ' when getting buffer\'s current positions.'))
                }
            }, {
                key: 'getTargetPosition',
                value(t) {
                    return this._reels[t] ? this._reels[t].getTargetPosition() : console.error('Invalid reel index '.concat(t, ' when getting buffer\'s target positions.'))
                }
            }, {
                key: 'getDistanceToTarget',
                value(t) {
                    const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                    return this._reels[t] ? this._reels[t].getDistanceToTarget(e) : console.error('Invalid reel index '.concat(t, ' when getting buffer\'s target positions.'))
                }
            }, {
                key: 'addReels',
                value(t, e, n) {
                    const r = this
                    var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : k
                    var o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : y
                    var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : M.a
                    var s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._config
                    if (e.length < t) return console.warn('You should pass buffers for every new reel, that you are trying to create!')
                    let u = this.reels.length
                    var c = this._createMarkers(t, u)
                    var l = this._createReels(c, e, n, i, o, s, u)
                    return this._controller.createReels(s, l, a), l.forEach((t) => {
                        let e = t.index
                        r._reels.push(t), r.addChildAt(t, e), r._bubbleAnimationEvents(r.animations[e]), r._bubbleRendererEvents(t), r._bubbleBufferEvents(t.buffer)
                    }), l
                }
            }, {
                key: 'startReels',
                value(t) {
                    const e = this
                    return t && t.length
                        ? this._controller.isSpinning
                            ? void t.forEach((t) => {
                                let n = e.animations.find((e) => {
                                    return e.index === t
                                })
                                if (!n) return console.warn('There isn\'t a reel to start at index: '.concat(t, '!'))
                                e._controller.startReel(n)
                            })
                            : console.warn('Reels are not spinning yet!')
                        : console.warn('You should specify which reels to start spinning!')
                }
            }, {
                key: 'removeReels',
                value(t) {
                    const e = this
                    t && t.length && t.forEach((t) => {
                        return e._removeReel(t)
                    })
                }
            }, {
                key: 'lockReels',
                value(t) {
                    this.controller.lock(t)
                }
            }, {
                key: 'unlockReels',
                value(t) {
                    this.controller.unlock(t)
                }
            }, {
                key: '_removeReel',
                value(t) {
                    const e = this._reels.find((e) => {
                        return e.index === t
                    })
                    if (!e) return console.warn('There isn\'t reel at index '.concat(t, ' to remove.'))
                    this._reels = this._reels.filter((t) => {
                        return t.index !== e.index
                    }), this._removeListeners(e), this._controller.removeReel(t), this.removeChild(e)
                }
            }, {
                key: '_removeListeners',
                value(t) {
                    const e = this.animations.find((e) => {
                        return e.index === t.index
                    })
                    var n = t.buffer
                    e.removeAllListeners(), t.removeAllListeners(), n.removeAllListeners()
                }
            }, {
                key: '_bubbleAnimationEvents',
                value(t) {
                    const e = this
                    var n = new Object(L.a)(t.constructor.events, M.a.events)
                    Object.keys(n).forEach((r) => {
                        t.on(n[r], (i) => {
                            return e.emit(n[r], U({
                                animation: t,
                                index: t.index
                            }, i))
                        })
                    })
                }
            }, {
                key: '_bubbleRendererEvents',
                value(t) {
                    const e = this
                    var n = new Object(L.a)(t.constructor.events, k.events)
                    Object.keys(n).forEach((r) => {
                        let i = {}
                        t.on(n[r], (o) => {
                            [n.RENDERER_TILE_ENTERING, n.RENDERER_TILE_LEAVING].includes(n[r]) && (i.label = e._controller.reels[t.index].label), e.emit(n[r], U(U({
                                renderer: t,
                                index: t.index
                            }, o), i))
                        })
                    })
                }
            }, {
                key: '_bubbleControllerEvents',
                value() {
                    const t = this
                    var e = new Object(L.a)(this._controller.constructor.events, N.a.events)
                    Object.keys(e).forEach((n) => {
                        t._controller.on(e[n], (r) => {
                            return t.emit(e[n], U({}, r))
                        })
                    })
                }
            }, {
                key: '_bubbleBufferEvents',
                value(t) {
                    const e = this
                    var n = new Object(L.a)(t.constructor.events, y.events)
                    Object.keys(n).forEach((r) => {
                        t.on(n[r], (i) => {
                            e.emit(n[r], U({
                                buffer: t,
                                index: t.index
                            }, i))
                        })
                    })
                }
            }, {
                key: '_createMarkers',
                value(t, e) {
                    for (var n = [], r = 0; r < t; r++) n.push(this._getMarker(e + r))
                    return n
                }
            }, {
                key: '_getMarker',
                value(t) {
                    const e = new j.a.ReelMaster.mask();
                    var n = this._markers[0]
                        var r = n.x
                        var i = n.y
                        var o = e.width
                    return this._markers.length > 1 && (o = this._markers[1].x - r), e.x = r + t * o, e.y = i, e
                }
            }]) && X(n.prototype, r), i && X(n, i), e
        }(r.a))
    },
    './src/core/features/reels/renderers/Renderer.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return l
        })
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')

        function i(t) {
            return (i = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function o(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function a(t, e, n) {
            return e = s(e),
            (function (t, e) {
                if (e && (i(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], s(t).constructor)
                : e.apply(t, n)))
        }

        function s(t) {
            return (s = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function u(t, e) {
            return (u = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const c = {
            RENDERER_MOVE: 'renderer_move',
            RENDERER_DRAW: 'renderer_draw',
            RENDERER_UPDATED: 'renderer_updated'
        }
        var l = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = a(this, e))._index = null, t._config = null, t._buffer = null, t._hasBlur = !1, t._tiles = {}, t
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && u(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return c
                }
            }], (r = [{
                key: 'index',
                get() {
                    return this._index
                }
            }, {
                key: 'buffer',
                get() {
                    return this._buffer
                }
            }, {
                key: 'tiles',
                get() {
                    return this._tiles
                }
            }, {
                key: 'config',
                get() {
                    return this._config
                }
            }, {
                key: 'hasBlur',
                get() {
                    return this._hasBlur
                }
            }, {
                key: 'onCreated',
                value(t) {
                    throw new Error('Subclass MUST override "onCreated(settings)" with its OWN custom logic!')
                }
            }, {
                key: 'getTileCellPosition',
                value(t) {
                    throw new Error('Subclass MUST override "getTileCellPosition(index)" with its OWN custom logic!')
                }
            }, {
                key: 'getTileCoordinates',
                value(t) {
                    throw new Error('Subclass MUST override "getTileCoordinates(index)" with its OWN custom logic!')
                }
            }, {
                key: 'getTileData',
                value() {
                    const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                    return this._buffer.fetchEntry(t)
                }
            }, {
                key: 'getResultData',
                value() {
                    return this._buffer.fetchResultScreen()
                }
            }, {
                key: 'replaceTile',
                value(t, e) {
                    const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                    this._buffer.changeEntry(t, e, n), this.updateTiles()
                }
            }, {
                key: 'resetTile',
                value(t) {
                    this._buffer.resetEntry(t), this.updateTiles()
                }
            }, {
                key: 'resetTiles',
                value() {
                    const t = this
                    Object.keys(this._tiles).forEach((e) => {
                        return t.resetTile(e)
                    })
                }
            }, {
                key: 'enableBlur',
                value() {
                    if (!this._hasBlur) return console.warn('The active renderer '.concat(this.index, ' does not support blur.'))
                }
            }, {
                key: 'disableBlur',
                value() {
                    if (!this._hasBlur) return console.warn('The active renderer '.concat(this.index, ' does not support blur.'))
                }
            }, {
                key: 'getReelBounds',
                value() {
                    return this._config.bounds
                }
            }]) && o(n.prototype, r), i && o(n, i), e
        }(r.Container))
    },
    './src/core/features/reels/tiles/Tile.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return h
        })
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = n('./src/core/features/reels/tiles/TileBuilder.js')

        function o(t) {
            return (o = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function a(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function s(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function u(t, e, n) {
            return e = c(e),
            (function (t, e) {
                if (e && (o(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], c(t).constructor)
                : e.apply(t, n)))
        }

        function c(t) {
            return (c = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function l(t, e) {
            return (l = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        var h = (function (t) {
            function e() {
                let t; const n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : r.Texture.EMPTY
                return a(this, e), (t = u(this, e, [n])).index = null, t._id = null, t
            }
            let n, o, c
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && l(t, e)
            }(e, t)), n = e, (o = [{
                key: 'id',
                get() {
                    return this._id
                }
            }, {
                key: 'to',
                value(t, e, n, r) {
                    const i = t.id
                    var o = t.replaced
                    var a = Number.isInteger(o) ? o : i
                    var s = this.fetchTileTexture(a, e, n, r)
                    var u = s.texture
                    var c = s.pivot
                    this._id = a, this.texture = u, this.pivot.set(-c.x, -c.y)
                }
            }, {
                key: 'fetchTileTexture',
                value(t, e, n, r) {
                    return i.a.tiles[t][e]
                }
            }]) && s(n.prototype, o), c && s(n, c), e
        }(r.Sprite))
    },
    './src/core/features/reels/tiles/TileBuilder.js': function (t, e, n) {
        'use strict'
        const r = n('./src/core/loader/index.js')
        const i = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const o = n('./src/core/utils/Cache.js')
        const a = n('./node_modules/@pixi/core/dist/esm/core.js')
        const s = n('./node_modules/@pixi/math/dist/esm/math.js')
        let u = function (t, e) {
            return (u = Object.setPrototypeOf || Array.isArray({
                __proto__: []
            })
            && function (t, e) {
                t.__proto__ = e
            } || function (t, e) {
                for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            })(t, e)
        }
        const c = (function (t) {
            function e(e, n, r) {
                void 0 === e && (e = 4), void 0 === n && (n = 3), void 0 === r && (r = !1)
                let i = t.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}', r ? '\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n' : '\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}') || this
                return i._kernels = [], i._blur = 4, i._quality = 3, i.uniforms.uOffset = new Float32Array(2), i._pixelSize = new s.g(), i.pixelSize = 1, i._clamp = r, Array.isArray(e) ? i.kernels = e : (i._blur = e, i.quality = n), i
            }
            return (function (t, e) {
                function n() {
                    this.constructor = t
                }
                u(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n())
            }(e, t)), e.prototype.apply = function (t, e, n, r) {
                let i; const o = this._pixelSize.x / e._frame.width
                var a = this._pixelSize.y / e._frame.height
                if (this._quality === 1 || this._blur === 0) { i = this._kernels[0] + 0.5, this.uniforms.uOffset[0] = i * o, this.uniforms.uOffset[1] = i * a, t.applyFilter(this, e, n, r)
                }
                else {
                    for (var s = t.getFilterTexture(), u = e, c = s, l = void 0, h = this._quality - 1, f = 0; f < h; f++) i = this._kernels[f] + 0.5, this.uniforms.uOffset[0] = i * o, this.uniforms.uOffset[1] = i * a, t.applyFilter(this, u, c, 1), l = u, u = c, c = l
                    i = this._kernels[h] + 0.5, this.uniforms.uOffset[0] = i * o, this.uniforms.uOffset[1] = i * a, t.applyFilter(this, u, n, r), t.returnFilterTexture(s)
                }
            }, e.prototype._updatePadding = function () {
                this.padding = Math.ceil(this._kernels.reduce((t, e) => {
                    return t + e + 0.5
                }, 0))
            }, e.prototype._generateKernels = function () {
                const t = this._blur
                var e = this._quality
                var n = [t]
                if (t > 0) {
                    for (let r = t, i = t / e, o = 1; o < e; o++) r -= i, n.push(r)
                }
                this._kernels = n, this._updatePadding()
            }, Object.defineProperty(e.prototype, 'kernels', {
                get() {
                    return this._kernels
                },
                set(t) {
                    Array.isArray(t) && t.length > 0 ? (this._kernels = t, this._quality = t.length, this._blur = Math.max.apply(Math, t)) : (this._kernels = [0], this._quality = 1)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'clamp', {
                get() {
                    return this._clamp
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'pixelSize', {
                get() {
                    return this._pixelSize
                },
                set(t) {
                    'number' == typeof t ? (this._pixelSize.x = t, this._pixelSize.y = t) : Array.isArray(t) ? (this._pixelSize.x = t[0], this._pixelSize.y = t[1]) : t instanceof s.g ? (this._pixelSize.x = t.x, this._pixelSize.y = t.y) : (this._pixelSize.x = 1, this._pixelSize.y = 1)
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'quality', {
                get() {
                    return this._quality
                },
                set(t) {
                    this._quality = Math.max(1, Math.round(t)), this._generateKernels()
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, 'blur', {
                get() {
                    return this._blur
                },
                set(t) {
                    this._blur = t, this._generateKernels()
                },
                enumerable: !1,
                configurable: !0
            }), e
        }(a.u))

        function l(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function h(t) {
            return (h = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function f(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function d(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function p(t, e, n) {
            return e = m(e),
            (function (t, e) {
                if (e && (h(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], m(t).constructor)
                : e.apply(t, n)))
        }

        function m(t) {
            return (m = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function y(t, e) {
            return (y = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const v = (function (t) {
            function e() {
                return f(this, e), p(this, e, arguments)
            }
            let n, r, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && y(t, e)
            }(e, t)), n = e, (r = [{
                key: 'apply',
                value (t) {
                    var e = this._cfg
                                var n = e.x
                                var r = e.y
                                var o = e.quality
                                var a = {
                        x: n > 0 ? o / n : 0,
                        y: r > 0 ? o / r : 0
                    };
                    var s = t.filters || []
                                var u = new c(r, o)
                    u.pixelSize = [a.x, a.y]
                    var l = t.width
                                var h = t.height
                                var f = t.pivot
                                var d = n * o * a.x * 2
                                var p = r * o * a.y * 2
                                var m = l + d
                                var y = h + p
                    return f.x -= d / 2, f.y -= p / 2, t.filters = s.concat(u), t.filterArea = new i.Rectangle(0, 0, m, y), t
                }
            }, {
                key: 'generateTexture',
                value (t) {
                    var e = this.apply(t)
                                var n = e.filterArea
                                var r = e.pivot
                                var i = n.width
                                var a = n.height
                    return {
                        blurredTexture: new Object(o.f)(e, i, a),
                        blurPivot: r
                    }
                }
            }]) && d(n.prototype, r), a && d(n, a), e
        }(function () {
            function t(e) {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this._cfg = e
            }
            let e, n, r
            return e = t, (n = [{
                key: 'apply',
                value (t) {
                    if (!t.children || t.children.length === 0) return t
                    var e = t.children.reduce((t, e) => {
                        return {
                            x: Math.min(t.x, e.x),
                            y: Math.min(t.y, e.y)
                        }
                    }, {
                        x: 1 / 0,
                        y: 1 / 0
                    })
                    return t.pivot.x = e.x, t.pivot.y = e.y, t
                }
            }, {
                key: 'generateTexture',
                value () {
                    console.warn('generateTexture is not implemented')
                }
            }, {
                key: 'generateSpritesheet',
                value () {
                    console.warn('generateSpritesheet is not implemented')
                }
            }]) && l(e.prototype, n), r && l(e, r), t
        }()))
        let _ = n('./node_modules/pixi-spine/lib/all.es.js')

        function g(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function b(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? g(new Object(n), !0).forEach((e) => {
                            E(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : g(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function E(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function x(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const T = 'animate'
        let S = 'spine'
        let w = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this._tiles = {}, this._guides = {}
            }
            let e, n, a
            return e = t, (n = [{
                key: 'guides',
                get() {
                    return this._guides
                }
            }, {
                key: 'tiles',
                get() {
                    return this._tiles
                }
            }, {
                key: 'build',
                value(t, e) {
                    let n = this
                    var r = t.tiles
                    var i = r.map((t) => {
                        return t.id
                    }).concat(0)
                    if (e.sizes && e.sizes.length > 1) { this.buildMegaWays({
                        tiles: r
                    }, e)
                    }
                    else {
                        let o = e.visible
                        var a = e.blur
                        var s = e.tilesAnimSource
                        var u = e.animSource
                        var c = void 0 === u ? T : u
                        var l = e.guides
                        var h = void 0 === l ? {} : l
                        this._tiles = i.reduce((t, e) => {
                            return b(b({}, t), {}, E({}, e, n._create({
                                id: e,
                                size: o,
                                blur: a,
                                animSource: c,
                                guides: h
                            }, s)))
                        }, {})
                    }
                }
            }, {
                key: 'buildMegaWays',
                value(t, e) {
                    let n = this
                    var r = t.tiles.map((t) => {
                        return t.id
                    }).concat(0)
                    var i = e.sizes
                    var o = e.blur
                    var a = e.tilesAnimSource
                    var s = e.ignoreSizes
                    var u = void 0 === s ? {} : s
                    var c = e.animSource
                    var l = void 0 === c ? T : c
                    var h = e.guides
                    var f = void 0 === h ? {} : h
                    this._tiles = r.reduce((t, e) => {
                        return b(b({}, t), {}, E({}, e, n._createForSizes({
                            id: e,
                            sizes: i,
                            blur: o,
                            ignoreSizes: u,
                            animSource: l,
                            guides: f
                        }, a)))
                    }, {})
                }
            }, {
                key: '_getTileName',
                value(t, e) {
                    let n = t.id
                    var r = t.size
                    return e['tile'.concat(n, 'x').concat(r)] ? 'tile'.concat(n, 'x').concat(r) : 'tile'.concat(n)
                }
            }, {
                key: '_getTileGuide',
                value(t) {
                    let e = t.animSource
                    var n = t.source
                    var r = t.size
                    var i = t.guides
                    return e === S ? i['x'.concat(r)] || i.default : n['tileGuidex'.concat(r)] ? new (n['tileGuidex'.concat(r)])() : new n.tileGuide()
                }
            }, {
                key: '_validateTile',
                value(t) {
                    let e; const n = t.size
                    var r = t.id
                    return (e = t.ignoreSizes[r]) === null || void 0 === e || !e.includes(n)
                }
            }, {
                key: '_validateAnimationSource',
                value(t, e, n) {
                    let r = t.id
                    return !!e[n] || (r !== 0 && console.warn('there is no movie clip for tile', n), !1)
                }
            }, {
                key: '_create',
                value(t) {
                    let e = t.id
                    var n = t.size
                    var i = t.blur
                    var o = t.ignoreSizes
                    var a = void 0 === o ? {} : o
                    var s = t.animSource
                    var u = void 0 === s ? T : s
                    var c = t.guides
                    var l = void 0 === c ? {} : c
                    var h = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'Tiles'
                    if (u !== S && !r.a[h]) throw new Error('No tiles source with name \''.concat(h, '\' found!'))
                    return this._validateTile({
                        size: n,
                        id: e,
                        ignoreSizes: a
                    })
                        ? u === T
                            ? this._createAnimate({
                                    id: e,
                                    size: n,
                                    blur: i,
                                    ignoreSizes: a,
                                    animSource: u,
                                    guides: l
                                }, h)
                            : u === S
                                ? this._createSpine({
                                        id: e,
                                        size: n,
                                        blur: i,
                                        ignoreSizes: a,
                                        animSource: u,
                                        guides: l
                                    }, h)
                                : void 0
                        : this._createEmpty(i.enabled)
                }
            }, {
                key: '_createAnimate',
                value(t) {
                    let e = t.id
                    var n = t.size
                    var i = t.blur
                    var a = t.animSource
                    var s = void 0 === a ? T : a
                    var u = t.guides
                    var c = void 0 === u ? {} : u
                    var l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'Tiles'
                    var h = r.a[l]
                    var f = this._getTileName({
                        id: e,
                        size: n
                    }, h)
                    var d = this._getTileGuide({
                        animSource: s,
                        source: h,
                        size: n,
                        guides: c
                    })
                    if (this._guides = b(b({}, this._guides), {}, E({}, n, d)), !this._validateAnimationSource({
                        id: e
                    }, h, f)) { return this._createEmpty(i.enabled)
                    }
                    let p = new h[f]()
                            var m = this._prepare(p)
                            var y = {
                        normal: {
                            texture: new Object(o.f)(m),
                            pivot: m.pivot.clone()
                        }
                    };
                    return i.enabled && (y = this._addBlurToTile(y, {
                        id: e,
                        blur: i,
                        animSource: s
                    }, m, d)), y
                }
            }, {
                key: '_createSpine',
                value(t) {
                    let e = t.id
                    var n = t.size
                    var i = t.blur
                    var a = t.animSource
                    var s = void 0 === a ? S : a
                    var u = t.guides
                    var c = void 0 === u ? {} : u
                    var l = r.g
                    var h = this._getTileName({
                        id: e,
                        size: n
                    }, l)
                    var f = this._getTileGuide({
                        animSource: s,
                        source: l,
                        size: n,
                        guides: c
                    })
                    if (this._guides = b(b({}, this._guides), {}, E({}, n, f)), !this._validateAnimationSource({
                        id: e
                    }, l, h)) { return this._createEmpty(i.enabled)
                    }
                    let d = new _.d(l[h])
                    var p = d.spineData.findAnimation('initX'.concat(n))
                    var m = (p == null ? void 0 : p.name) || 'init'
                    d.state.setAnimation(0, m, 0)
                    let y = d.getBounds()
                    var v = this._prepareSpine(d, y)
                    var g = {
                        x: f.width / 2 + v.pivot.x,
                        y: f.height / 2 + v.pivot.y
                    }
                    var x = {
                        normal: {
                            texture: new Object(o.f)(v),
                            pivot: g
                        }
                    }
                    return i.enabled && (x = this._addBlurToTile(x, {
                        id: e,
                        blur: i,
                        animSource: s
                    }, v, f)), x
                }
            }, {
                key: '_createForSizes',
                value(t, e) {
                    let n = this
                    var r = t.id
                    var i = t.sizes
                    var o = t.blur
                    var a = t.ignoreSizes
                    var s = t.animSource
                    var u = t.guides
                    return i.reduce((t, i) => {
                        return b(b({}, t), {}, E({}, i, n._create({
                            id: r,
                            size: i,
                            blur: o,
                            ignoreSizes: a,
                            animSource: s,
                            guides: u
                        }, e)))
                    }, {})
                }
            }, {
                key: '_prepare',
                value(t) {
                    let e = t.children
                    if (!e || !e.length) return t
                    let n = e.some((t) => {
                        return t.isMask
                    })
                    var r = e.reduce((t, e) => {
                        if (n) {
                            if (e.isMask) {
                                let r = e.getLocalBounds()
                                return {
                                    x: Math.min(t.x, r.x),
                                    y: Math.min(t.y, r.y)
                                }
                            }
                            return t
                        }
                        return {
                            x: Math.min(t.x, e.x),
                            y: Math.min(t.y, e.y)
                        }
                    }, {
                        x: 1 / 0,
                        y: 1 / 0
                    })
                    return t.pivot.set(r.x, r.y), t
                }
            }, {
                key: '_prepareSpine',
                value(t, e) {
                    return t.pivot.set(e.x, e.y), t
                }
            }, {
                key: '_createEmpty',
                value(t) {
                    let e = {
                        normal: {
                            texture: i.Texture.EMPTY,
                            pivot: {
                                x: 0,
                                y: 0
                            }
                        }
                    }
                    return t && (e = b(b({}, e), {}, {
                        blurred: {
                            texture: i.Texture.EMPTY,
                            pivot: {
                                x: 0,
                                y: 0
                            }
                        }
                    })), e
                }
            }, {
                key: '_addBlurToTile',
                value(t, e, n, r) {
                    let i = e.id
                    var o = e.blur
                    var a = e.animSource
                    var s = new v(o[i] || o.default).generateTexture(n)
                    var u = s.blurredTexture
                    var c = s.blurPivot
                    return a === S && (c = {
                        x: r.width / 2 + c.x,
                        y: r.height / 2 + c.y
                    }), b(b({}, t), {}, {
                        blurred: {
                            texture: u,
                            pivot: c
                        }
                    })
                }
            }]) && x(e.prototype, n), a && x(e, a), t
        }())
        e.a = new w()
    },
    './src/core/features/sound/SoundRouter.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return lt
        })
        const r = n('./src/core/loader/AssetCache.js')
        const i = n('./node_modules/ramda/es/isNil.js')
        const o = n('./node_modules/howler/dist/howler.js')
        const a = n('./node_modules/@games/gsap/all.js')
        const s = 'soundConfig.js'
        const u = {
            freeSpinsStart: 0.58,
            winNormal: 0.87,
            reelSpinLoop: 1,
            backgrLoop: 0.3,
            winLines: 0.76,
            wildExpandHit: 1,
            reelSpinMechLoop: 1.26,
            winLinesExtraWin: 1.01,
            bangupLoop: 1.29,
            fsWin: 0.85,
            bigWinStart: 0.8,
            superWinStart: 0.83,
            megaWinStart: 0.85,
            megaWinEnd: 1.15,
            superWinEnd: 1.22,
            bigWinEnd: 1.22,
            smallWin: 0.67,
            fsSplash3: 0.73,
            fsSplash2: 0.64,
            specialWildPass: 0.82
        }
        const c = {
            name: 'mainGain',
            value: 1
        }
        const l = {
            channels: [{
                effects: []
            }, {
                effects: [{
                    name: 'CompressorEffect',
                    properties: {
                        threshold: -1,
                        knee: 0,
                        attack: 0.10000000149011612,
                        release: 0.5,
                        ratio: 12
                    }
                }]
            }, {
                effects: [{
                    name: 'CompressorEffect',
                    properties: {
                        threshold: -1,
                        knee: 0,
                        attack: 0.10000000149011612,
                        release: 0.5,
                        ratio: 12
                    }
                }]
            }, {
                effects: []
            }, {
                effects: []
            }, {
                effects: []
            }, {
                effects: []
            }, {
                effects: []
            }, {
                effects: []
            }, {
                effects: []
            }],
            soundNameToChannelIndex: {
                anticipation: 0,
                anticipationFS: 0,
                backgrLoop: 0,
                bangupEnd: '0',
                bangupLoop: '0',
                bangupStart: '0',
                bigWinEnd: '1',
                bigWinLoop: '1',
                bigWinStart: '1',
                freeSpinsStart: 0,
                fsHit1: '2',
                fsHit2: '2',
                fsHit3: '2',
                fsHit4: 0,
                fsHit5: 0,
                fsInFs: 0,
                fsLoop: 0,
                fsPreloaderLoop: 0,
                fsWin: 0,
                introEnterGame: 0,
                jackHit: 0,
                jackSiren: 0,
                jpHit1: 0,
                jpHit2: 0,
                jpHit3: 0,
                jpSpawn1: 0,
                jpSpawn2: 0,
                jpSpawn3: 0,
                megaWinEnd: '1',
                megaWinLoop: '1',
                megaWinStart: '1',
                nearMiss: 0,
                payTableButtons: 0,
                payTablePages: 0,
                playButton: 0,
                reelSpinLoop: 0,
                reelSpinMechLoop: 0,
                reelStop: 0,
                respinLoop: 0,
                spinStart: 0,
                superWinEnd: '1',
                superWinLoop: '1',
                superWinStart: '1',
                totalWin: 0,
                winLines: 0,
                winNormal: 0,
                winSmall: 0,
                wildHit1: 0,
                wildExpand: 0,
                wildExpandHit: 0,
                fsLoop2: 0,
                fsLoop3: 0,
                fsSplash1: 0,
                fsSplash2: 0,
                fsSplash3: 0,
                addWild: 0,
                extraWinWait: '1',
                winLinesExtraWin: 0,
                smallWin: 0,
                fsPass: 0,
                specialWildPass: 0,
                wildPass: 0
            }
        }

        function h(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function f(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const d = (function () {
            function t() {
                h(this, t), this.inputNode = null, this.outputNode = null
            }
            let e, n, r
            return e = t, (n = [{
                key: 'mixerData',
                get() {
                    throw new new Error('Subclass MUST override mixerData getter')()
                }
            }, {
                key: 'mixerConfig',
                get() {
                    let t = this
                    return {
                        name: this.mixerData.name,
                        properties: Object.fromEntries(this.mixerData.properties.map((e) => {
                            var n = e.name
                                return [n, t[n]]
                        }))
                    }
                }
            }, {
                key: 'context',
                get() {
                    return o.Howler.ctx
                }
            }]) && f(e.prototype, n), r && f(e, r), t
        }())

        function p(t, e) {
            let n = typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
            if (!n) {
                if (Array.isArray(t) || (n = (function (t, e) {
                    if (!t) return
                    if (typeof t == 'string') return m(t, e)
                    let n = Object.prototype.toString.call(t).slice(8, -1)
                    n === 'Object' && t.constructor && (n = t.constructor.name)
                    if (n === 'Map' || n === 'Set') return Array.from(t)
                    if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return m(t, e)
                }(t))) || e && t && typeof t.length == 'number') {
                    n && (t = n)
                    let r = 0
                    const i = function () {}
                    return {
                        s: i,
                        n() {
                            return r >= t.length
                                ? {
                                        done: !0
                                    }
                                : {
                                        done: !1,
                                        value: t[r++]
                                    }
                        },
                        e(t) {
                            throw t
                        },
                        f: i
                    }
                }
                throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }
            let o; let a = !0
            let s = !1
            return {
                s() {
                    n = n.call(t)
                },
                n() {
                    const t = n.next()
                    return a = t.done, t
                },
                e(t) {
                    s = !0, o = t
                },
                f() {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw o
                    }
                }
            }
        }

        function m(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function y(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const v = (function () {
            function t(e) {
                const n = e.context
                var r = e.index
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.context = n, this.node = this.context.createGain(), this.index = r, this._connectedTo = null, this._effects = []
            }
            let e, n, r
            return e = t, (n = [{
                key: 'mixerConfig',
                get() {
                    return {
                        effects: this._effects.map((t) => {
                            return t.mixerConfig
                        })
                    }
                }
            }, {
                key: 'gain',
                get() {
                    return this.node.gain.value
                },
                set(t) {
                    isNaN(t) || this.node.gain.setValueAtTime(t, this.context.currentTime)
                }
            }, {
                key: 'connect',
                value(t) {
                    this._connectedTo = t, this._updateConnections()
                }
            }, {
                key: 'addEffect',
                value(t) {
                    this._effects.push(t), this._updateConnections()
                }
            }, {
                key: 'removeEffect',
                value(t) {
                    t.outputNode.disconnect(), this._effects = this._effects.filter((e) => {
                        return e != t
                    }), this._updateConnections()
                }
            }, {
                key: '_updateConnections',
                value() {
                    this.node.disconnect()
                    var t; let e = p(this._effects)
                    try {
                        for (e.s(); !(t = e.n()).done;) t.value.outputNode.disconnect()
                    } catch (t) {
                        e.e(t)
                    } finally {
                        e.f()
                    }
                    if (this._effects.length > 0) {
                        this.node.connect(this._effects[0].inputNode)
                        for (let n = 0; n < this._effects.length - 1; n++) this._effects[n].outputNode.connect(this._effects[n + 1].inputNode)
                        this._effects[this._effects.length - 1].outputNode.connect(this._connectedTo)
                    } else { this.node.connect(this._connectedTo)
                    }
                }
            }]) && y(e.prototype, n), r && y(e, r), t
        }())

        function _(t) {
            return (_ = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function g(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function b(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function E(t, e, n) {
            return e = x(e),
            (function (t, e) {
                if (e && (_(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], x(t).constructor)
                : e.apply(t, n)))
        }

        function x(t) {
            return (x = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function T(t, e) {
            return (T = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const S = {
            name: 'CompressorEffect',
            properties: [{
                name: 'threshold',
                min: -100,
                max: 100
            }, {
                name: 'knee',
                min: -100,
                max: 100
            }, {
                name: 'attack',
                min: 0,
                max: 2
            }, {
                name: 'release',
                min: 0,
                max: 2
            }, {
                name: 'ratio',
                min: 0,
                max: 100
            }]
        }
        const w = (function (t) {
            function e() {
                let t; const n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                g(this, e), (t = E(this, e, [n])).inputNode = t.context.createDynamicsCompressor(), t.outputNode = t.context.createGain(), t.inputNode.connect(t.outputNode)
                let r = n.threshold
                var i = void 0 === r ? -24 : r
                var o = n.knee
                var a = void 0 === o ? 30 : o
                var s = n.attack
                var u = void 0 === s ? 0.003 : s
                var c = n.release
                var l = void 0 === c ? 0.25 : c
                var h = n.ratio
                var f = void 0 === h ? 12 : h
                return t.threshold = i, t.knee = a, t.attack = u, t.release = l, t.ratio = f, t
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && T(t, e)
            }(e, t)), n = e, (r = [{
                key: 'mixerData',
                get() {
                    return S
                }
            }, {
                key: 'threshold',
                get() {
                    return this.inputNode.threshold.value
                },
                set(t) {
                    this.inputNode.threshold.value = t
                }
            }, {
                key: 'knee',
                get() {
                    return this.inputNode.knee.value
                },
                set(t) {
                    this.inputNode.knee.value = t
                }
            }, {
                key: 'attack',
                get() {
                    return this.inputNode.attack.value
                },
                set(t) {
                    this.inputNode.attack.value = t
                }
            }, {
                key: 'release',
                get() {
                    return this.inputNode.release.value
                },
                set(t) {
                    this.inputNode.release.value = t
                }
            }, {
                key: 'ratio',
                get() {
                    return this.inputNode.ratio.value
                },
                set(t) {
                    this.inputNode.ratio.value = t
                }
            }]) && b(n.prototype, r), i && b(n, i), e
        }(d))

        function O(t) {
            return (O = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function P(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function R(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function A(t, e, n) {
            return e = I(e),
            (function (t, e) {
                if (e && (O(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], I(t).constructor)
                : e.apply(t, n)))
        }

        function I(t) {
            return (I = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function C(t, e) {
            return (C = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const k = {
            name: 'EchoEffect',
            properties: [{
                name: 'dry',
                min: 0,
                max: 1
            }, {
                name: 'wet',
                min: 0,
                max: 1
            }, {
                name: 'time',
                min: 0,
                max: 5
            }, {
                name: 'feedback',
                min: 0,
                max: 1
            }]
        }
        const N = (function (t) {
            function e() {
                let t; let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                P(this, e), (t = A(this, e, [n])).inputNode = t.context.createGain(), t.outputNode = t.context.createGain(), t.dryGainNode = t.context.createGain(), t.wetGainNode = t.context.createGain(), t.feedbackGainNode = t.context.createGain(), t.delayNode = t.context.createDelay(), t.inputNode.connect(t.dryGainNode), t.dryGainNode.connect(t.outputNode), t.delayNode.connect(t.feedbackGainNode), t.feedbackGainNode.connect(t.delayNode), t.inputNode.connect(t.delayNode), t.delayNode.connect(t.wetGainNode), t.wetGainNode.connect(t.outputNode)
                var r = n.dry
                            var i = void 0 === r ? 0.7 : r
                            var o = n.wet
                            var a = void 0 === o ? 0.3 : o
                            var s = n.time
                            var u = void 0 === s ? 0.5 : s
                            var c = n.feedback
                            var l = void 0 === c ? 0.3 : c
                return t.dry = i, t.wet = a, t.time = u, t.feedback = l, t
            }
            let n, r, i
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && C(t, e)
            }(e, t)), n = e, (r = [{
                key: 'mixerData',
                get () {
                    return k
                }
            }, {
                key: 'dry',
                get () {
                    return this.dryGainNode.gain.value
                },
                set (t) {
                    this.dryGainNode.gain.value = t
                }
            }, {
                key: 'wet',
                get () {
                    return this.wetGainNode.gain.value
                },
                set (t) {
                    this.wetGainNode.gain.value = t
                }
            }, {
                key: 'time',
                get () {
                    return this._time
                },
                set (t) {
                    this._time = t, this.delayNode.delayTime.value = t
                }
            }, {
                key: 'feedback',
                get () {
                    return this._feedback
                },
                set (t) {
                    this._feedback = t, this.feedbackGainNode.gain.value = t
                }
            }]) && R(n.prototype, r), i && R(n, i), e
        }(d))
        const M = n('./src/core/utils/index.js')

        function j(t) {
            return (j = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function D(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function L(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function F(t, e, n) {
            return e = B(e),
            (function (t, e) {
                if (e && (j(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], B(t).constructor)
                : e.apply(t, n)))
        }

        function B(t) {
            return (B = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function U(t, e) {
            return (U = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const G = {
            name: 'ReverbEffect',
            properties: [{
                name: 'dry',
                min: 0,
                max: 1
            }, {
                name: 'wet',
                min: 0,
                max: 1
            }, {
                name: 'duration',
                min: 0,
                max: 10
            }, {
                name: 'decay',
                min: 0.1,
                max: 5
            }]
        }
        const X = (function (t) {
            function e() {
                let t; const n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                D(this, e), t = F(this, e, [n])
                let r = n.dry
                var i = void 0 === r ? 0.7 : r
                var o = n.wet
                var a = void 0 === o ? 0.3 : o
                var s = n.duration
                var u = void 0 === s ? 1 : s
                var c = n.decay
                var l = void 0 === c ? 2 : c
                return t._duration = u, t._decay = l, t.inputNode = t.context.createGain(), t.outputNode = t.context.createGain(), t.dryGainNode = t.context.createGain(), t.wetGainNode = t.context.createGain(), t.convolverNode = t.context.createConvolver(), t.convolverNode.buffer = t._buildImpulseResponse(u, l), t.inputNode.connect(t.dryGainNode), t.dryGainNode.connect(t.outputNode), t.inputNode.connect(t.convolverNode), t.convolverNode.connect(t.wetGainNode), t.wetGainNode.connect(t.outputNode), t.dry = i, t.wet = a, t
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && U(t, e)
            }(e, t)), n = e, (r = [{
                key: 'mixerData',
                get() {
                    return G
                }
            }, {
                key: 'dry',
                get() {
                    return this.dryGainNode.gain.value
                },
                set(t) {
                    this.dryGainNode.gain.value = t
                }
            }, {
                key: 'wet',
                get() {
                    return this.wetGainNode.gain.value
                },
                set(t) {
                    this.wetGainNode.gain.value = t
                }
            }, {
                key: 'duration',
                get() {
                    return this._duration
                },
                set(t) {
                    this._duration = t, this.convolverNode.buffer = this._buildImpulseResponse(this._duration, this._decay)
                }
            }, {
                key: 'decay',
                get() {
                    return this._decay
                },
                set(t) {
                    this._decay = t, this.convolverNode.buffer = this._buildImpulseResponse(this._duration, this._decay)
                }
            }, {
                key: '_buildImpulseResponse',
                value(t, e) {
                    for (var n = this.context.sampleRate * t, r = this.context.createBuffer(1, n, this.context.sampleRate), i = r.getChannelData(0), o = 0; o < i.length; o++) {
                        let a = (1 - o / n) ** e;
                        i[o] = new Object(M.h)(-a, a)
                    }
                    return r
                }
            }]) && L(n.prototype, r), i && L(n, i), e
        }(d))

        function H(t) {
            return (H = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function V(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function W(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? V(new Object(n), !0).forEach((e) => {
                            Y(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : V(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Y(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function z(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function q(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function K(t, e, n) {
            return e && q(t.prototype, e), n && q(t, n), t
        }

        function Z(t, e, n) {
            return e = $(e),
            (function (t, e) {
                if (e && (H(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], $(t).constructor)
                : e.apply(t, n)))
        }

        function $(t) {
            return ($ = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function J(t, e) {
            if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Q(t, e)
        }

        function Q(t, e) {
            return (Q = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const tt = {
            properties: [{
                name: 'frequency',
                min: 0,
                max: 2e4
            }, {
                name: 'peak',
                min: 0,
                max: 1e3
            }]
        }
        const et = (function (t) {
            function e() {
                let t; let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                z(this, e), t = Z(this, e, [n])
                var r = n.name
                            var i = n.type
                            var o = n.frequency
                            var a = void 0 === o ? 350 : o
                            var s = n.peak
                            var u = void 0 === s ? 1 : s
                return t.name = r, t.inputNode = t.outputNode = t.context.createBiquadFilter(), t.inputNode.type = i, t.frequency = a, t.peak = u, t
            }
            return J(e, t), K(e, [{
                key: 'mixerData',
                get () {
                    return W(W({}, tt), {}, {
                        name: this.name
                    })
                }
            }, {
                key: 'frequency',
                get () {
                    return this.inputNode.frequency.value
                },
                set (t) {
                    this.inputNode.frequency.value = t
                }
            }, {
                key: 'peak',
                get () {
                    return this.inputNode.Q.value
                },
                set (t) {
                    this.inputNode.Q.value = t
                }
            }]), e
        }(d))
        const nt = {
            CompressorEffect: w,
            EchoEffect: N,
            ReverbEffect: X,
            LowPassFilterEffect: (function (t) {
                function e(t) {
                    return z(this, e), Z(this, e, [W({
                        type: 'lowpass',
                        name: 'LowPassFilterEffect'
                    }, t)])
                }
                return J(e, t), K(e)
            }(et)),
            HighPassFilterEffect: (function (t) {
                function e(t) {
                    return z(this, e), Z(this, e, [W({
                        type: 'highpass',
                        name: 'HighPassFilterEffect'
                    }, t)])
                }
                return J(e, t), K(e)
            }(et))
        }

        function rt(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function it(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? rt(new Object(n), !0).forEach((e) => {
                            ct(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : rt(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function ot(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || at(t, e) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function at(t, e) {
            if (t) {
                if (typeof t == 'string') return st(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                return n === 'Object' && t.constructor && (n = t.constructor.name), n === 'Map' || n === 'Set' ? Array.from(t) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? st(t, e) : void 0
            }
        }

        function st(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function ut(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function ct(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        var lt = (function () {
            function t() {
                let e; let n; const s = this
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), ct(this, 'getSoundsProxy', (t) => {
                    return new Proxy(t, {
                        get(e, n) {
                            if (!o.Howler.noAudio) {
                                let r = !1
                                Object.keys(t).forEach((e) => {
                                    t[e]._sprite.hasOwnProperty(n) && (r = !0)
                                }), !r && s._soundNotLoaded(n)
                            }
                            return s.getSoundProxy(n)
                        }
                    })
                }), ct(this, 'getSoundProxy', (t) => {
                    return new Proxy({}, {
                        get(e, n) {
                            return o.Howler.noAudio
                                ? function () {
                                    return s.getSoundProxy(t)
                                }
                                : s._isMethodInterceptable(n) ? s.getSoundMethodProxy(t, n) : r.e.main_0[n]
                        }
                    })
                }), ct(this, 'getSoundMethodProxy', (t, e) => {
                    return new Proxy(() => {}, {
                        apply(n, r, o) {
                            let a = (0, s.interceptMethods[e])(t, o)
                            return new Object(i.a)(a) ? s.getSoundProxy(t) : a
                        }
                    })
                }), ct(this, 'play', (t) => {
                    if (s._passedLimitInterval(t)) {
                        const e = s._getSoundHowl(t)
                        if (e) {
                            const n = e.play(t)
                            var r = s._getSoundHowl(t)._soundById(n)
                            s._gains[t] || s._attachGain(r, t), r._node.disconnect(o.Howler.masterGain), r._node.connect(s._gains[t]), s._gains[t].disconnect()
                            let i = s._channels[s._soundNameToChannelIndex[t]]
                            i && s._gains[t].connect(i.node), s.ids[t] = n, s.lastPlayedAt[t] = Date.now(), s._getSoundHowl(t).once('end', () => {
                                n && s._getSoundHowl(t).loop(n) || delete s.ids[t]
                            }, n)
                        }
                    }
                }), ct(this, 'playing', (t) => {
                    const e = s.ids[t]
                    return Boolean(e && s._getSoundHowl(t).playing(e))
                }), ct(this, 'stop', (t) => {
                    const e = s.ids[t]
                    e && s._getSoundHowl(t).stop(e), delete s.ids[t]
                }), ct(this, 'loop', (t, e) => {
                    const n = ot(e, 1)[0]
                    var r = s.ids[t]
                    r && s._getSoundHowl(t).loop(n, r)
                }), ct(this, 'fadeIn', (t, e) => {
                    const n = ot(e, 1)[0]
                    s.fadeTo(t, [n, 1])
                }), ct(this, 'fadeTo', (t, e) => {
                    const n = ot(e, 3)
                    var r = n[0]
                    var i = n[1]
                    var o = n[2]
                    var u = s.ids[t]
                    if (u) {
                        s._tweens[u] = {
                            _volume: s._getSoundHowl(t).volume(u)
                        }
                        let c = r * Math.abs(s._tweens[u]._volume - i)
                        a.b.to(s._tweens[u], {
                            duration: c,
                            _volume: i,
                            onUpdate() {
                                return s._getSoundHowl(t).volume(s._tweens[u]._volume, u)
                            },
                            onComplete() {
                                return o && s.stop(t)
                            }
                        })
                    }
                }), ct(this, 'fadeOut', (t, e) => {
                    const n = ot(e, 2)
                    var r = n[0]
                    var i = n[1]
                    void 0 === i && (i = !0), s.fadeTo(t, [r, 0, i])
                }), ct(this, 'volume', (t, e) => {
                    const n = ot(e, 1)[0]
                    var r = s.ids[t]
                    if (new Object(i.a)(n)) return r && s._getSoundHowl(t).volume(r)
                    r && s._getSoundHowl(t).volume(n, r)
                }), ct(this, 'on', (t, e) => {
                    const n = ot(e, 2)
                    var r = n[0]
                    var i = n[1]
                    var o = s.ids[t]
                    o && s._getSoundHowl(t).on(r, i, o)
                }), ct(this, 'off', (t, e) => {
                    const n = ot(e, 2)
                    var r = n[0]
                    var i = n[1]
                    var o = s.ids[t]
                    o && s._getSoundHowl(t).off(r, i, o)
                }), ct(this, 'once', (t, e) => {
                    const n = ot(e, 2)
                    var r = n[0]
                    var i = n[1]
                    var o = s.ids[t]
                    o && s._getSoundHowl(t).once(r, i, o)
                }), ct(this, 'limitInterval', (t, e) => {
                    const n = ot(e, 1)[0]
                    s.intervals[t] = 1e3 * n
                }), ct(this, 'pauseAll', () => {
                    Object.keys(s.ids).forEach((t) => {
                        if (s.playing(t)) {
                            let e = s.ids[t]
                            s.soundsToPause.push(e), e && s._getSoundHowl(t).pause(e)
                        }
                    })
                }), ct(this, 'resumeAll', () => {
                    s.soundsToPause.forEach((t) => {
                        Object.keys(r.e).forEach((e) => {
                            r.e[e]._soundById(t) && r.e[e].play(t)
                        })
                    }), s.soundsToPause = []
                }), ct(this, 'fadeOutSounds', function () {
                    const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                    var e = []
                    t.forEach((t) => {
                        s.ids[t] ? e.push(t) : console.warn('Sound not found', t)
                    }), Object.keys(s.ids).forEach((t) => {
                        s.playing(t) && s.volume(t, []) > 0 && !e.includes(t) && (s.fadedSounds.push({
                            name: t,
                            vol: s.volume(t, [])
                        }), s.fadeOut(t, [1, !1]))
                    })
                }), ct(this, 'fadeInSounds', () => {
                    s.fadedSounds.forEach((t) => {
                        return s.fadeTo(t.name, [1, t.vol])
                    }), s.fadedSounds = []
                }), this.soundsToPause = [], this._tweens = [], this.ids = new Proxy({}, {
                    get(t, e) {
                        return t[e] || 0
                    }
                }), this.intervals = new Proxy({}, {
                    get(t, e) {
                        return t[e] || 0
                    }
                }), this.lastPlayedAt = new Proxy({}, {
                    get(t, e) {
                        return t[e] || 0
                    }
                }), this.interceptMethods = {
                    play: this.play,
                    playing: this.playing,
                    stop: this.stop,
                    loop: this.loop,
                    fadeIn: this.fadeIn,
                    fadeOut: this.fadeOut,
                    fadeTo: this.fadeTo,
                    reset: this.reset,
                    volume: this.volume,
                    on: this.on,
                    once: this.once,
                    off: this.off,
                    limitInterval: this.limitInterval
                }, this._gains = {}, this._effectsConstructors = nt, this._channels = [], this.masterChannel = this._createChannel(o.Howler.masterGain), this._soundNameToChannelIndex = {}, ((e = l) === null || void 0 === e || (n = e.channels) === null || void 0 === n ? void 0 : n.length) > 0 ? this._soundNameToChannelIndex = this._loadMixerConfig() : this._soundNameToChannelIndex = this._initMixerNoConfig(), this._gainsValues = it({}, u), o.Howler.noAudio && Object.keys(this.interceptMethods).forEach((t) => {
                    return s.interceptMethods[t] = function () {}
                }), this.fadedSounds = [], this.sounds = this.getSoundsProxy(r.e), this.mainGainValue = this.mainGainConfig.value
            }
            let e, n, h
            return e = t, h = [{
                key: 'mute',
                value() {
                    o.Howler.mute(!0)
                }
            }, {
                key: 'unmute',
                value() {
                    o.Howler.mute(!1)
                }
            }, {
                key: 'setRate',
                value(t) {
                    o.Howler._howls.forEach((e) => {
                        e.rate(t)
                    })
                }
            }], (n = [{
                key: 'gainValues',
                get() {
                    return this._gainsValues
                }
            }, {
                key: 'soundNames',
                get() {
                    let t = {}
                    return Object.keys(r.e).forEach((e) => {
                        t = it(it({}, t), r.e[e]._sprite)
                    }), Object.keys(t)
                }
            }, {
                key: 'exportFileName',
                get() {
                    return s
                }
            }, {
                key: 'mainGainConfig',
                get() {
                    return c
                }
            }, {
                key: 'mainGainValue',
                get() {
                    return this.masterChannel.gain
                },
                set(t) {
                    this.masterChannel.gain = t
                }
            }, {
                key: 'mixerConfig',
                get() {
                    return {
                        channels: this._channels.map((t) => {
                            return t.mixerConfig
                        }),
                        soundNameToChannelIndex: this._soundNameToChannelIndex
                    }
                }
            }, {
                key: 'setGainValue',
                value(t, e) {
                    const n = this._gains[t]
                    if (n) {
                        const r = n.context
                        n.gain.setValueAtTime(e, r.currentTime)
                    }
                    this._gainsValues[t] = e
                }
            }, {
                key: '_createChannel',
                value() {
                    const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.masterChannel.node
                    var e = new v({
                        context: o.Howler.masterGain.context,
                        index: this._channels.length
                    })
                    return this._channels.push(e), e.connect(t), e
                }
            }, {
                key: '_getSoundHowl',
                value(t) {
                    let e = null
                    return Object.keys(r.e).forEach((n) => {
                        r.e[n]._sprite.hasOwnProperty(t) && (e = r.e[n])
                    }), e
                }
            }, {
                key: '_initMixerNoConfig',
                value() {
                    for (let t = 0; t < 9; t++) this._createChannel()
                    let e = {}
                    return this.soundNames.forEach((t) => {
                        e[t] = 0
                    }), e
                }
            }, {
                key: '_loadMixerConfig',
                value() {
                    let t; const e = l
                    var n = e.channels
                    var r = e.soundNameToChannelIndex
                    var i = void 0 === r ? {} : r
                    var o = (function (t, e) {
                        let n = typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                        if (!n) {
                            if (Array.isArray(t) || (n = at(t)) || e && t && typeof t.length == 'number') {
                                n && (t = n)
                                var r = 0
                                            var i = function () {}
                                return {
                                    s: i,
                                    n () {
                                        return r >= t.length
? {
                                            done: !0
                                        }
: {
                                            done: !1,
                                            value: t[r++]
                                        }
                                    },
                                    e (t) {
                                        throw t
                                    },
                                    f: i
                                }
                            }
                            throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
                        }
                        let o; let a = !0
                                    var s = !1
                        return {
                            s () {
                                n = n.call(t)
                            },
                            n () {
                                var t = n.next()
                                        return a = t.done, t
                            },
                            e (t) {
                                s = !0, o = t
                            },
                            f () {
                                try {
                                    a || n.return == null || n.return()
                                } finally {
                                    if (s) throw o
                                }
                            }
                        }
                    }(this.soundNames))
                    try {
                        for (o.s(); !(t = o.n()).done;) {
                            const a = t.value
                            i.hasOwnProperty(a) || (i[a] = 0)
                        }
                    } catch (t) {
                        o.e(t)
                    } finally {
                        o.f()
                    }
                    this._loadChannelConfig(this.masterChannel, n[0])
                    for (let s = 1; s < n.length; s++) {
                        const u = this._createChannel()
                        this._loadChannelConfig(u, n[s])
                    }
                    return i
                }
            }, {
                key: '_loadChannelConfig',
                value(t, e) {
                    const n = this
                    e.effects.forEach((e) => {
                        let r = new n._effectsConstructors[e.name]({})
                        Object.assign(r, e.properties), t.addEffect(r)
                    })
                }
            }, {
                key: '_attachGain',
                value(t, e) {
                    if (t) {
                        const n = t._node.context
                        var r = 1
                        Object.keys(this._gainsValues).includes(e) && (r = this._gainsValues[e])
                        let i = n.createGain()
                        i.gain.setValueAtTime(r, n.currentTime), this._gains[e] = i
                    }
                }
            }, {
                key: '_isMethodInterceptable',
                value(t) {
                    return !!this.interceptMethods[t]
                }
            }, {
                key: '_soundNotLoaded',
                value(t) {
                    return console.warn('Warning: Sound '.concat(t, ' not loaded'))
                }
            }, {
                key: '_passedLimitInterval',
                value(t) {
                    const e = this.lastPlayedAt[t]
                    var n = this.intervals[t]
                    var r = !0
                    return e && n && Date.now() - e < n && (r = !1), r
                }
            }]) && ut(e.prototype, n), h && ut(e, h), t
        }())
    },
    './src/core/fixes/index.js': function (t, e, n) {
        'use strict'
        let r; let i; const o = n('./node_modules/pixi.js/dist/esm/pixi.js')
        r = {
            willReadFrequently: !0
        }, i = (function () {
            try {
                const t = new OffscreenCanvas(0, 0)
                let e = t.getContext('2d', r)
                return e && e.measureText ? t : document.createElement('canvas')
            } catch (t) {
                return document.createElement('canvas')
            }
        }()), o.TextMetrics._canvas = i, o.TextMetrics._context = i.getContext('2d', r)
    },
    './src/core/loader/AssetCache.js': function (t, e, n) {
        'use strict'
        n.d(e, 'c', () => {
            return r
        }), n.d(e, 'e', () => {
            return i
        }), n.d(e, 'a', () => {
            return o
        }), n.d(e, 'd', () => {
            return a
        }), n.d(e, 'f', () => {
            return s
        }), n.d(e, 'b', () => {
            return u
        })
        var r = {}
        var i = {}
        var o = {}
        var a = {}
        var s = {}
        var u = {}
    },
    './src/core/loader/index.js': function (t, e, n) {
        'use strict'
        n.d(e, 'd', () => {
            return d.c
        }), n.d(e, 'f', () => {
            return d.e
        }), n.d(e, 'a', () => {
            return d.a
        }), n.d(e, 'e', () => {
            return d.d
        }), n.d(e, 'g', () => {
            return d.f
        }), n.d(e, 'c', () => {
            return d.b
        })
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = n('./src/core/utils/misc.js')
        const o = n('./src/core/utils/EventsHub.js')
        const a = n('./node_modules/@games/dope/src/Dopamine.js')
        const s = n('./src/config.js')

        function u(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function c(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        u(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        u(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function l(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function h(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const f = (function () {
            function t() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                var r = n.cdn
                var i = void 0 === r ? './' : r
                l(this, t), this._list = null, this._basePath = i, this.progress = 0, this._onProgress = e
            }
            let e, n, r, u, f
            return e = t, (n = [{
                key: 'loadList',
                value: (f = c(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (e = i.length > 0 && void 0 !== i[0] ? i[0] : [], n = !(i.length > 1 && void 0 !== i[1]) || i[1], this.list = e, e.length) {
                                            t.next = 6;
                                            break
                                        }
                                        return this.progress = 100, t.abrupt("return", Promise.resolve());
                                    case 6:
                                        return t.prev = 6, t.next = 9, this.attemptLoad();
                                    case 9:
                                        t.next = 18;
                                        break;
                                    case 11:
                                        if (t.prev = 11, t.t0 = t.catch(6), !Array.isArray(t.t0)) {
                                            t.next = 17;
                                            break
                                        }
                                        return r = t.t0.map((function(t) {
                                            return t.src
                                        })).join("\n"), o.a.emit(o.a.events.MESSAGE_SHOW, {
                                            title: a.c.texts.TITLE_SERVER_ERROR || "",
                                            text: "".concat(a.c.texts.CANNOT_PRELOAD_ASSETS, "\n").concat(r),
                                            msgType: "server_error",
                                            details: "".concat(a.c.texts.CANNOT_PRELOAD_ASSETS, "\n").concat(r),
                                            nonRecoverable: n
                                        }), t.abrupt("return", n ? new Promise((function() {})) : Promise.reject());
                                    case 17:
                                        console.error(t.t0);
                                    case 18:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this, [
                        [6, 11]
                    ])
                })), function () {
                    return f.apply(this, arguments)
                })
            }, {
                key: 'attemptLoad',
                value: (u = c(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = o.length > 0 && void 0 !== o[0] ? o[0] : this.list, n = o.length > 1 && void 0 !== o[1] ? o[1] : 5, t.prev = 2, t.next = 5, this.load(e);
                                    case 5:
                                        t.next = 20;
                                        break;
                                    case 7:
                                        if (t.prev = 7, t.t0 = t.catch(2), Array.isArray(t.t0)) {
                                            t.next = 12;
                                            break
                                        }
                                        return console.error(t.t0), t.abrupt("return");
                                    case 12:
                                        if (n - 1 != 0) {
                                            t.next = 14;
                                            break
                                        }
                                        return t.abrupt("return", Promise.reject(t.t0));
                                    case 14:
                                        return r = t.t0.map((function(t) {
                                            return t.src
                                        })).join("\n"), console.warn("Failed to load assets:\n".concat(r, ".\nTrying ").concat(n - 1, " more time(s).")), t.next = 18, Object(i.c)(1);
                                    case 18:
                                        return t.next = 20, this.attemptLoad(t.t0, n - 1);
                                    case 20:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this, [
                        [2, 7]
                    ])
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'load',
                value () {
                    return Promise.resolve()
                }
            }, {
                key: 'list',
                get () {
                    return this._list
                },
                set (t) {
                    this._list = t
                }
            }, {
                key: 'progress',
                get () {
                    return this._progress
                },
                set (t) {
                    this._progress = t, typeof this._onProgress == 'function' && this._onProgress(t)
                }
            }, {
                key: '_resolvePath',
                value (t) {
                    var e = this._basePath + t.src
                    return s.a.isBundleEnv && t.isCore ? this._replacePath(e) : e
                }
            }, {
                key: '_replacePath',
                value (t) {
                    var e = ''.concat(s.a.gameAppId, '.').concat(s.a.lang)
                                var n = ''.concat(s.a.gameAppId, '.en')
                        return t.replace(e, n)
                }
            }]) && h(e.prototype, n), r && h(e, r), t
        }())
        var d = n('./src/core/loader/AssetCache.js')
        let p = n('./src/core/Platform.js')

        function m(t) {
            return (m = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function y(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return v(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return v(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function v(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function _(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function g(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function b(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function E(t, e, n) {
            return e = x(e),
            (function (t, e) {
                if (e && (m(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], x(t).constructor)
                : e.apply(t, n)))
        }

        function x(t) {
            return (x = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function T(t, e) {
            return (T = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        r.utils.TextureCache
        const S = (function (t) {
            function e() {
                return g(this, e), E(this, e, arguments)
            }
            let n, i, o, a, u
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && T(t, e)
            }(e, t)), n = e, (i = [{
                key: 'load',
                value: (a = regeneratorRuntime.mark(function t() {
                    let e; let n; let i; let o; let a; let u; let c; let l = this
                            var h = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return e = h.length > 0 && void 0 !== h[0] ? h[0] : this.list, this.loader.reset(), e.forEach((function(t) {
                                        l.loader.resources[t.id] || l.loader.add(t.id, l._resolvePath(t))
                                    })), this.loader.use((function(t, e) {
                                        var n = s.a.scale[p.a.resolution].default;
                                        if (s.a.video.supportedFormats.includes(t.extension)) {
                                            var i = t.name,
                                                o = new r.Texture(new r.BaseTexture(t.data, {
                                                    resourceOptions: {
                                                        autoPlay: !1
                                                    }
                                                }));
                                            o.baseTexture.cacheId = i, o.source = t.data, r.BaseTexture.addToCache(o.baseTexture, i), r.Texture.addToCache(o, i), t.texture = o
                                        }
                                        return "jpg" === t.extension && t.texture.baseTexture.setResolution(n), e(t.error)
                                    })), n = [], i = function(t) {
                                        return l.progress = t.progress
                                    }, o = function(t, r, i) {
                                        var o = e.find((function(t) {
                                            return i.name.includes(t.id)
                                        }));
                                        n.push(o)
                                    }, a = this.loader.onProgress.add(i), u = this.loader.onError.add(o), c = this.loader.onComplete.add(i), t.next = 12, new Promise((function(t) {
                                        return l.loader.load(t)
                                    }));
                                case 12:
                                    if (a.detach(), u.detach(), c.detach(), Object.entries(this.loader.resources).forEach((function(t) {
                                            var e = y(t, 2),
                                                n = e[0],
                                                r = e[1];
                                            n.includes("_atlas_") ? r.textures && Object.assign(d.c, r.textures) : d.c[n] = r.texture
                                        })), !n.length) {
                                        t.next = 18;
                                        break
                                    }
                                    return t.abrupt("return", Promise.reject(n));
                                case 18:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                }), u = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = a.apply(t, e)

                        function o(t) {
                            _(i, n, r, o, s, 'next', t)
                        }

                        function s(t) {
                            _(i, n, r, o, s, 'throw', t)
                        }
                        o(void 0)
                    })
                }, function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'loader',
                get() {
                    return this._loader = this._loader || new r.Loader(), this._loader
                }
            }]) && b(n.prototype, i), o && b(n, o), e
        }(f))

        function w(t) {
            return (w = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function O(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function P(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function R(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function A(t, e, n) {
            return e = C(e),
            (function (t, e) {
                if (e && (w(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], C(t).constructor)
                : e.apply(t, n)))
        }

        function I(t, e, n) {
            return (I = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = C(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function C(t) {
            return (C = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function k(t, e) {
            return (k = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const N = (function (t) {
            function e() {
                return P(this, e), A(this, e, arguments)
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && k(t, e)
            }(e, t)), n = e, (r = [{
                key: 'load',
                value: (o = regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i; let o; let a = this
                                var s = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = s.length > 0 && void 0 !== s[0] ? s[0] : this.list, n = e.map((function(t) {
                                            var e = a._resolvePath(t),
                                                n = document.createElement("script");
                                            return n.setAttribute("src", e), new Promise((function(e, r) {
                                                n.onload = function() {
                                                    return e({
                                                        asset: t,
                                                        failed: !1
                                                    })
                                                }, n.onerror = function() {
                                                    return e({
                                                        asset: t,
                                                        failed: !0
                                                    })
                                                }, document.body.appendChild(n)
                                            }))
                                        })), t.next = 4, Promise.all(n);
                                    case 4:
                                        if (r = t.sent, i = r.filter((function(t) {
                                                return t.failed
                                            })).map((function(t) {
                                                return t.asset
                                            })), (o = r.length - i.length) && (this.progress = o / r.length * 100), !i.length) {
                                            t.next = 10;
                                            break
                                        }
                                        return t.abrupt("return", Promise.reject(i));
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                }), a = function () {
                    let t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = o.apply(t, e)

                        function a(t) {
                            O(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            O(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_replacePath',
                value (t) {
                    if (!s.a.isBundlerV2Build) return I(C(e.prototype), '_replacePath', this).call(this, t)
                    var n = s.a.bundlerGameId || s.a.gameAppId
                                var r = ''.concat(this._basePath, 'assets/');
                    var i = '../games.'.concat(n, '/assets/');
                    var o = t.replace(r, i)
                    return I(C(e.prototype), '_replacePath', this).call(this, o)
                }
            }]) && R(n.prototype, r), i && R(n, i), e
        }(f))
        let M = n('./node_modules/howler/dist/howler.js')

        function j(t) {
            return (j = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function D(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function L(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        D(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        D(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function F(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function B(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function U(t, e, n) {
            return e = G(e),
            (function (t, e) {
                if (e && (j(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], G(t).constructor)
                : e.apply(t, n)))
        }

        function G(t) {
            return (G = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function X(t, e) {
            return (X = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const H = (function (t) {
            function e() {
                return F(this, e), U(this, e, arguments)
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && X(t, e)
            }(e, t)), n = e, (r = [{
                key: 'load',
                value: (a = L(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if ((e = i.length > 0 && void 0 !== i[0] ? i[0] : this.list).length) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        n = 0;
                                    case 4:
                                        if (!(n < e.length)) {
                                            t.next = 12;
                                            break
                                        }
                                        return t.next = 7, this._loadSpritesheet(e[n]);
                                    case 7:
                                        r = t.sent, d.e[e[n].id] = r;
                                    case 9:
                                        n++, t.next = 4;
                                        break;
                                    case 12:
                                        this.progress = 100;
                                    case 13:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_loadSpritesheet',
                value: (o = L(regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; let o = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.prev = 0, t.next = 3, fetch(this._resolvePath(e));
                                    case 3:
                                        if ((n = t.sent).ok) {
                                            t.next = 6;
                                            break
                                        }
                                        throw Error(n.statusText);
                                    case 6:
                                        t.next = 11;
                                        break;
                                    case 8:
                                        return t.prev = 8, t.t0 = t.catch(0), t.abrupt("return", Promise.reject(e));
                                    case 11:
                                        return t.next = 13, n.json();
                                    case 13:
                                        (r = t.sent).urls = r.urls.map((function(t) {
                                            return o._resolvePath({
                                                isCore: !0,
                                                src: t
                                            })
                                        })), t.prev = 15, i = new M.Howl({
                                            src: r.urls,
                                            sprite: r.sprite
                                        }), t.next = 23;
                                        break;
                                    case 19:
                                        return t.prev = 19, t.t1 = t.catch(15), M.Howler.noAudio = !0, t.abrupt("return");
                                    case 23:
                                        if ("unloaded" !== i.state()) {
                                            t.next = 25;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 25:
                                        return t.prev = 25, t.next = 28, this._loadPromise(i);
                                    case 28:
                                        t.next = 33;
                                        break;
                                    case 30:
                                        return t.prev = 30, t.t2 = t.catch(25), t.abrupt("return", Promise.reject(e));
                                    case 33:
                                        return t.abrupt("return", i);
                                    case 34:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this, [
                        [0, 8],
                        [15, 19],
                        [25, 30]
                    ])
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_loadPromise',
                value (t) {
                    return new Promise((e, n) => {
                        var r = function () {
                                t.off('loaderror', i), t.off('load', o)
                            };
                                    var i = function() {
                                        r(), n()
                                    };
                                    var o = function () {
                                r(), e()
                            };
                        t.on('loaderror', i), t.on('load', o)
                    })
                }
            }]) && B(n.prototype, r), i && B(n, i), e
        }(f))
        let V = n('./node_modules/@games/pixi-animate/lib/index.js')

        function W(t) {
            return (W = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Y(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function z(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function q(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function K(t, e, n) {
            return e = Z(e),
            (function (t, e) {
                if (e && (W(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Z(t).constructor)
                : e.apply(t, n)))
        }

        function Z(t) {
            return (Z = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function $(t, e) {
            return ($ = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const J = (function (t) {
            function e() {
                return z(this, e), K(this, e, arguments)
            }
            let n, i, o, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && $(t, e)
            }(e, t)), n = e, (i = [{
                key: 'load',
                value: (a = regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i; let o; let a; let s; let u; let c = this
                            var l = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return e = l.length > 0 && void 0 !== l[0] ? l[0] : this.list, this.loader.reset(), e.forEach((function(t) {
                                        var e = t.id.replace(".shapes", "");
                                        c.loader.resources[e] || c.loader.add(e, c._resolvePath(t))
                                    })), n = [], r = function(t) {
                                        return c.progress = t.progress
                                    }, i = function(t, r, i) {
                                        return n.push(e.find((function(t) {
                                            return t.id === "".concat(i.name, ".shapes")
                                        })))
                                    }, o = this.loader.onProgress.add(r), a = this.loader.onError.add(i), s = this.loader.onComplete.add(r), t.next = 11, new Promise((function(t) {
                                        return c.loader.load((function(e, n) {
                                            return t(n)
                                        }))
                                    }));
                                case 11:
                                    if (u = t.sent, o.detach(), a.detach(), s.detach(), Object.keys(u).forEach((function(t) {
                                            var e = u[t];
                                            n.find((function(t) {
                                                return t.id === "".concat(e.name, ".shapes")
                                            })) || (V.ShapesCache.add(e.name, e.data), Object.assign(d.d, V.ShapesCache))
                                        })), !n.length) {
                                        t.next = 18;
                                        break
                                    }
                                    return t.abrupt("return", Promise.reject(n));
                                case 18:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                }), s = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = a.apply(t, e)

                        function o(t) {
                            Y(i, n, r, o, s, 'next', t)
                        }

                        function s(t) {
                            Y(i, n, r, o, s, 'throw', t)
                        }
                        o(void 0)
                    })
                }, function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'loader',
                get() {
                    return this._loader = this._loader || new r.Loader(), this._loader
                }
            }]) && q(n.prototype, i), o && q(n, o), e
        }(f))

        function Q(t) {
            return (Q = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function tt(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return et(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return et(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function et(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function nt(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function rt(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        nt(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        nt(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function it(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function ot(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function at(t, e, n) {
            return e = st(e),
            (function (t, e) {
                if (e && (Q(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], st(t).constructor)
                : e.apply(t, n)))
        }

        function st(t) {
            return (st = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ut(t, e) {
            return (ut = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const ct = (function (t) {
            function e() {
                return it(this, e), at(this, e, arguments)
            }
            let n, i, o, a, u
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ut(t, e)
            }(e, t)), n = e, (i = [{
                key: 'load',
                value: (u = rt(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i; let o; let a; let u = this
                                var c = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = c.length > 0 && void 0 !== c[0] ? c[0] : this.list, this.loader.reset(), e.forEach((function(t) {
                                            u.loader.resources[t.id] || u.loader.add(t.id, u._resolvePath(t))
                                        })), n = [], r = function(t) {
                                            return u.progress = t.progress
                                        }, i = function(t, r, i) {
                                            var o;
                                            o = "png" === i.extension ? e.find((function(t) {
                                                return i.name.includes(t.id)
                                            })) : e.find((function(t) {
                                                return t.id === i.name
                                            })), n.push(o)
                                        }, o = this.loader.onProgress.add(r), a = this.loader.onError.add(i), t.next = 10, new Promise((function(t) {
                                            return u.loader.load(t)
                                        }));
                                    case 10:
                                        if (s.a.useGameSumFont && this._cacheSumFont(), o.detach(), a.detach(), !n.length) {
                                            t.next = 15;
                                            break
                                        }
                                        return t.abrupt("return", Promise.reject(n));
                                    case 15:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: '_cacheSumFont',
                value: (a = rt(regeneratorRuntime.mark(function t() {
                    let e, n, r
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (e = this.loader.resources.sumFont_atlas_) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        if (e.bitmapFont) {
                                            t.next = 6;
                                            break
                                        }
                                        return t.next = 6, new Promise((function(t) {
                                            return e.onAfterMiddleware.add(t)
                                        }));
                                    case 6:
                                        if (e.bitmapFont) {
                                            t.next = 8;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 8:
                                        n = {}, r = [], Object.entries(e.bitmapFont.chars).forEach((function(t, e) {
                                            var i = tt(t, 2),
                                                o = i[0],
                                                a = i[1],
                                                s = a.texture.orig,
                                                u = s.x,
                                                c = s.y,
                                                l = s.width,
                                                h = s.height,
                                                f = a.page,
                                                d = String.fromCharCode(Number(o));
                                            r.push({}[e] = [u, c, l, h, Number(f)]), n[d] = [Number(e)]
                                        })), d.b.frames = r, d.b.animations = n, d.b.images = e.children.map((function(t) {
                                            return t.name
                                        }));
                                    case 14:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'loader',
                get () {
                    return this._loader = this._loader || new r.Loader(), this._loader
                }
            }]) && ot(n.prototype, i), o && ot(n, o), e
        }(f))
        let lt = n('./node_modules/pixi-spine/lib/all.es.js')

        function ht(t) {
            return (ht = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ft(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function dt(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function pt(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function mt(t, e, n) {
            return e = yt(e),
            (function (t, e) {
                if (e && (ht(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], yt(t).constructor)
                : e.apply(t, n)))
        }

        function yt(t) {
            return (yt = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function vt(t, e) {
            return (vt = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const _t = lt.a.prototype
        _t.newMeshAttachment = function (t, e, n) {
            const r = this.atlas.findRegion(n)
            const i = new lt.b(e)
            return r == null
                ? (console.warn('Region not found in atlas: '.concat(n, ' (mesh attachment: ').concat(e, ')')), o.a.emit(o.a.events.ERROR, {
                        priority: 'high',
                        nonRecoverable: !0,
                        details: {
                            message: 'Region not found in atlas: '.concat(n, ' (mesh attachment: ').concat(e, ')')
                        },
                        errorType: 'crash'
                    }))
                : i.region = r, i
        }, _t.newRegionAttachment = function (t, e, n) {
            const r = this.atlas.findRegion(n)
            const i = new lt.c(e)
            return r == null
                ? (console.warn('Region not found in atlas: '.concat(n, ' (region attachment: ').concat(e, ')')), o.a.emit(o.a.events.ERROR, {
                        priority: 'high',
                        nonRecoverable: !0,
                        details: {
                            message: 'Region not found in atlas: '.concat(n, ' (mesh attachment: ').concat(e, ')')
                        },
                        errorType: 'crash'
                    }))
                : i.region = r, i
        }
        const gt = (function (t) {
            function e() {
                return dt(this, e), mt(this, e, arguments)
            }
            let n, i, o, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && vt(t, e)
            }(e, t)), n = e, (i = [{
                key: 'load',
                value: (a = regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i; let o; let a; let s; let u = this
                                var c = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = c.length > 0 && void 0 !== c[0] ? c[0] : this.list, this.loader.reset(), e.forEach((function(t) {
                                            var e = new lt.e;
                                            e.addTextureHash(d.c, !0), u.loader.resources[t.id] || u.loader.add(t.id, u._resolvePath(t), {
                                                metadata: {
                                                    spineAtlas: e
                                                }
                                            })
                                        })), n = [], r = function(t) {
                                            return u.progress = t.progress
                                        }, i = function(t, r, i) {
                                            return n.push(e.find((function(t) {
                                                return t.id === i.name
                                            })))
                                        }, o = this.loader.onProgress.add(r), a = this.loader.onError.add(i), t.next = 10, new Promise((function(t) {
                                            return u.loader.load((function(e, n) {
                                                return t(n)
                                            }))
                                        }));
                                    case 10:
                                        if (s = t.sent, o.detach(), a.detach(), Object.keys(s).forEach((function(t) {
                                                var e = s[t];
                                                e.error || (d.f[t] = e.spineData)
                                            })), !n.length) {
                                            t.next = 16;
                                            break
                                        }
                                        return t.abrupt("return", Promise.reject(n));
                                    case 16:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                }), s = function () {
                    let t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = a.apply(t, e)

                        function o(t) {
                            ft(i, n, r, o, s, 'next', t)
                        }

                        function s(t) {
                            ft(i, n, r, o, s, 'throw', t)
                        }
                        o(void 0)
                    })
                }, function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'loader',
                get () {
                    return this._loader = this._loader || new r.Loader(), this._loader
                }
            }]) && pt(n.prototype, i), o && pt(n, o), e
        }(f))
        let bt = n('./node_modules/ramda/es/without.js')
        let Et = n('./node_modules/ramda/es/internal/_curry1.js')
        let xt = n('./node_modules/ramda/es/keys.js')
        let Tt = new Object(Et.a)((t) => {
            for (var e = new Object(xt.a)(t), n = e.length, r = [], i = 0; i < n;) r[i] = t[e[i]], i += 1
            return r
        })

        function St(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function wt(t) {
            return (function (t) {
                if (Array.isArray(t)) return Ot(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return Ot(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ot(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function Ot(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function Pt(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Rt(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Pt(new Object(n), !0).forEach((e) => {
                            At(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Pt(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function At(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function It(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const Ct = {
            IMAGES: 'images',
            VIDEO: 'video',
            SOUNDS: 'sounds',
            SOUNDS_MOBILE: 'sounds-mobile',
            SHAPES: 'shapes',
            ANIMATE: 'animate',
            FONTS: 'fonts',
            SPRITE_SHEETS: 'spriteSheets',
            SPINE: 'spine'
        }
        const kt = [Ct.IMAGES, Ct.SPRITE_SHEETS, Ct.SHAPES]
        const Nt = new Object(bt.a)(kt, Tt(Ct))
        const Mt = []
        const jt = [Ct.SPRITE_SHEETS]
        const Dt = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.assetsList = null
            }
            let e, n, r, i, o
            return e = t, (n = [{
                key: 'filterAssets',
                value(t) {
                    let e = t.assets
                                var n = t.feature
                    if ((e = e[t.scale] || e)[n]) { return e[n].map(function(t) {
                                return Rt(Rt({}, t), {}, {
                                    isCore: !0
                                })
                            });
                    }
                    let r = e[s.a.baseLang] && e[s.a.baseLang][n] ? e[s.a.baseLang][n] : []
                                var i = e[a.c.code] && e[a.c.code][n] ? e[a.c.code][n] : []
                    return r.forEach((t) => {
                        return t.isCore = !0
                    }), i.length === 0 ? r : i
                }
            }, {
                key: 'getLoaderForAssetType',
                value(t) {
                    return At(At(At(At(At(At(At(At(At({}, Ct.IMAGES, S), Ct.VIDEO, S), Ct.SPRITE_SHEETS, S), Ct.SOUNDS, H), Ct.SOUNDS_MOBILE, H), Ct.SHAPES, J), Ct.ANIMATE, N), Ct.FONTS, ct), Ct.SPINE, gt)[t]
                }
            }, {
                key: 'makeAssetsUnique',
                value(t) {
                    return t.map((t) => {
                        var e = t.src.split('c=');
                        return t.id += '_'.concat(e[1] || Date.now()), t
                    })
                }
            }, {
                key: 'getAssetsVariant',
                value(t) {
                    let e = s.a.skin
                    return this.assetsList[e][t] || []
                }
            }, {
                key: 'loadAssets',
                value(t) {
                    let e = t.type
                                var n = t.feature
                                var r = t.scale
                                var i = t.onProgress
                                var o = t.nonrecoverable
                                var a = !Mt.includes(e)
                                var u = jt.includes(e)
                                var c = this.getLoaderForAssetType(e)
                                var l = this.getAssetsVariant(e)
                    return a && (l = this.filterAssets({
                        assets: l,
                        feature: n,
                        scale: r
                    })), u && (l = this.makeAssetsUnique(l)), new c(i, s.a).loadList(l, o)
                }
            }, {
                key: 'loadManifest',
                value() {
                    let t = this
                    return fetch(''.concat(s.a.cdn, 'manifest.json?t=').concat(s.a.timestamp || Date.now())).then((t) => {
                        return t.json()
                    }).then((e) => {
                        return t.assetsList = e
                    })
                }
            }, {
                key: 'getFeatureScaleForResolution',
                value(t) {
                    let e = t.feature
                                var n = t.resolution
                                var r = s.a.scale[n]
                    return r ? r[e] || r.default : 1
                }
            }, {
                key: 'getCorrectScaleForFeature',
                value(t) {
                    let e = t.feature
                                var n = t.scale
                                var r = p.a.resolution
                                var i = this.getFeatureScaleForResolution({
                        feature: e,
                        resolution: r
                    })
                    return 'scale@'.concat(n || i).replace('.', '_')
                }
            }, {
                key: 'getInitialProgress',
                value() {
                    return Tt([].concat(kt, wt(Nt))).reduce((t, e) => {
                        return Rt(Rt({}, t), {}, At({}, e, 0))
                    }, {})
                }
            }, {
                key: 'getTotalProgress',
                value(t) {
                    return Math.round(t.reduce((t, e) => {
                        return t + e
                    }, 0) / t.length)
                }
            }, {
                key: 'updateProgress',
                value(t, e) {
                    let n = this
                                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {}
                    return function (i) {
                        e[t] = i, r(n.getTotalProgress(Tt(e)))
                    }
                }
            }, {
                key: 'loadFeature',
                value: (i = regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; let o; let a; let u; let c; let l = this
                                var h = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (n = h.length > 1 && void 0 !== h[1] ? h[1] : {}, r = n.onProgress, i = void 0 === r ? function() {} : r, o = n.scale, a = n.nonrecoverable, -1 !== e.indexOf("_core")) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.next = 4, this.loadFeature("".concat(e, "_core"), i, o, a);
                                    case 4:
                                        return o = this.getCorrectScaleForFeature({
                                            feature: e,
                                            scale: o
                                        }), u = this.getInitialProgress(), c = function(t) {
                                            return l.loadAssets({
                                                type: t,
                                                feature: e,
                                                scale: o,
                                                onProgress: l.updateProgress(t, u, i),
                                                nonrecoverable: a
                                            })
                                        }, s.a.platform.monoSounds.indexOf(p.a.resolution) > -1 ? Nt.indexOf(Ct.SOUNDS) > -1 && Nt.splice(Nt.indexOf(Ct.SOUNDS), 1) : Nt.indexOf(Ct.SOUNDS_MOBILE) > -1 && Nt.splice(Nt.indexOf(Ct.SOUNDS_MOBILE), 1), t.next = 10, Promise.all(kt.map(c));
                                    case 10:
                                        return t.abrupt("return", Promise.all(Nt.map(c)));
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                }), o = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let o = i.apply(t, e)

                        function a(t) {
                            St(o, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            St(o, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function (t) {
                    return o.apply(this, arguments)
                })
            }]) && It(e.prototype, n), r && It(e, r), t
        }())
        e.b = new Dt()
    },
    './src/core/main.js': function (t, e, n) {
        'use strict'
        n.r(e)
        const r = n('./src/core/utils/EventsHub.js')
        const i = n('./src/core/App.js')
        const o = n('./src/config.js')
        const a = n('./src/core/utils/Status.js')
        const s = n('./node_modules/@games/dope/src/Dopamine.js')
        const u = n('./src/core/features/sound/SoundRouter.js')
        const c = n('./src/core/utils/CombinedTicker.js')
        const l = n('./src/core/server/SpinData.js')
        const h = n('./src/states.js')
        const f = n('./src/core/utils/canvasErrors.js')
        const d = n('./src/core/loader/index.js')
        const p = n('./src/core/utils/ExternalInput.js')

        function m(t) {
            return (m = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function y(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function v(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? y(new Object(n), !0).forEach((e) => {
                            _(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : y(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function _(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function g(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return b(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return b(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function b(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function E(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function x(t, e, n) {
            return e = T(e),
            (function (t, e) {
                if (e && (m(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], T(t).constructor)
                : e.apply(t, n)))
        }

        function T(t) {
            return (T = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function S(t, e) {
            return (S = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const w = {
            READY: 'ready',
            WIN_LINES: 'win_lines',
            WIN_LINES_EXTRA_WIN: 'win_lines_extra_win',
            WIN_LINES_SUM: 'win_lines_sum',
            WIN_LINES_NO_WIN: 'win_lines_no_win',
            JACKPOT_WIN: 'jackpot_win',
            FINISH: 'finish',
            PLAY_START: 'play_start',
            PLAY_END: 'play_end',
            PLAY_DATA: 'play_data'
        }
        const O = {
            SERVER_ERROR: 'server_error',
            GAME_ERROR: 'game_error',
            WARNING: 'warning',
            INFO: 'info'
        }
        const P = {
            GAME_ENABLED: 'gameEnabled',
            GAME_BUSY: 'gameBusy',
            RESULT_READY: 'resultReady',
            PAYTABLE: 'paytable',
            MUTE: 'mute',
            IN_FREE_SPINS: 'inFreeSpins',
            IN_RESPIN: 'inRespin',
            IS_SPIN_BUTTON_ACTIVE: 'isSpinButtonActive',
            IS_WHOLE_GAME_STAGE_USED: 'isWholeGameStageUsed'
        }
        const R = (function (t) {
            function e(t, n) {
                let o
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (o = x(this, e))._app = new i.a(t, n), o._app.init(), r.a.onAny((t) => {
                    var e = g(t, 2);
                                var n = e[0];
                                var r = e[1]
                            return o.emit(n, Object.assign({}, r, {
                        type: n
                    }))
                }), o
            }
            let n, m, y
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && S(t, e)
            }(e, t)), n = e, (m = [{
                key: 'events',
                get () {
                    return r.a.events
                }
            }, {
                key: 'states',
                get () {
                    return w
                }
            }, {
                key: 'messageTypes',
                get () {
                    return O
                }
            }, {
                key: 'statuses',
                get () {
                    return P
                }
            }, {
                key: 'app',
                get () {
                    return this._app
                }
            }, {
                key: 'preload',
                value () {
                    return this.app.start(), this.app.preload()
                }
            }, {
                key: 'getContainer',
                value () {
                    return this.app.container
                }
            }, {
                key: 'enableGame',
                value () {
                    this.app.game.enable()
                }
            }, {
                key: 'disableGame',
                value () {
                    this.app.game.disable()
                }
            }, {
                key: 'rumbleStart',
                value (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                                var n = this.app.game.scenario.features.rumble
                            if (n) {
                        var r = t.x;
                                    var i = t.y
                                n.start(v(v({}, t), {}, {
                            intensity: {
                                x: r,
                                y: i
                            },
                            duration: e
                        }))
                    }
                }
            }, {
                key: 'rumbleStop',
                value () {
                    var t = this.app.game.scenario.features.rumble
                            t && t.stop()
                }
            }, {
                key: 'setCurrencyFormat',
                value (t) {
                    s.a.set(t)
                }
            }, {
                key: 'freeze',
                value (t) {
                    t ? this.app.renderer.pause() : (this.app.game && this.app.game.scenario.features.soundEngine.router.pauseAll(), this.app.ticker.stop())
                }
            }, {
                key: 'unfreeze',
                value (t) {
                    t ? this.app.renderer.resume() : (this.app.game && this.app.game.scenario.features.soundEngine.router.resumeAll(), this.app.ticker.start())
                }
            }, {
                key: 'attachPrePlayHandler',
                value (t) {
                    this.app.game && this.app.game.attachPreSpinHandler(t)
                }
            }, {
                key: 'skip',
                value (t) {
                    this.app.game && this.app.game.skip(t)
                }
            }, {
                key: 'gamble',
                value () {}
            }, {
                key: 'reset',
                value () {
                    var t = this.app.game.scenario
                            t.reset && t.reset()
                }
            }, {
                key: 'autoPlayStart',
                value (t) {
                    this.app.game.autoPlayStart(), r.a.emit(r.a.events.AUTOPLAY_START)
                }
            }, {
                key: 'autoPlayStop',
                value (t) {
                    a.a.get(a.a.TYPES.AUTO_PLAY) && (this.app.game.autoPlayStop(), r.a.emit(r.a.events.AUTOPLAY_STOP, {
                        reason: t
                    }))
                }
            }, {
                key: 'setStake',
                value (t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                                var i = this.app.game.setStake(t, e, n);
                                var o = i.value;
                                var a = i.index
                            i.types, r.a.emit(r.a.events.STAKE_CHANGE, {
                        value: o,
                        index: a,
                        bonusId: n
                    })
                }
            }, {
                key: 'setBalance',
                value (t, e, n) {}
            }, {
                key: 'paytableShow',
                value () {
                    a.a.get(a.a.TYPES.PAYTABLE) || this.paytableToggle(!1)
                }
            }, {
                key: 'paytableHide',
                value () {
                    a.a.get(a.a.TYPES.PAYTABLE) && this.paytableToggle(!0)
                }
            }, {
                key: 'paytableToggle',
                value (t) {
                    var e = 'boolean' == typeof t ? t : a.a.get(a.a.TYPES.PAYTABLE)
                            this.app.game.paytableToggle(e), a.a.get(a.a.TYPES.PAYTABLE) && this.app.game.scenario.features.paytable.slideToPays()
                }
            }, {
                key: 'getPaytableScreenIndex',
                value () {
                    return this.app && this.app.game ? this.app.game.scenario.features.paytable ? this.app.game.scenario.features.paytable.currentScreenIndex : console.warn('There is no paytable') : console.warn('There is no game attached')
                }
            }, {
                key: 'getIsGambleAllowed',
                value () {
                    var t = l.a.hasError;
                                var e = a.a.get(a.a.TYPES.STATE) === h.a.READY;
                                var n = a.a.get(a.a.TYPES.IN_FREE_SPINS);
                                var r = l.a.main.jackpots && l.a.main.jackpots.win;
                                var i = a.a.get(a.a.TYPES.IN_RESPIN)
                            return !t && !n && e && !r && !i
                }
            }, {
                key: 'getRoundInfo',
                value () {
                    return {
                        roundId: a.a.get(a.a.TYPES.ROUND_ID) !== null ? a.a.get(a.a.TYPES.ROUND_ID) : void 0,
                        isStateful: a.a.get(a.a.TYPES.HAS_MATH_STATE),
                        isGambleAllowed: this.getIsGambleAllowed()
                    }
                }
            }, {
                key: 'getGameStatus',
                value () {
                    return _(_(_(_(_(_(_(_({}, a.a.TYPES.STATE, a.a.get(a.a.TYPES.STATE)), a.a.TYPES.GAME_ENABLED, a.a.get(a.a.TYPES.GAME_ENABLED)), a.a.TYPES.GAME_BUSY, a.a.get(a.a.TYPES.GAME_BUSY)), a.a.TYPES.RESULT_READY, a.a.get(a.a.TYPES.RESULT_READY)), a.a.TYPES.PAYTABLE, a.a.get(a.a.TYPES.PAYTABLE)), a.a.TYPES.MUTE, a.a.get(a.a.TYPES.MUTE)), a.a.TYPES.IN_FREE_SPINS, a.a.get(a.a.TYPES.IN_FREE_SPINS)), a.a.TYPES.IS_WHOLE_GAME_STAGE_USED, a.a.get(a.a.TYPES.IS_WHOLE_GAME_STAGE_USED))
                }
            }, {
                key: 'getCurrencyFormat',
                value () {
                    var t = s.a.singleton
                            return {
                        code: t.code,
                        symbol: t.symbol,
                        thousand: t.thousands,
                        decimal: t.decimals
                    }
                }
            }, {
                key: 'getStakes',
                value () {
                    return this.app.game.getStakes()
                }
            }, {
                key: 'getGameInfo',
                value () {
                    var t; var e; var n = this.app.rtp
                            return {
                        branding: o.a.branding,
                        rtp: n,
                        gameAppId: o.a.gameAppId,
                        client: o.a.client,
                        lang: s.c.code,
                        version: o.a.version,
                        isRealPlay: 'real' === o.a.playMode,
                        helpURL: o.a.cdn + this._app.helpPath,
                        scale: o.a.size.scale,
                        hasPaytable: o.a.hasPaytable,
                        hasAutoplay: o.a.hasAutoplay,
                        hasInternalJackpot: o.a.hasInternalJackpot,
                        hasBottomBar: o.a.hasBottomBar,
                        autoplay: 'external',
                        useExternalLoading: !0,
                        useExternalPaytableUI: !0,
                        useExternalPaytableModal: o.a.paytable.useExternalPaytableModal,
                        paytableScreens: ((t = this.app.game) === null || void 0 === t ? void 0 : t.scenario.features.paytable.screens) || o.a.paytable.screens,
                        expanded: o.a.expanded,
                        hasFeatureEvents: o.a.hasFeatureEvents,
                        isStateful: o.a.isStateful,
                        hasFreeSpins: o.a.hasFreeSpins,
                        hasChoices: o.a.hasChoices,
                        paytableMinimal: (e = this.app.game) === null || void 0 === e ? void 0 : e.scenario.features.paytable.isMinimal,
                        hasSuperQuickSpins: o.a.hasSuperQuickSpins
                    }
                }
            }, {
                key: 'getErrors',
                value () {
                    return f.a
                }
            }, {
                key: 'action',
                value (t, e) {
                    switch (t) {
                        case 'spin':
                            e && e.result && (e = e.result), this.app.game.spinStart(e)
                                    break;
                        case 'feature_action':
                            p.a.resolveAction(e)
                                    break;
                        case 'jackpot_wheel_end':
                            this.app.game.jackpotWheelHide()
                                    break;
                        case 'jackpot_wheel_end_all':
                            this.app.game.jackpotWheelHideAll()
                                    break;
                        case 'jackpot_wheel_start':
                            this.app.game.jackpotWheelStart()
                                    break;
                        default:
                            console.warn('GameAPI.action(\''.concat(t, '\') not yet implemented'))
                    }
                }
            }, {
                key: 'start',
                value () {
                    if (!this._app || !this._app.game) return console.warn('There is no game attached');
                    this._app.startGame()
                }
            }, {
                key: 'soundMute',
                value () {
                    u.a.mute(), a.a.set(a.a.TYPES.MUTE, !0)
                }
            }, {
                key: 'soundUnmute',
                value () {
                    u.a.unmute(), a.a.set(a.a.TYPES.MUTE, !1)
                }
            }, {
                key: 'soundToggle',
                value () {
                    a.a.get(a.a.TYPES.MUTE) ? this.soundUnmute() : this.soundMute()
                }
            }, {
                key: 'fadeOutSounds',
                value (t) {
                    this.app.game.scenario.features.soundEngine.router.fadeOutSounds(t)
                }
            }, {
                key: 'fadeInSounds',
                value () {
                    this.app.game.scenario.features.soundEngine.router.fadeInSounds()
                }
            }, {
                key: 'resumeJackpot',
                value () {
                    this.app.game.resumeJackpot()
                }
            }, {
                key: 'updateResize',
                value (t) {
                    this._app.size = t, r.a.emit(r.a.events.RESIZE, {
                        width: t.width,
                        height: t.height
                    })
                }
            }, {
                key: 'paytablePlay',
                value () {
                    this._app.startGame()
                }
            }, {
                key: 'paytableSetIndex',
                value (t) {
                    return this._app.game.setPaytableIndex(t)
                }
            }, {
                key: 'setSpeed',
                value (t) {
                    "number" == typeof t && !isNaN(t) && t >= 0 && c.a.setTimeScale(t)
                }
            }, {
                key: 'setOptions',
                value (t) {
                    void 0 !== t && ('number' == typeof t.minRoundDuration && a.a.set(a.a.TYPES.MIN_ROUND_DURATION, t.minRoundDuration), t.minRoundDurationStrict && (o.a.reels.spin.minSpinDurationEnabled = t.minRoundDurationStrict), t.lang && this._app.setLanguage(t.lang), t.roundCelebrationThreshold && (o.a.restrictRoundCelebrations = !0, o.a.roundCelebrationThreshold = t.roundCelebrationThreshold), o.a.gaffSkipStateValidation = !(t == null || !t.skipStateValidation))
                }
            }, {
                key: 'getSumFont',
                value () {
                    return o.a.useGameSumFont ? d.c : null
                }
            }]) && E(n.prototype, m), y && E(n, y), e
        }(s.b))
        const A = (n('./src/core/Game.js'), n('./src/core/utils/index.js'))
        n('./src/core/utils/misc.js')
        const I = window.com || {}
        I.casino = I.casino || {}, I.casino.instances = I.casino.instances || {}, I.casino.game = function (t, e) {
            const n = new R(t, e)
            return I.casino.instances.slot = n, n
        }, I.casino.game.utils = A.a, window.com = I
    },
    './src/core/server/GameData.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/seamless-immutable/seamless-immutable.development.js')
        const i = n.n(r)

        function o(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const a = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t))
            }
            let e, n, r
            return e = t, (n = [{
                key: 'init',
                value(t) {
                    this.settings = i()(t)
                }
            }]) && o(e.prototype, n), r && o(e, r), t
        }())
        e.a = new a()
    },
    './src/core/server/Server.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/@games/dope/src/Dopamine.js')
        const i = n('./src/core/utils/Status.js')
        const o = n('./src/core/utils/EventsHub.js')

        function a(t) {
            return (a = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function s(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const u = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t))
            }
            let e, n, r
            return e = t, (n = [{
                key: 'parse',
                value(t) {
                    return this._moneyToNumber(t), t
                }
            }, {
                key: '_moneyToNumber',
                value(t) {
                    let e
                    for (const n in t) {
                        if (t.hasOwnProperty(n)) {
                                if ("object" === a(e = t[n])) this._moneyToNumber(e);
                                else if ("string" == typeof e) {
                            if ("rtp" === n || "userId" === n || "sessionId" === n) continue;
                            !isNaN(parseFloat(e)) && isFinite(e) && (t[n] = parseFloat(e))
                        }
}
                    }
                }
            }]) && s(e.prototype, n), r && s(e, r), t
        }())

        function c(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function l(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const h = {
            SETTINGS: 'settings',
            SPIN: 'spin',
            CHOICE: 'choice',
            FINISH: 'finish',
            NOTIFICATION: 'notification',
            BONUS_START: 'bonus_start',
            BONUS_BUY_IN: 'bonus_buy_in',
            BONUS_COLLECT: 'bonus_collect',
            BONUS_CANCEL: 'bonus_cancel',
            BONUS_CHOICE: 'bonus_choice'
        }
        const f = (function () {
            function t(e) {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this._client = e, this.parser = new u()
            }
            let e, n, a, s, f
            return e = t, n = [{
                key: 'spin',
                value: (s = regeneratorRuntime.mark(function e(n) {
                    let r, o
                    return regeneratorRuntime.wrap(function (e) {
                        for (;;) { switch (e.prev = e.next) {
                                    case 0:
                                        if (n) {
                                            e.next = 2;
                                            break
                                        }
                                        return e.abrupt("return", Promise.reject(new Error("No stake was provided, for the spin request")));
                                    case 2:
                                        return e.next = 4, this._request(t.requests.SPIN, {
                                            stake: n
                                        });
                                    case 4:
                                        return r = e.sent, o = r.result.transactions.roundId, i.a.set(i.a.TYPES.ROUND_ID, o), e.abrupt("return", r.result);
                                    case 8:
                                    case "end":
                                        return e.stop()
                                }
}
                    }, e, this)
                }), f = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = s.apply(t, e)

                        function o(t) {
                            c(i, n, r, o, a, 'next', t)
                        }

                        function a(t) {
                            c(i, n, r, o, a, 'throw', t)
                        }
                        o(void 0)
                    })
                }, function (t) {
                    return f.apply(this, arguments)
                })
            }, {
                key: 'settings',
                value(e) {
                    return this._request(t.requests.SETTINGS, e)
                }
            }, {
                key: 'choice',
                value(e) {
                    return this._request(t.requests.CHOICE, e)
                }
            }, {
                key: '_request',
                value(e, n) {
                    let a = this
                    return new Promise((s) => {
                        a._client[e](n, function(n, u) {
                                    var c = a.parser.parse(u);
                                    if (!n) return s(c);
                                    var l = e === t.requests.SETTINGS,
                                        h = l,
                                        f = {
                                            title: r.c.texts.TITLE_SERVER_ERROR || "",
                                            text: r.c.texts.NO_CONNECTION || "",
                                            msgType: "server_error",
                                            details: n,
                                            nonRecoverable: h,
                                            code: 99,
                                            requestType: e
                                        };
                                    if (c && c.error) {
                                        var d = c.error.code;
                                        f.text = c.error.msg, f.details = c.error.details, f.nonRecoverable = l || 1 === d || 3 === d || 14 === d || 16 === d || 17 === d, f.code = d
                                    }
                                    o.a.emit("message_show", f), !0 === i.a.get(i.a.TYPES.AUTO_PLAY) && o.a.emit(o.a.events.AUTOPLAY_STOP), s(n)
                                })
                    })
                }
            }], a = [{
                key: 'requests',
                get() {
                    return h
                }
            }], n && l(e.prototype, n), a && l(e, a), t
        }())
        e.a = f
    },
    './src/core/server/SpinData.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/seamless-immutable/seamless-immutable.development.js')
        const i = n.n(r)
        const o = n('./src/core/server/GameData.js')
        const a = n('./src/config.js')

        function s(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function u(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? s(new Object(n), !0).forEach((e) => {
                            c(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : s(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function c(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function l(t) {
            return (function (t) {
                if (Array.isArray(t)) return h(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return h(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return h(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function h(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function f(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const d = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this._main = i()({}), this._currentSpin = null, this._counter = 0
            }
            let e, n, r
            return e = t, (n = [{
                key: 'hasNext',
                get() {
                    return this._counter < this.extraSpins.length
                }
            }, {
                key: 'roundHasCelebrations',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a.a.roundCelebrationThreshold
                            var n = this._main.game.stake
                            var r = t / n
                    if (!a.a.restrictRoundCelebrations) return !0
                    var i = !e || r > e
                    return i
                }
            }, {
                key: 'hasError',
                get() {
                    return this._currentSpin && this._currentSpin.hasError
                }
            }, {
                key: 'hasWin',
                get() {
                    let t = this._currentSpin.game
                    return t && t.win && t.win.lines > 0
                }
            }, {
                key: 'hasJackpotWin',
                get() {
                    let t = this._currentSpin.jackpots
                    return t && t.win > 0
                }
            }, {
                key: 'hasExtraWin',
                get() {
                    if (!this._currentSpin || !this._currentSpin.game) return !1
                    var t = o.a.settings.game.extraWin
                            var e = this._currentSpin.game
                            var n = e.win
                            var r = e.stake
                            var i = e.winsMultipliers
                    return (i ? i.lines : n.lines / r) >= Math.min.apply(Math, l(Object.values(t)))
                }
            }, {
                key: 'main',
                get() {
                    return this._main
                }
            }, {
                key: 'currentSpin',
                get() {
                    return this._currentSpin
                }
            }, {
                key: 'extraSpins',
                get() {
                    let t = this.parseExtraSpins(this._main.game)
                    return this.flattenExtraSpins(t)
                }
            }, {
                key: 'update',
                value(t) {
                    this._main = i()(t), this._counter = 0, this._currentSpin = this._main
                }
            }, {
                key: 'nextSpin',
                value() {
                    this._currentSpin = this._currentSpin.set('game', this.extraSpins[this._counter++])
                }
            }, {
                key: 'flattenExtraSpins',
                value() {
                    let t = this
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                    return e.reduce((e, n) => {
                        var r = t.parseExtraSpins(n)
                            return r
? [].concat(l(e), [u(u({}, n), {}, {
                            bonusSpins: r.length
                        })], l(t.flattenExtraSpins(r)))
: [].concat(l(e), [n])
                    }, [])
                }
            }, {
                key: 'parseExtraSpins',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    return t.freeSpins || t.respin
                }
            }]) && f(e.prototype, n), r && f(e, r), t
        }())
        e.a = new d()
    },
    './src/core/utils/AsyncAction.js': function (t, e, n) {
        'use strict'

        function r(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        n.d(e, 'a', () => {
            return i
        })
        var i = (function () {
            function t() {
                const e = this
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.isComplete = !1, this._completePromise = function () {}, this._actionPromise = new Promise((t) => {
                    return e._completePromise = t
                })
            }
            let e, n, i
            return e = t, (n = [{
                key: 'complete',
                value(t) {
                    this.isComplete = !0, this._completePromise(t)
                }
            }, {
                key: 'wait',
                value() {
                    return this._actionPromise
                }
            }]) && r(e.prototype, n), i && r(e, i), t
        }())
    },
    './src/core/utils/Cache.js': function (t, e, n) {
        'use strict'
        n.d(e, 'd', () => {
            return c
        }), n.d(e, 'a', () => {
            return l
        }), n.d(e, 'c', () => {
            return a
        }), n.d(e, 'f', () => {
            return s
        }), n.d(e, 'e', () => {
            return u
        }), n.d(e, 'b', () => {
            return o
        })
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = n('./src/core/utils/CombinedTicker.js')
        var o = null
        var a = function (t) {
            o || (o = t)
        }
        var s = function (t) {
            const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.width
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.height
            if (!(t instanceof r.DisplayObject)) throw new Error('provided object '.concat(t, ' is not an instance of DisplayObject'))
            const i = r.RenderTexture.create({
                width: e,
                height: n
            })
            return o.render(t, {
                renderTexture: i
            }), i
        }
        var u = function (t) {
            const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 20
            const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.width
            const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.height
            const s = h(t)
            const u = t.x + s.x - e
            const c = t.y + s.y - e
            t.pivot.set(u, c)
            const l = r.RenderTexture.create({
                width: n + 2 * e,
                height: a + 2 * e
            })
            o.mask && (o.mask.enableScissor = !0)
            const f = function () {
                return o.render(t, {
                    renderTexture: l
                })
            }
            return i.a.Ticker.add(f), {
                texture: l,
                pivot: {
                    x: u,
                    y: c
                },
                tickUpdater: f
            }
        }

        function c(t, e) {
            const n = e.width
            const i = e.height
            const a = e.offsetX
            const s = void 0 === a ? 0 : a
            const u = e.offsetY
            const c = void 0 === u ? 0 : u
            const l = new r.BaseRenderTexture(n + s, i + c)
            const h = new r.RenderTexture(l)
            return t.y = c, t.x = s, o.render(t, {
                renderTexture: h
            }), new r.Sprite(h)
        }

        function l(t) {
            return new Promise((e) => {
                if (o.type !== r.RENDERER_TYPE.WEBGL) return e()
                const n = o.plugins.prepare
                n.add(t), n.upload(e)
            })
        }

        function h(t) {
            let e = {
                x: 0,
                y: 0
            }
            const n = t.children || []
            return n.length > 0 && (e = n.reduce((t, e) => {
                return {
                    x: Math.min(t.x, e.x),
                    y: Math.min(t.y, e.y)
                }
            }, {
                x: 1 / 0,
                y: 1 / 0
            })), e
        }
    },
    './src/core/utils/CombinedTicker.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return l
        })
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = n('./node_modules/@games/gsap/gsap-core.js')
        const o = n('./node_modules/@games/gsap/CSSPlugin.js')
        const a = i.A.registerPlugin(o.a) || i.A
        const s = (a.core.Tween, n('./node_modules/@games/pixi-animate/lib/index.js'))
        const u = n('./src/core/utils/SpineUpdater.js')

        function c(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        var l = (function () {
            function t(e) {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.update = this._update.bind(this), this._renderer = e, t.Ticker.isLowFPS = !1, t.Ticker.autoStart = !1, t.Ticker.stop(), t.setFPS(60), s.MovieClip.Ticker = t.Ticker, this.start()
            }
            let e, n, i
            return e = t, i = [{
                key: 'currentFPS',
                get() {
                    return t.Ticker.FPS
                }
            }, {
                key: 'setTimeScale',
                value(t) {
                    a.globalTimeline.timeScale(t), s.MovieClip.TIME_SCALE = t
                }
            }, {
                key: 'resetTimeScale',
                value() {
                    return r.Ticker.setTimeScale(1)
                }
            }, {
                key: 'setFPS',
                value(t) {
                    a.ticker.fps(t)
                }
            }, {
                key: 'elapsedTime',
                get() {
                    return this.Ticker.lastTime
                }
            }], (n = [{
                key: 'start',
                value() {
                    a.ticker.add(this.update), a.globalTimeline.play()
                }
            }, {
                key: 'stop',
                value() {
                    a.ticker.remove(this.update), a.globalTimeline.pause()
                }
            }, {
                key: '_update',
                value(e, n) {
                    t.Ticker.update(), u.a.update(n / 1e3), this._renderer.render()
                }
            }]) && c(e.prototype, n), i && c(e, i), t
        }())
        l.Ticker = new r.Ticker()
    },
    './src/core/utils/EventsHub.js': function (t, e, n) {
        'use strict'
        const r = new (n('./node_modules/@games/dope/src/Dopamine.js').b)()
        r.events = {
            INIT: 'init',
            LOAD_GAME_START: 'load_game_start',
            LOAD_GAME_PROGRESS: 'load_game_progress',
            LOAD_GAME_COMPLETE: 'load_game_complete',
            GAME_READY: 'game_ready',
            GAME_STARTED: 'game_started',
            ENABLE_WINBAR: 'enable_winbar',
            DISABLE_WINBAR: 'disable_winbar',
            BALANCE_CHANGE: 'balance_change',
            BALANCE_CHANGE_END: 'balance_change_end',
            WINBAR_CHANGE: 'winbar_change',
            PAID_TOTAL: 'paid_total',
            STAKE_CHANGE: 'stake_change',
            DRAG_START: 'drag_start',
            DRAG_END: 'drag_stop',
            STATE_CHANGED: 'state_changed',
            PROPERTY_CHANGED: 'property_changed',
            MESSAGE_SHOW: 'message_show',
            AUTOPLAY_START: 'autoplay_start',
            AUTOPLAY_SPIN: 'autoplay_spin',
            AUTOPLAY_STOP: 'autoplay_stop',
            AUTOPLAY_BONUS: 'autoplay_bonus',
            JACKPOTS_SPLASH_SHOW: 'jackpots_splash_show',
            BONUS_WON: 'bonus_won',
            FEATURE_START: 'feature_start',
            FEATURE_UPDATE: 'feature_update',
            FEATURE_END: 'feature_end',
            PAYTABLE_SCREEN_CHANGE: 'paytable_screen_change',
            FEATURE_CONTROLS_SHOW: 'feature_controls_show',
            FEATURE_CONTROLS_HIDE: 'feature_controls_hide',
            RESIZE: 'resize',
            CHANGE_BASE_SIZE: 'change_base_size',
            ERROR: 'error'
        }, e.a = r
    },
    './src/core/utils/ExternalInput.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/@games/dope/src/Dopamine.js')
        const i = n('./src/core/utils/AsyncAction.js')

        function o(t) {
            return (o = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function a(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function s(t, e, n) {
            return e = u(e),
            (function (t, e) {
                if (e && (o(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], u(t).constructor)
                : e.apply(t, n)))
        }

        function u(t) {
            return (u = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function c(t, e) {
            return (c = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const l = {
            ACTION_RESOLVED: 'input_action_resolved'
        }
        const h = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = s(this, e))._actions = {}, t
            }
            let n, r, o
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && c(t, e)
            }(e, t)), n = e, (r = [{
                key: 'events',
                get() {
                    return l
                }
            }, {
                key: 'when',
                value(t) {
                    return this._actions[t] || (this._actions[t] = new i.a()), this._actions[t].wait()
                }
            }, {
                key: 'resolveAction',
                value(t) {
                    let e = t.name
                    this._actions[e] && (this.emit(l.ACTION_RESOLVED, {
                        data: t
                    }), this._actions[e].complete(t), delete this._actions[e])
                }
            }]) && a(n.prototype, r), o && a(n, o), e
        }(r.b))
        e.a = new h()
    },
    './src/core/utils/SpineUpdater.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/@games/pixi-animate/lib/index.js')
        n('./node_modules/pixi-spine/lib/all.es.js')

        function i(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const o = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this._spines = []
            }
            let e, n, o
            return e = t, (n = [{
                key: 'add',
                value(t) {
                    this._spines.includes(t) || this._spines.push(t)
                }
            }, {
                key: 'remove',
                value(t) {
                    let e = this._spines.indexOf(t); e !== -1 && this._spines.splice(e, 1)
                }
            }, {
                key: 'update',
                value(t) {
                    let e = this
                    this._spines.forEach((n) => {
                        n._destroyed ? e.remove(n) : n.update(t * r.MovieClip.TIME_SCALE)
                    })
                }
            }]) && i(e.prototype, n), o && i(e, o), t
        }())
        e.a = new o()
    },
    './src/core/utils/Status.js': function (t, e, n) {
        'use strict'
        let r; const i = n('./src/core/utils/EventsHub.js')

        function o(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const a = {
            STATE: 'state',
            START_SCREEN: 'startScreen',
            GAME_ENABLED: 'gameEnabled',
            GAME_BUSY: 'gameBusy',
            RESULT_READY: 'resultReady',
            PAYTABLE: 'paytable',
            MUTE: 'mute',
            IN_FREE_SPINS: 'inFreeSpins',
            IN_RESPIN: 'inRespin',
            IS_WHOLE_GAME_STAGE_USED: 'isWholeGameStageUsed',
            ROUND_ID: 'roundId',
            AUTO_PLAY: 'autoplay',
            HAS_MATH_STATE: 'hasMathState',
            SPIN_MODE: 'spinMode',
            MIN_ROUND_DURATION: 'minRoundDuration',
            PLAY_START_TIME: 'playStartTime'
        }
        const s = (o(o(o(o(o(o(o(o(o(o(r = {}, a.STATE, null), a.START_SCREEN, !1), a.GAME_ENABLED, !0), a.GAME_BUSY, !1), a.RESULT_READY, !1), a.PAYTABLE, !1), a.MUTE, !1), a.IN_FREE_SPINS, !1), a.IN_RESPIN, !1), a.IS_WHOLE_GAME_STAGE_USED, !0), o(o(o(o(o(o(r, a.ROUND_ID, null), a.AUTO_PLAY, !1), a.HAS_MATH_STATE, !1), a.SPIN_MODE, ''), a.MIN_ROUND_DURATION, -1), a.PLAY_START_TIME, -1))
        e.a = {
            get(t) {
                if (void 0 !== s[t]) return s[t]
                console.error('Status \''.concat(t, '\' not found'))
            },
            set(t, e) {
                if (void 0 !== s[t]) { return s[t] = e, i.a.emit(i.a.events.PROPERTY_CHANGED, {
                    prop: t,
                    value: e
                }), !0
                }
                console.error('Status \''.concat(t, '\' not found'))
            },
            TYPES: a
        }
    },
    './src/core/utils/Timer.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return a
        })
        const r = n('./node_modules/@games/gsap/all.js')
        const i = n('./node_modules/@games/gsap/gsap-core.js')

        function o(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        var a = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.MAX_CYCLE = 10, this._cycle = 0, this._totalCycles = 0, this._tween = null
            }
            let e, n, a
            return e = t, (n = [{
                key: 'start',
                value() {
                    this._tween ? this._tween.resume() : this._tween = this._createTicker()
                }
            }, {
                key: 'stop',
                value() {
                    return this._tween ? (this._tween.pause(), this.getTime()) : console.warn('I should start first, right?')
                }
            }, {
                key: 'clear',
                value() {
                    this._tween.kill(), this._tween = null, this._cycle = 0, this._totalCycles = 0
                }
            }, {
                key: 'getTime',
                value() {
                    return this._totalCycles * this.MAX_CYCLE + this._cycle
                }
            }, {
                key: '_createTicker',
                value() {
                    return r.b.to(this, {
                        duration: this.MAX_CYCLE,
                        _cycle: this.MAX_CYCLE,
                        onRepeat: this._repeatCycle,
                        repeat: -1,
                        ease: i.b.easeNone
                    })
                }
            }, {
                key: '_repeatCycle',
                value() {
                    ++this._totalCycles
                }
            }]) && o(e.prototype, n), a && o(e, a), t
        }())
    },
    './src/core/utils/canvasErrors.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return r
        })
        var r = [{
            match: 'webglcontextlost',
            priority: 'high',
            nonRecoverable: !0,
            details: {},
            errorType: 'crash',
            isSilent: !0
        }]
    },
    './src/core/utils/constants.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return r
        }), n.d(e, 'c', () => {
            return i
        }), n.d(e, 'b', () => {
            return o
        })
        var r = {
            ACTIVATE_START: 'activate_start',
            ACTIVATE_END: 'activate_end',
            DEACTIVATE_START: 'deactivate_start',
            DEACTIVATE_END: 'deactivate_end',
            SHOW_START: 'show_start',
            SHOW_END: 'show_end',
            HIDE_START: 'hide_start',
            HIDE_END: 'hide_end',
            SKIP_START: 'skip_start',
            SKIP_END: 'skip_end',
            UPDATE_START: 'update_start',
            UPDATE_END: 'update_end',
            RESET_START: 'reset_start',
            RESET_END: 'reset_end'
        }
        var i = {
            TEXTURE: 'texture',
            MOVIE_CLIP: 'movieClip',
            MIXED: 'mixed'
        }
        var o = {
            CIRCLE: 'circle',
            RECTANGLE: 'rect'
        }
    },
    './src/core/utils/index.js': function (t, e, n) {
        'use strict';
        (function (t) {
            n.d(e, 'a', () => {
                return v
            })
            const r = n('./node_modules/@games/quark/dist/quark.js')
            const i = n('./src/core/utils/textures.js')
            const o = n('./src/core/loader/index.js')
            const a = n('./src/core/utils/particles.js')
            const s = n('./src/core/utils/constants.js')
            const u = n('./node_modules/@games/pixi-animate/lib/index.js')
            const c = n('./node_modules/pixi-heaven/lib/pixi-heaven.es.js')
            const l = n('./src/core/utils/misc.js')
            const h = n('./src/core/utils/CombinedTicker.js')
            n('./src/core/utils/mixins.js')
            n.d(e, 'b', () => {
                return l.a
            }), n.d(e, 'c', () => {
                return l.b
            }), n.d(e, 'd', () => {
                return l.c
            }), n.d(e, 'f', () => {
                return l.d
            }), n.d(e, 'g', () => {
                return l.e
            }), n.d(e, 'h', () => {
                return l.f
            }), n.d(e, 'i', () => {
                return l.g
            }), n.d(e, 'k', () => {
                return l.h
            }), n.d(e, 'l', () => {
                return l.j
            }), n.d(e, 'm', () => {
                return l.k
            }), n.d(e, 'n', () => {
                return l.l
            }), n.d(e, 'o', () => {
                return l.m
            })
            const f = n('./src/core/utils/resizing.js')
            n.d(e, 'e', () => {
                return f.a
            })
            const d = n('./src/core/utils/movieclip.js')

            function p(t, e) {
                const n = Object.keys(t)
                if (Object.getOwnPropertySymbols) {
                    let r = Object.getOwnPropertySymbols(t)
                    e && (r = r.filter((e) => {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    })), n.push.apply(n, r)
                }
                return n
            }

            function m(t) {
                for (let e = 1; e < arguments.length; e++) {
                    var n = arguments[e] != null ? arguments[e] : {}
                    e % 2
                        ? p(new Object(n), !0).forEach((e) => {
                                y(t, e, n[e])
                            })
                        : Object.getOwnPropertyDescriptors
                            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                            : p(new Object(n)).forEach((e) => {
                                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                                })
                }
                return t
            }

            function y(t, e, n) {
                return e in t
                    ? Object.defineProperty(t, e, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        })
                    : t[e] = n, t
            }
            n.d(e, 'j', () => {
                return d.a
            })
            var v = {
                pixiInstance: m(m({}, t), {}, {
                    animate: {
                        MovieClip: u.MovieClip,
                        Ease: u.Ease
                    },
                    heaven: {
                        SpriteH: c.a
                    }
                }),
                ImagesCache: o.d,
                SoundsCache: o.f,
                AnimationsCache: o.a,
                ShapesCache: o.e,
                fromFrame: i.a,
                getTexture: i.b,
                Quark: r,
                createEmitter: a.a,
                sourceTypes: s.c,
                ticker: h.a.Ticker,
                delay: l.c,
                getRandomFloat: l.f,
                getRandomInt: l.g
            }
        }).call(this, n('./node_modules/pixi.js/dist/esm/pixi.js'))
    },
    './src/core/utils/misc.js': function (t, e, n) {
        'use strict'
        n.d(e, 'h', () => {
            return l
        }), n.d(e, 'c', () => {
            return h
        }), n.d(e, 'b', () => {
            return f
        }), n.d(e, 'i', () => {
            return d
        }), n.d(e, 'g', () => {
            return p
        }), n.d(e, 'f', () => {
            return m
        }), n.d(e, 'k', () => {
            return y
        }), n.d(e, 'l', () => {
            return v
        }), n.d(e, 'a', () => {
            return _
        }), n.d(e, 'd', () => {
            return g
        }), n.d(e, 'j', () => {
            return b
        }), n.d(e, 'e', () => {
            return E
        }), n.d(e, 'm', () => {
            return x
        })
        n('./node_modules/pixi.js/dist/esm/pixi.js')
        const r = n('./node_modules/@games/gsap/all.js')
        const i = n('./node_modules/ramda/es/mergeDeepRight.js')
        const o = n('./node_modules/ramda/es/clone.js')
        const a = n('./src/config.js')
        const s = n('./node_modules/seedrandom/index.js')
        const u = n.n(s)
        let c = null

        function l(t, e) {
            for (var n = new Array(t), r = 0; r < t; r++) {
                const i = typeof e == 'function' ? e(r) : e
                n[r] = void 0 !== i ? i : r
            }
            return n
        }

        function h(t, e) {
            return r.b.to({
                val: 0
            }, {
                duration: t,
                val: 1
            }).then(e)
        }

        function f() {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
            return e.length < 2 || void 0 === e[1] ? e[0] : e.reduce(i.a)
        }

        function d() {
            c = u()(a.a.static ? a.a.randomSeed : null)
        }

        function p(t, e) {
            return Math.floor(m(t, e + 1))
        }

        function m(t, e) {
            return c() * (e - t) + t
        }

        function y(t, e) {
            const n = t.sort(() => {
                return 0.5 - Math.random()
            })
            return void 0 === e ? n[0] : n.slice(0, e)
        }

        function v(t) {
            const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
            e || (t = new Object(o.a)(t))
            for (let n = t.length - 1; n > 0; n--) {
                const r = p(0, n)
                const i = t[r]
                t[r] = t[n], t[n] = i
            }
            return t
        }

        function _(t) {
            return p(1, 100) <= t
        }

        function g(t, e) {
            const n = Math.abs(t % e)
            return n !== 0 && t < 0 ? e - n : n
        }

        function b(t, e) {
            for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-5, r = 0.25, i = 0, o = e - t(i); Math.abs(o) > n;)(o = e - t(i += r)) < 0 != r < 0 && (r *= -0.5)
            return i
        }

        function E(t) {
            const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
            return {
                reel: a.a.reels.tiles.visible * t + e,
                index: 0
            }
        }

        function x(t) {
            const e = a.a.reels.tiles.visible
            return {
                reel: Math.floor(t / e),
                index: t - Math.floor(t / e) * e
            }
        }
    },
    './src/core/utils/mixins.js': function (t, e, n) {
        'use strict'
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = n('./src/core/utils/EventsHub.js')
        const o = n('./src/core/utils/canvasErrors.js')
        const a = n('./node_modules/howler/dist/howler.js')
        const s = n('./node_modules/pixi-heaven/lib/pixi-heaven.es.js')

        function u(t, e) {
            let n = typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
            if (!n) {
                if (Array.isArray(t) || (n = (function (t, e) {
                    if (!t) return
                    if (typeof t == 'string') return c(t, e)
                    let n = Object.prototype.toString.call(t).slice(8, -1)
                    n === 'Object' && t.constructor && (n = t.constructor.name)
                    if (n === 'Map' || n === 'Set') return Array.from(t)
                    if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return c(t, e)
                }(t))) || e && t && typeof t.length == 'number') {
                    n && (t = n)
                    let r = 0
                    const i = function () {}
                    return {
                        s: i,
                        n() {
                            return r >= t.length
                                ? {
                                        done: !0
                                    }
                                : {
                                        done: !1,
                                        value: t[r++]
                                    }
                        },
                        e(t) {
                            throw t
                        },
                        f: i
                    }
                }
                throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }
            let o; let a = !0
            let s = !1
            return {
                s() {
                    n = n.call(t)
                },
                n() {
                    const t = n.next()
                    return a = t.done, t
                },
                e(t) {
                    s = !0, o = t
                },
                f() {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw o
                    }
                }
            }
        }

        function c(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }
        r.LoaderResource.prototype._loadSourceElement = function (t) {
            if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === 'audio' && void 0 !== window.Audio ? this.data = new Audio() : this.data = document.createElement(t), this.data !== null) {
                if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource) {
                    if (navigator.isCocoonJS) { this.data.src = Array.isArray(this.url) ? this.url[0] : this.url
                    }
                    else if (Array.isArray(this.url)) {
                        for (let e = this.metadata.mimeType, n = 0; n < this.url.length; ++n) this.data.appendChild(this._createSource(t, this.url[n], Array.isArray(e) ? e[n] : e))
                    }
                    else {
                        const r = this.metadata.mimeType
                        this.data.appendChild(this._createSource(t, this.url, Array.isArray(r) ? r[0] : r))
                    }
                }
                document.body.appendChild(this.data), this.data.addEventListener('error', this._boundOnError, !1), this.data.addEventListener('load', this._boundComplete, !1), this.data.addEventListener('progress', this._boundOnProgress, !1), this.data.addEventListener('canplaythrough', this._boundComplete, !1), this.data.setAttribute('preload', 'auto'), this.data.setAttribute('webkit-playsinline', ''), this.data.setAttribute('playsinline', ''), this.data.setAttribute('autoplay', ''), this.data.setAttribute('controls', 'false'), this.data.crossOrigin = 'anonymous', this.data.addEventListener('stalled', (t) => {
                    console.warn('Failed to fetch video data, but trying.')
                }), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
            } else { this.abort(`Unsupported element: ${t}`)
            }
        }, r.Graphics.prototype.setRenderable = r.Graphics.prototype.re = function (t) {
            return this.renderable = !!t, this
        }, r.ContextSystem.prototype.handleContextLost = function (t) {
            const e = o.a.find((e) => {
                return e.match === t.type
            })
            if (e) {
                const n = e.priority
                const r = e.nonRecoverable
                const a = e.details
                const s = e.errorType
                i.a.emit(i.a.events.ERROR, {
                    priority: n,
                    nonRecoverable: r,
                    details: a,
                    errorType: s
                })
            }
        }, r.DisplayObject.prototype.promises = {
            press() {
                return new Promise((t) => {
                    t()
                })
            }
        }, r.DisplayObject.prototype.setMask = r.DisplayObject.prototype.ma = function (t) {
            return t && !(t instanceof r.Graphics || t instanceof r.Sprite || t instanceof s.a) ? (typeof console != 'undefined' && console.warn && console.warn('Warning: Masks can only be PIXI.Graphics, PIXI.Sprite or Pixi heaven SpriteH objects.'), this) : (t instanceof s.a ? this.setSpriteMask(t) : this.mask = t, this)
        }, r.DisplayObject.prototype.maS = r.DisplayObject.prototype.setSpriteMask = function (t) {
            if (!(t && t instanceof s.a)) return this
            const e = function (t, e) {
                t.maskSprite = e, t.hasSpriteMask = !0, t.pluginName = 'batchMasked'
            }
            const n = function (t, n) {
                t.on('childAdded', (t) => {
                    t instanceof r.Sprite && t.convertToHeaven && t.convertToHeaven(), e(t, n)
                })
            }
            return this instanceof s.a ? e(this, t) : this.maskSprite = t, n(this, t),
            (function t(r, i) {
                if (r.children) {
                    let o; const a = u(r.children)
                    try {
                        for (a.s(); !(o = a.n()).done;) {
                            const c = o.value
                            c instanceof s.a ? e(c, i) : c.children.length && (n(c, i), t(c, i))
                        }
                    } catch (t) {
                        a.e(t)
                    } finally {
                        a.f()
                    }
                }
            }(this, t)), this
        }, r.Container.prototype.setBlendMode = function (t) {
            return this._blendMode = t,
            (function e(n) {
                n.children && n.children.forEach((n) => {
                    n instanceof r.Sprite ? n.blendMode = t : n.children.length && e(n)
                })
            }(this)), this
        }, HowlerGlobal.prototype._autoSuspend = function () {
            const t = this
            if (t.autoSuspend && t.ctx && void 0 !== t.ctx.suspend && Howler.usingWebAudio) {
                for (let e = 0; e < t._howls.length; e++) {
                    if (t._howls[e]._webAudio) {
                        for (let n = 0; n < t._howls[e]._sounds.length; n++) {
                            if (!t._howls[e]._sounds[n]._paused) return t
                        }
                    }
                }
                return t._suspendTimer && clearTimeout(t._suspendTimer), t._suspendTimer = setTimeout(() => {
                    t.autoSuspend && (t._suspendTimer = null, t.ctx == null || t.ctx.state === 'interrupted'
                        ? (t.state = 'suspended', t._autoResume())
                        : (t.state = 'suspending', t.ctx.suspend().then(() => {
                                t.state = 'suspended', t._resumeAfterSuspend && (delete t._resumeAfterSuspend, t._autoResume())
                            })))
                }, 3e4), t
            }
        }, Sound.prototype.reset = function () {
            const t = this._parent
            return this._muted = t._muted, this._loop = t._loop, this._volume = t._volume, this._rate = t._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = '__default', this._node.disconnect(0), this._node.connect(Howler.masterGain), this._id = ++Howler._counter, this
        }, a.Howl.prototype.loop = function () {
            let t; let e; let n; const r = this
            const i = arguments
            if (i.length === 0) return r._loop
            if (i.length === 1) {
                if (typeof i[0] != 'boolean') return !!(n = r._soundById(Number.parseInt(i[0], 10))) && n._loop
                t = i[0], r._loop = t
            } else { i.length === 2 && (t = i[0], e = Number.parseInt(i[1], 10))
            }
            for (let o = r._getSoundIds(e), a = 0; a < o.length; a++)(n = r._soundById(o[a])) && (n._loop = t, r._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = t, t && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop, r.playing(o[a]) && (r.pause(o[a], !0), r.play(o[a], !0)))))
            return r
        }
        r.Loader.prototype._onLoad = function (t) {
            const e = this._queue.__proto__.constructor
            const n = this
            t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), e.eachSeries(this._afterMiddleware, (e, r) => {
                e.call(n, t, r)
            }, () => {
                t.error && t.extension === 'png' || t.onAfterMiddleware.dispatch(t), n.progress = Math.min(100, n.progress + t.progressChunk), n.onProgress.dispatch(n, t), t.error ? n.onError.dispatch(t.error, n, t) : n.onLoad.dispatch(n, t), t.error && t.extension === 'png' ? n._resourcesParsing = [] : n._resourcesParsing.splice(n._resourcesParsing.indexOf(t), 1), n._queue.idle() && n._resourcesParsing.length === 0 && n._onComplete()
            }, !0)
        }
    },
    './src/core/utils/movieclip.js': function (t, e, n) {
        'use strict'

        function r(t) {
            if (!Array.isArray(t.labels)) return !1
            for (var e = t.labels.map((t) => {
                    return t.label
                }), n = arguments.length, r = Array.from({ length: n > 1 ? n - 1 : 0 }), i = 1; i < n; i++) r[i - 1] = arguments[i]
            return r.every((t) => {
                return e.includes(t)
            })
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './src/core/utils/particles.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return v
        })
        const r = n('./node_modules/@games/quark/dist/quark.js')
        const i = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const o = n('./src/core/utils/textures.js')
        const a = n('./src/core/utils/Cache.js')
        const s = n('./src/core/utils/misc.js')
        const u = n('./node_modules/@games/pixi-animate/lib/index.js')
        const c = n('./src/config.js')
        const l = n('./src/core/utils/CombinedTicker.js')
        const h = n('./src/core/utils/constants.js')

        function f(t, e, n) {
            return (f = d()
                ? Reflect.construct
                : function (t, e, n) {
                    const r = [null]
                    r.push.apply(r, e)
                    const i = new (Function.bind.apply(t, r))()
                    return n && p(i, n.prototype), i
                }).apply(null, arguments)
        }

        function d() {
            if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
            if (Reflect.construct.sham) return !1
            if (typeof Proxy == 'function') return !0
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {})), !0
            } catch (t) {
                return !1
            }
        }

        function p(t, e) {
            return (p = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function m(t) {
            return (function (t) {
                if (Array.isArray(t)) return y(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return y(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return y(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function y(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function v(t) {
            const e = new r.Emitter(t)
            const n = (function (t) {
                let e = t.sourceType
                            var n = t.behaviors
                            var r = void 0 === n ? {} : n
                            var o = t.maxParticles
                            var s = void 0 === o ? 500 : o
                            var u = null
                u = e !== h.c.MOVIE_CLIP && e !== h.c.MIXED && a.b instanceof i.Renderer
                    ? new i.ParticleContainer(s, {
                        rotation: Boolean(r.rotation),
                        vertices: Boolean(r.scale),
                        alpha: Boolean(r.alpha)
                    })
                    : new i.Container()
                return u
            }(t))
            const d = t.emitterGuide
            if (c.a.static || l.a.Ticker.isLowFPS) { return d.visible = !1, {
                emitter: e,
                container: new i.Container()
            }
            }
            !(function (t, e) {
                const n = e.behaviors
                if (!n) return
                const i = n.zone
                let o = n.alpha
                let a = n.attraction
                let s = (n.collision, n.gravity)
                let u = n.gravityWell
                let c = n.randomDrift
                let l = n.repulsion
                let h = n.rotation
                let d = n.scale
                if (i) {
                    let p; let y; const v = i.guide.getBounds()
                    let _ = v.x
                    let g = v.y
                    let b = v.width
                    let E = v.height
                    switch (i.type) {
                        case 'bounding':
                            y = r.CrossZone.CROSS_TYPES.BOUND
                            break
                        case 'dead':
                            y = r.CrossZone.CROSS_TYPES.DEAD
                    }(p = new r.CrossZone(new r.RectZone(_, g, b, E), y)) && (t.addBehavior(p), i.guide.visible = !1)
                }
                o && t.addBehavior(new r.Alpha(r.getSpan.apply(void 0, m(o.from)), o.to && r.getSpan.apply(void 0, m(o.to))))
                a && t.addBehavior(new r.Attraction(f(r.Vector2D, m(a.center)), a.force, a.radius))
                s && t.addBehavior(f(r.Gravity, m(s)))
                u && t.addBehavior(new r.GravityWell(f(r.Vector2D, m(u.center)), u.force))
                c && t.addBehavior(new r.RandomDrift(c.x, c.y, c.delay))
                l && t.addBehavior(new r.Repulsion(f(r.Vector2D, m(l.center)), l.force, l.radius))
                h && t.addBehavior(new r.Rotate(r.getSpan.apply(void 0, m(h.from)), h.to && r.getSpan.apply(void 0, m(h.to))))
                d && t.addBehavior(new r.Scale(r.getSpan.apply(void 0, m(d.from)), d.to && r.getSpan.apply(void 0, m(d.to))))
            }(e, t)),
            (function (t, e) {
                const n = e.initializers
                let i = e.emitterGuide
                let o = e.emitterGuideType
                if (!n) return
                const a = n.life
                let s = n.mass
                let u = n.radius
                let c = (n.rate, n.velocity)
                if (i) {
                    let l; const d = i.width
                    let p = i.height
                    switch (o) {
                        case h.b.CIRCLE:
                            l = new r.CircleZone(0, 0, d / 2)
                            break
                        case h.b.RECTANGLE:
                            l = new r.RectZone(0, 0, d, p)
                    }
                    l && t.addInitialize(new r.Position(l))
                }
                a && t.addInitialize(f(r.Life, m(a)))
                s && t.addInitialize(f(r.Mass, m(s)))
                u && t.addInitialize(f(r.Radius, m(u)))
                c && (c.speed = [].concat(c.speed), t.addInitialize(new r.Velocity(c.speed, c.angle, 'polar')))
            }(e, t))
            const p = e.initializes.find((t) => {
                return t.zone
            })
            d.visible = !1
            const y = function () {
                if (l.a.Ticker.isLowFPS) return console.warn('Turning off particles due to low fps'), e.stopEmit(), e.destroy(), void v()
                let r, i, o, a, s
                !e.dead || n.children.length
                    ? (e.p.x = d.x, e.p.y = d.y, i = (r = t).resizable, o = r.emitterGuideType, a = h.b.CIRCLE, s = h.b.RECTANGLE, !i || o !== a && o !== s || (function (t, e) {
                            t.zone.width !== e.width && (t.zone.width = e.width)
                            t.zone.height !== e.height && (t.zone.height = e.height)
                            t.zone.radius && (t.zone.radius = e.width / 2)
                        }(p, d)), (function (t, e) {
                            let n, r
                            return t.length && (e == null || (n = e.behaviors) === null || void 0 === n || (r = n.zone) === null || void 0 === r ? void 0 : r.moving)
                        }(e.behaviors, t)) && (function (t, e) {
                            const n = t.find((t) => {
                                return 'CrossZone' === t.name
                            }).zone
                            var r = e.behaviors.zone.guide
                            n.x !== r.x && (n.x = r.x)
                            n.y !== r.y && (n.y = r.y)
                            n.width !== r.width && (n.width = r.width)
                            n.height !== r.height && (n.height = r.height)
                        }(e.behaviors, t)), e.update(0.0167))
                    : v()
            }
            var v = function () {
                n.visible = !1, n.destroy(), l.a.Ticker.remove(y)
            }
            return e.particleCreated.add((e) => {
                const r = (function (t) {
                    let e = t.sourceType
                            var n = t.source
                    switch (e) {
                        case h.c.MOVIE_CLIP:
                            return new (_(n))()
                        case h.c.MIXED:
                            var r = _(n)
                            return typeof r == 'function' ? new r() : new i.Sprite(new Object(o.a)(r))
                        default:
                            return new i.Sprite(new Object(o.a)(_(n)))
                    }
                }(t))
                e.source = r, r.scale.set(e.scale), r.angle = e.rotation, r.anchor && r.anchor.set(0.5), typeof t.blendMode == 'string' && (r.blendMode = i.BLEND_MODES[t.blendMode.toUpperCase()]), t.randomFrameStart && r instanceof u.MovieClip && r.gotoAndPlay(function (t) {
                    return new Object(s.g)(0, t.totalFrames - 1)
                }(r)), n.addChild(r)
            }), e.particleUpdate.add((t) => {
                const e = t.source
                e.position.x = t.p.x, e.position.y = t.p.y, e.scale.set(t.scale), e.alpha = t.alpha, e.angle = t.rotation
            }), e.particleDead.add((t) => {
                n.removeChild(t.source), t.source.destroy(), delete t.source, n.children.length || v()
            }), l.a.Ticker.add(y), {
                emitter: e,
                container: n
            }
        }

        function _(t) {
            return Array.isArray(t) ? new Object(s.k)(t) : t
        }
    },
    './src/core/utils/resizing.js': function (t, e, n) {
        'use strict'

        function r(t, e) {
            const n = e.width
            const r = e.height
            const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
            const o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
            const a = n / t.width
            const s = r / t.height
            const u = o ? 1 / 0 : 1
            const c = Math.min(a, s, u)
            t.scale.x *= i ? a : c, t.scale.y *= i ? s : c
        }
        n.d(e, 'a', () => {
            return r
        })
    },
    './src/core/utils/textures.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return s
        }), n.d(e, 'b', () => {
            return u
        })
        const r = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const i = n('./src/core/loader/index.js')
        const o = n('./src/core/utils/EventsHub.js')
        const a = n('./src/core/utils/Cache.js')

        function s(t) {
            return i.d[t] || (console.warn('TextureCache: \''.concat(t, '\' no such texture in texture cache')), o.a.emit(o.a.events.ERROR, {
                priority: 'high',
                nonRecoverable: !0,
                details: {
                    message: 'TextureCache: \''.concat(t, '\' no such texture in texture cache')
                },
                errorType: 'crash'
            })), i.d[t] || r.Texture.EMPTY
        }

        function u(t) {
            return a.b.generateTexture(t)
        }
    },
    './src/features/ParticlesContainer.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return g
        })
        const r = n('./src/core/features/ParticlesContainer.js')
        const i = n('./src/core/utils/index.js')
        const o = n('./src/core/utils/particles.js')
        const a = n('./node_modules/pixi.js/dist/esm/pixi.js')

        function s(t) {
            return (s = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const u = ['life']

        function c(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function l(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? c(new Object(n), !0).forEach((e) => {
                            h(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : c(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function h(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function f(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function d(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function p(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function m(t, e, n) {
            return e = v(e),
            (function (t, e) {
                if (e && (s(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], v(t).constructor)
                : e.apply(t, n)))
        }

        function y(t, e, n) {
            return (y = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = v(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function v(t) {
            return (v = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function _(t, e) {
            return (_ = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        var g = (function (t) {
            function e(t) {
                let n; const r = t.reelMaster
                let i = t.source
                let o = t.guide
                let a = t.config
                let s = t.mask
                let u = t.particleBoundsContainer
                let c = t.name
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = m(this, e, [{
                    source: i,
                    guide: o,
                    config: a,
                    mask: s
                }])).name = c, n._reelMaster = r, n._particleBoundsContainer = u, n
            }
            let n, r, s, c, h
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && _(t, e)
            }(e, t)), n = e, (r = [{
                key: 'emitterGuide',
                get() {
                    return this._emitterGuide
                }
            }, {
                key: 'activate',
                value: (c = regeneratorRuntime.mark(function t() {
                    let n; let r; let o; let s; let u; let c; let l; let h; let f; let d; let p; let m; let _; let g; const b = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return r = b.length > 0 && void 0 !== b[0] ? b[0] : {}, o = new Object(i.c)(this._config, r), s = o.guideAnimation, u = void 0 === s ? ((n = this._emitterGuide.parent) === null || void 0 === n ? void 0 : n.totalFrames) > 1 : s, c = o.centerInTile, l = o.position, h = o.inCover, f = o.hue, d = y(v(e.prototype), 'activate', this).call(this, o), u && this._animateGuide(), f && ((p = new a.filters.ColorMatrixFilter()).hue(f), this.filters = [p]), l && (m = this._getCoords(l), _ = m.x, g = m.y, c
? this._centerGuideInTile(h, {
                                    x: _,
                                    y: g
                                })
: this._emitterGuide.position.set(_, g)), t.next = 9, d
                                case 9:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                }), h = function () {
                    const t = this
                    let e = arguments
                    return new Promise((n, r) => {
                        const i = c.apply(t, e)

                        function o(t) {
                            d(i, n, r, o, a, 'next', t)
                        }

                        function a(t) {
                            d(i, n, r, o, a, 'throw', t)
                        }
                        o(void 0)
                    })
                }, function () {
                    return h.apply(this, arguments)
                })
            }, {
                key: '_animateGuide',
                value() {
                    let t
                    this._emitterGuide.startTick(), (t = this._emitterGuide.parent) === null || void 0 === t || t.gotoAndPlay(0, {
                        repeat: -1
                    })
                }
            }, {
                key: '_getCoords',
                value(t) {
                    const e = t.x
                    var n = t.y
                    var r = t.reel
                    var i = t.index
                    return void 0 !== e && void 0 !== n
                        ? {
                                x: e,
                                y: n
                            }
                        : this._reelMaster.getTilePosition({
                                reel: r,
                                index: i
                            })
                }
            }, {
                key: '_centerGuideInTile',
                value(t, e) {
                    const n = e.x
                    var r = e.y
                    var i = this._reelMaster.tileGuide
                    var o = i.width / 2
                    var a = i.height / 2
                    t ? this._emitterGuide.position.set(o, a) : this._emitterGuide.position.set(n + o, r + a)
                }
            }, {
                key: '_createEmitter',
                value(t) {
                    let e; let n; let r; const i = t.life
                    var a = f(t, u)
                    var s = new Object(o.a)(l(l({}, a.emitter), {}, {
                        emitterGuide: this._emitterGuide,
                        source: this._particlesSource
                    }))
                    var c = s.emitter
                    var h = s.container
                    return c.life = i, (e = a.emitter) !== null && void 0 !== e && (n = e.behaviors) !== null && void 0 !== n && (r = n.rotation) !== null && void 0 !== r && r.useFixedAngle && c.particleUpdate.add((t) => {
                        let e; let n; let r = t.source
                                var i = (e = t.p, n = t.old.p, 180 * Math.atan2(e.y - n.y, e.x - n.x) / Math.PI)
                        r.angle = i
                    }), {
                        emitter: c,
                        container: h
                    }
                }
            }]) && p(n.prototype, r), s && p(n, s), e
        }(r.a))
    },
    './src/features/index.js': function (t, e, n) {
        'use strict'
        const r = n('./src/core/features/covers/Cover.js')
        const i = n('./src/core/Platform.js')
        const o = n('./node_modules/pixi.js/dist/esm/pixi.js')
        const a = n('./node_modules/@games/gsap/all.js')
        const s = n('./node_modules/@games/dope/src/Dopamine.js')
        const u = n('./src/core/utils/Cache.js')

        function c(t) {
            return (c = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function l(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function h(t, e, n) {
            return e = f(e),
            (function (t, e) {
                if (e && (c(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], f(t).constructor)
                : e.apply(t, n)))
        }

        function f(t) {
            return (f = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function d(t, e) {
            return (d = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const p = {
            TOP_LEFT: {
                x: 0,
                y: 0
            },
            LEFT: {
                x: 0,
                y: 0.5
            },
            BOTTOM_LEFT: {
                x: 0,
                y: 1
            },
            TOP_CENTER: {
                x: 0.5,
                y: 0
            },
            CENTER: {
                x: 0.5,
                y: 0.5
            },
            BOTTOM_CENTER: {
                x: 0.5,
                y: 1
            },
            TOP_RIGHT: {
                x: 1,
                y: 0
            },
            RIGHT: {
                x: 1,
                y: 0.5
            },
            BOTTOM_RIGHT: {
                x: 1,
                y: 1
            }
        }
        const m = {
            BANGUP_END: 'counter_bangup_end'
        }
        const y = (function (t) {
            function e(t) {
                let n; const r = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = h(this, e))._config = r, n._count = 1, n._num = n._createNum(), n._updateTween = null, n._template = r.template || '{{val}}', n
            }
            let n, r, c
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && d(t, e)
            }(e, t)), n = e, c = [{
                key: 'events',
                get() {
                    return m
                }
            }], (r = [{
                key: 'alignValues',
                get() {
                    return p
                }
            }, {
                key: 'currentCount',
                get() {
                    return this._count
                },
                set(t) {
                    this._updateNum(t)
                }
            }, {
                key: 'update',
                value(t) {
                    let e = this
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                                var r = n.duration
                                var i = void 0 === r ? 0 : r
                                var o = n.easing
                                var s = void 0 === o ? 'none' : o
                                var u = n.onUpdate
                                var c = n.from
                                var l = void 0 === c ? this._count : c
                                var h = {
                        value: l
                    };
                    return this._updateTween = a.b.to(h, {
                        duration: i,
                        value: t,
                        ease: s,
                        onUpdate () {
                            e._updateNum(e._config.round ? Number.parseInt(h.value) : h.value), u && u(h.value)
                        },
                        onComplete () {
                            e.emit(m.BANGUP_END, {
                                value: h.value
                            })
                        }
                    }), this._updateTween
                }
            }, {
                key: 'reset',
                value() {
                    this._updateTween = null, this._updateNum(1)
                }
            }, {
                key: 'skip',
                value() {
                    this._updateTween && this._updateTween.progress() !== 1 && this._updateTween.progress(1)
                }
            }, {
                key: 'prepareText',
                value() {
                    return new Object(u.a)(this._num)
                }
            }, {
                key: '_updateNum',
                value(t) {
                    this._count = this._format(t, this._config.precision)
                    var e = this._config.currency ? s.a.format(this._count, this._config.hideDecimals) : this._count
                    this._num.text = this._template.replace('{{val}}', e), void 0 !== this._config.letterSpacing && this._config.letterSpacing !== null && (this._num.letterSpacing = this._config.letterSpacing * i.a.resolutionScale, this._align(this._num, this._config.alignType))
                }
            }, {
                key: '_createNum',
                value() {
                    let t = this._config
                                var e = t.font
                                var n = t.alignType
                                var r = t.fontSize
                                var i = new o.BitmapText('', {
                        fontName: e,
                        fontSize: r
                    })
                    return this.addChild(i), this._align(i, n), i
                }
            }, {
                key: '_align',
                value(t, e) {
                    let n = this.alignValues[e]
                                var r = n.x
                                var i = n.y
                    t.anchor.set(r, i)
                }
            }, {
                key: '_format',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2
                    return Number.parseFloat(t.toFixed(e))
                }
            }]) && l(n.prototype, r), c && l(n, c), e
        }(o.Container))

        function v(t) {
            return (v = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function _(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function g(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? _(new Object(n), !0).forEach((e) => {
                            b(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : _(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function b(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function E(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function x(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        E(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        E(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function T(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function S(t, e, n) {
            return e = O(e),
            (function (t, e) {
                if (e && (v(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], O(t).constructor)
                : e.apply(t, n)))
        }

        function w(t, e, n) {
            return (w = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = O(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function O(t) {
            return (O = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function P(t, e) {
            return (P = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const R = {
            INIT: 'init',
            INCREMENT_START: 'incrementStart',
            INCREMENT_END: 'incrementEnd',
            DECREMENT_START: 'decrementStart',
            DECREMENT_END: 'decrementEnd',
            ONE_SPIN: 'oneSpin',
            LAST_SPIN: 'lastSpin',
            RETURN_SPINS: 'returnSpins',
            SPIN: 'spin',
            SPINS: 'spins'
        }
        const A = (function (t) {
            function e(t) {
                let n; let r = t.name
                            var i = t.animation
                            var o = t.config
                            var a = t.mask
                            var s = t.data
                            var u = t.stopTickChildren
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = S(this, e, [{
                    name: r,
                    animation: i,
                    config: o,
                    mask: a,
                    data: s,
                    stopTickChildren: u
                }]))._count = 0, n._isInLastSpin = !1, n._counterMc = n._anim.counter, n._counter = n._createCounter(), n._counterMc.promises.gotoAndStop('init'), n
            }
            let n, r, i, o, a, s, u, c, l
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && P(t, e)
            }(e, t)), n = e, (r = [{
                key: 'animLabels',
                get () {
                    return R
                }
            }, {
                key: 'count',
                get () {
                    return this._count
                }
            }, {
                key: 'activate',
                value: (l = x(regeneratorRuntime.mark(function t() {
                    var e; var n; var r = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = r.length > 0 && void 0 !== r[0] ? r[0] : {}, void 0 !== (n = e.spins)) {
                                            t.next = 4;
                                            break
                                        }
                                        throw new Error("Spins count not provided!");
                                    case 4:
                                        return this._counter.reset(), this._count = n, this._isInLastSpin = !1, this._addCounter(), this._counter.update(this._count), this.anim.textContainer.promises.gotoAndStop(this.animLabels.INIT), t.next = 12, this.show();
                                    case 12:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'update',
                value: (c = x(regeneratorRuntime.mark(function t() {
                    var e; var n; var r = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return e = r.length > 0 && void 0 !== r[0] ? r[0] : {}, n = e.spins, this._count += n, t.abrupt("return", this._updateCount(g(g({}, e), {}, {
                                            animLabelStart: this.animLabels.INCREMENT_START,
                                            animLabelEnd: this.animLabels.INCREMENT_END
                                        })));
                                    case 4:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'deactivate',
                value: (u = x(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, this.hide();
                                    case 2:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'increment',
                value: (s = x(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        this._count++, this._updateCount({
                                            animLabelStart: this.animLabels.INCREMENT_START,
                                            animLabelEnd: this.animLabels.INCREMENT_END
                                        });
                                    case 2:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'decrement',
                value () {
                    this._count && (this._count--, this._updateCount({
                        animLabelStart: this.animLabels.DECREMENT_START,
                        animLabelEnd: this.animLabels.DECREMENT_END
                    }))
                }
            }, {
                key: 'skip',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                            if (this._counter.skip(), t) return w(O(e.prototype), 'skip', this).call(this)
                }
            }, {
                key: '_updateCount',
                value: (a = x(regeneratorRuntime.mark(function t() {
                    var e; var n; var r; var i; var o = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return e = o.length > 0 && void 0 !== o[0] ? o[0] : {}, n = e.animLabelStart, r = e.animLabelEnd, i = this._counterMc.promises.gotoAndPlay, t.next = 5, i(n);
                                    case 5:
                                        return t.next = 7, this._onCountAnimHit(e);
                                    case 7:
                                        return t.next = 9, i(r);
                                    case 9:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_onCountAnimHit',
                value: (o = x(regeneratorRuntime.mark(function t() {
                    var e; var n; var r = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = r.length > 0 && void 0 !== r[0] ? r[0] : {}, n = e.duration, !(this._count > 0)) {
                                            t.next = 5;
                                            break
                                        }
                                        return t.next = 5, this._counter.update(this._count, {
                                            duration: n
                                        });
                                    case 5:
                                        this._updateTitle();
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_addCounter',
                value () {
                    this._counterMc.numContainer.inner.removeChildren(), this._counterMc.numContainer.inner.addChild(this._counter)
                }
            }, {
                key: '_updateTitle',
                value () {
                    var t = this.anim.textContainer;
                                var e = this.animLabels;
                                var n = e.LAST_SPIN;
                                var r = e.RETURN_SPINS;
                                var i = e.SPIN;
                                var o = e.SPINS;
                                var a = e.INIT
                            this._count ? (this._isInLastSpin && this.play(r), this._count === 1 ? t.promises.gotoAndPlay(i) : [o, a].includes(t.currentLabel) || t.promises.gotoAndPlay(o), this._isInLastSpin = !1) : (this._isInLastSpin = !0, this.play(n))
                }
            }, {
                key: '_createCounter',
                value () {
                    var t = this._counterMc.numContainer.inner.getLocalBounds().height
                            return new y({
                        config: g({
                            fontSize: t
                        }, this._config.counter)
                    })
                }
            }]) && T(n.prototype, r), i && T(n, i), e
        }(r.a))
        const I = n('./src/core/utils/EventsHub.js')
        const C = n('./src/core/utils/ExternalInput.js')
        const k = n('./src/core/utils/index.js')

        function N(t) {
            return (N = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function M(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function j(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        M(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        M(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function D(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function L(t, e, n) {
            return e = F(e),
            (function (t, e) {
                if (e && (N(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], F(t).constructor)
                : e.apply(t, n)))
        }

        function F(t) {
            return (F = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function B(t, e) {
            return (B = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function U(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function G(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? U(new Object(n), !0).forEach((e) => {
                            X(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : U(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function X(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const H = G(G({}, r.a.animLabels), {}, {
            SHOW_BUTTON: 'showButton',
            INCREMENT_START: 'incrementStart',
            INCREMENT_END: 'incrementEnd',
            WIN: 'win'
        })
        const V = G(G({}, r.a.events), {}, {
            BUTTON_CLICKED: 'button_clicked',
            COUNT_END: 'count_end'
        })
        const W = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = t.animation
                var o = t.config
                var a = t.mask
                var s = t.data
                var u = t.stopTickChildren
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = L(this, e, [{
                    name: r,
                    animation: i,
                    config: o,
                    mask: a,
                    data: s,
                    stopTickChildren: u
                }]))._skip = null, n._count = 1, n._finalCount = 0, n._counterMc = n._anim.counter, n._counter = n._createCounter(), n._counterMc.promises.gotoAndStop('init'), n
            }
            let n, r, i, o, a, u, c, l, h
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && B(t, e)
            }(e, t)), n = e, r = [{
                key: 'counter',
                get() {
                    return this._counter
                }
            }, {
                key: 'activate',
                value: (h = j(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = o.length > 0 && void 0 !== o[0] ? o[0] : {}, this._count = 1, this._counter.reset(), r = n.spins, i = n.instant, this._finalCount = r, i && (this._count = r, this._counter.update(r)), this._addCounter(), this._counterMc.promises.gotoAndStop("init"), t.next = 10, this.show();
                                    case 10:
                                        if (i) {
                                            t.next = 14;
                                            break
                                        }
                                        return t.next = 13, this._countTo(r);
                                    case 13:
                                        this.emit(e.events.COUNT_END, {
                                            count: this._counter.currentCount
                                        });
                                    case 14:
                                        return t.next = 16, this._win();
                                    case 16:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return h.apply(this, arguments)
                })
            }, {
                key: 'showStart',
                value: (l = j(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return I.a.emit(I.a.events.FEATURE_CONTROLS_SHOW, {
                                            options: this._getButtonOptions()
                                        }), t.next = 3, C.a.when("FREE_SPINS_START");
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value: (c = j(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (this._skip) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        this._skip(), this._skip = null, this._count = this._finalCount, this._counter.update(this._count);
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'start',
                value: (u = j(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        I.a.emit(I.a.events.FEATURE_CONTROLS_HIDE), this.emit(e.events.BUTTON_CLICKED);
                                    case 2:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: '_countTo',
                value: (a = j(regeneratorRuntime.mark(function t(n) {
                    let r = this
                    return regeneratorRuntime.wrap((t) => {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.abrupt("return", new Promise(function() {
                                            var t = j(regeneratorRuntime.mark((function t(i) {
                                                return regeneratorRuntime.wrap((function(t) {
                                                    for (;;) switch (t.prev = t.next) {
                                                        case 0:
                                                            if (r._skip = i, r._count++, !(r._count > n)) {
                                                                t.next = 4;
                                                                break
                                                            }
                                                            return t.abrupt("return", i());
                                                        case 4:
                                                            return t.next = 6, r._counterMc.promises.gotoAndPlay(e.animLabels.INCREMENT_START);
                                                        case 6:
                                                            return r._counter.update(r._count), t.next = 9, r._counterMc.promises.gotoAndPlay(e.animLabels.INCREMENT_END);
                                                        case 9:
                                                            return t.next = 11, Object(k.d)(r._getCountIntervalDelay());
                                                        case 11:
                                                            return t.abrupt("return", i(r._countTo(n)));
                                                        case 12:
                                                        case "end":
                                                            return t.stop()
                                                    }
                                                }), t)
                                            })));
                                            return function(e) {
                                                return t.apply(this, arguments)
                                            }
                                        }()));
                                    case 1:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t)
                })), function (t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_win',
                value: (o = j(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, this._counterMc.promises.gotoAndPlay(e.animLabels.WIN);
                                    case 2:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_getCountIntervalDelay',
                value() {
                    let t = this._config.countUpdate.interval
                    return new Object(k.h)(t.min, t.max)
                }
            }, {
                key: '_addCounter',
                value() {
                    this._counterMc.numContainer.inner.removeChildren(), this._counterMc.numContainer.inner.addChild(this._counter)
                }
            }, {
                key: '_createCounter',
                value() {
                    let t = this._counterMc.numContainer.inner.getLocalBounds().height
                    return new y({
                        config: G({
                            fontSize: t
                        }, this._config.counter)
                    })
                }
            }, {
                key: '_getButtonOptions',
                value() {
                    return {
                        align: 'center',
                        buttons: [{
                            name: 'FREE_SPINS_START',
                            label: s.c.texts.FREE_SPINS_START,
                            type: 'primary',
                            size: 'large',
                            spacebar: !0
                        }]
                    }
                }
            }], i = [{
                key: 'events',
                get() {
                    return V
                }
            }, {
                key: 'animLabels',
                get() {
                    return H
                }
            }], r && D(n.prototype, r), i && D(n, i), e
        }(r.a))

        function Y(t) {
            return (Y = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function z(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function q(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? z(new Object(n), !0).forEach((e) => {
                            K(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : z(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function K(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function Z(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function $(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function J(t, e, n) {
            return e = Q(e),
            (function (t, e) {
                if (e && (Y(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Q(t).constructor)
                : e.apply(t, n)))
        }

        function Q(t) {
            return (Q = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function tt(t, e) {
            return (tt = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const et = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = t.animation
                var o = t.config
                var a = t.mask
                var s = t.data
                var u = t.stopTickChildren
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = J(this, e, [{
                    name: r,
                    animation: i,
                    config: o,
                    mask: a,
                    data: s,
                    stopTickChildren: u
                }]))._counterMc = n._anim.counter, n._counter = n._createCounter(), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && tt(t, e)
            }(e, t)), n = e, (r = [{
                key: 'activate',
                value: (o = regeneratorRuntime.mark(function t() {
                    let e; let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = r.length > 0 && void 0 !== r[0] ? r[0] : {}, n = e.spins, this._counter.update(n), this._counterMc.numContainer.inner.removeChildren(), this._counterMc.numContainer.inner.addChild(this._counter), t.abrupt("return", this.show());
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                }), a = function () {
                    let t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = o.apply(t, e)

                        function a(t) {
                            Z(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            Z(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_createCounter',
                value () {
                    var t = this._counterMc.numContainer.inner.getLocalBounds().height
                    return new y({
                        config: q({
                            fontSize: t
                        }, this._config.counter)
                    })
                }
            }]) && $(n.prototype, r), i && $(n, i), e
        }(r.a))
        let nt = n('./src/core/features/reels/engines/ReelMaster.js')
        let rt = n('./src/core/features/reels/engines/SpinningReelMaster.js')
        let it = n('./src/core/features/reels/renderers/Renderer.js')
        let ot = n('./node_modules/ramda/es/internal/_curry2.js')

        function at(t) {
            return Object.prototype.toString.call(t) === '[object Number]'
        }
        const st = new Object(ot.a)((t, e) => {
            if (!at(t) || !at(e)) throw new TypeError('Both arguments to range must be numbers')
            for (var n = [], r = t; r < e;) n.push(r), r += 1
            return n
        })
        const ut = n('./node_modules/ramda/es/isEmpty.js')
        const ct = n('./node_modules/ramda/es/internal/_includes.js')

        function lt(t, e, n) {
            let r; let i = typeof t
            switch (i) {
                case 'string':
                case 'number':
                    return t === 0 && 1 / t == -1 / 0 ? !!n._items['-0'] || (e && (n._items['-0'] = !0), !1) : n._nativeSet !== null ? e ? (r = n._nativeSet.size, n._nativeSet.add(t), n._nativeSet.size === r) : n._nativeSet.has(t) : i in n._items ? t in n._items[i] || (e && (n._items[i][t] = !0), !1) : (e && (n._items[i] = {}, n._items[i][t] = !0), !1)
                case 'boolean':
                    if (i in n._items) {
                        const o = t ? 1 : 0
                        return !!n._items[i][o] || (e && (n._items[i][o] = !0), !1)
                    }
                    return e && (n._items[i] = t ? [!1, !0] : [!0, !1]), !1
                case 'function':
                    return n._nativeSet !== null ? e ? (r = n._nativeSet.size, n._nativeSet.add(t), n._nativeSet.size === r) : n._nativeSet.has(t) : i in n._items ? !!new Object(ct.a)(t, n._items[i]) || (e && n._items[i].push(t), !1) : (e && (n._items[i] = [t]), !1)
                case 'undefined':
                    return !!n._items[i] || (e && (n._items[i] = !0), !1)
                case 'object':
                    if (t === null) return !!n._items.null || (e && (n._items.null = !0), !1)
                default:
                    return (i = Object.prototype.toString.call(t)) in n._items ? !!new Object(ct.a)(t, n._items[i]) || (e && n._items[i].push(t), !1) : (e && (n._items[i] = [t]), !1)
            }
        }
        const ht = (function () {
            function t() {
                this._nativeSet = typeof Set == 'function' ? new Set() : null, this._items = {}
            }
            return t.prototype.add = function (t) {
                return !lt(t, !0, this)
            }, t.prototype.has = function (t) {
                return lt(t, !1, this)
            }, t
        }())
        let ft = new Object(ot.a)((t, e) => {
            for (var n = [], r = 0, i = t.length, o = e.length, a = new ht(), s = 0; s < o; s += 1) a.add(e[s])
            for (; r < i;) a.add(t[r]) && (n[n.length] = t[r]), r += 1
            return n
        })
        let dt = n('./src/core/features/reels/buffers/Buffer.js')

        function pt(t) {
            return (pt = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function mt(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function yt(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function vt(t, e, n) {
            return e = _t(e),
            (function (t, e) {
                if (e && (pt(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], _t(t).constructor)
                : e.apply(t, n)))
        }

        function _t(t) {
            return (_t = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function gt(t, e) {
            return (gt = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function bt(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Et(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? bt(new Object(n), !0).forEach((e) => {
                            xt(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : bt(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function xt(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Tt = Et({}, dt.a.events)
        const St = (function (t) {
            function e() {
                return mt(this, e), vt(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && gt(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get () {
                    return Tt
                }
            }], (r = [{
                key: 'update',
                value (t) {
                    var e = t[1];
                                var n = e.filter((function(t) {
                                    return !!t
                                })).length;
                                var r = e.map(function(t) {
                                    return {
                                        id: t,
                                        heightIndex: n,
                                        replaced: null
                                    }
                                });
                    this._data = r
                }
            }, {
                key: 'changeEntry',
                value (t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                            this._data[t] = Et(Et({}, this._data[t]), {}, n
? {
                        id: e,
                        replaced: null
                    }
: {
                        replaced: e
                    })
                }
            }, {
                key: 'fetchEntry',
                value (t) {
                    return this._data[t]
                }
            }, {
                key: 'fetchResultScreen',
                value () {
                    return this._data
                }
            }, {
                key: 'resetEntry',
                value (t) {
                    this.changeEntry(t, null)
                }
            }]) && yt(n.prototype, r), i && yt(n, i), e
        }(dt.a))
        const wt = n('./src/core/features/reels/tiles/Tile.js')

        function Ot(t) {
            return (Ot = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Pt(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Rt(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Pt(new Object(n), !0).forEach((e) => {
                            At(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Pt(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function At(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function It(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ct(t, e, n) {
            return e = kt(e),
            (function (t, e) {
                if (e && (Ot(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], kt(t).constructor)
                : e.apply(t, n)))
        }

        function kt(t) {
            return (kt = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Nt(t, e) {
            return (Nt = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Mt = {
            FALL_IN: 'fall_in',
            FALL_OUT: 'fall_out'
        }
        const jt = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = Ct(this, e))._dropTiles = {}, t._tilesCache = {}, t._guide = null, t._tilesGenerator = null, t
            }
            let n, r, i
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Nt(t, e)
            }(e, t)), n = e, i = [{
                key: 'tileTypes',
                get () {
                    return Mt
                }
            }], (r = [{
                key: 'tileGuide',
                get () {
                    return this._guide
                }
            }, {
                key: 'dropTiles',
                get () {
                    return this._dropTiles
                }
            }, {
                key: 'tilesGenerator',
                get () {
                    return this._tilesGenerator
                }
            }, {
                key: 'onCreated',
                value (t) {
                    var e = t.data;
                                var n = t.tileTypes;
                                var r = t.marker;
                                var i = t.index;
                                var o = t.config;
                                var a = t.tileGuide;
                                var s = t.bufferSource;
                                var u = void 0 === s ? St : s;
                                var c = t.tilesGenerator;
                                var l = r.children[0];
                                var h = l.getBounds()
                            o.useOwnMask ? this.mask = l : l.alpha = 0, this._index = i, this._tilesGenerator = c, this._guide = a, this.position.set(r.x, r.y)
                            var f = this._createTilesConfig({
                        tileTypes: n,
                        config: o,
                        bounds: h
                    })
                            this._config = new Object(k.c)(o, {
                        tiles: f,
                        index: i
                    }, {
                        bounds: h
                    })
                            var d = this._createTiles(st(0, this._config.tiles.visible), this._config.tiles)
                            this._tiles = d, this._buffer = new u(), this._buffer.update(e), this.setSpinnableTiles(), this.updateTiles(d)
                }
            }, {
                key: 'replaceTile',
                value (t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Mt.FALL_OUT
                            this._buffer.changeEntry(t, e, n)
                            var i = r === Mt.FALL_IN ? this._dropTiles : this._tiles
                            this.updateTile(i[t], this._buffer.data[t])
                }
            }, {
                key: 'createDropTiles',
                value (t, e) {
                    this._buffer.update(t)
                            var n = this._config.tiles;
                                var r = this._getAvailableIndices(n.visible);
                                var i = this._createTiles(r, n);
                                var o = this._calcYOffset(r, n)
                            this._dropTiles = i, this.updateTiles(i, o + e)
                }
            }, {
                key: 'reset',
                value () {
                    this._tilesCache = this._tiles, Object.values(this._tilesCache).forEach(function(t) {
                                return t.visible = !1
                            }), this._tiles = this._dropTiles
                }
            }, {
                key: 'getTileCellPosition',
                value (t) {
                    return {
                        x: this.x + this._tiles[t].x,
                        y: this.y + t * this._guide.height
                    }
                }
            }, {
                key: 'getTileCoordinates',
                value (t) {
                    return {
                        x: this.x,
                        y: this.y + this._tiles[t].y
                    }
                }
            }, {
                key: 'updateTiles',
                value () {
                    var t = this;
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._tiles;
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                                var r = this._buffer.data
                            Object.keys(e).forEach(function(i) {
                                var o = e[i];
                                t.updateTile(o, r[i]), o.position.set(0, t._guide.height * i - n)
                            })
                }
            }, {
                key: 'setSpinnableTiles',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._index;
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._config.tiles
                            this._tilesGenerator && (this._tilesGenerator.setSpinnableTiles({
                        index: t,
                        tiles: e.spinnable,
                        cache: !0
                    }), new Object(ut.a)(e.stacked) || this._tilesGenerator.enableStack({
                        index: t,
                        stacked: e.stacked
                    }))
                }
            }, {
                key: 'updateTile',
                value (t, e) {
                    if (!t || !e) return console.warn('Tile with id '.concat(e.replaced || e.id, ' doesn\'t exist.'))
                            t.to(e, 'normal')
                }
            }, {
                key: '_createTiles',
                value (t) {
                    var e = this
                            return t.reduce(function(t, n) {
                                return Rt(Rt({}, t), {}, At({}, n, e._createTile(n)))
                            }, {})
                }
            }, {
                key: '_createTile',
                value (t) {
                    var e = null
                            return Object.keys(this._tilesCache).length > 0 && this._tilesCache[t] ? (e = this._tilesCache[t]).visible = !0 : (e = new wt.a()).index = t, this.addChild(e), e
                }
            }, {
                key: '_calcYOffset',
                value (t) {
                    return t.length * this._guide.height
                }
            }, {
                key: '_getAvailableIndices',
                value (t) {
                    return ft(st(0, t), Object.keys(this._tiles))
                }
            }, {
                key: '_createTilesConfig',
                value (t) {
                    var e; var n = t.tileTypes;
                                var r = t.config;
                                var i = {
                            bounds: t.bounds,
                            ids: n.map(function(t) {
                                        return t.id
                                    }).concat(0),
                            sizes: r.tiles.sizes || [r.tiles.visible],
                            spinnable: n.filter(function(t) {
                                        return "normal" === t.type
                                    }).map(function(t) {
                                        return t.id
                                    })
                        };
                    return (e = r.fall.pass) !== null && void 0 !== e && e.excludeTiles && (i.spinnable = ft(i.spinnable, r.fall.pass.excludeTiles)), i
                }
            }]) && It(n.prototype, r), i && It(n, i), e
        }(it.a))
        const Dt = n('./src/core/features/reels/controllers/Controller.js')
        const Lt = n('./src/core/utils/Status.js')
        n('./src/core/utils/CombinedTicker.js')

        function Ft(t) {
            return (Ft = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Bt(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Ut(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Bt(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Bt(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Gt(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Xt(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ht(t, e, n) {
            return e = Vt(e),
            (function (t, e) {
                if (e && (Ft(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Vt(t).constructor)
                : e.apply(t, n)))
        }

        function Vt(t) {
            return (Vt = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Wt(t, e) {
            return (Wt = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Yt(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function zt(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Yt(new Object(n), !0).forEach((e) => {
                            qt(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Yt(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function qt(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Kt = zt({}, Dt.a.events)
        const Zt = (function (t) {
            function e() {
                return Gt(this, e), Ht(this, e, arguments)
            }
            let n, r, i, o, a
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Wt(t, e)
            }(e, t)), n = e, r = [{
                key: 'stop',
                value: (a = Ut(regeneratorRuntime.mark(function t(n, r) {
                    return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (!this.isStopping) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        return this.emit(e.events.SPIN_STOPPING), this.isStopping = !0, this._config.spin.minSpinDurationEnabled && !Lt.a.get(Lt.a.TYPES.IN_FREE_SPINS) && console.time("stop_time"), t.next = 7, this._onStop(n, r);
                                    case 7:
                                        this._reset(), this.emit(e.events.SPIN_END), this._config.spin.minSpinDurationEnabled && (console.timeEnd("stop_time"), console.timeEnd("spin"));
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t, e) {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'generateFakeFall',
                value: (o = Ut(regeneratorRuntime.mark(function t() {
                    var e, n, r, i, o, a, s
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        r = this._calcSpinDelay(), i = 2 * (this._reels[0]._renderer.config.bounds.height + (null === (e = this._config.fall.pass) || void 0 === e ? void 0 : e.offset)), o = i / (null === (n = this._config.fall.pass) || void 0 === n ? void 0 : n.speed), a = Math.floor(r / o), console.time("fall_pass"), s = 0;
                                    case 6:
                                        if (!(s <= a)) {
                                            t.next = 12;
                                            break
                                        }
                                        return t.next = 9, this._anticipate();
                                    case 9:
                                        s++, t.next = 6;
                                        break;
                                    case 12:
                                        console.timeEnd("fall_pass");
                                    case 13:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_onStart',
                value () {
                    var t = this;
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._config.fall.out;
                                var n = this._reels.map(function(n) {
                                    return n.start(t._mergeWithPreConfig(n, Object(k.c)(t._config.fall.out, e), "start"))
                                });
                    return Promise.all(n)
                }
            }, {
                key: '_onStop',
                value (t) {
                    var e = this;
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._config.fall.in;
                                var r = this._reels.map(function(r) {
                                    return r.stop(t[r.index], e._mergeWithPreConfig(r, Object(k.c)(e._config.fall.in, n), "stop"))
                                });
                    return Promise.all(r)
                }
            }, {
                key: '_onInstantStop',
                value (t) {
                    this._reels.forEach(function(e, n) {
                                return e.isStopping && e.stopInstant(t[n])
                            })
                }
            }, {
                key: '_prepareConfig',
                value (t, e) {
                    return zt(zt({}, t), {}, {
                        delays: this._calcDelays(t, e)
                    })
                }
            }, {
                key: '_mergeWithPreConfig',
                value (t, e, n) {
                    return this._preConfigs[n][t.index] ? this._prepareConfig(new Object(k.c)(e, this._preConfigs[n][t.index]), t.renderer) : this._prepareConfig(e, t.renderer)
                }
            }, {
                key: '_createReel',
                value (t, e, n) {
                    var r = new n({
                        renderer: e,
                        config: t
                    })
                            this._reels.push(r), this._renderers.push(e), this._preConfigs.start[e.index] = {}, this._preConfigs.stop[e.index] = {}
                }
            }, {
                key: '_anticipate',
                value () {
                    var t = this;
                                var e = this._reels.map(function(e) {
                                    return t._screenPass(e)
                                });
                    return Promise.all(e)
                }
            }, {
                key: '_screenPass',
                value (t) {
                    var e = [
                        [], 
this._renderers[t.index].tilesGenerator.generateRandomTiles({
                            count: this._config.tiles.visible,
                            index: t.index
                        }), 
[]
                    ];
                    return t.screenPass(e, this._mergeWithPreConfig(t, this._config.fall.pass, 'stop'))
                }
            }, {
                key: '_calcDelays',
                value (t, e) {
                    var n = t.delays;
                                var r = n.betweenBlockSets;
                                var i = n.betweenBlocks;
                                var o = n.beforeSetStart
                            return new Object(k.c)({
                        beforeStart: r * e.index + o,
                        blockDelays: this._calcBlockDelays(i, e)
                    }, t.delays)
                }
            }, {
                key: '_calcBlockDelays',
                value (t, e) {
                    var n = e.config
                            return st(0, n.tiles.visible).map(function(e) {
                                return t * e
                            })
                }
            }], i = [{
                key: 'events',
                get () {
                    return Kt
                }
            }], r && Xt(n.prototype, r), i && Xt(n, i), e
        }(Dt.a))
        const $t = n('./src/core/features/reels/animations/Animation.js')

        function Jt(t) {
            return (Jt = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Qt(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function te(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Qt(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Qt(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function ee(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function ne(t, e, n) {
            return e = re(e),
            (function (t, e) {
                if (e && (Jt(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], re(t).constructor)
                : e.apply(t, n)))
        }

        function re(t) {
            return (re = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ie(t, e) {
            return (ie = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function oe(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function ae(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? oe(new Object(n), !0).forEach((e) => {
                            se(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : oe(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function se(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const ue = ae(ae({}, $t.a.events), {}, {
            ANIMATION_SINGLE_START: 'animation_single_start',
            ANIMATION_SINGLE_ENDING: 'animation_single_ending',
            ANIMATION_SINGLE_END: 'animation_single_end'
        })
        const ce = ae({}, $t.a.labels)
        const le = 'IN'
        const he = 'OUT'
        const fe = (function (t) {
            function e(t) {
                let n; let r = t.renderer
                            var i = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = ne(this, e, [{
                    renderer: r,
                    config: i
                }]))._timeScaleTween = null, n._fallInTimeline = null, n._fallOutTimeline = null, n._screenPassTimeline = null, n._isStarting = !1, n._isSpinning = !1, n._isStopping = !1, n._inSpin = !1, n._reset(), n
            }
            let n, r, i, o, s, u, c, l
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ie(t, e)
            }(e, t)), n = e, r = [{
                key: 'inSpin',
                get () {
                    return this._inSpin
                }
            }, {
                key: 'isStarting',
                get () {
                    return this._isStarting
                }
            }, {
                key: 'isSpinning',
                get () {
                    return this._isSpinning
                }
            }, {
                key: 'isStopping',
                get () {
                    return this._isStopping
                }
            }, {
                key: 'start',
                value: (l = te(regeneratorRuntime.mark(function t() {
                    var n; var r = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (n = r.length > 0 && void 0 !== r[0] ? r[0] : {}, !this._inSpin) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return", Promise.resolve());
                                    case 3:
                                        return this._inSpin = !0, this._isStarting = !0, this.emit(e.events.ANIMATION_SPIN_STARTING), t.next = 8, this._fallOut(n);
                                    case 8:
                                        this.emit(e.events.ANIMATION_SPINNING), this._isSpinning = !0;
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'stop',
                value: (c = te(regeneratorRuntime.mark(function t(n) {
                    var r; var i = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return r = i.length > 1 && void 0 !== i[1] ? i[1] : {}, this._isStopping = !0, this.emit(e.events.ANIMATION_STOPPING), t.next = 5, this._fallIn(n, r);
                                    case 5:
                                        this.emit(e.events.ANIMATION_SPIN_END), this._inSpin = !1;
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'stopInstant',
                value () {
                    if (!this._isStarting) return console.error('I\'m not started yet, reel:', this._index)
                            if (!this._isStopping) return console.error('I\'m not stopping yet, reel:', this._index)
                            var t = this._config.fall.instantStop.speedUpReels
                            t.enabled ? this.setTimeScale(t.speedFactor, t.switchDuration) : (this._fallOutTimeline && this._fallOutTimeline.progress() !== 1 && this._fallOutTimeline.progress(1), this._fallInTimeline && this._fallInTimeline.progress() !== 1 && this._fallInTimeline.progress(1), this._screenPassTimeline && this._screenPassTimeline.progress() !== 1 && this._screenPassTimeline.progress(1)), this._inInstantStop = !0
                }
            }, {
                key: 'setTimeScale',
                value (t, e) {
                    if (!this._inInstantStop) {
                        var n = this._config.fall.instantStop.speedUpReels.overwrite
                                this._timeScaleTween = a.b.to([this._fallInTimeline, this._fallOutTimeline, this._screenPassTimeline], {
                            duration: e,
                            timeScale: t,
                            overwrite: n
                        })
                    }
                }
            }, {
                key: 'screenPass',
                value: (u = te(regeneratorRuntime.mark(function t(e, n) {
                    var r; var i; var o; var s; var u; var c; var l; var h; var f; var d; var p = this
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return r = n.delays, i = n.speed, n.easeEnd, o = n.ease, s = n.offset, u = void 0 === s ? 50 : s, this._renderer.createDropTiles(e, u), c = this._renderer, l = c.dropTiles, h = c.config.bounds, f = a.b.timeline(), d = Object.values(l).reverse().map((function(t, e) {
                                            return p._getScreenPassTimeline({
                                                tile: t,
                                                i: e,
                                                bounds: h,
                                                speed: i,
                                                offset: u,
                                                delays: r,
                                                ease: o
                                            })
                                        })), f.add(d), this._screenPassTimeline = f, t.next = 9, f.then();
                                    case 9:
                                        this._renderer.reset(), this._reset();
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t, e) {
                    return u.apply(this, arguments)
                })
            }, {
                key: '_fallOut',
                value: (s = te(regeneratorRuntime.mark(function t(n) {
                    var r; var i; var o; var s; var u; var c; var l; var h; var f; var d; var p; var m = this
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return r = n.delays, i = n.speed, o = n.ease, s = n.offset, u = void 0 === s ? 50 : s, c = this._renderer, l = c.tiles, h = c.config.bounds, f = a.b.timeline({}), d = he, p = Object.values(l).reverse().map((function(t, n) {
                                            var s = h.height + u,
                                                c = s / i;
                                            return a.b.to(t, {
                                                y: "+=".concat(s),
                                                duration: c,
                                                ease: o,
                                                onUpdate: function() {
                                                    return m._onTweenUpdate(t, d)
                                                },
                                                delay: r.blockDelays[n],
                                                onStart: function() {
                                                    return m.emit(e.events.ANIMATION_SINGLE_START, {
                                                        tile: t
                                                    })
                                                }
                                            })
                                        })), f.add(p, "+=".concat(r.beforeStart)), this._fallOutTimeline = f, t.next = 9, f.then();
                                    case 9:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_fallIn',
                value: (o = te(regeneratorRuntime.mark(function t(e, n) {
                    var r; var i; var o; var s; var u; var c; var l; var h; var f; var d; var p; var m; var y = this
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return r = n.delays, i = n.speed, o = n.easeEnd, s = void 0 === o ? {
                                            offset: 0,
                                            speed: 0,
                                            easings: []
                                        } : o, u = n.ease, c = n.offset, l = void 0 === c ? 50 : c, this._renderer.createDropTiles(e, l), h = this._renderer, f = h.dropTiles, d = h.tileGuide, h.config.bounds, p = a.b.timeline({}), m = Object.values(f).reverse().map((function(t, e) {
                                            return y._getFallInTimeline({
                                                tile: t,
                                                i: e,
                                                delays: r,
                                                speed: i,
                                                dropTiles: f,
                                                tileGuide: d,
                                                ease: u,
                                                easeEnd: s
                                            })
                                        })), p.add(m), this._fallInTimeline = p, t.next = 9, p.then();
                                    case 9:
                                        this._renderer.reset(), this._reset();
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t, e) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_getFallInTimeline',
                value (t) {
                    var n = this;
                                var r = t.tile;
                                var i = t.i;
                                var o = t.delays;
                                var s = t.speed;
                                var u = t.dropTiles;
                                var c = t.tileGuide;
                                var l = t.ease;
                                var h = t.easeEnd;
                                var f = ((Object.values(u).length - i - 1) * c.height - r.y) / s;
                                var d = le;
                                var p = a.b.timeline({
                            onComplete: function () {
                                return n.emit(e.events.ANIMATION_SINGLE_END, {
                                    tile: r
                                })
                            },
                            onUpdate: function () {
                                return n._onTweenUpdate(r, d)
                            },
                            delay: o.beforeStart
                        }).to(r, {
                            y: (Object.values(u).length - i - 1) * c.height,
                            duration: f,
                            ease: l,
                            delay: o.blockDelays[i],
                            onComplete: function () {
                                return n.emit(e.events.ANIMATION_SINGLE_ENDING, {
                                    tile: r
                                })
                            }
                        })
                            return h.offset !== 0 && this._setEaseEndOffsets(p, r, h), p
                }
            }, {
                key: '_getScreenPassTimeline',
                value (t) {
                    var n = this;
                                var r = t.tile;
                                var i = t.i;
                                var o = t.delays;
                                var s = t.speed;
                                var u = t.offset;
                                var c = t.ease;
                                var l = 2 * (t.bounds.height + u);
                                var h = l / s;
                                var f = he
                            return a.b.to(r, {
                        y: '+='.concat(l),
                        duration: h,
                        ease: c,
                        onUpdate: function () {
                            n._onTweenUpdate(r, f)
                        },
                        delay: o.betweenBlockSets * this.index + o.blockDelays[i],
                        onStart: function () {
                            return n.emit(e.events.ANIMATION_SINGLE_START, {
                                tile: r
                            })
                        }
                    })
                }
            }, {
                key: '_setEaseEndOffsets',
                value (t, e, n) {
                    var r = n.offset;
                                var i = n.speed;
                                var o = n.easings
                            if (i === 0 || o.length !== 2) return console.error('Invalid ease end configuration offset: '.concat(r, ', speed: ').concat(i, ', easings: ').concat(o))
                            var a = Math.abs(r) / i / o.length
                            t.to(e, {
                        y: '+='.concat(r),
                        duration: a,
                        ease: o[0]
                    }).to(e, {
                        y: '-='.concat(r),
                        duration: a,
                        ease: o[1]
                    })
                }
            }, {
                key: '_onTweenUpdate',
                value (t, n) {
                    this.emit(e.events.ANIMATION_UPDATE, {
                        tile: t,
                        fallType: n
                    })
                }
            }, {
                key: '_reset',
                value () {
                    this._fallInTimeline = null, this._fallOutTimeline = null, this._screenPassTimeline = null, this._timeScaleTween && (this._timeScaleTween.kill(), this._timeScaleTween = null), this._isStarting = this._isSpinning = this._isStopping = !1, this._inInstantStop = !1
                }
            }], i = [{
                key: 'events',
                get () {
                    return ue
                }
            }, {
                key: 'labels',
                get () {
                    return ce
                }
            }], r && ee(n.prototype, r), i && ee(n, i), e
        }($t.a))
        const de = n('./src/core/features/reels/TilesGenerator.js')
        const pe = n('./node_modules/ramda/es/flatten.js')
        const me = n('./node_modules/ramda/es/mergeDeepLeft.js')

        function ye(t) {
            return (ye = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ve(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function _e(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? ve(new Object(n), !0).forEach((e) => {
                            ge(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : ve(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function ge(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function be(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ee(t, e, n) {
            return e = xe(e),
            (function (t, e) {
                if (e && (ye(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], xe(t).constructor)
                : e.apply(t, n)))
        }

        function xe(t) {
            return (xe = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Te(t, e) {
            return (Te = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Se = (function (t) {
            function e(t) {
                let n = t.reelsBuffer
                var r = t.tiles
                var i = t.reelMasterAnim
                var o = t.reelRenderer
                var a = void 0 === o ? jt : o
                var s = t.controller
                var u = void 0 === s ? Zt : s
                var c = t.reelAnimation
                var l = void 0 === c ? fe : c
                var h = t.reelBufferSource
                var f = void 0 === h ? St : h
                var d = t.tilesGeneratorSource
                var p = void 0 === d ? de.a : d
                var m = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), Ee(this, e, [{
                    data: n,
                    tiles: r,
                    reelMasterAnim: i,
                    reelRenderer: a,
                    controller: u,
                    reelAnimation: l,
                    reelBufferSource: f,
                    tilesGeneratorSource: p,
                    config: m
                }])
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Te(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get () {
                    return _e(_e(_e(_e({}, fe.events), jt.events), Zt.events), St.events)
                }
            }, {
                key: 'labels',
                get () {
                    return _e({}, fe.labels)
                }
            }], (r = [{
                key: 'generateFakeFall',
                value () {
                    return this._controller.generateFakeFall()
                }
            }, {
                key: 'replaceTile',
                value (t, e, n) {
                    var r = this
                                var i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                                var o = arguments.length > 4 ? arguments[4] : void 0
                                var a = new Object(pe.a)([].concat(n)).map((t) => {
                        return r._reels[t]
                    })
                        a.forEach((n) => {
                        return n.replaceTile(t, e, i, o)
                    })
                }
            }, {
                key: 'replaceTilesArea',
                value (t) {
                    var e = this
                                var n = t.index
                                var r = t.offset
                                var i = t.width
                                var o = t.height
                                var a = t.id
                                var s = t.force
                                var u = void 0 !== s && s
                                var c = t.type
                                var l = new Object(k.k)(i, (t) => {
                        return t + n
                    })
                        Object(k.k)(o, (t) => {
                        return t + r
                    }).forEach((t) => {
                        return e.replaceTile(t, a, l, u, c)
                    })
                }
            }, {
                key: '_bubbleAnimationEvents',
                value (t) {
                    var e = this
                                var n = new Object(me.a)(t.constructor.events, fe.events)
                    Object.keys(n).forEach((r) => {
                        t.on(n[r], function(i) {
                                    return e.emit(n[r], _e({
                                        animation: t,
                                        index: t.index
                                    }, i))
                                })
                    })
                }
            }, {
                key: '_bubbleRendererEvents',
                value (t) {
                    var e = this
                                var n = new Object(me.a)(t.constructor.events, jt.events)
                    Object.keys(n).forEach((r) => {
                        t.on(n[r], function(i) {
                                    return e.emit(n[r], _e({
                                        renderer: t,
                                        index: t.index
                                    }, i))
                                })
                    })
                }
            }, {
                key: '_bubbleControllerEvents',
                value () {
                    var t = this
                                var e = new Object(me.a)(this._controller.constructor.events, Zt.events)
                    Object.keys(e).forEach((n) => {
                        t._controller.on(e[n], function(r) {
                                    return t.emit(e[n], _e({}, r))
                                })
                    })
                }
            }, {
                key: '_bubbleBufferEvents',
                value (t) {
                    var e = this
                                var n = new Object(me.a)(t.constructor.events, St.events)
                    Object.keys(n).forEach((r) => {
                        t.on(n[r], function(i) {
                                    return e.emit(n[r], _e({
                                        buffer: t,
                                        index: t.index
                                    }, i))
                                })
                    })
                }
            }]) && be(n.prototype, r), i && be(n, i), e
        }(nt.a))
        let we = n('./src/core/features/reels/tiles/TileBuilder.js')
        let Oe = n('./node_modules/ramda/es/times.js')
        let Pe = n('./node_modules/ramda/es/always.js')

        function Re(t) {
            return (Re = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Ae(t) {
            return (function (t) {
                if (Array.isArray(t)) return Ie(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return Ie(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ie(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function Ie(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function Ce(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function ke(t, e, n) {
            return e = Ne(e),
            (function (t, e) {
                if (e && (Re(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Ne(t).constructor)
                : e.apply(t, n)))
        }

        function Ne(t) {
            return (Ne = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Me(t, e) {
            return (Me = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function je(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function De(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? je(new Object(n), !0).forEach((e) => {
                            Le(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : je(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Le(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Fe = De({}, dt.a.events)
        const Be = (function (t) {
            function e(t) {
                let n; const r = t.bufferData
                var i = t.index
                var o = t.tilesGenerator
                var a = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = ke(this, e)).index = i, n.currentPosition = null, n.targetPosition = null, n.distance = null, n.size = null, n._screens = null, n._config = a, n._guides = a.guides, n._minTileSize = a.minTileSize, n._maxTileSize = a.maxTileSize, n._tilesGenerator = o, n._sizesMap = a.sizes.reduce((t, e) => {
                    return De(De({}, t), {}, Le({}, e, a.maxTileSize / e))
                }, {}), n.init(r), n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Me(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return Fe
                }
            }], (r = [{
                key: 'firstEntry',
                get() {
                    return this._data[0]
                }
            }, {
                key: 'targetEntry',
                get() {
                    return this._data[this.targetPosition]
                }
            }, {
                key: 'distanceToTarget',
                get() {
                    let t = this
                                var e = this._data.slice(this.targetPosition, this.currentPosition).reduce((e, n) => {
                        var r = n.heightIndex
                                    return e + t._sizesMap[r]
                    }, 0)
                    return Math.round(e)
                }
            }, {
                key: 'init',
                value(t) {
                    let e = this._parseData({
                        data: t,
                        isReal: !0
                    })
                                var n = e.parsed
                                var r = e.targetPosition
                    this.update(n, r, r)
                }
            }, {
                key: 'merge',
                value(t, e, n) {
                    let r = this._parseData({
                        data: t,
                        isReal: !0
                    })
                                var i = r.parsed
                                var o = r.targetPosition
                                var a = [].concat(Ae(i), Ae(this._generateRandom(n)))
                    this.expandLeft(a.length, a), this.setTargetPosition(o), e && this._resizeDistance(e, i.length, a.length)
                }
            }, {
                key: 'update',
                value(t, e, n) {
                    let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                                var i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
                    this._data = t, this._screens = this._parseScreens(this._data), this.size = t.length, this.currentPosition = e, this.targetPosition = n, i && this._clearCache(), this._updatePositions(r)
                }
            }, {
                key: 'expandLeft',
                value(t, e, n) {
                    let r = e || this._generateScreens(Math.ceil(t / this._maxTileSize))
                    this._addEntries(0, r, n)
                }
            }, {
                key: 'fetchEntry',
                value(t) {
                    return this._data[t + this.currentPosition]
                }
            }, {
                key: 'changeEntry',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                                var e = arguments.length > 1 ? arguments[1] : void 0
                                var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                                var r = arguments.length > 3 ? arguments[3] : void 0
                                var i = void 0 !== r ? r : this._data[this.targetPosition + t].heightIndex
                    this._data[this.targetPosition + t] = De(De({}, this._data[this.targetPosition + t]), {}, n
                        ? {
                                id: e,
                                heightIndex: i,
                                replaced: null
                            }
                        : {
                                heightIndex: i,
                                replaced: e
                            })
                }
            }, {
                key: 'fetchResultScreen',
                value() {
                    let t = this.targetEntry
                                var e = this._data.slice(this.targetPosition, this.targetPosition + t.heightIndex)
                                var n = new Object(Oe.a)(() => {
                        return {
                            id: new Object(Pe.a)(0)(),
                            heightIndex: t.heightIndex
                        }
                    }, this._maxTileSize - e.length)
                    return [].concat(Ae(e), Ae(n))
                }
            }, {
                key: 'resetEntry',
                value(t) {
                    this.changeEntry(t, null)
                }
            }, {
                key: 'setCurrentPosition',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                    this.currentPosition = t, this._updatePositions(e)
                }
            }, {
                key: 'setTargetPosition',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                    this.targetPosition = t, this._updatePositions(e)
                }
            }, {
                key: 'setTargetValue',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                    this._data[this.targetPosition + e].id = t
                }
            }, {
                key: 'cleanLeft',
                value() {
                    this._data.splice(0, this.currentPosition), this.update(this._data, 0, this.targetPosition - this.currentPosition)
                }
            }, {
                key: '_addEntries',
                value(t, e) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                    this._data.splice(t, 0, e), this._data = new Object(pe.a)(this._data), this.update(this._data, this.currentPosition + e.length, n ? this.targetPosition + e.length : this.targetPosition)
                }
            }, {
                key: '_removeEntries',
                value(t, e) {
                    this._data.splice(e, t), this.update(this._data, this.currentPosition - t, this.targetPosition)
                }
            }, {
                key: '_parseScreens',
                value(t) {
                    for (var e = [], n = 0, r = 0, i = 0, o = 0; o < t.length; o++) { t[o + 1]
? (n++, i = t[o].heightIndex, t[o + 1].heightIndex === i && n !== i || (e.push({
                        from: r,
                        to: o
                    }), r = o + 1, n = 0))
: e.push({
                        from: r,
                        to: o
                    })
}
                    return e
                }
            }, {
                key: '_resizeDistance',
                value(t, e, n) {
                    let r = this._getScreenForPosition(e)
                                var i = t - (this._getScreenForPosition(this.targetPosition) - r + 1)
                    i > 0 && this._doResize(i * this._maxTileSize, n)
                }
            }, {
                key: '_doResize',
                value(t, e) {
                    if (!Number.isInteger(t) || !Number.isInteger(e)) return console.error('Wrong configuration =>', 'howMany:', t, ', fromPos:', e)
                    if (!(t < 0)) {
                        let n = []
                                    var r = this._data.slice(e, this.currentPosition)
                        if (r.length > 0) {
                            let i = r[0].heightIndex
                            if (r.length > i) {
                                if (!t) {
                                    let o = this.currentPosition
                                    return this._removeEntries(o - e, e)
                                }
                                return this._doResize(t - this._maxTileSize, e + i)
                            }
                            r.length < i && (n = [].concat(Ae(n), Ae(this._generateEntries(i - r.length, i)))), t -= this._maxTileSize
                        }
                        t > 0 && (n = [].concat(Ae(n), Ae(this._generateRandom(t))).reverse()), this._addEntries(e, n)
                    }
                }
            }, {
                key: '_clearCache',
                value() {
                    let t = this.size - (this.currentPosition + this._config.total)
                    t > 30 && (this._data.splice(30 - t), this.update(this._data, this.currentPosition, this.targetPosition, !1, !1))
                }
            }, {
                key: '_generateRandom',
                value(t) {
                    let e = Math.floor(t / this._maxTileSize)
                                var n = t % this._maxTileSize
                                var r = this._generateScreens(e)
                                var i = this._generateEntries(n)
                    return [].concat(Ae(r), Ae(i))
                }
            }, {
                key: '_generateScreens',
                value(t) {
                    let e = this._tilesGenerator.generateRandomScreens({
                        count: t,
                        index: this.index,
                        minTileSize: this._minTileSize,
                        maxTileSize: this._maxTileSize
                    })
                    return this._parseData({
                        data: e
                    }).parsed
                }
            }, {
                key: '_generateEntries',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._maxTileSize
                                var n = this._tilesGenerator.generateRandomTiles({
                        count: t,
                        index: this.index
                    })
                    return n.map((t) => {
                        return {
                            id: t,
                            heightIndex: e,
                            replaced: null
                        }
                    })
                }
            }, {
                key: '_getScreenForPosition',
                value(t) {
                    return this._screens.findIndex((e) => {
                        return t >= e.from && t <= e.to
                    })
                }
            }, {
                key: '_updatePositions',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                    this.distance = this.currentPosition - this.targetPosition, t || this.emit(e.events.BUFFER_UPDATED, {
                        index: this.index
                    })
                }
            }, {
                key: '_parseData',
                value(t) {
                    let e = t.data
                                var n = t.isReal
                                var r = void 0 !== n && n
                                var i = 'function' == typeof this._config.customParser
? this._config.customParser
: function (t) {
                        return t
                    };
                    var o = this._calcTargetPosition({
                        data: e,
                        isReal: r
                    })
                                var a = []
                    return e.forEach((t) => {
                        var e = t.filter(Boolean);
                                    var n = e.length;
                                    var r = e.map(function(t) {
                                        return {
                                            id: t,
                                            heightIndex: n,
                                            replaced: null
                                        }
                                    });
                        a = a.concat(r)
                    }), {
                        targetPosition: o,
                        parsed: i(a)
                    }
                }
            }, {
                key: '_calcTargetPosition',
                value(t) {
                    let e = t.data
                                var n = t.isReal
                    return void 0 !== n && n ? e[0].filter(Boolean).length : this.targetPosition
                }
            }]) && Ce(n.prototype, r), i && Ce(n, i), e
        }(dt.a))

        function Ue(t) {
            return (Ue = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Ge(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Xe(t, e, n) {
            return e = He(e),
            (function (t, e) {
                if (e && (Ue(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], He(t).constructor)
                : e.apply(t, n)))
        }

        function He(t) {
            return (He = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Ve(t, e) {
            return (Ve = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const We = (function (t) {
            function e(t) {
                let n
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Xe(this, e, [t]))._heightIndex = null, n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Ve(t, e)
            }(e, t)), n = e, (r = [{
                key: 'heightIndex',
                get () {
                    return this._heightIndex
                }
            }, {
                key: 'fetchTileTexture',
                value (t, e, n, r) {
                    return this._heightIndex = r, we.a.tiles[t][r][e]
                }
            }]) && Ge(n.prototype, r), i && Ge(n, i), e
        }(wt.a))
        let Ye = n('./node_modules/ramda/es/internal/_isString.js')
        let ze = new Object(ot.a)((t, e) => {
            const n = t < 0 ? e.length + t : t
            return new Object(Ye.a)(e) ? e.charAt(n) : e[n]
        })
        let qe = ze(0)
        let Ke = ze(-1)

        function Ze(t) {
            return (Ze = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function $e(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Je(t, e, n) {
            return e = Qe(e),
            (function (t, e) {
                if (e && (Ze(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Qe(t).constructor)
                : e.apply(t, n)))
        }

        function Qe(t) {
            return (Qe = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function tn(t, e) {
            return (tn = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function en(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function nn(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? en(new Object(n), !0).forEach((e) => {
                            rn(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : en(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function rn(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const on = nn(nn({}, it.a.events), {}, {
            RENDERER_TILE_ENTERING: 'renderer_tile_entering',
            RENDERER_TILE_LEAVING: 'renderer_tile_leaving'
        })
        const an = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = Je(this, e))._tiles = {}, t._tileGuides = {}, t._tileIndex = 0, t._offset = 0, t._marker = null, t._hasBlur = null, t._tileEntering = !1, t._tilesGenerator = null, t
            }
            let n, r, i
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && tn(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get () {
                    return on
                }
            }], (r = [{
                key: 'guides',
                get () {
                    return this._tileGuides
                }
            }, {
                key: 'offset',
                get () {
                    return Number.parseFloat(this._offset.toFixed(7))
                }
            }, {
                key: 'offsetInTiles',
                get () {
                    return this.offset / this.minTileHeight
                }
            }, {
                key: 'minTileSize',
                get () {
                    return qe(this._config.tiles.sizes)
                }
            }, {
                key: 'maxTileSize',
                get () {
                    return Ke(this._config.tiles.sizes)
                }
            }, {
                key: 'minTileHeight',
                get () {
                    return this.guides[this.maxTileSize]
                }
            }, {
                key: 'currentSize',
                get () {
                    return this._buffer.targetEntry.heightIndex
                }
            }, {
                key: 'onCreated',
                value (t) {
                    var e = t.data;
                                var n = t.tileTypes;
                                var r = t.marker;
                                var i = t.tileGuide;
                                var o = t.index;
                                var a = t.config;
                                var s = t.bufferSource;
                                var u = void 0 === s ? Be : s;
                                var c = t.tilesGenerator;
                                var l = r.children[0];
                                var h = l.getBounds()
                            a.useOwnMask ? this.mask = l : l.alpha = 0, this._marker = r, this._index = o, this._tilesGenerator = c, this.position.set(r.x, r.y)
                            var f = this._createTilesConfig({
                        tileTypes: n,
                        config: a,
                        bounds: h
                    })
                            this._config = new Object(k.c)(a, {
                        tiles: f,
                        index: o
                    }, {
                        bounds: h
                    }), this._hasBlur = this._config.tiles.blur.enabled, this._tiles = this._createTiles(this._config.tiles), this._tileGuides = this._createGuides(a.tiles.sizes, i), this._buffer = this._createBuffer(u, {
                        bufferData: e,
                        index: o
                    }), this._setSpinnableTiles(o), this._onBufferUpdate(), this.updateTiles(), this._draw(), this._buffer.on(u.events.BUFFER_UPDATED, this._onBufferUpdate, this)
                }
            }, {
                key: 'getTileCellPosition',
                value (t) {
                    return {
                        x: this._marker.x + this._tiles[t].x,
                        y: this._marker.y + t * this.guides[this.currentSize]
                    }
                }
            }, {
                key: 'getTileCoordinates',
                value (t) {
                    var e = this.toGlobal(this.tiles[t].position)
                            return this.parent.parent.toLocal(nn({}, e))
                }
            }, {
                key: 'moveTo',
                value (t) {
                    var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                                var r = this._calculateMoveData(this._offset + t, this._tileIndex, this._buffer.data);
                                var i = r.offset;
                                var o = r.index
                            this._update(i, o, n), this._draw(), this.emit(e.events.RENDERER_MOVE, {
                        index: this._index,
                        delta: t
                    }), this._tileEntering && this._emitTileEvents(), this._tileEntering = !1
                }
            }, {
                key: 'updateTiles',
                value () {
                    var t = this
                            Object.keys(this._tiles).forEach(function(e) {
                                return t.updateTile(parseInt(e))
                            })
                }
            }, {
                key: 'updateTile',
                value (t) {
                    if (!this._tiles[t]) return console.warn('Sorry, but there is no tile with index ' + t + ' in my world!');
                    var e = this._tiles[t];
                                var n = this.getTileData(t);
                                var r = n.id;
                                var i = n.replaced;
                                var o = n.heightIndex
                            e.to({
                        id: r,
                        replaced: i
                    }, this.blur ? 'blurred' : 'normal', '', o)
                }
            }, {
                key: 'getTileData',
                value (t) {
                    return this._buffer.data[new Object(k.f)(this._tileIndex + t, this._buffer.size)]
                }
            }, {
                key: 'enableBlur',
                value () {
                    this._hasBlur && (this.blur = !0), this.updateTiles()
                }
            }, {
                key: 'disableBlur',
                value () {
                    this._hasBlur && (this.blur = !1), this.updateTiles()
                }
            }, {
                key: 'replaceTile',
                value (t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.currentSize
                            this._buffer.changeEntry(t, e, n, r), this.updateTiles(), this._draw()
                }
            }, {
                key: 'reset',
                value () {
                    this._update(0, this._buffer.targetPosition, !0), this._draw()
                }
            }, {
                key: '_createGuides',
                value (t, e) {
                    return t.reduce(function(t, n) {
                                return nn(nn({}, t), {}, rn({}, n, e[n].height))
                            }, {})
                }
            }, {
                key: '_onBufferUpdate',
                value () {
                    this._tileIndex = this._buffer.currentPosition, this.emit(e.events.RENDERER_UPDATED, {
                        offset: this._config.spin.speed
                    })
                }
            }, {
                key: '_update',
                value (t, e, n) {
                    this._offset = t, e !== this._tileIndex && (this._tileIndex = e, this._buffer.setCurrentPosition(e, !0), this.updateTiles(), n || (this._tileEntering = !0))
                }
            }, {
                key: '_draw',
                value () {
                    var t = this
                            Object.keys(this._tiles).forEach(function(e) {
                                var n = parseInt(e),
                                    r = t._tiles[n];
                                r.y = 0 === n ? 0 : n < 0 ? -t._tileGuides[r.heightIndex] : t._tiles[n - 1].y + t._tileGuides[t._tiles[n - 1].heightIndex]
                            }), this.y = this._offset + this._marker.y, this.emit(e.events.RENDERER_DRAW, {
                        index: this._index
                    })
                }
            }, {
                key: '_createTilesConfig',
                value (t) {
                    var e = t.tileTypes;
                                var n = t.config
                            return {
                        bounds: t.bounds,
                        ids: e.map(function(t) {
                                    return t.id
                                }).concat(0),
                        sizes: n.tiles.sizes || [n.tiles.visible],
                        spinnable: e.filter(function(t) {
                                    return "normal" === t.type
                                }).map(function(t) {
                                    return t.id
                                })
                    }
                }
            }, {
                key: '_createTiles',
                value (t) {
                    var e = this;
                                var n = t.offsetTop;
                                var r = t.offsetBottom;
                                var i = t.visible
                            return st(-n, i + r).reduce(function(t, n) {
                                return nn(nn({}, t), {}, rn({}, n, e._createTile(n)))
                            }, {})
                }
            }, {
                key: '_createTile',
                value (t) {
                    var e = new We
                            return e.index = t, this.addChild(e), e
                }
            }, {
                key: '_setSpinnableTiles',
                value (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._config.tiles
                            this._tilesGenerator.setSpinnableTiles({
                        index: t,
                        tiles: e.spinnable,
                        cache: !0
                    }), new Object(ut.a)(e.stacked) || this._tilesGenerator.enableStack({
                        index: t,
                        stacked: e.stacked
                    })
                }
            }, {
                key: '_createBuffer',
                value (t, e) {
                    return new t({
                        bufferData: e.bufferData,
                        index: e.index,
                        tilesGenerator: this._tilesGenerator,
                        config: this._createBufferConfig()
                    })
                }
            }, {
                key: '_createBufferConfig',
                value () {
                    return nn(nn({}, this._config.tiles), {}, {
                        guides: this.guides,
                        minTileSize: this.minTileSize,
                        maxTileSize: this.maxTileSize
                    })
                }
            }, {
                key: '_calculateMoveData',
                value (t, e, n) {
                    var r = e - 1 >= 0 ? e - 1 : n.length - 1;
                                var i = this._tileGuides[n[r].heightIndex]
                            return t <= i
? {
                        index: e,
                        offset: t
                    }
: this._calculateMoveData(t - i, r, n)
                }
            }, {
                key: '_emitTileEvents',
                value () {
                    this.emit(e.events.RENDERER_TILE_ENTERING, {
                        tile: this.getTileData(0),
                        tileIndex: this._tileIndex
                    }), this.emit(e.events.RENDERER_TILE_LEAVING, {
                        tile: this.getTileData(this._config.tiles.visible)
                    })
                }
            }]) && $e(n.prototype, r), i && $e(n, i), e
        }(it.a))
        const sn = n('./src/core/features/reels/controllers/SpinningController.js')
        const un = n('./src/core/utils/Timer.js')

        function cn(t) {
            return (cn = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ln(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function hn(t, e, n) {
            return e = fn(e),
            (function (t, e) {
                if (e && (cn(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], fn(t).constructor)
                : e.apply(t, n)))
        }

        function fn(t) {
            return (fn = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function dn(t, e) {
            return (dn = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function pn(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function mn(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const yn = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? pn(new Object(n), !0).forEach((e) => {
                            mn(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : pn(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, $t.a.events))
        let vn = {
            NONE: 'none',
            EASE_START: 'easeStart',
            SPINNING: 'spinning',
            STOPPING: 'stopping',
            EASE_END: 'easeEnd'
        }
        let _n = (function (t) {
            function e(t) {
                let n; const r = t.renderer
                let i = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = hn(this, e, [{
                    renderer: r,
                    config: i
                }])).buffer = r.buffer, n.tween = null, n.isStarting = !1, n.isSpinning = !1, n.isStopping = !1, n._initialConfig = i, n._inInstantStop = !1, n._lastEvent = null, n._timeline = null, n._reelSpinningListener = null, n._reset(), n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && dn(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return yn
                }
            }, {
                key: 'labels',
                get() {
                    return vn
                }
            }], (r = [{
                key: 'easeStartDuration',
                get() {
                    return this._config.easeStartOffset / this._config.easeStartSpeed
                }
            }, {
                key: 'easeEndDuration',
                get() {
                    return Math.abs(this._config.easeEndOffset) / this._config.easeEndSpeed
                }
            }, {
                key: 'label',
                get() {
                    return this._timeline && this._timeline.currentLabel() || e.labels.NONE
                }
            }, {
                key: 'start',
                value() {
                    let t = this
                    this.isStarting = !0
                    let n = this._config
                    var r = n.delay
                    var i = n.speed
                    this._timeline = a.b.timeline({
                        delay: r / i
                    }), this._dispatch(e.events.ANIMATION_SPIN_STARTING), this._doEaseStart(), this._timeline.addLabel(e.labels.SPINNING).call(() => {
                        t._onTween(), t._dispatch(e.events.ANIMATION_SPINNING), t.isSpinning = !0
                    }), this._doLoop()
                }
            }, {
                key: 'stop',
                value(t) {
                    let n = this
                    if (!this.isStarting) return console.error('I\'m not started yet, reel:', this._index)
                    if (this.isStopping) return console.error('I\'m already stopping, reel:', this._index)
                    this.isStopping = !0
                    let r = this._calculateSyncTime()
                    this._lastEvent === e.events.ANIMATION_SPIN_STARTING
                        ? (this._timer = new un.a(), this._timer.start(), this._reelSpinningListener = function () {
                                n._reelSpinningListener = null, n._onStop(r - n._timer.stop(), t)
                            }, this.once(e.events.ANIMATION_SPINNING, this._reelSpinningListener, this))
                        : this._lastEvent === e.events.ANIMATION_SPINNING ? this._onStop(r, t) : console.error('Well this should never happen!', this._lastEvent), this._config.autoStopInstantly && this.stopInstant(t)
                }
            }, {
                key: 'stopInstant',
                value(t) {
                    if (!this.isStarting) return console.error('I\'m not started yet, reel:', this._index)
                    if (!this.isStopping) return console.error('I\'m not stopping yet, reel:', this._index)
                    this._reelSpinningListener && (this.off(e.events.ANIMATION_SPINNING, this._reelSpinningListener), this._reelSpinningListener = null, this._timer.stop())
                    let n = this._config.instantStop.speedUpReels
                    var r = n.enabled
                    switch (r && this.setTimeScale(n.speedFactor, n.switchDuration), this.label) {
                        case e.labels.EASE_START:
                            this._dispatch(e.events.ANIMATION_SPINNING), this._onStop(0, t), r || this._timeline.seek(e.labels.EASE_END)
                            break
                        case e.labels.SPINNING:
                            this._onStop(0, t), r || this._timeline.seek(e.labels.EASE_END)
                            break
                        case e.labels.STOPPING:
                            r || this._timeline.seek(e.labels.EASE_END)
                            break
                        case e.labels.EASE_END:
                    }
                    this._inInstantStop = !0
                }
            }, {
                key: 'setTimeScale',
                value(t, e) {
                    if (!this._inInstantStop) {
                        let n = this._initialConfig.instantStop.speedUpReels.overwrite
                        a.b.to(this._timeline, {
                            duration: e,
                            timeScale: t,
                            overwrite: n
                        })
                    }
                }
            }, {
                key: '_doEaseStart',
                value() {
                    let t = this
                    var n = this._config
                    var r = n.easeStartOffset
                    var i = n.easeStartEasings
                    var o = this.easeStartDuration / i.length
                    this._timeline.addLabel(e.labels.EASE_START), i.length === 2
                        ? this._timeline.to(this.tween, {
                                duration: o,
                                pos: `-=${ r}`,
                                ease: i[0],
                                onUpdate: function () {
                                    return t._onTween()
                                }
                            }).to(this.tween, {
                                duration: o,
                                pos: `+=${ r}`,
                                ease: i[1],
                                onUpdate: function () {
                                    return t._onTween()
                                }
                            })
                        : this._timeline.to(this.tween, {
                                duration: o,
                                pos: `+=${ r}`,
                                ease: i[0],
                                onUpdate () {
                                    return t._onTween()
                                }
                            })
                }
            }, {
                key: '_doLoop',
                value() {
                    let t = this
                    this._timeline.to(this.tween, {
                        duration: this._loopingDistance / this._config.speed,
                        pos: `+=${ this._loopingDistance}`,
                        ease: 'none',
                        onUpdate () {
                            return t._onTween()
                        },
                        onComplete () {
                            return t._doLoop()
                        }
                    }).to(this.tween, {
                        duration: this._loopingDistance / this._config.speed,
                        pos: `+=${ this._loopingDistance}`,
                        ease: 'none',
                        onUpdate () {
                            return t._onTween()
                        }
                    })
                }
            }, {
                key: '_onStop',
                value(t, e) {
                    (Number(t) !== t || t < 0) && (t = 0)
                    let n = this._config
                    var r = n.distance
                    var i = n.extraDistance
                    var o = n.speed
                    this.buffer.merge(e, r, i), this._doStop(t / o)
                }
            }, {
                key: '_doStop',
                value(t) {
                    let n = this
                    var r = this._config.speed
                    var i = this._renderer.offsetInTiles
                    var o = this.buffer.distanceToTarget + t
                    var a = (o - i) / r
                    var s = this.tween.pos + o - i
                    this._timeline.killTweensOf(this.tween), this._timeline.clear().addLabel(e.labels.STOPPING).call(() => {
                        return n._dispatch(e.events.ANIMATION_STOPPING)
                    }).to(this.tween, {
                        duration: a,
                        pos: s,
                        ease: 'none',
                        onUpdate () {
                            return n._onTween()
                        }
                    }).addLabel(e.labels.EASE_END).call(() => {
                        return n._onSpinEnding()
                    })
                }
            }, {
                key: '_doEaseEnd',
                value() {
                    let t = this
                    var e = this._config
                    var n = e.easeEndOffset
                    var r = e.easeEndEasings
                    var i = this.easeEndDuration / r.length
                    this._timeline.to(this.tween, {
                        duration: i,
                        pos: `+=${ n}`,
                        ease: r[0],
                        onUpdate () {
                            return t._onTween()
                        }
                    }).to(this.tween, {
                        duration: i,
                        pos: `-=${ n}`,
                        ease: r[1],
                        onUpdate () {
                            return t._onTween()
                        },
                        onComplete () {
                            return t._onSpinEnd()
                        }
                    })
                }
            }, {
                key: '_onTween',
                value() {
                    this._config.autoExpandBuffer && this._lastEvent === e.events.ANIMATION_SPINNING && this._checkIsOutsideBuffer() && this.buffer.expandLeft(this._renderer.maxTileSize), this._renderer.moveTo((this.tween.pos - this.tween.lastPos) * this._renderer.minTileHeight), this.tween.lastPos = this.tween.pos
                }
            }, {
                key: '_onSpinEnding',
                value() {
                    this._dispatch(e.events.ANIMATION_SPIN_ENDING)
                    let t = this._initialConfig.instantStop.speedUpReels
                    this._inInstantStop && t.enabled && t.keepEaseEndSpeed && this._timeline.timeScale(1), this._doEaseEnd()
                }
            }, {
                key: '_onSpinEnd',
                value() {
                    this._onTween(), this._reset(), this._renderer.reset(), this._dispatch(e.events.ANIMATION_SPIN_END)
                }
            }, {
                key: '_checkIsOutsideBuffer',
                value() {
                    return this.buffer.currentPosition < this.buffer.firstEntry.heightIndex
                }
            }, {
                key: '_calculateSyncTime',
                value() {
                    return this._config.delay / this._config.speed + this.easeStartDuration
                }
            }, {
                key: '_reset',
                value() {
                    let t = ['power1.out', 'power1.in']
                    var e = ['power1.out', 'power1.in']
                    var n = this._initialConfig
                    var r = n.easeStart
                    var i = n.easeEnd
                    var o = n.delay
                    var a = n.speed
                    var s = n.minDistance
                    var u = n.autoExpandTilesCount
                    var c = n.instantStop
                    r.easings && (r.easings.length === 0 || r.easings.length > 2 ? console.error('Invalid easing start configuration '.concat(r.easings)) : t = r.easings), i.easings && (i.easings.length !== 2 ? console.error('Invalid easing end configuration '.concat(i.easings)) : e = i.easings)
                    let l = this._renderer.maxTileSize
                    this._loopingDistance = s, this._config = {
                        delay: this._index * o.atStart,
                        speed: a,
                        distance: Math.floor(s / l),
                        extraDistance: this._index * o.atEnd,
                        easeStartOffset: r.offset,
                        easeEndOffset: i.offset,
                        easeStartSpeed: r.speed,
                        easeEndSpeed: i.speed,
                        easeStartEasings: t,
                        easeEndEasings: e,
                        autoExpandBuffer: !0,
                        autoStopInstantly: !1,
                        autoExpandTilesCount: Number.isInteger(u) && u > 0 ? u : 1,
                        instantStop: c,
                        speedFactor: c.speedUpReels.speedFactor
                    }, this._timeline && this._timeline.clear().kill(), this.isStarting = this.isSpinning = this.isStopping = !1, this.tween = {
                        pos: 0,
                        lastPos: 0
                    }, this._inInstantStop = !1, this._lastEvent = null
                }
            }, {
                key: '_dispatch',
                value(t) {
                    this._lastEvent = t, this.emit(t, {
                        reel: this._renderer
                    })
                }
            }]) && ln(n.prototype, r), i && ln(n, i), e
        }($t.a))

        function gn(t) {
            return (gn = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function bn(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function En(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function xn(t, e, n) {
            return e = Tn(e),
            (function (t, e) {
                if (e && (gn(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Tn(t).constructor)
                : e.apply(t, n)))
        }

        function Tn(t) {
            return (Tn = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Sn(t, e) {
            return (Sn = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function wn(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function On(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Pn = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? wn(new Object(n), !0).forEach((e) => {
                            On(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : wn(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, sn.a.events))
        let Rn = (function (t) {
            function e() {
                return bn(this, e), xn(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Sn(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return Pn
                }
            }], (r = [{
                key: '_addBlurListeners',
                value(t) {
                    let e = this
                    t.on(_n.events.ANIMATION_SPINNING, () => {
                        return e._renderers[t.index].enableBlur()
                    }), t.on(_n.events.ANIMATION_SPIN_ENDING, () => {
                        return e._renderers[t.index].disableBlur()
                    })
                }
            }, {
                key: '_addCustomPreconfigStopProps',
                value(t, e) {
                    Number.isInteger(t.extraDistance) && (e.extraDistance = t.extraDistance)
                }
            }]) && En(n.prototype, r), i && En(n, i), e
        }(sn.a))

        function An(t) {
            return (An = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function In(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Cn(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? In(new Object(n), !0).forEach((e) => {
                            kn(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : In(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function kn(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function Nn(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Mn(t, e, n) {
            return e = jn(e),
            (function (t, e) {
                if (e && (An(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], jn(t).constructor)
                : e.apply(t, n)))
        }

        function jn(t) {
            return (jn = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Dn(t, e) {
            return (Dn = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Ln = (function (t) {
            function e(t) {
                let n = t.reelsBuffer
                var r = t.tiles
                var i = t.reelMasterAnim
                var o = t.reelRenderer
                var a = void 0 === o ? an : o
                var s = t.controller
                var u = void 0 === s ? Rn : s
                var c = t.reelAnimation
                var l = void 0 === c ? _n : c
                var h = t.reelBufferSource
                var f = void 0 === h ? Be : h
                var d = t.tilesGeneratorSource
                var p = void 0 === d ? de.a : d
                var m = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), Mn(this, e, [{
                    data: n,
                    tiles: r,
                    reelMasterAnim: i,
                    reelRenderer: a,
                    controller: u,
                    reelAnimation: l,
                    reelBufferSource: f,
                    tilesGeneratorSource: p,
                    config: m
                }])
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Dn(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get () {
                    return Cn(Cn(Cn(Cn({}, _n.events), an.events), Rn.events), Be.events)
                }
            }, {
                key: 'labels',
                get () {
                    return Cn({}, _n.labels)
                }
            }], (r = [{
                key: 'tileGuide',
                get () {
                    return we.a.guides
                }
            }, {
                key: 'getCurrentPosition',
                value (t) {
                    return this._reels[t] ? this._reels[t].buffer.currentPosition : console.error('Invalid reel index '.concat(t, ' when getting buffer\'s current positions.'))
                }
            }, {
                key: 'getTargetPosition',
                value (t) {
                    return this._reels[t] ? this._reels[t].buffer.targetPosition : console.error('Invalid reel index '.concat(t, ' when getting buffer\'s target positions.'))
                }
            }, {
                key: 'replaceTile',
                value (t, e, n) {
                    var r = this
                                var i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                                var o = arguments.length > 4 ? arguments[4] : void 0
                                var a = new Object(pe.a)([].concat(n)).map((t) => {
                        return r._reels[t]
                    })
                        a.forEach((n) => {
                        return n.replaceTile(t, e, i, o)
                    })
                }
            }, {
                key: '_bubbleAnimationEvents',
                value (t) {
                    var e = this
                                var n = new Object(me.a)(t.constructor.events, _n.events)
                    Object.keys(n).forEach((r) => {
                        t.on(n[r], function(i) {
                                    return e.emit(n[r], Cn(Cn({}, i), {}, {
                                        animation: t,
                                        index: t.index
                                    }))
                                })
                    })
                }
            }, {
                key: '_bubbleRendererEvents',
                value (t) {
                    var e = this
                                var n = new Object(me.a)(t.constructor.events, an.events)
                    Object.keys(n).forEach((r) => {
                        var i = {}
                                t.on(n[r], function(o) {
                                    [n.RENDERER_TILE_ENTERING, n.RENDERER_TILE_LEAVING].includes(n[r]) && (i.label = e._controller.reels[t.index].label), e.emit(n[r], Cn(Cn({
                                        renderer: t,
                                        index: t.index
                                    }, o), i))
                                })
                    })
                }
            }, {
                key: '_bubbleControllerEvents',
                value () {
                    var t = this
                                var e = new Object(me.a)(this._controller.constructor.events, Rn.events)
                    Object.keys(e).forEach((n) => {
                        t._controller.on(e[n], function(r) {
                                    return t.emit(e[n], Cn({}, r))
                                })
                    })
                }
            }, {
                key: '_bubbleBufferEvents',
                value (t) {
                    var e = this
                                var n = new Object(me.a)(t.constructor.events, Be.events)
                    Object.keys(n).forEach((r) => {
                        t.on(n[r], function(i) {
                                    e.emit(n[r], Cn({
                                        buffer: t,
                                        index: t.index
                                    }, i))
                                })
                    })
                }
            }]) && Nn(n.prototype, r), i && Nn(n, i), e
        }(nt.a))
        let Fn = n('./node_modules/@games/gsap/InertiaPlugin.js')

        function Bn(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Un(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const Gn = {
            onStart() {},
            onUpdate() {},
            onComplete() {},
            traction: {
                x: 1,
                y: 1
            },
            maxOffset: {
                x: 1 / 0,
                y: 1 / 0
            }
        }
        const Xn = (function () {
            function t(e) {
                let n = this
                            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                Bn(this, t), this._cfg = new Object(k.c)(Gn, r), this._target = e, this._dragStart = !1, this._isOver = !1, this._dragX = 0, this._dragY = 0, this._tracker = null, this._enabled = !0, this._hasMoved = !1, a.b.registerPlugin(Fn.a)
                var i = function (t) {
                    n._isOver = !1, n._onComplete(t)
                }
                e.on('mousedown', this._onStart.bind(this)), e.on('touchstart', (t) => {
                    n._isOver = !0, n._onStart(t)
                }), e.on('mousemove', this._onUpdate.bind(this)), e.on('touchmove', this._onUpdate.bind(this)), e.on('mouseup', this._onComplete.bind(this)), e.on('touchend', this._onComplete.bind(this)), e.on('mouseover', () => {
                    n._isOver = !0
                }), e.on('mouseout', i), e.on('touchendoutside', i)
            }
            let e, n, r
            return e = t, (n = [{
                key: 'disable',
                value (t) {
                    t && (this._enabled = !1), this._target.interactive = !1
                }
            }, {
                key: 'enable',
                value (t) {
                    t && (this._enabled = !0), this._enabled && (this._target.interactive = !0)
                }
            }, {
                key: 'toggle',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : !this._target.interactive
                            t ? this.enable() : this.disable()
                }
            }, {
                key: 'enabled',
                get () {
                    return this._enabled
                }
            }, {
                key: '_onStart',
                value (t) {
                    if (!this._dragStart && this._enabled) {
                        this._dragStart = !0
                                var e = this._cfg.onStart;
                                    var n = t.data.global;
                                    var r = n.x;
                                    var i = n.y
                                this._identifier = t.data.identifier, this._dragX = r, this._dragY = i, this._start = {
                            x: r,
                            y: i
                        }, this._tracker = this._tracker || Fn.a.track(this, '_dragX,_dragY')[0], this._diraction = {
                            x: 0,
                            y: 0
                        }, e({
                            x: r,
                            y: i
                        })
                    }
                }
            }, {
                key: '_onUpdate',
                value (t) {
                    if (this._dragStart && this._isOver && this._identifier === t.data.identifier) {
                        if (t.data && t.data.button === 2) return this._onComplete(t)
                                this._hasMoved = !0
                                var e = this._cfg;
                                    var n = e.onUpdate;
                                    var r = e.traction;
                                    var i = e.maxOffset;
                                    var o = t.data.global;
                                    var a = o.x;
                                    var s = o.y;
                                    var u = window.devicePixelRatio || 1;
                                    var c = {
                                        x: this._dragX - this._start.x,
                                        y: this._dragY - this._start.y
                                    };
                                    var l = {
                                x: Math.abs(c.x) * u < i.x ? (a - this._dragX) / r.x * u : 0,
                                y: Math.abs(c.y) * u < i.y ? (s - this._dragY) / r.y * u : 0
                            };
                        this._diraction = {
                            x: Math.sign(l.x),
                            y: Math.sign(l.y)
                        }, this._dragX = a, this._dragY = s, n({
                            delta: l,
                            velocity: {
                                x: this._tracker ? this._tracker.get('_dragX') : 0,
                                y: this._tracker ? this._tracker.get('_dragY') : 0
                            },
                            direction: this._diraction
                        })
                    }
                }
            }, {
                key: '_onComplete',
                value (t) {
                    if (this._dragStart && this._identifier === t.data.identifier) {
                        this._dragStart = !1
                                var e = this._cfg.onComplete;
                                    var n = {
                                        x: t.data.global.x,
                                        y: t.data.global.y
                                    };
                                    var r = {
                                x: this._tracker && this._hasMoved ? this._tracker.get('_dragX') : 0,
                                y: this._tracker && this._hasMoved ? this._tracker.get('_dragY') : 0
                            };
                        this._hasMoved = !1, e({
                            position: n,
                            velocity: r,
                            direction: this._diraction
                        })
                    }
                }
            }]) && Un(e.prototype, n), r && Un(e, r), t
        }())
        const Hn = n('./src/core/utils/constants.js')

        function Vn(t) {
            return (Vn = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Wn(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Yn(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Wn(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Wn(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function zn(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function qn(t, e, n) {
            return e = Kn(e),
            (function (t, e) {
                if (e && (Vn(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Kn(t).constructor)
                : e.apply(t, n)))
        }

        function Kn(t) {
            return (Kn = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Zn(t, e) {
            return (Zn = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function $n(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Jn(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? $n(new Object(n), !0).forEach((e) => {
                            Qn(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : $n(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Qn(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const tr = {
            align: 'center',
            buttons: {
                collect: {
                    type: 'secondary',
                    size: 'large'
                },
                gamble: {
                    type: 'primary',
                    size: 'large'
                }
            }
        }
        const er = {
            COLLECT: 'CHOICE_COLLECT',
            GAMBLE: 'CHOICE_GAMBLE',
            ACCEPT: 'CHOICE_ACCEPT',
            DECLINE: 'CHOICE_DECLINE',
            EXCHANGE: 'CHOICE_EXCHANGE'
        }
        const nr = Qn(Qn(Qn(Qn(Qn({}, er.COLLECT, 'collect'), er.GAMBLE, 'gamble'), er.ACCEPT, 'accept'), er.DECLINE, 'decline'), er.EXCHANGE, 'exchange')
        const rr = Jn(Jn({}, Hn.a), {}, {
            CHOICE_COLLECT: 'choice_collect',
            CHOICE_GAMBLE: 'choice_gamble',
            CHOICE_ACCEPT: 'choice_accept',
            CHOICE_DECLINE: 'choice_decline',
            CHOICE_EXCHANGE: 'choice_exchange'
        })
        const ir = (function (t) {
            function e(t) {
                let n; let r = t.config
                            var i = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = qn(this, e)).mask = i, n._client = null, n._buttonsActions = [], n._config = new Object(k.c)(tr, r), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Zn(t, e)
            }(e, t)), n = e, r = [{
                key: 'activate',
                value (t, e) {
                    var n = t.choices
                            if (!n.available) throw new Error('No available choices provided!');
                    return this._client || (this._client = e), this._showChoiceButtons(n.available)
                }
            }, {
                key: 'pick',
                value () {
                    var t = this._buttonsActions.map(function(t) {
                                return C.a.when(t)
                            });
                    return Promise.race(t)
                }
            }, {
                key: 'deactivate',
                value: (a = Yn(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        this.emit(e.events.HIDE_START), I.a.emit(I.a.events.FEATURE_CONTROLS_HIDE);
                                    case 2:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'handleChoice',
                value: (o = Yn(regeneratorRuntime.mark(function t(n) {
                    var r, i
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return this.emit(e.events[n.name]), r = {
                                            roundId: Lt.a.get(Lt.a.TYPES.ROUND_ID),
                                            choice: e.choiceNames[n.name]
                                        }, t.next = 4, this._client.choice(r);
                                    case 4:
                                        return i = t.sent, t.abrupt("return", i.result);
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_showChoiceButtons',
                value (t) {
                    var n = this;
                                var r = t.map(function(t) {
                                    return n._getButtonData(t)
                                });
                    this._buttonsActions = r.map(function(t) {
                                return t.name
                            }), this.emit(e.events.SHOW_START), I.a.emit(I.a.events.FEATURE_CONTROLS_SHOW, {
                        options: Jn(Jn({}, this._config), {}, {
                            buttons: r
                        })
                    })
                }
            }, {
                key: '_getButtonData',
                value (t) {
                    var n = t.toUpperCase()
                            return Jn(Jn({}, this._config.buttons[t]), {}, {
                        name: e.types[n],
                        label: s.c.texts[e.types[n]] || n
                    })
                }
            }], i = [{
                key: 'events',
                get () {
                    return rr
                }
            }, {
                key: 'types',
                get () {
                    return er
                }
            }, {
                key: 'choiceNames',
                get () {
                    return nr
                }
            }], r && zn(n.prototype, r), i && zn(n, i), e
        }(o.Container))
        const or = n('./src/config.js')
        const ar = n('./node_modules/eventemitter3/index.js')
        const sr = n.n(ar)
        const ur = n('./src/core/server/SpinData.js')

        function cr(t) {
            return (cr = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function lr(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function hr(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function fr(t, e, n) {
            return e = dr(e),
            (function (t, e) {
                if (e && (cr(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], dr(t).constructor)
                : e.apply(t, n)))
        }

        function dr(t) {
            return (dr = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function pr(t, e) {
            return (pr = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const mr = {
            UPDATE_START: 'update_start',
            UPDATE_END: 'update_end'
        }
        const yr = (function (t) {
            function e() {
                let t
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (t = fr(this, e)).cfg = or.a.wins.winBar, t.value = 0, t._bangupPromise = Promise.resolve(), t
            }
            let n, r, i, o, s
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && pr(t, e)
            }(e, t)), n = e, r = [{
                key: 'activate',
                value (t, e, n) {
                    var r = this._getBangupDuration(t, e, n)
                            return this.set(this.value + Number.parseFloat(t), r)
                }
            }, {
                key: 'increment',
                value (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                            return this.set(this.value + t, e)
                }
            }, {
                key: 'finish',
                value () {
                    return this._bangupPromise
                }
            }, {
                key: 'set',
                value: (o = regeneratorRuntime.mark(function t(e) {
                    var n; var r; var i = this;
                                var o = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (n = o.length > 1 && void 0 !== o[1] ? o[1] : 0, r = o.length > 2 && void 0 !== o[2] && o[2], ur.a.roundHasCelebrations(e) || (n = 0, r = !0), this.emit(mr.UPDATE_START, {
                                                isInstant: !n,
                                                silent: r
                                            }), 0 !== n) {
                                            t.next = 9;
                                            break
                                        }
                                        return this.value = parseFloat(e), I.a.emit(I.a.events.WINBAR_CHANGE, {
                                            value: this.value
                                        }), this._bangupPromise = Promise.resolve(), t.abrupt("return", this.emit(mr.UPDATE_END, {
                                            isInstant: !n
                                        }));
                                    case 9:
                                        return this._bangupTween = a.b.to(this, {
                                            duration: n,
                                            value: parseFloat(e),
                                            onUpdate: function() {
                                                return I.a.emit(I.a.events.WINBAR_CHANGE, {
                                                    value: i.value
                                                })
                                            }
                                        }), this._bangupPromise = this._bangupTween.then(), t.next = 13, this._bangupPromise;
                                    case 13:
                                        this.emit(mr.UPDATE_END, {
                                            isInstant: !n
                                        });
                                    case 14:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                }), s = function () {
                    let t = this
                                var e = arguments
                    return new Promise((n, r) => {
                        var i = o.apply(t, e)

                                function a(t) {
                            lr(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            lr(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value () {
                    this._bangupTween && this._bangupTween.progress() !== 1 && this._bangupTween.progress(1)
                }
            }, {
                key: 'reset',
                value () {
                    this.value = 0, I.a.emit(I.a.events.WINBAR_CHANGE, {
                        value: this.value
                    })
                }
            }, {
                key: '_getBangupDuration',
                value (t, e, n) {
                    var r = Number.parseFloat(t);
                                var i = parseFloat(e);
                                var o = this.cfg;
                                var a = o.skipMplr;
                                var s = o.bangupSpeed
                            return r <= a * i || n ? 0 : r / (s * i)
                }
            }], i = [{
                key: 'events',
                get () {
                    return mr
                }
            }], r && hr(n.prototype, r), i && hr(n, i), e
        }(sr.a))
        const vr = n('./src/core/loader/AssetCache.js')

        function _r(t) {
            return (_r = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function gr(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function br(t, e, n) {
            return e = Er(e),
            (function (t, e) {
                if (e && (_r(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Er(t).constructor)
                : e.apply(t, n)))
        }

        function Er(t) {
            return (Er = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function xr(t, e) {
            return (xr = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Tr(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Sr(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const wr = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Tr(new Object(n), !0).forEach((e) => {
                            Sr(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Tr(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, Hn.a))
        let Or = (function (t) {
            function e(t, n, r, i) {
                let o; const a = i.config
                let s = i.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (o = br(this, e)).mask = s, o.lines = [], o.markers = n, o.linesData = t, o._config = a, o._tileWidth = r.width, o._tileHeight = r.height, o._lineOffsets = o._calcOffsets(), o._initLines(), o
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && xr(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return wr
                }
            }], (r = [{
                key: 'show',
                value(t) {
                    this.lines[t.index].visible = !0, this.emit(e.events.SHOW_START)
                }
            }, {
                key: 'showAll',
                value() {
                    let t = this
                    this.lines.forEach((e, n) => {
                        return t.show({
                            index: n
                        })
                    })
                }
            }, {
                key: 'hide',
                value(t) {
                    this.lines[t.index].visible = !1
                }
            }, {
                key: 'hideAll',
                value() {
                    let t = this
                    this.lines.forEach((e, n) => {
                        return t.hide({
                            index: n
                        })
                    })
                }
            }, {
                key: '_initLines',
                value() {
                    let t = this
                    this.linesData.forEach((e, n) => {
                        let r = t._createLine(e, n)
                        t.addChildAt(r, 0), t.lines.push(r)
                    })
                }
            }, {
                key: '_createLine',
                value(t) {}
            }, {
                key: '_calcOffsets',
                value() {
                    let t; let e; const n = this
                    var r = new Object(Oe.a)(new Object(Pe.a)(this._config.topOffset), or.a.reels.tiles.visible)
                    return this.linesData.map((i) => {
                        return t = i[0], e = r[t], r[t] += n._config.lineOffset, e
                    })
                }
            }, {
                key: '_createPoints',
                value(t) {
                    let e = this.markers
                    var n = this._config.endToEnd
                    var r = this._tileWidth
                    var i = this._tileHeight
                    var a = []
                    return n && a.push(new o.Point(e[0].x, e[0].y + t[0] * i)), t.forEach((t, n) => {
                        let s = e[n].x + r / 2
                                    var u = e[n].y + t * i
                        a.push(new o.Point(s, u))
                    }), n && a.push(new o.Point(e[e.length - 1].x + r, e[e.length - 1].y + t[t.length - 1] * i)), a
                }
            }]) && gr(n.prototype, r), i && gr(n, i), e
        }(o.Container))

        function Pr(t) {
            return (Pr = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Rr(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Ar(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ir(t, e, n) {
            return e = Cr(e),
            (function (t, e) {
                if (e && (Pr(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Cr(t).constructor)
                : e.apply(t, n)))
        }

        function Cr(t) {
            return (Cr = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function kr(t, e) {
            return (kr = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Nr = (function (t) {
            function e() {
                return Rr(this, e), Ir(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && kr(t, e)
            }(e, t)), n = e, (r = [{
                key: '_createLine',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                            var n = this._createPoints(t)
                            var r = new o.SimpleRope(vr.c.lineFill, n)
                    return r.y = this._lineOffsets[e], r.visible = !1, r
                }
            }]) && Ar(n.prototype, r), i && Ar(n, i), e
        }(Or))

        function Mr(t) {
            return (Mr = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function jr(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Dr(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Lr(t, e, n) {
            return e = Fr(e),
            (function (t, e) {
                if (e && (Mr(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Fr(t).constructor)
                : e.apply(t, n)))
        }

        function Fr(t) {
            return (Fr = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Br(t, e) {
            return (Br = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Ur = (function (t) {
            function e() {
                return jr(this, e), Lr(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Br(t, e)
            }(e, t)), n = e, (r = [{
                key: '_createLine',
                value(t) {
                    let e = this
                            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                            var r = new o.Graphics
                            var i = 0
                    if (r.points = this._createPoints(t), this._config.layers.forEach((t) => {
                        return e._drawLayer(r, t)
                    }), this._config.filter.enabled) {
                        let a = this._config.filter
                                var s = a.strength
                                var c = a.quality
                                var l = a.resolution
                                var h = a.padding
                                var f = new o.filters.BlurFilter(s, c, l)
                        f.blurX = 0, f.padding = h, i = h / 2, r.filters = [f]
                    }
                    let d = r.getBounds()
                            var p = d.width
                            var m = d.height
                            var y = d.x
                            var v = d.y
                            var _ = v < 0 ? i + Math.abs(v) : i
                            var g = this._lineOffsets[n] - i
                            var b = new Object(u.d)(r, {
                        width: p + y,
                        height: m + Math.abs(v) + i,
                        offsetY: _
                    })
                            var E = [r.points[0], r.points[r.points.length - 1]]
                    return E[0].y += i, E[1].y += i, b.y = v < 0 ? v + g : g, b.visible = !1, b.points = E, delete r.points, r.destroy(), b
                }
            }, {
                key: '_drawLayer',
                value(t, e) {
                    let n = e.image
                            var r = e.width
                            var i = e.alignment
                    t.lineTextureStyle({
                        width: r,
                        texture: vr.c[n],
                        alignment: i
                    })
                    var o = t.points
                    o.forEach((e, n) => {
                        var r = e.x;
                                var i = e.y
                            0 === n ? t.moveTo(o[0].x, o[0].y) : t.lineTo(r, i)
                    })
                }
            }]) && Dr(n.prototype, r), i && Dr(n, i), e
        }(Or))

        function Gr(t) {
            return (Gr = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Xr(t) {
            return (function (t) {
                if (Array.isArray(t)) return Hr(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return Hr(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Hr(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function Hr(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function Vr(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Wr(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Vr(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Vr(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Yr(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function zr(t, e, n) {
            return e = qr(e),
            (function (t, e) {
                if (e && (Gr(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], qr(t).constructor)
                : e.apply(t, n)))
        }

        function qr(t) {
            return (qr = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Kr(t, e) {
            return (Kr = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Zr(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function $r(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Zr(new Object(n), !0).forEach((e) => {
                            Jr(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Zr(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Jr(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Qr = nt.a.events.ANIMATION_SPIN_ENDING
        const ti = nt.a.events.RENDERER_MOVE
        const ei = $r($r({}, Hn.a), {}, {
            PLAY_ANIM_START: 'rc_play_anim_start',
            PLAY_ANIM_END: 'rc_play_anim_end',
            SINGLE_PLAY_ANIM_START: 'rc_single_play_anim_start',
            SINGLE_PLAY_ANIM_END: 'rc_single_play_anim_end',
            SINGLE_SHOW_START: 'rc_single_show_start',
            SINGLE_SHOW_END: 'rc_single_show_end',
            SINGLE_HIDE_START: 'rc_single_hide_start',
            SINGLE_HIDE_END: 'rc_single_hide_end'
        })
        const ni = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = void 0 === r ? 'ReelCovers' : r
                var a = t.reelMaster
                var s = t.source
                var c = void 0 === s ? {} : s
                var l = t.config
                var h = void 0 === l ? {} : l
                var f = t.mask
                var d = void 0 === f ? null : f
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = zr(this, e)).name = i, n.mask = d, n.isActive = !1, n._reelMaster = a, n._sourceData = c, n._config = h, n._rtConfig = h.renderTexture || {}, n._useRenderTexture = u.b.type === o.RENDERER_TYPE.WEBGL && n._rtConfig.enabled, n._rtCache = {}, n._observeActivations = [], n._addRendererListeners(), n
            }
            let n, i, a, s, c, l, h, f, d, p
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Kr(t, e)
            }(e, t)), n = e, i = [{
                key: 'inRtMode',
                get() {
                    return this._useRenderTexture
                }
            }, {
                key: 'observeReels',
                value() {
                    let t = this
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    this._observeActivations = []
                    var n = this._config.observeReels || {}
                                var r = new Object(k.c)(n, e)
                                var i = r.activationEvent
                                var o = void 0 === i ? Qr : i
                                var a = r.reels
                    this._reelMaster.onceReels(o, (n) => {
                        return t.handleObserveEvent($r($r({
                            activationEvent: o
                        }, n), e))
                    }, !0, a)
                }
            }, {
                key: 'whenAllActive',
                value: (p = Wr(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, Promise.all(this._observeActivations);
                                    case 2:
                                        this._observeActivations = [];
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return p.apply(this, arguments)
                })
            }, {
                key: 'activate',
                value: (d = Wr(regeneratorRuntime.mark(function t(n) {
                    let r; let i = this
                                var o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (r = o.length > 1 && void 0 !== o[1] ? o[1] : {}, n) {
                                            t.next = 3;
                                            break
                                        }
                                        throw new Error('"'.concat(this.name, '" ==> No activation data provided!'));
                                    case 3:
                                        return this.isActive = !0, this.visible = !0, this.emit(e.events.ACTIVATE_START), t.next = 8, Promise.all([].concat(n).map((function(t) {
                                            return i._addCover(t, r)
                                        })));
                                    case 8:
                                        this.emit(e.events.ACTIVATE_END);
                                    case 9:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return d.apply(this, arguments)
                })
            }, {
                key: 'deactivate',
                value: (f = Wr(regeneratorRuntime.mark(function t(n) {
                    let r; let i; let o; let a; let s; let u = this
                                var c = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = c.length > 1 && void 0 !== c[1] ? c[1] : {}, this.emit(e.events.DEACTIVATE_START), i = r.detachFromReels, o = void 0 !== i && i, a = r.removeAtEnd, s = void 0 === a || a, o && this.detach(n), t.next = 6, this._exec(n, (function(t) {
                                            return u._hideCover(t, $r({
                                                stopTickChildren: s
                                            }, r))
                                        }));
                                    case 6:
                                        s && this._exec(n, (function(t) {
                                            return u._destroyCover(t, r)
                                        })), this.emit(e.events.DEACTIVATE_END);
                                    case 8:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return f.apply(this, arguments)
                })
            }, {
                key: 'play',
                value: (h = Wr(regeneratorRuntime.mark(function t(n, r) {
                    let i; let o = this
                                var a = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return i = a.length > 2 && void 0 !== a[2] ? a[2] : {}, this.emit(e.events.PLAY_ANIM_START, {
                                            label: n
                                        }), t.next = 4, this._exec(r, (function(t) {
                                            return o._playAnimation(n, t, i)
                                        }));
                                    case 4:
                                        this.emit(e.events.PLAY_ANIM_END, {
                                            label: n
                                        });
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return h.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value(t) {
                    this._exec(t, (t) => {
                        return t.skip()
                    })
                }
            }, {
                key: 'attach',
                value(t) {
                    this._exec(t, (t) => {
                        return t.attached = !0
                    })
                }
            }, {
                key: 'detach',
                value(t) {
                    this._exec(t, (t) => {
                        return t.attached = !1
                    })
                }
            }, {
                key: 'stop',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    return this._exec(t, (t) => {
                        return t.stop(e)
                    })
                }
            }, {
                key: 'finish',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    return this._exec(t, (t) => {
                        return t.finish(e)
                    })
                }
            }, {
                key: 'remove',
                value(t) {
                    let e = this
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    this._exec(t, (t) => {
                        return e._destroyCover(t, n)
                    })
                }
            }, {
                key: 'getCovers',
                value(t) {
                    let e = this
                    return t
                        ? [].concat(t).map((t) => {
                                let n = t.reel;
                                    var r = t.index
                                return e._getCoverOnPos({
                                    reel: n,
                                    index: r
                                })
                            }).filter(Boolean)
                        : Xr(this.children)
                }
            }, {
                key: 'applyTexture',
                value(t) {
                    let e = t.from
                                var n = t.to
                                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                                var i = this._getCoverOnPos(e)
                    if (!i) throw new Error('"'.concat(this.name, '" ==> No cover on the given position!'))
                    var o = $r($r({}, e), {}, {
                        tileId: i.tileId
                    })
                                var a = this._createRenderTexture(o, i, r)
                    this._exec(n, (t) => {
                        return t.applyTexture(a)
                    })
                }
            }, {
                key: 'removeTexture',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var e = t.from
                    this._exec(e, (t) => {
                        return t.removeTexture()
                    })
                }
            }, {
                key: 'onCreated',
                value(t, e, n) {}
            }, {
                key: 'onDestroyed',
                value(t, e) {}
            }, {
                key: 'onShowStart',
                value(t, e, n, r) {}
            }, {
                key: 'onShowEnd',
                value(t, e, n, r) {}
            }, {
                key: 'onHideStart',
                value(t, e, n) {}
            }, {
                key: 'onHideEnd',
                value(t, e, n) {}
            }, {
                key: 'onPlayStart',
                value(t, e, n) {}
            }, {
                key: 'onPlayEnd',
                value(t, e, n) {}
            }, {
                key: 'handleObserveEvent',
                value(t) {
                    let e = this.onReelEvent(t) || Promise.resolve()
                    this._observeActivations.push(e)
                }
            }, {
                key: 'onReelEvent',
                value(t) {
                    return Promise.resolve()
                }
            }, {
                key: '_addCover',
                value: (l = Wr(regeneratorRuntime.mark(function t(n) {
                    let r; let i; let o; let a; let s; let u; let c = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = c.length > 1 && void 0 !== c[1] ? c[1] : {}, i = r.attachToReels, o = void 0 !== i && i, a = r.animLabel, s = void 0 === a ? "show" : a, u = this._create(n, r), this.addChild(u), o && this.attach(n), this.onShowStart(u, s, n, r), this.emit(e.events.SINGLE_SHOW_START, {
                                            cover: u,
                                            label: s
                                        }), t.next = 9, u.show($r({
                                            animLabel: s,
                                            force: this._useRenderTexture
                                        }, r));
                                    case 9:
                                        this.onShowEnd(u, s, n, r), this.emit(e.events.SINGLE_SHOW_END, {
                                            cover: u,
                                            label: s
                                        });
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return l.apply(this, arguments)
                })
            }, {
                key: '_create',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                                var n = this._getCoverOnPos(t)
                    return n || (n = this._createCover(t, new Object(k.c)(this._sourceData, e), e), this._setUpCover(n, t, e), this.onCreated(n, t, e)), this._useRenderTexture && n.applyTexture(this._createRenderTexture(t, null, e)), n
                }
            }, {
                key: '_setUpCover',
                value(t, e, n) {
                    let r; let i = e.reel
                                var o = e.index
                                var a = void 0 === o ? 0 : o
                    t.name = ''.concat(this.name, 'Cover').concat(a, 'x').concat(i), t.reel = i, t.index = a, t.attached = !1, (r = t.position).set.apply(r, Xr(this._calcCoverPosition(e)))
                }
            }, {
                key: '_createCover',
                value(t, e, n) {
                    let i = e.cover
                    return new (void 0 === i ? r.a : i)({
                        animation: e.animation,
                        config: e.config,
                        mask: e.mask,
                        data: t
                    })
                }
            }, {
                key: '_calcCoverPosition',
                value(t) {
                    let e = t.reel
                                var n = t.index
                                var r = void 0 === n ? 0 : n
                                var i = this._reelMaster.getTilePosition({
                        reel: e,
                        index: r
                    })
                    return [i.x, i.y]
                }
            }, {
                key: '_hideCover',
                value: (c = Wr(regeneratorRuntime.mark(function t(n) {
                    let r; let i; let o; let a = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (r = a.length > 1 && void 0 !== a[1] ? a[1] : {}, n) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return", Promise.resolve());
                                    case 3:
                                        return i = r.animLabel, o = void 0 === i ? "hide" : i, this.onHideStart(n, o, r), this.emit(e.events.SINGLE_HIDE_START, {
                                            cover: n,
                                            label: o
                                        }), t.next = 8, n.hide($r({
                                            animLabel: o,
                                            force: this._useRenderTexture
                                        }, r));
                                    case 8:
                                        this.onHideEnd(n, o, r), this.emit(e.events.SINGLE_HIDE_END, {
                                            cover: n,
                                            label: o
                                        });
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return c.apply(this, arguments)
                })
            }, {
                key: '_destroyCover',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    e.silent || this.onDestroyed(t, e), t.destroy(), this._reset()
                }
            }, {
                key: '_exec',
                value(t, e) {
                    let n = this.getCovers(t)
                    return n.length
                        ? Promise.all(n.map((t) => {
                                return e(t)
                            }))
                        : Promise.resolve()
                }
            }, {
                key: '_getCoverOnPos',
                value(t) {
                    let e = t.reel
                                var n = t.index
                                var r = void 0 === n ? 0 : n
                    return this.children.find((t) => {
                        return t.reel === e && t.index === r
                    })
                }
            }, {
                key: '_playAnimation',
                value: (s = Wr(regeneratorRuntime.mark(function t(n, r) {
                    let i; let o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return i = o.length > 2 && void 0 !== o[2] ? o[2] : {}, this.onPlayStart(r, n, i), this.emit(e.events.SINGLE_PLAY_ANIM_START, {
                                            cover: r,
                                            label: n
                                        }), t.next = 5, r.play(n, $r({
                                            force: this._useRenderTexture
                                        }, i));
                                    case 5:
                                        this.onPlayEnd(r, n, i), this.emit(e.events.SINGLE_PLAY_ANIM_END, {
                                            cover: r,
                                            label: n
                                        });
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_createRenderTexture',
                value(t, e, n) {
                    if (!this._fetchFromRtCache(t)) {
                        let r = e || this._createCover(t, new Object(k.c)(this._sourceData, n), n)
                                    var i = n.padding
                                    var o = void 0 === i ? this._rtConfig.padding : i
                        this._addToRtCache(t, r.generateRenderTexture({
                            padding: o
                        }))
                    }
                    return this._fetchFromRtCache(t)
                }
            }, {
                key: '_addToRtCache',
                value(t, e) {
                    let n = t.tileId
                    this._rtCache['tid'.concat(n)] = e
                }
            }, {
                key: '_fetchFromRtCache',
                value(t) {
                    let e = t.tileId
                    return this._rtCache['tid'.concat(e)]
                }
            }, {
                key: '_onReelsMove',
                value(t) {
                    let e = this
                                var n = t.index
                                var r = t.delta
                                var i = this.getCovers().filter((t) => {
                        return Boolean(t.attached)
                    })
                    i.length && i.filter((t) => {
                        return t.reel === n
                    }).forEach((t) => {
                        e._updateCoverPosition(t, r), e._isOutOfBounds(t) && e._destroyCover(t, {
                            silent: !0
                        })
                    })
                }
            }, {
                key: '_updateCoverPosition',
                value(t, e) {
                    t.y -= e
                }
            }, {
                key: '_isOutOfBounds',
                value(t) {
                    let e = this._reelMaster.reels[t.reel].y + this._reelMaster.getReelBounds(t.reel).height + this._calcOutOfBoundsOffset(t.reel)
                    return t.y > e
                }
            }, {
                key: '_calcOutOfBoundsOffset',
                value(t) {
                    let e; let n = this._config.offsetFactor || 1
                    return (this._reelMaster.tileGuide.height || ((e = this._reelMaster.tileGuide[this._reelMaster.reels[t].minTileSize]) === null || void 0 === e ? void 0 : e.height) || 0) * n
                }
            }, {
                key: '_addRendererListeners',
                value() {
                    let t = this
                    this._config.attachable && this._reelMaster.on(this._config.reelsMoveEvent || ti, (e) => {
                        return t._onReelsMove(e)
                    })
                }
            }, {
                key: '_reset',
                value() {
                    this.children.length || (this.isActive = !1, this.visible = !1, this._rtCache = {})
                }
            }], a = [{
                key: 'events',
                get() {
                    return ei
                }
            }], i && Yr(n.prototype, i), a && Yr(n, a), e
        }(o.Container))

        function ri(t) {
            return (ri = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ii(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function oi(t, e, n) {
            return e = si(e),
            (function (t, e) {
                if (e && (ri(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], si(t).constructor)
                : e.apply(t, n)))
        }

        function ai(t, e, n) {
            return (ai = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = si(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function si(t) {
            return (si = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ui(t, e) {
            return (ui = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function ci(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function li(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const hi = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? ci(new Object(n), !0).forEach((e) => {
                            li(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : ci(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, ni.events))
        let fi = (function (t) {
            function e(t) {
                const n = t.reelMaster
                let r = t.source
                let i = t.config
                let o = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), oi(this, e, [{
                    name: 'WinTiles',
                    reelMaster: n,
                    source: r,
                    config: i,
                    mask: o
                }])
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ui(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return hi
                }
            }], (r = [{
                key: 'onCreated',
                value(t, n, r) {
                    ai(si(e.prototype), 'onCreated', this).call(this, t, n, r), t.setTile(n, r)
                }
            }]) && ii(n.prototype, r), i && ii(n, i), e
        }(ni))

        function di(t) {
            return (di = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function pi(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function mi(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function yi(t, e, n) {
            return e = _i(e),
            (function (t, e) {
                if (e && (di(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], _i(t).constructor)
                : e.apply(t, n)))
        }

        function vi(t, e, n) {
            return (vi = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = _i(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function _i(t) {
            return (_i = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function gi(t, e) {
            return (gi = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const bi = (function (t) {
            function e() {
                return pi(this, e), yi(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && gi(t, e)
            }(e, t)), n = e, (r = [{
                key: 'setTile',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                            var n = this._anim.tileContainer
                    n && (n.removeChildren(), n.addChild(this._createInnerTile(t, e)))
                }
            }, {
                key: '_createInnerTile',
                value(t, e) {
                    let n = new wt.a()
                    return n.to({
                        id: t.tileId
                    }, 'normal'), n
                }
            }, {
                key: '_createAnim',
                value(t) {
                    vi(_i(e.prototype), '_createAnim', this).call(this, t['winTile'.concat(this._data.tileId || '')] || t.winTile)
                }
            }]) && mi(n.prototype, r), i && mi(n, i), e
        }(r.a))

        function Ei(t) {
            return (Ei = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function xi(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Ti(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Si(t, e, n) {
            return e = Oi(e),
            (function (t, e) {
                if (e && (Ei(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Oi(t).constructor)
                : e.apply(t, n)))
        }

        function wi(t, e, n) {
            return (wi = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Oi(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Oi(t) {
            return (Oi = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Pi(t, e) {
            return (Pi = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Ri = (function (t) {
            function e() {
                return xi(this, e), Si(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Pi(t, e)
            }(e, t)), n = e, (r = [{
                key: 'setTile',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                            var n = this._anim.tileContainer
                    n && (n.removeChildren(), n.addChild(this._createInnerTile(t, e)))
                }
            }, {
                key: '_createInnerTile',
                value(t, e) {
                    let n = new We()
                    return n.to({
                        id: t.tileId
                    }, 'normal', e.variant, t.size), n
                }
            }, {
                key: '_createAnim',
                value(t) {
                    let n = t['winTile'.concat(this._data.tileId, 'x').concat(this._data.size)] ? 'winTile'.concat(this._data.tileId, 'x').concat(this._data.size) : 'winTilex'.concat(this._data.size)
                    wi(Oi(e.prototype), '_createAnim', this).call(this, t[n])
                }
            }]) && Ti(n.prototype, r), i && Ti(n, i), e
        }(r.a))

        function Ai(t) {
            return (Ai = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Ii(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Ci(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Ii(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Ii(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function ki(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ni(t, e, n) {
            return e = Mi(e),
            (function (t, e) {
                if (e && (Ai(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Mi(t).constructor)
                : e.apply(t, n)))
        }

        function Mi(t) {
            return (Mi = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ji(t, e) {
            return (ji = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Di = {
            SHOW_LINES_START: 'show_lines_start',
            SHOW_LINES_END: 'show_end',
            SHOW_LINE: 'show_line'
        }
        const Li = (function (t) {
            function e(t) {
                let n; const r = t.linesData
                var i = t.tiles
                var o = t.lines
                var a = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Ni(this, e)).tiles = i, n.lines = o, n._linesData = r, n._config = a, n._skippedTilePositions = [], n._specialTilePositions = [], n._lineShowPromises = [], n._loopActivated = !1, n
            }
            let n, r, i, o, s, u
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ji(t, e)
            }(e, t)), n = e, r = [{
                key: 'setSkippedPositions',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                    this.tiles.inRtMode ? console.warn('Skipping WinTiles positions not supported in RenderTexture mode!') : this._skippedTilePositions = t
                }
            }, {
                key: 'setSpecialPositions',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                    this.tiles.inRtMode ? console.warn('Setting special WinTiles positions not supported in RenderTexture mode!') : this._specialTilePositions = t
                }
            }, {
                key: 'showLines',
                value: (u = Ci(regeneratorRuntime.mark(function t(n) {
                    let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = i.length > 1 && void 0 !== i[1] ? i[1] : {}, this.emit(e.events.SHOW_LINES_START), t.next = 4, this._singleLoop(n, Object(k.c)({
                                            delay: this._config.lines.delays.betweenLines,
                                            skipTiles: !0,
                                            hidePrevious: !1
                                        }, r));
                                    case 4:
                                        this.emit(e.events.SHOW_LINES_END);
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'startLoop',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    this.lines.hideAll(), this._loopActivated = !0, this._loop(t, e)
                }
            }, {
                key: 'deactivate',
                value() {
                    this._loopActivated = !1, this._lineShowPromises.forEach((t) => {
                        return t.kill()
                    }), this._lineShowPromises = [], this.lines.hideAll(), this.tiles.remove()
                }
            }, {
                key: 'isWinningPosition',
                value(t, e) {
                    let n = this._linesData
                    return e.map((t) => {
                        var e = t.index;
                                    var r = t.start;
                                    var i = t.length
                                return n[e].slice(r, r + i)
                    }).some((e) => {
                        return e[t.reel] === t.index
                    })
                }
            }, {
                key: 'skip',
                value() {
                    this._loopActivated || (this._lineShowPromises.forEach((t) => {
                        1 !== t.progress() && t.progress(1)
                    }), this._lineShowPromises = [])
                }
            }, {
                key: '_loop',
                value: (s = Ci(regeneratorRuntime.mark(function t(e, n) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (this._loopActivated) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        return this._lineShowPromises = [], t.next = 5, this._singleLoop(e, Object(k.c)({
                                            delay: this._config.lines.delays.singleLoop,
                                            skipTiles: !1,
                                            hidePrevious: !0
                                        }, n));
                                    case 5:
                                        return t.next = 7, Object(k.d)(this._config.lines.delays.singleLoop);
                                    case 7:
                                        return t.next = 9, this._loop(e, n);
                                    case 9:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_singleLoop',
                value: (o = Ci(regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; let o; let s = this
                                var u = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = u.length > 1 && void 0 !== u[1] ? u[1] : {}, r = n.delay, i = n.hidePrevious, o = void 0 !== i && i, e.forEach((function(t, e, i) {
                                            s._lineShowPromises.push(a.b.delayedCall(e * r, (function() {
                                                o && s._hideLine(i[e - 1] ? i[e - 1] : i[i.length - 1], n), s._showLine(t, n)
                                            })))
                                        })), t.next = 5, Promise.all(this._lineShowPromises);
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_showLine',
                value(t, n) {
                    let r = n.delay
                                var i = n.skipTiles
                    if (this.emit(e.events.SHOW_LINE, {
                        delay: r,
                        skipTiles: i,
                        inLoop: this._loopActivated,
                        tileId: t.tile
                    }), this.lines.show(t), !i) {
                        let o = this._generateLinePositions(t)
                                    var a = o.positions
                                    var s = o.skipped
                        this.tiles.activate(a), n.onLineTilesShown && n.onLineTilesShown({
                            line: t,
                            positions: a,
                            skipped: s
                        })
                    }
                }
            }, {
                key: '_hideLine',
                value(t, e) {
                    let n = e.skipTiles
                    if (this.lines.hide(t), !n) {
                        let r = this._generateLinePositions(t)
                                    var i = r.positions
                                    var o = r.skipped
                        this.tiles.remove(i), e.onLineTilesHidden && e.onLineTilesHidden({
                            line: t,
                            positions: i,
                            skipped: o
                        })
                    }
                }
            }, {
                key: '_generateLinePositions',
                value(t) {
                    let e = this
                                var n = []
                                var r = []
                    return t.tiles.forEach((i, o) => {
                        i && (e._getOnPosition(t, o, e._skippedTilePositions) ? r.push(e._generatePositionData(t, o)) : n.push(e._generatePositionData(t, o)))
                    }), {
                        positions: n,
                        skipped: r
                    }
                }
            }, {
                key: '_generatePositionData',
                value(t, e) {
                    let n = t.index
                    return {
                        reel: e,
                        index: this._linesData[n][e],
                        tileId: this._getTileId(t, e)
                    }
                }
            }, {
                key: '_getOnPosition',
                value(t, e, n) {
                    let r = this._linesData[t.index]
                    return n.find((t) => {
                        var n = t.reel;
                                    var i = t.index
                                return n === e && i === r[e]
                    })
                }
            }, {
                key: '_getTileId',
                value(t, e) {
                    let n = this._getOnPosition(t, e, this._specialTilePositions)
                    return (n == null ? void 0 : n.tileId) || (n == null ? void 0 : n.tile) || t.tile
                }
            }], i = [{
                key: 'events',
                get() {
                    return Di
                }
            }], r && ki(n.prototype, r), i && ki(n, i), e
        }(sr.a))

        function Fi(t) {
            return (Fi = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Bi(t) {
            return (function (t) {
                if (Array.isArray(t)) return Ui(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return Ui(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ui(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function Ui(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function Gi(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Xi(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Gi(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Gi(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Hi(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Vi(t, e, n) {
            return e = Wi(e),
            (function (t, e) {
                if (e && (Fi(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Wi(t).constructor)
                : e.apply(t, n)))
        }

        function Wi(t) {
            return (Wi = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Yi(t, e) {
            return (Yi = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const zi = {
            SHOW_ALL_START: 'show_all_start',
            SHOW_ALL_END: 'show_all_end',
            SHOW_SINGLE: 'show_single',
            HIDE_ALL_START: 'hide_all_start',
            HIDE_ALL_END: 'hide_all_end',
            HIDE_SINGLE: 'hide_single',
            REMOVE_ALL_START: 'remove_all_start',
            REMOVE_ALL_END: 'remove_all_end',
            REMOVE_SINGLE: 'remove_single'
        }
        const qi = (function (t) {
            function e(t) {
                let n; const r = t.reelMaster
                var i = t.tiles
                var o = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Vi(this, e)).tiles = i, n._reelMaster = r, n._config = o, n._skippedTilePositions = [], n._specialTilePositions = [], n
            }
            let n, r, i, o, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Yi(t, e)
            }(e, t)), n = e, r = [{
                key: 'setSkippedPositions',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                    this._skippedTilePositions = t
                }
            }, {
                key: 'setSpecialPositions',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                    this.tiles.inRtMode ? console.warn('Setting special WinTiles positions not supported in RenderTexture mode!') : this._specialTilePositions = t
                }
            }, {
                key: 'show',
                value: (s = Xi(regeneratorRuntime.mark(function t(n) {
                    let r; let i = this
                                var o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = o.length > 1 && void 0 !== o[1] ? o[1] : {}, this.emit(e.events.SHOW_ALL_START), t.next = 4, Promise.all(n.map((function(t, e) {
                                            return i._showSingle(t, e, r)
                                        })));
                                    case 4:
                                        this.emit(e.events.SHOW_ALL_END);
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'hide',
                value: (a = Xi(regeneratorRuntime.mark(function t(n) {
                    let r; let i; let o = this
                                var a = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (r = a.length > 1 && void 0 !== a[1] ? a[1] : {}, this.emit(e.events.HIDE_ALL_START), n) {
                                            t.next = 9;
                                            break
                                        }
                                        return i = this._getActivePositions(), r.onTilesHide && r.onTilesHide({
                                            positions: i,
                                            skipped: this._skippedTilePositions
                                        }), t.next = 7, this.tiles.deactivate(null, r);
                                    case 7:
                                        t.next = 11;
                                        break;
                                    case 9:
                                        return t.next = 11, Promise.all([].concat(n).map((function(t, e) {
                                            return o._hideSingle(t, e, r)
                                        })));
                                    case 11:
                                        this.emit(e.events.HIDE_ALL_END);
                                    case 12:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'remove',
                value(t) {
                    let n = this
                                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    if (this.emit(e.events.REMOVE_ALL_START), t) { [].concat(t).forEach(function(t, e) {
                                return n._removeSingle(t, e, r)
                            });
                    }
                    else {
                        let i = this._getActivePositions()
                        r.onTilesRemove && r.onTilesRemove({
                            positions: i,
                            skipped: this._skippedTilePositions
                        }), this.tiles.remove(null, r)
                    }
                    this.emit(e.events.REMOVE_ALL_END)
                }
            }, {
                key: 'deactivate',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    this.remove(t, e)
                }
            }, {
                key: '_showSingle',
                value: (o = Xi(regeneratorRuntime.mark(function t(n, r) {
                    let i; let o; let a; let s; let u; let c; let l; let h = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (i = h.length > 2 && void 0 !== h[2] ? h[2] : {}, o = Object(me.a)(i, this._config), a = o.delays.betweenShows, s = this._generatePositions(n), u = s.positions, c = s.skipped, !((l = a * r) > 0)) {
                                            t.next = 7;
                                            break
                                        }
                                        return t.next = 7, Object(k.d)(l);
                                    case 7:
                                        return this.emit(e.events.SHOW_SINGLE, {
                                            winData: n,
                                            positions: u,
                                            skipped: c,
                                            index: r
                                        }), i.onTilesShow && i.onTilesShow({
                                            winData: n,
                                            positions: u,
                                            skipped: c,
                                            index: r
                                        }), t.abrupt("return", this.tiles.activate(u, i));
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_hideSingle',
                value(t, n) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                                var i = this._generatePositions(t)
                                var o = i.positions
                                var a = i.skipped
                    return this.emit(e.events.HIDE_SINGLE, {
                        winData: t,
                        positions: o,
                        skipped: a,
                        index: n
                    }), r.onTilesHide && r.onTilesHide({
                        winData: t,
                        positions: o,
                        skipped: a,
                        index: n
                    }), this.tiles.deactivate(o, r)
                }
            }, {
                key: '_removeSingle',
                value(t, n) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                                var i = this._generatePositions(t)
                                var o = i.positions
                                var a = i.skipped
                    this.emit(e.events.REMOVE_SINGLE, {
                        winData: t,
                        positions: o,
                        skipped: a,
                        index: n
                    }), r.onTilesRemove && r.onTilesRemove({
                        winData: t,
                        positions: o,
                        skipped: a,
                        index: n
                    }), this.tiles.remove(o, r)
                }
            }, {
                key: '_generatePositions',
                value(t) {
                    let e = this
                                var n = t.tiles
                                var r = t.tile
                                var i = []
                                var o = []
                    return n.forEach((t, n) => {
                        var a = e._getPositionsOnReel(n, t, r)
                                i.push.apply(i, Bi(a.skipped)), o.push.apply(o, Bi(a.positions))
                    }), {
                        positions: o,
                        skipped: i
                    }
                }
            }, {
                key: '_getPositionsOnReel',
                value(t, e, n) {
                    let r = this
                                var i = this._reelMaster.reels[t].currentSize
                                var o = []
                                var a = []
                    return e.forEach((e, s) => {
                        if (e) {
                            var u = r._getTileId({
                                    reel: t,
                                    index: s
                                }, n);
                                        var c = r._isPositionSkipped(t, s);
                                        var l = {
                                    reel: t,
                                    index: s,
                                    size: i,
                                    tileId: u
                                };
                            c ? a.push(l) : o.push(l)
                        }
                    }), {
                        positions: o,
                        skipped: a
                    }
                }
            }, {
                key: '_getTileId',
                value(t, e) {
                    let n = t.reel
                                var r = t.index
                                var i = this._specialTilePositions.find((t) => {
                        return t.reel === n && t.index === r
                    })
                    return (i == null ? void 0 : i.tileId) || (i == null ? void 0 : i.tile) || e
                }
            }, {
                key: '_isPositionSkipped',
                value(t, e) {
                    return Boolean(this._skippedTilePositions.find((n) => {
                        return n.index === e && n.reel === t
                    }))
                }
            }, {
                key: '_getActivePositions',
                value() {
                    return this.tiles.getCovers().map((t) => {
                        return t.data
                    })
                }
            }], i = [{
                key: 'events',
                get() {
                    return zi
                }
            }], r && Hi(n.prototype, r), i && Hi(n, i), e
        }(sr.a))

        function Ki(t) {
            return (Ki = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Zi(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function $i(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Zi(new Object(n), !0).forEach((e) => {
                            Ji(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Zi(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Ji(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function Qi(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function to(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function eo(t, e, n) {
            return e = ro(e),
            (function (t, e) {
                if (e && (Ki(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], ro(t).constructor)
                : e.apply(t, n)))
        }

        function no(t, e, n) {
            return (no = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = ro(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function ro(t) {
            return (ro = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function io(t, e) {
            return (io = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const oo = {
            TOP_LEFT: {
                x: 0,
                y: 0
            },
            LEFT: {
                x: 0,
                y: 0.5
            },
            BOTTOM_LEFT: {
                x: 0,
                y: 1
            },
            TOP_CENTER: {
                x: 0.5,
                y: 0
            },
            CENTER: {
                x: 0.5,
                y: 0.5
            },
            BOTTOM_CENTER: {
                x: 0.5,
                y: 1
            },
            TOP_RIGHT: {
                x: 1,
                y: 0
            },
            RIGHT: {
                x: 1,
                y: 0.5
            },
            BOTTOM_RIGHT: {
                x: 1,
                y: 1
            }
        }
        const ao = (function (t) {
            function e(t) {
                let n; let r = t.animation
                            var i = t.config
                            var o = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = eo(this, e, [{
                    animation: r,
                    config: i,
                    mask: o
                }]))._shadow = n._anim.main.shadow, n._adjustGuide = n._anim.main.adjust, n._innerContainer = n._anim.main.inner, n._waysLabels = n._innerContainer.waysLabels, n._waysCountContainer = n._innerContainer.waysCountContainer, n._sumContainer = n._innerContainer.sumContainer, n._sumCounter = null, n._waysCounter = null, n._initCounters(), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && io(t, e)
            }(e, t)), n = e, (r = [{
                key: 'show',
                value: (o = regeneratorRuntime.mark(function t(n, r) {
                    var i; var o; var a = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (i = a.length > 2 && void 0 !== a[2] ? a[2] : {}, !this._isShowing && !this._isShown) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        return o = n.reduce((function(t, e) {
                                            return t + e.ways
                                        }), 0), this._reset(), this._waysCounter.currentCount = o, this._sumCounter.currentCount = r, this._setLabel(o), this._adjustPosition(), t.abrupt("return", no(ro(e.prototype), "show", this).call(this, i));
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                }), a = function () {
                    let t = this
                                var e = arguments
                    return new Promise((n, r) => {
                        var i = o.apply(t, e)

                                function a(t) {
                            Qi(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            Qi(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function (t, e) {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_setLabel',
                value (t) {
                    t > 1 ? this._waysLabels.ways.visible = !0 : this._waysLabels.way.visible = !0
                }
            }, {
                key: '_initCounters',
                value () {
                    this._sumCounter = this._createCounter(this._sumContainer, $i($i({}, this._config.sum), {}, {
                        alignType: 'TOP_LEFT'
                    })), this._waysCounter = this._createCounter(this._waysCountContainer, $i($i({}, this._config.waysCount), {}, {
                        alignType: 'TOP_LEFT'
                    }))
                }
            }, {
                key: '_createCounter',
                value (t, e) {
                    var n = t.getLocalBounds().height;
                                var r = new y({
                            config: $i({
                                fontSize: n
                            }, e)
                        })
                            return t.removeChildren(), t.addChild(r), r
                }
            }, {
                key: '_adjustPosition',
                value () {
                    var t = this._config;
                                var e = t.labelSpacing;
                                var n = e.left;
                                var r = void 0 === n ? 0 : n;
                                var i = e.right;
                                var o = void 0 === i ? 0 : i;
                                var a = t.alignType;
                                var s = void 0 === a ? "CENTER" : a;
                                var u = t.fit;
                                var c = u.ignoreRatio;
                                var l = u.overscale;
                                var h = t.shadow;
                                var f = h.enabled;
                                var d = h.emptySpace;
                                var p = this._adjustGuide.getLocalBounds();
                                var m = p.width;
                                var y = p.height;
                                var v = oo[s];
                                var _ = this._adjustGuide.getLocalBounds()
                            this._waysCountContainer.x = 0, this._waysLabels.x = this._waysCountContainer.width + r, this._sumContainer.x = this._waysLabels.x + this._waysLabels.width + o, new Object(k.e)(this._innerContainer, _, c, l), this._innerContainer.x = this._adjustGuide.x + (m - this._innerContainer.width) * v.x, this._innerContainer.y = this._adjustGuide.y + (y - this._innerContainer.height) * v.y, this._shadow && f && (this._shadow.scale.x = this._innerContainer.width / (this._shadow.inner.width - 2 * d), this._shadow.x = this._adjustGuide.x + m / 2, this._shadow.y = this._adjustGuide.y + y / 2)
                }
            }, {
                key: '_reset',
                value () {
                    this._innerContainer.scale.set(1), this._waysLabels.ways.visible = !1, this._waysLabels.way.visible = !1
                }
            }]) && to(n.prototype, r), i && to(n, i), e
        }(r.a))
        const so = n('./node_modules/ramda/es/isNil.js')
        const uo = n('./src/core/loader/index.js')
        const co = n('./src/core/features/ParticlesContainer.js')

        function lo(t) {
            return (lo = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const ho = ['thresholds', 'animation', 'config', 'mask', 'counterConstructor']

        function fo(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return po(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return po(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function po(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function mo(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function yo(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? mo(new Object(n), !0).forEach((e) => {
                            vo(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : mo(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function vo(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function _o(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function go(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        _o(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        _o(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function bo(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function Eo(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function xo(t, e, n) {
            return e = To(e),
            (function (t, e) {
                if (e && (lo(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], To(t).constructor)
                : e.apply(t, n)))
        }

        function To(t) {
            return (To = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function So(t, e) {
            return (So = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const wo = {
            NORMAL_WIN: 'normalWin',
            BIG_WIN: 'bigWin',
            SUPER_WIN: 'superWin',
            MEGA_WIN: 'megaWin',
            EPIC_WIN: 'epicWin',
            TOTAL_WIN: 'totalWin'
        }
        const Oo = {
            SUM_PLAY_START: 'sum_play_start',
            SUM_PLAY_END: 'sum_play_end',
            HIDE_START: 'hide_start',
            HIDE_END: 'hide_end',
            BANGUP_START: 'bangup_start',
            BANGUP_END: 'bangup_end',
            LABEL_SHOW_START: 'label_show_start',
            LABEL_SHOW_END: 'label_show_end',
            LABEL_SUM_SHOW_START: 'label_sum_show_start',
            LABEL_SUM_SHOW_END: 'label_sum_show_end',
            LABEL_CHANGE: 'label_change'
        }
        const Po = (function (t) {
            function e(t) {
                let n; let r = t.thresholds
                            var i = void 0 === r ? {} : r
                            var o = t.animation
                            var a = t.config
                            var s = t.mask
                            var u = t.counterConstructor
                            var c = void 0 === u ? y : u
                            var l = bo(t, ho)
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = xo(this, e)).mask = s, n.thresholds = i, n.movieClip = o, n.type = null, n.amount = null, n.multiplier = null, n.anim = null, n.winLabels = null, n.sum = null, n.sumInner = null, n.sumTween = null, n.coins = null, n.isSkipped = !1, n.isLabelShown = !1, n.isSumShown = !1, n.isBangupActive = !1, n.roundHasCelebrations = !0, n._counterConstructor = c, n._fitBounds = null, n._config = a, n._init(l), n._createAnim(), n
            }
            let n, r, i, o, s, u, c, l, h
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && So(t, e)
            }(e, t)), n = e, r = [{
                key: 'showLabel',
                value: (h = go(regeneratorRuntime.mark(function t() {
                    var e; var n; var r = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = r.length > 0 && void 0 !== r[0] ? r[0] : wo.BIG_WIN, n = r.length > 1 && void 0 !== r[1] ? r[1] : "show", this.roundHasCelebrations) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 4:
                                        if (this._setUpAnimation(), this.winLabels[e]) {
                                            t.next = 7;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 7:
                                        return this.type = e, this.emit(Oo.LABEL_SHOW_START, {
                                            label: e
                                        }), this.winLabels["".concat(e, "Bg")].promises.gotoAndPlay(n), t.next = 12, this.winLabels[e].promises.gotoAndPlay(n);
                                    case 12:
                                        this.isLabelShown = !0, this.emit(Oo.LABEL_SHOW_END, {
                                            label: e
                                        });
                                    case 14:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return h.apply(this, arguments)
                })
            }, {
                key: 'showLabelSum',
                value: (l = go(regeneratorRuntime.mark(function t() {
                    var e; var n = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = n.length > 0 && void 0 !== n[0] ? n[0] : wo.BIG_WIN, this.roundHasCelebrations) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        if (this._setUpAnimation(), this.winLabels[e]) {
                                            t.next = 6;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 6:
                                        if (this.winLabels[e].labels.find((function(t) {
                                                return "showSum" === t.label
                                            }))) {
                                            t.next = 8;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 8:
                                        return this.type = e, this.emit(Oo.LABEL_SUM_SHOW_START, {
                                            label: e
                                        }), t.next = 12, this.winLabels[e].promises.gotoAndPlay("showSum");
                                    case 12:
                                        this.emit(Oo.LABEL_SUM_SHOW_END, {
                                            label: e
                                        });
                                    case 13:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'hideLabel',
                value: (c = go(regeneratorRuntime.mark(function t() {
                    var e; var n; var r = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = r.length > 0 && void 0 !== r[0] ? r[0] : this.type, n = r.length > 1 && void 0 !== r[1] ? r[1] : "hide", this.winLabels[e] && this.roundHasCelebrations) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 4:
                                        return this.winLabels["".concat(e, "Bg")].promises.gotoAndPlay(n), t.next = 7, this.winLabels[e].promises.gotoAndPlay(n);
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'playSum',
                value: (u = go(regeneratorRuntime.mark(function t() {
                    var e; var n; var r; var i; var o; var a; var s; var u; var c = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = c.length > 0 && void 0 !== c[0] ? c[0] : {}, n = e.value, r = e.anim, i = void 0 === r ? "show" : r, o = e.shouldLoop, a = void 0 !== o && o, s = e.loopAnim, u = void 0 === s ? "loop" : s, this.roundHasCelebrations) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        return this.type || (this.type = wo.NORMAL_WIN), this.isSumShown = !0, this._setUpAnimation(), this._createCounter(n), this.emit(Oo.SUM_PLAY_START, {
                                            anim: i
                                        }), t.next = 10, this.sum.promises.gotoAndPlay(i);
                                    case 10:
                                        this.emit(Oo.SUM_PLAY_END, {
                                            anim: i
                                        }), a && this.sum.promises.gotoAndPlay(u, {
                                            repeat: -1
                                        });
                                    case 12:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'bangup',
                value: (s = go(regeneratorRuntime.mark(function t() {
                    var e; var n; var r; var i; var o; var a; var s; var u; var c; var l; var h = this;
                                var f = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = f.length > 0 && void 0 !== f[0] ? f[0] : {}, n = e.from, r = void 0 === n ? this.counter.currentCount : n, i = e.to, o = e.duration, a = e.stake, s = void 0 === a ? this.stake : a, u = e.dynamicLabels, c = e.speed, l = void 0 === c ? this._config.bangupSpeed : c, this.roundHasCelebrations) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        return this.stake = s, o = Object(so.a)(o) ? this._calculateBangupDuration(r, i, l) : o, this.emit(Oo.BANGUP_START, {
                                            label: this.type
                                        }), t.next = 8, this.counter.update(i, {
                                            from: r,
                                            duration: o,
                                            onUpdate: function(t) {
                                                return h._onBangup(t, u)
                                            },
                                            easing: Object(k.m)(this._config.easings)
                                        });
                                    case 8:
                                        this.isBangupActive = !1, this.emit(Oo.BANGUP_END, {
                                            label: this.type
                                        });
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'pulseSum',
                value () {
                    if (this.sumInner) {
                        var t = this._config.pulseSum;
                                    var e = this.sumInner.scale
                                this.sumInner.initialScale = {
                            x: e.x,
                            y: e.y
                        }, this.sumTween = a.b.to(e, yo(yo({}, t.animation), {}, {
                            x: this.sumInner.initialScale.x * t.scaleBy,
                            y: this.sumInner.initialScale.y * t.scaleBy
                        }))
                    }
                }
            }, {
                key: 'stopPulse',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._config.pulseSum.returnAnimation;
                                var e = t.duration;
                                var n = t.ease
                            if (this.sumTween) {
                        var r = this.sumInner.initialScale || {
                            x: 1,
                            y: 1
                        };
                        this.sumTween.kill(), this.sumTween = null, a.b.to(this.sumInner.scale, {
                            duration: e,
                            ease: n,
                            x: r.x,
                            y: r.y
                        })
                    }
                }
            }, {
                key: 'startCoins',
                value () {
                    this.winLabels && this.roundHasCelebrations && (this.anim.winLabels.coinsContainer.removeChild(this.coins), this.coins = new co.a({
                        source: uo.a.ExtraWin.extraWinCoin,
                        guide: this.winLabels.coinsGuide,
                        config: this._config.coins
                    }), this.anim.winLabels.coinsContainer.addChild(this.coins), this.coins.activate())
                }
            }, {
                key: 'stopCoins',
                value () {
                    this.coins && this.coins.deactivate()
                }
            }, {
                key: 'hide',
                value: (o = go(regeneratorRuntime.mark(function t() {
                    var e; var n; var r; var i; var o; var a = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = a.length > 0 && void 0 !== a[0] ? a[0] : {}, n = e.sumAnim, r = void 0 === n ? "hide" : n, i = e.labelsAnim, o = void 0 === i ? "hide" : i, this.roundHasCelebrations) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        return this.emit(Oo.HIDE_START, {
                                            label: this.type
                                        }), t.next = 6, Promise.all([this.playSum({
                                            anim: r
                                        }), this.hideLabel(this.type, o)]);
                                    case 6:
                                        this.emit(Oo.HIDE_END, {
                                            label: this.type
                                        }), this.reset();
                                    case 8:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value () {
                    this.canSkip() && (this.counter.skip(), this.isSkipped = !0)
                }
            }, {
                key: 'canSkip',
                value () {
                    return this.isSumShown && this.isBangupActive && !this.isSkipped
                }
            }, {
                key: 'reset',
                value () {
                    this.removeChild(this.anim), this.sumInner.removeChildren(), this.counter = null, this.coins = null, this.type = null, this.amount = null, this.multiplier = null, this.isSkipped = !1, this.isLabelShown = !1, this.isSumShown = !1, this.isBangupActive = !1
                }
            }, {
                key: 'getTypeBasedOnMultiplier',
                value (t) {
                    return Object.entries(this.thresholds).reduce(function(e, n) {
                                var r = fo(n, 2),
                                    i = r[0],
                                    o = r[1];
                                return t >= o ? i : e
                            }, wo.NORMAL_WIN)
                }
            }, {
                key: 'getDelay',
                value (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.type;
                                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.multiplier
                            if (!this.roundHasCelebrations) return 0
                            var r = t[e];
                                var i = r.default;
                                var o = r.custom
                            return new Object(ut.a)(o)
? i
: Object.entries(o).reduce(function(t, e) {
                                var r = fo(e, 2),
                                    i = r[0],
                                    o = r[1];
                                return n > i ? o : t
                            }, null)
                }
            }, {
                key: '_init',
                value (t) {}
            }, {
                key: '_createAnim',
                value () {
                    if (!this.anim) {
                        this.anim = new this.movieClip(), this.addChild(this.anim), this.sum = this.anim.sumContainer, this.sumInner = this.sum.amount.sumInner, this.winLabels = this.anim.winLabels, this._initAnims()
                                var t = this.sumInner.getLocalBounds();
                                    var e = t.width;
                                    var n = t.height
                                this._fitBounds = yo({
                            width: e,
                            height: n
                        }, this._config.sum.fitBounds)
                    }
                }
            }, {
                key: '_createCounter',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                            if (!this.counter) {
                        var e = {
                            config: yo({
                                fontSize: this._fitBounds.height
                            }, this._config.sum)
                        };
                        this.counter = new this._counterConstructor(e), this.counter.name = 'extraWinSum', this.sumInner.removeChildren(), this.sumInner.addChild(this.counter), this.counter.currentCount = t
                    }
                }
            }, {
                key: '_setUpAnimation',
                value () {
                    this.anim.parent || (this.addChild(this.anim), this._initAnims())
                }
            }, {
                key: '_initAnims',
                value () {
                    this.sum.promises.gotoAndStop('init'), this.winLabels.children.forEach(function(t) {
                                var e, n;
                                return null === (e = (n = t.promises).gotoAndStop) || void 0 === e ? void 0 : e.call(n, "init")
                            })
                }
            }, {
                key: '_onBangup',
                value (t) {
                    var e = this;
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._config.dynamicLabels
                            this.isBangupActive = !0, this.amount = t, this.multiplier = t / this.stake
                            var r = this._config.sum;
                                var i = r.ignoreRatio;
                                var o = r.overscale
                            if (new Object(k.e)(this.counter, this._fitBounds, i, o), this.type !== wo.TOTAL_WIN && this.type !== wo.JACKPOT_WIN && n) {
                        var a = this.getTypeBasedOnMultiplier(this.multiplier);
                        [wo.NORMAL_WIN, this.type].includes(a) || (this.emit(Oo.LABEL_CHANGE, {
                            oldLabel: this.type,
                            newLabel: a,
                            isSkipped: this.isSkipped
                        }), this.hideLabel(), this.showLabel(a).then(function() {
                                    e.type === a && e.showLabelSum(a)
                                }))
                    }
                }
            }, {
                key: '_calculateBangupDuration',
                value (t, e, n) {
                    return (e - t) / (this.stake * n)
                }
            }], i = [{
                key: 'events',
                get () {
                    return Oo
                }
            }, {
                key: 'types',
                get () {
                    return wo
                }
            }], r && Eo(n.prototype, r), i && Eo(n, i), e
        }(o.Container))
        const Ro = n('./node_modules/ramda/es/clone.js')

        function Ao(t) {
            return (Ao = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Io(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Co(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Io(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Io(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function ko(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function No(t, e, n) {
            return e = jo(e),
            (function (t, e) {
                if (e && (Ao(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], jo(t).constructor)
                : e.apply(t, n)))
        }

        function Mo(t, e, n) {
            return (Mo = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = jo(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function jo(t) {
            return (jo = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Do(t, e) {
            return (Do = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Lo(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Fo(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Lo(new Object(n), !0).forEach((e) => {
                            Bo(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Lo(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Bo(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Uo = Fo(Fo({}, Po.animLabels), {}, {
            sum: {
                PULSE: 'pulse'
            }
        })
        const Go = (function (t) {
            function e(t) {
                let n
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = No(this, e, [t]))._preventSkip = !1, n._inSkipDelay = !1, n._skipCount = 0, n._skipCfg = {}, n
            }
            let n, r, i, o, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Do(t, e)
            }(e, t)), n = e, r = [{
                key: 'reset',
                value() {
                    this._skipCount = 0, this._skipCfg = {}, this._inSkipDelay = !1, this._preventSkip = !1, Mo(jo(e.prototype), 'reset', this).call(this)
                }
            }, {
                key: 'showLabel',
                value: (s = Co(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        for (this._preventSkip = !this._config.sum.skip.skipOnLabelChange, r = a.length, i = new Array(r), o = 0; o < r; o++) i[o] = a[o];
                                        return t.next = 4, (n = Mo(jo(e.prototype), "showLabel", this)).call.apply(n, [this].concat(i));
                                    case 4:
                                        this._preventSkip = !1;
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value() {
                    if (this.canSkip()) {
                        this._skipCfg = this._getCurrentSkipConfig()
                        var t = this._getStepAmount()
                        return this.counter.skip(t), this._setSkipDelay(), this._pulseAnim()
                    }
                }
            }, {
                key: 'canSkip',
                value() {
                    return this.isSumShown && this.isBangupActive && !this._inSkipDelay && !this._preventSkip
                }
            }, {
                key: '_setSkipDelay',
                value: (a = Co(regeneratorRuntime.mark(function t() {
                    let e
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (e = this._getCurrentOption("skipDelay"), this._inSkipDelay = !!e, !this._inSkipDelay) {
                                            t.next = 5;
                                            break
                                        }
                                        return t.next = 5, Object(k.d)(e);
                                    case 5:
                                        this._inSkipDelay = !1;
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_pulseAnim',
                value: (o = Co(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (this.sumInner) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        if (!this.sum.labelsMap[Uo.sum.PULSE]) {
                                            t.next = 8;
                                            break
                                        }
                                        return t.next = 6, this.sum.promises.gotoAndPlay(Uo.sum.PULSE);
                                    case 6:
                                        t.next = 12;
                                        break;
                                    case 8:
                                        return this.pulseSum(), t.next = 11, this.sumTween;
                                    case 11:
                                        this.stopPulse();
                                    case 12:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_getStepMultiplier',
                value() {
                    let t = this._getCurrentOption('stepDeviation') || 0
                                var e = this._getCurrentOption('stepMultiplier') + new Object(k.h)(-t, t)
                    return Math.abs(e)
                }
            }, {
                key: '_getStepAmount',
                value() {
                    let t = this._skipCfg
                                var e = t.skipToThreshold
                                var n = t.value
                    if (!e) {
                        let r = this._getStepMultiplier() * this.stake
                                    var i = this.counter.currentCount + r
                        return this._skipCount++, i
                    }
                    return n * this.stake
                }
            }, {
                key: '_getCurrentOption',
                value(t) {
                    if (this._skipCfg && this._skipCfg[t]) {
                        let e = this._skipCfg[t]
                        return Array.isArray(e) ? e[this._skipCount] || e[e.length - 1] : e
                    }
                }
            }, {
                key: '_getCurrentSkipConfig',
                value() {
                    let t = this
                                var e = new Object(Ro.a)(this._config.sum.skip.thresholds).sort(function(t, e) {
                                    return t.value - e.value
                                });
                    var n = e[e.length - 1]
                    return e.find((e) => {
                        return t.multiplier < e.value
                    }) || n
                }
            }], i = [{
                key: 'animLabels',
                get() {
                    return Uo
                }
            }], r && ko(n.prototype, r), i && ko(n, i), e
        }(Po))

        function Xo(t) {
            return (Xo = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Ho(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Vo(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Ho(new Object(n), !0).forEach((e) => {
                            Wo(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Ho(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Wo(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function Yo(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function zo(t, e, n) {
            return e = qo(e),
            (function (t, e) {
                if (e && (Xo(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], qo(t).constructor)
                : e.apply(t, n)))
        }

        function qo(t) {
            return (qo = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Ko(t, e) {
            return (Ko = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Zo = (function (t) {
            function e(t) {
                let n; const r = t.target
                var i = t.mask
                var o = t.config
                var a = void 0 === o ? {} : o
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = zo(this, e)).mask = i, n._reference = {
                    x: r.x,
                    y: r.y
                }, n._target = r, n._config = n._parseConfig(a), n._rumbler = {
                    x: null,
                    y: null
                }, n._accelerator = {
                    x: null,
                    y: null
                }, n._decelerator = {
                    x: null,
                    y: null
                }, n._stopDelay = {
                    x: null,
                    y: null
                }, n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Ko(t, e)
            }(e, t)), n = e, (r = [{
                key: 'isActive',
                get () {
                    var t, e, n, r, i, o
                    return ((t = this._rumbler) === null || void 0 === t || (e = t.x) === null || void 0 === e || (n = e.isActive) === null || void 0 === n ? void 0 : n.call(e)) || ((r = this._rumbler) === null || void 0 === r || (i = r.y) === null || void 0 === i || (o = i.isActive) === null || void 0 === o ? void 0 : o.call(i)) || !1
                }
            }, {
                key: 'start',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    this.stop()
                    var e = new Object(k.c)(this._config, this._parseConfig(t))
                    if (this._isConfigValid(e)) {
                        var n = e.duration
                                    var r = e.randomize
                                    var i = e.intensity
                                    var o = e.acceleration
                                    var a = e.deceleration
                                    var s = e.interval
                        i.x > 0 && n.x !== 0 && this._startRumble({
                            axis: 'x',
                            acceleration: o,
                            deceleration: a,
                            intensity: i,
                            duration: n,
                            interval: s,
                            randomize: r
                        }), i.y > 0 && n.y !== 0 && this._startRumble({
                            axis: 'y',
                            acceleration: o,
                            deceleration: a,
                            intensity: i,
                            duration: n,
                            interval: s,
                            randomize: r
                        })
                    }
                }
            }, {
                key: 'stop',
                value () {
                    var t = this
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ['x', 'y'];
                    [].concat(e).forEach((e) => {
                        var n, r, i, o
                                null === (n = t._rumbler[e]) || void 0 === n || n.kill(), (r = t._accelerator[e]) === null || void 0 === r || r.kill(), (i = t._decelerator[e]) === null || void 0 === i || i.kill(), (o = t._stopDelay[e]) === null || void 0 === o || o.kill(), t._rumbler[e] = null, t._accelerator[e] = null, t._decelerate[e] = null, t._stopDelay[e] = null, t._target[e] = t._reference[e]
                    })
                }
            }, {
                key: '_startRumble',
                value (t) {
                    var e; let n; let r; let i; let o = this
                                var s = t.axis
                                var u = t.acceleration
                                var c = t.deceleration
                                var l = t.intensity
                                var h = t.duration
                                var f = t.interval
                                var d = t.randomize
                                var p = (e = u[s]) !== null && void 0 !== e && e.duration
                        ? {
                                intensity: Wo({}, s, ((n = u[s]) === null || void 0 === n ? void 0 : n.fromIntensity) || 0)
                            }
                        : {
                                intensity: Wo({}, s, l[s])
                            };
                    ((r = u[s]) === null || void 0 === r ? void 0 : r.duration) > 0 && (this._accelerator[s] = this._accelerate(p, {
                        intensity: Wo({}, s, l[s]),
                        duration: h[s],
                        acceleration: u[s]
                    })), h[s] > 0 && ((i = c[s]) === null || void 0 === i ? void 0 : i.duration) > 0 && (this._decelerator[s] = this._decelerate(p, {
                        axis: s,
                        duration: h[s],
                        deceleration: c[s]
                    })), this._rumbler[s] = a.b.to({
                        val: 0
                    }, {
                        val: 1,
                        duration: f[s],
                        repeat: -1,
                        onRepeat: function () {
                            return o._rumble({
                                axis: s,
                                intensity: p.intensity,
                                randomize: d[s]
                            })
                        }
                    }), h[s] > 0 && (this._stopDelay[s] = a.b.delayedCall(h[s], () => {
                        return o.stop([s])
                    }))
                }
            }, {
                key: '_rumble',
                value (t) {
                    var e = t.axis
                                var n = t.intensity
                                var r = t.randomize
                    if (n[e] > 0) {
                        var i = r ? this._getRandomOffset(n[e]) : n[e]
                        i *= this._target[e] > this._reference[e] ? -1 : 1, this._target[e] = this._reference[e] + i
                    }
                }
            }, {
                key: '_accelerate',
                value (t, e) {
                    var n = e.intensity
                                var r = e.duration
                                var i = e.acceleration
                    if (void 0 !== i.fromIntensity) {
                        var o = i.fromIntensity
                        if (delete i.fromIntensity, o > 0) { return a.b.to(t.intensity, Vo(Vo({
                            delay: r - i.duration
                        }, n), i))
                        }
                    }
                    return a.b.to(t.intensity, Vo(Vo({}, n), i))
                }
            }, {
                key: '_decelerate',
                value (t, e) {
                    var n = e.axis
                                var r = e.duration
                                var i = e.deceleration
                    if (void 0 !== i.toIntensity) {
                        var o = i.toIntensity
                        if (delete i.toIntensity, o > 0) return a.b.to(t.intensity, Vo(Wo({}, ''.concat(n), o), i))
                    }
                    return a.b.to(t.intensity, Vo(Wo({
                        delay: r - i.duration
                    }, ''.concat(n), 0), i))
                }
            }, {
                key: '_getRandomOffset',
                value (t) {
                    var e
                    do {
                        e = new Object(k.h)(0, t)
                    } while (e === 0 && t !== 0)
                        return e
                }
            }, {
                key: '_isConfigValid',
                value (t) {
                    var e = t.acceleration
                                var n = t.deceleration
                                var r = t.duration
                                var i = this._isAccelerationValid({
                        axis: 'x',
                        acceleration: e,
                        deceleration: n,
                        duration: r
                    }) && this._isAccelerationValid({
                        axis: 'y',
                        acceleration: e,
                        deceleration: n,
                        duration: r
                    })
                    return r.x === 0 && r.y === 0 && (console.error('You are trying to do a Rumble with 0 duration for both x and y!', t), i = !1), i
                }
            }, {
                key: '_isAccelerationValid',
                value (t) {
                    var e = t.axis
                                var n = t.acceleration
                                var r = t.deceleration
                                var i = t.duration
                                var o = !0
                    return i[e] > 0 && n[e].duration + r[e].duration > i[e] && (o = !1, console.error('The sum of acceleration and deceleration durations of '.concat(e, ' config MUST NOT be greater than the rumble duration!'))), o
                }
            }, {
                key: '_parseConfig',
                value () {
                    var t = this
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    return Object.keys(e).reduce((n, r) => {
                        return n[r] = {}, 'acceleration' === r || 'deceleration' === r ? n[r] = t._parseAcceleration(e[r]) : 'number' == typeof e[r] ? (n[r].x = e[r], n[r].y = e[r]) : n[r] = e[r], n
                    }, {})
                }
            }, {
                key: '_parseAcceleration',
                value (t) {
                    return t.x && t.y
                        ? t
                        : {
                                x: t.x || t,
                                y: t.y || t
                            }
                }
            }]) && Yo(n.prototype, r), i && Yo(n, i), e
        }(o.Container))
        let $o = n('./node_modules/seamless-immutable/seamless-immutable.development.js')
        let Jo = n.n($o)

        function Qo(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const ta = (function () {
            function t(e) {
                const n = e.user.prevRounds
                var r = e.game
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.lastSpinData = this._parseInitialState(n), this.defaultState = Jo()({
                    reelsBuffer: r.reelsBuffer
                }), this._lastMainSpinData = this._parseInitialState(n, !0) || Jo()({}), this._enabled = r.stateful, this._currBonusId = 0
            }
            let e, n, r
            return e = t, (n = [{
                key: 'enabled',
                get() {
                    return this._enabled
                }
            }, {
                key: 'getData',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                            var n = e ? this._lastMainSpinData[t] : this.lastSpinData[t]
                    return n && n[this._currBonusId] || this.defaultState
                }
            }, {
                key: 'updateData',
                value(t) {
                    let e = ur.a.extraSpins
                            var n = ur.a.main.game
                            var r = e.length ? e[e.length - 1] : n
                    this.lastSpinData[t] || (this.lastSpinData = this.lastSpinData.set(t, {})), this._lastMainSpinData[t] || (this._lastMainSpinData = this._lastMainSpinData.set(t, {})), this.lastSpinData = Jo.a.setIn(this.lastSpinData, [''.concat(t), ''.concat(this._currBonusId)], r), this._lastMainSpinData = Jo.a.setIn(this._lastMainSpinData, [''.concat(t), ''.concat(this._currBonusId)], n)
                }
            }, {
                key: 'setCurrBonusId',
                value(t) {
                    t || (t = 0), this._currBonusId = t
                }
            }, {
                key: '_parseInitialState',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                            var n = or.a.hasFeatureBuy && or.a.featureBuy.excludeDataFromPrevRounds
                        ? t.filter((t) => {
                                return void 0 === t.game[0].bonus
                            })
                        : t
                    return Jo()(n.reduce((t, n) => {
                        var r = ur.a.parseExtraSpins(n.game[0]);
                                var i = r && !e ? ur.a.flattenExtraSpins(r) : n.game;
                                var o = parseFloat(n.stake);
                                var a = Number.parseInt(n.bonusId)
                            return t[o] || (t[o] = {}), t[o][a] = i[i.length - 1], t
                    }, {}))
                }
            }]) && Qo(e.prototype, n), r && Qo(e, r), t
        }())

        function ea(t) {
            return (ea = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function na(t) {
            return (function (t) {
                if (Array.isArray(t)) return ra(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return ra(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ra(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function ra(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function ia(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function oa(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function aa(t, e, n) {
            return e = ua(e),
            (function (t, e) {
                if (e && (ea(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], ua(t).constructor)
                : e.apply(t, n)))
        }

        function sa(t, e, n) {
            return (sa = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = ua(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function ua(t) {
            return (ua = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ca(t, e) {
            return (ca = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function la(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function ha(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? la(new Object(n), !0).forEach((e) => {
                            fa(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : la(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function fa(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const da = ha(ha({}, ni.events), {}, {
            TILE_ADD: 'tile_add'
        })
        const pa = (function (t) {
            function e() {
                return ia(this, e), aa(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ca(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return da
                }
            }], (r = [{
                key: 'onCreated',
                value(t, n, r) {
                    sa(ua(e.prototype), 'onCreated', this).call(this, t, n, r), t.tileId = n.tileId
                }
            }, {
                key: 'onShowStart',
                value(t, n, r, i) {
                    sa(ua(e.prototype), 'onShowStart', this).call(this, t, n, r, i)
                    var o = r.reel
                                var a = r.index
                                var s = r.tileId
                    this._reelMaster.replaceTile(a, 0, o), this.emit(da.TILE_ADD, {
                        reel: o,
                        index: a,
                        tileId: s,
                        total: this.children.length
                    })
                }
            }, {
                key: 'onShowEnd',
                value(t, n, r, i) {
                    sa(ua(e.prototype), 'onShowEnd', this).call(this, t, n, r, i), this.play('loop', r, {
                        repeat: -1
                    })
                }
            }, {
                key: 'onDestroyed',
                value(t, n) {
                    sa(ua(e.prototype), 'onDestroyed', this).call(this, t, n), this._reelMaster.replaceTile(t.index, t.tileId, t.reel)
                }
            }, {
                key: 'onReelEvent',
                value(t) {
                    let e = this._getMatchingData(t.reel)
                    return e.length
                        ? this.activate(e, {
                                animLabel: t.animLabel,
                                attachToReels: t.attachToReels
                            })
                        : Promise.resolve()
                }
            }, {
                key: '_getMatchingData',
                value(t) {
                    let e = this._config.tileIds || [].concat(this._config.tileId)
                    return this._reelMaster.getResultData(t.index).reduce((n, r, i) => {
                        return e.includes(r.id)
? [].concat(na(n), [ha({
                            reel: t.index,
                            index: i,
                            tileId: r.id
                        }, r)])
: n
                    }, [])
                }
            }]) && oa(n.prototype, r), i && oa(n, i), e
        }(ni))

        function ma(t) {
            return (ma = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ya(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function va(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        ya(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        ya(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function _a(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function ga(t, e, n) {
            return e = ba(e),
            (function (t, e) {
                if (e && (ma(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], ba(t).constructor)
                : e.apply(t, n)))
        }

        function ba(t) {
            return (ba = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Ea(t, e) {
            return (Ea = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function xa(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Ta(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? xa(new Object(n), !0).forEach((e) => {
                            Sa(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : xa(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Sa(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const wa = Ta(Ta({}, Hn.a), {}, {
            SIRENS: 'SIRENS',
            WHEEL_START: 'WHEEL_START',
            WHEEL_HIDE: 'WHEEL_HIDE',
            WHEEL_HIDE_ALL: 'WHEEL_HIDE_ALL'
        })
        const Oa = (function (t) {
            function e(t) {
                let n; let r = t.features
                            var i = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = ga(this, e))._config = i, n._features = r, n._isSirenPlayed = !1, n
            }
            let n, r, i, o, a, s
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Ea(t, e)
            }(e, t)), n = e, r = [{
                key: 'observeReels',
                value (t) {
                    this._features.jackpotPopupTiles.observeReels(t)
                }
            }, {
                key: 'activate',
                value: (s = va(regeneratorRuntime.mark(function t() {
                    var e; var n; var r = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (e = r.length > 0 && void 0 !== r[0] ? r[0] : [], !(n = e.filter((function(t) {
                                                return !t.screen
                                            }))).length) {
                                            t.next = 9;
                                            break
                                        }
                                        return t.next = 5, Object(k.d)(this._config.delays.spawn.beforeShow);
                                    case 5:
                                        return this._features.wins.deactivate(), this._features.rumble.start({
                                            duration: this._config.rumble.duration
                                        }), t.next = 9, this._spawnTiles(n);
                                    case 9:
                                        e.length === this._config.winTilesThreshold && this._playSiren();
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'deactivate',
                value () {
                    this._features.jackpotPopupTiles.deactivate()
                }
            }, {
                key: 'reset',
                value () {
                    this._isSirenPlayed = !1
                }
            }, {
                key: 'resume',
                value () {}
            }, {
                key: 'wheelStart',
                value () {
                    this.emit(wa.WHEEL_START)
                }
            }, {
                key: 'wheelHide',
                value () {
                    this.emit(wa.WHEEL_HIDE)
                }
            }, {
                key: 'wheelHideAll',
                value () {
                    this.emit(wa.WHEEL_HIDE_ALL)
                }
            }, {
                key: '_spawnTiles',
                value: (a = va(regeneratorRuntime.mark(function t() {
                    var e; var n; var r; var i; var o = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        e = o.length > 0 && void 0 !== o[0] ? o[0] : [], n = this._config.delays.spawn.betweenTiles, r = 0;
                                    case 3:
                                        if (!(r < e.length)) {
                                            t.next = 13;
                                            break
                                        }
                                        if (i = e[r], 0 === r) {
                                            t.next = 8;
                                            break
                                        }
                                        return t.next = 8, Object(k.d)(n);
                                    case 8:
                                        return t.next = 10, this._addTileToReel(i);
                                    case 10:
                                        r++, t.next = 3;
                                        break;
                                    case 13:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_addTileToReel',
                value: (o = va(regeneratorRuntime.mark(function t(e) {
                    var n, r, i
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return n = this._config.labels, r = n.tileWin, i = n.tileIdle, t.next = 3, this._features.jackpotPopupTiles.activate(e, {
                                            animLabel: r
                                        });
                                    case 3:
                                        this._features.jackpotPopupTiles.play(i, e, {
                                            repeat: -1
                                        });
                                    case 4:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_playSiren',
                value () {
                    this._isSirenPlayed || (this.emit(wa.SIRENS), this._isSirenPlayed = !0)
                }
            }], i = [{
                key: 'events',
                get () {
                    return wa
                }
            }], r && _a(n.prototype, r), i && _a(n, i), e
        }(o.Container))
        const Pa = n('./node_modules/ramda/es/internal/_curryN.js')
        const Ra = n('./node_modules/ramda/es/internal/_dispatchable.js')
        const Aa = n('./node_modules/ramda/es/internal/_has.js')
        const Ia = n('./node_modules/ramda/es/internal/_reduce.js')
        const Ca = n('./node_modules/ramda/es/internal/_xfBase.js')
        const ka = (function () {
            function t(t, e, n, r) {
                this.valueFn = t, this.valueAcc = e, this.keyFn = n, this.xf = r, this.inputs = {}
            }
            return t.prototype['@@transducer/init'] = Ca.a.init, t.prototype['@@transducer/result'] = function (t) {
                let e
                for (e in this.inputs) {
                    if (new Object(Aa.a)(e, this.inputs) && (t = this.xf['@@transducer/step'](t, this.inputs[e]))['@@transducer/reduced']) {
                        t = t['@@transducer/value'];
                        break
                    }
                }
                return this.inputs = null, this.xf['@@transducer/result'](t)
            }, t.prototype['@@transducer/step'] = function (t, e) {
                let n = this.keyFn(e)
                return this.inputs[n] = this.inputs[n] || [n, this.valueAcc], this.inputs[n][1] = this.valueFn(this.inputs[n][1], e), t
            }, t
        }())
        const Na = new Object(Pa.a)(4, [], (t, e, n, r) => {
            return new ka(t, e, n, r)
        })
        const Ma = new Object(Pa.a)(4, [], new Object(Ra.a)([], Na, (t, e, n, r) => {
            return new Object(Ia.a)((r, i) => {
                var o = n(i)
                        return r[o] = t(new Object(Aa.a)(o, r) ? r[o] : e, i), r
            }, {}, r)
        }))((t, e) => {
            return t + 1
        }, 0)
        const ja = n('./node_modules/ramda/es/internal/_arity.js')

        function Da(t, e) {
            return function () {
                return e.call(this, t.apply(this, arguments))
            }
        }
        const La = n('./node_modules/ramda/es/internal/_curry3.js')
        const Fa = new Object(La.a)(Ia.a)
        const Ba = n('./node_modules/ramda/es/internal/_isArray.js')

        function Ua(t, e) {
            return function () {
                const n = arguments.length
                if (n === 0) return e()
                const r = arguments[n - 1]
                return new Object(Ba.a)(r) || typeof r[t] != 'function' ? e.apply(this, arguments) : r[t].apply(r, Array.prototype.slice.call(arguments, 0, n - 1))
            }
        }
        const Ga = n('./node_modules/ramda/es/internal/_curry1.js')
        const Xa = new Object(La.a)(Ua('slice', (t, e, n) => {
            return Array.prototype.slice.call(n, t, e)
        }))
        const Ha = new Object(Ga.a)(Ua('tail', Xa(1, 1 / 0)))

        function Va() {
            if (arguments.length === 0) throw new Error('pipe requires at least one argument')
            return new Object(ja.a)(arguments[0].length, Fa(Da, arguments[0], Ha(arguments)))
        }
        const Wa = new Object(Ga.a)((t) => {
            return new Object(Ye.a)(t) ? t.split('').reverse().join('') : Array.prototype.slice.call(t, 0).reverse()
        })

        function Ya(t) {
            return t
        }
        const za = new Object(Ga.a)(Ya)
        const qa = new Object(ot.a)((t, e) => {
            for (var n, r, i = new ht(), o = [], a = 0; a < e.length;) n = t(r = e[a]), i.add(n) && o.push(r), a += 1
            return o
        })(za)

        function Ka(t) {
            return Object.prototype.toString.call(t) === '[object Function]'
        }
        const Za = n('./node_modules/ramda/es/internal/_map.js')

        function $a(t) {
            return `"${t.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b').replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0').replace(/"/g, '\\"')}"`
        }
        const Ja = function (t) {
            return (t < 10 ? '0' : '') + t
        }
        const Qa = typeof Date.prototype.toISOString == 'function'
            ? function (t) {
                return t.toISOString()
            }
            : function (t) {
                return `${t.getUTCFullYear()}-${Ja(t.getUTCMonth() + 1)}-${Ja(t.getUTCDate())}T${Ja(t.getUTCHours())}:${Ja(t.getUTCMinutes())}:${Ja(t.getUTCSeconds())}.${(t.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5)}Z`
            }
        const ts = n('./node_modules/ramda/es/keys.js')
        const es = n('./node_modules/ramda/es/reject.js')
        const ns = new Object(Ga.a)((t) => {
            return (function t(e, n) {
                let r = function (r) {
                    var i = n.concat([e])
                    return new Object(ct.a)(r, i) ? '<Circular>' : t(r, i)
                };
                var i = function (t, e) {
                    return new Object(Za.a)((e) => {
                        return `${$a(e)  }: ${  r(t[e])}`
                    }, e.slice().sort())
                };
                switch (Object.prototype.toString.call(e)) {
                    case '[object Arguments]':
                        return `(function() { return arguments; }(${  new Object(Za.a)(r, e).join(', ')  }))`;
                    case '[object Array]':
                        return `[${  new Object(Za.a)(r, e).concat(i(e, new Object(es.a)(function(t) {
                                    return /^\d+$/.test(t)
                                }, new Object(ts.a)(e)))).join(', ')  }]`;
                    case '[object Boolean]':
                        return typeof e == 'object' ? `new Boolean(${  r(e.valueOf())  })` : e.toString()
                    case '[object Date]':
                        return `new Date(${  isNaN(e.valueOf()) ? r(Number.NaN) : $a(Qa(e))  })`;
                    case '[object Null]':
                        return 'null'
                    case '[object Number]':
                        return typeof e == 'object' ? `new Number(${  r(e.valueOf())  })` : 1 / e == -1 / 0 ? '-0' : e.toString(10)
                    case '[object String]':
                        return typeof e == 'object' ? `new String(${  r(e.valueOf())  })` : $a(e)
                    case '[object Undefined]':
                        return 'undefined'
                    default:
                        if (typeof e.toString == 'function') {
                            let o = e.toString()
                            if (o !== '[object Object]') return o
                        }
                        return `{${  i(e, new Object(ts.a)(e)).join(', ')  }}`
                }
            }(t, []))
        })
        const rs = new Object(ot.a)((t, e) => {
            if (new Object(Ba.a)(t)) {
                if (new Object(Ba.a)(e)) return t.concat(e)
                throw new TypeError(`${ns(e) } is not an array`)
            }
            if (new Object(Ye.a)(t)) {
                if (new Object(Ye.a)(e)) return t + e
                throw new TypeError(`${ns(e) } is not a string`)
            }
            if (t != null && Ka(t['fantasy-land/concat'])) return t['fantasy-land/concat'](e)
            if (t != null && Ka(t.concat)) return t.concat(e)
            throw new TypeError(`${ns(t) } does not have a method named "concat" or "fantasy-land/concat"`)
        })
        const is = n('./src/core/utils/misc.js')

        function os(t) {
            return (os = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function as(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function ss(t, e, n) {
            return e = cs(e),
            (function (t, e) {
                if (e && (os(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], cs(t).constructor)
                : e.apply(t, n)))
        }

        function us(t, e, n) {
            return (us = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = cs(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function cs(t) {
            return (cs = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ls(t, e) {
            return (ls = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function hs(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function fs(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? hs(new Object(n), !0).forEach((e) => {
                            ds(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : hs(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function ds(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const ps = fs(fs({}, ni.events), {}, {
            START: 'start',
            STOP: 'stop',
            FINISH: 'finish'
        })
        const ms = (function (t) {
            function e(t) {
                let n; const r = t.reelMaster
                var i = t.source
                var o = t.config
                var a = t.mask
                var s = t.name
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = ss(this, e, [{
                    reelMaster: r,
                    source: i,
                    config: o,
                    mask: a,
                    name: s
                }]))._activeReels = [], n._isOver = !1, n.name = s || 'Anticipation', n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ls(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return ps
                }
            }], (r = [{
                key: 'prepare',
                value(t) {
                    let e = this._reelMaster.parseBuffer(t).map((t) => {
                        return t[1]
                    })
                                var n = this._getReelTileTotals(e)
                                var r = this._getReelsCriteria(n)
                                var i = this._getReelDurations(r)
                    r.some(Boolean) && (this._reset(), this._adjustReelDurations(i), this._attachReelListeners(r))
                }
            }, {
                key: '_getReelTileTotals',
                value(t) {
                    let e = this._config.tileId
                                var n = [0]
                    return this._reelMaster.reels.forEach((r) => {
                        var i = t[r.index];
                                    var o = Ma(Number.parseInt)(i)[e] || 0
                                n.push(n[r.index] + o)
                    }), n.slice(0, -1)
                }
            }, {
                key: '_getReelsCriteria',
                value(t) {
                    let e = this
                    return t.map((t, n) => {
                        var r = e._config.reels.includes(n);
                                    var i = t >= e._config.minTiles && t <= e._config.maxTiles
                                return r && i
                    })
                }
            }, {
                key: '_getReelDurations',
                value(t) {
                    let e = []
                                var n = this._config
                                var r = n.minDuration
                                var i = n.maxDuration
                    return t.forEach((t, n) => {
                        var o = e[n - 1] || 0;
                                    var a = o
                                t && (a = new Object(is.g)(r, i) + o), e.push(a)
                    }), e
                }
            }, {
                key: '_adjustReelDurations',
                value(t) {
                    let e = this
                    t.forEach((t, n) => {
                        if (!(t <= 0)) {
                            var r = e._reelMaster.getReelConfig(n)
                                    e._reelMaster.preConfigStop({
                                distance: r.distance + t
                            }, n)
                        }
                    })
                }
            }, {
                key: '_attachReelListeners',
                value(t) {
                    let e = this
                                var n = this._config.activationEvent || nt.a.events.ANIMATION_SPIN_ENDING
                    this._reelMaster.onceAll(n, (n) => {
                        var r = !t.some(function(t, e) {
                                        return e > n.reel.index && t
                                    });
                                    var i = t[n.reel.index];
                                    var o = t[n.reel.index + 1]
                                if (r) return e._finishAnticipation(n.reel.index)
                                i && e._stopAnticipation(n.reel.index), o && e._startAnticipation(n.reel.index + 1)
                    }, !0)
                }
            }, {
                key: '_startAnticipation',
                value(t) {
                    let n = this
                                var r = this._config.reels.filter(function(e) {
                                    return e >= t && !n._activeReels.includes(e)
                                });
                    var i = r.map((t) => {
                        return {
                            reel: t
                        }
                    })
                    this.activate(i), this.emit(e.events.START, {
                        reelIndex: t
                    }), this._activeReels = (function () {
                        if (arguments.length === 0) throw new Error('compose requires at least one argument');
                        return Va.apply(this, Wa(arguments))
                    }(qa, rs))(this._activeReels, r)
                }
            }, {
                key: '_stopAnticipation',
                value(t) {
                    this._isOver || (this.deactivate({
                        reel: t
                    }), this.emit(e.events.STOP, {
                        reelIndex: t
                    }))
                }
            }, {
                key: '_finishAnticipation',
                value(t) {
                    if (!this._isOver) {
                        this._isOver = !0
                        var n = this._config.reels.filter((e) => {
                            return e >= t
                        }).map((t) => {
                            return {
                                reel: t
                            }
                        })
                        this.deactivate(n), this.emit(e.events.FINISH, {
                            reelIndex: t
                        })
                    }
                }
            }, {
                key: '_reset',
                value() {
                    us(cs(e.prototype), '_reset', this).call(this), this._activeReels = [], this._isOver = !1
                }
            }]) && as(n.prototype, r), i && as(n, i), e
        }(ni))

        function ys(t) {
            return (ys = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function vs(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function _s(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? vs(new Object(n), !0).forEach((e) => {
                            gs(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : vs(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function gs(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function bs(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Es(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        bs(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        bs(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function xs(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ts(t, e, n) {
            return e = Ss(e),
            (function (t, e) {
                if (e && (ys(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Ss(t).constructor)
                : e.apply(t, n)))
        }

        function Ss(t) {
            return (Ss = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ws(t, e) {
            return (ws = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Os = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = void 0 === r ? 'PassingEffects' : r
                var o = t.reelMaster
                var a = t.source
                var s = t.config
                var u = void 0 === s ? {} : s
                var c = t.mask
                var l = void 0 === c ? null : c
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Ts(this, e)).name = i, n.mask = l, n._config = u, n._reelMaster = o, n._sourceData = a, n.enabled = !1, n.observeReels(), n
            }
            let n, i, o, a, s, u
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ws(t, e)
            }(e, t)), n = e, (i = [{
                key: 'observeReels',
                value() {
                    let t = this
                            var e = this._config
                            var n = e.tileEnterEvent
                            var r = void 0 === n ? rt.a.events.RENDERER_TILE_ENTERING : n
                            var i = e.reelEndEvent
                            var o = void 0 === i ? rt.a.events.ANIMATION_SPIN_END : i
                            var a = e.moveEvent
                            var s = void 0 === a ? rt.a.events.RENDERER_MOVE : a
                    this._reelMaster.on(r, (e) => {
                        var n = e.tile;
                                var r = e.tileIndex;
                                var i = e.index;
                                var o = e.label
                            return t._handleTileEnter(n, i, o, r)
                    }), this._reelMaster.on(o, (e) => {
                        var n = e.index
                            return t._handleReelEnd(n)
                    }), this._reelMaster.on(s, (e) => {
                        var n = e.index;
                                var r = e.delta
                            return t._updatePositions(n, r)
                    })
                }
            }, {
                key: 'enable',
                value() {
                    this.enabled = !0
                }
            }, {
                key: 'disable',
                value() {
                    this.enabled = !1
                }
            }, {
                key: '_handleTileEnter',
                value: (u = Es(regeneratorRuntime.mark(function t(e, n, r, i) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    if (this._shouldTrigger({
                                            tileData: e,
                                            label: r,
                                            tileIndex: i
                                        })) {
                                        t.next = 2;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 2:
                                    this._createEffect({
                                        reel: n,
                                        index: i,
                                        id: e.id
                                    }).show(this._config.onShow);
                                case 4:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t, e, n, r) {
                    return u.apply(this, arguments)
                })
            }, {
                key: '_handleReelEnd',
                value: (s = Es(regeneratorRuntime.mark(function t(e) {
                    let n = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    this.children.filter((function(t) {
                                        return t.reel === e && n._shouldRemove(t, !1)
                                    })).forEach((function(t) {
                                        return n._removeEffect(t)
                                    }));
                                case 1:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_createEffect',
                value(t) {
                    let e = t.reel
                            var n = t.index
                            var i = this._sourceData
                            var o = i.cover
                            var a = void 0 === o ? r.a : o
                            var s = i.animation
                            var u = i.config
                            var c = i.mask
                            var l = this._reelMaster.getTileCoords({
                        reel: e,
                        index: n
                    })
                            var h = new a({
                        name: ''.concat(this.name, 'Cover').concat(n, 'x').concat(e),
                        animation: s,
                        config: u,
                        mask: c,
                        data: t
                    })
                    return h.reel = e, h.index = n, h.isRemoving = !1, h.position.set(l.x, l.y), this.addChild(h), h
                }
            }, {
                key: '_removeEffect',
                value: (a = Es(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return e.isRemoving = !0, t.next = 3, e.hide(_s({
                                        stopTickChildren: !0
                                    }, this._config.onHide));
                                case 3:
                                    this.removeChild(e);
                                case 4:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_updatePositions',
                value(t, e) {
                    let n = this
                    this.children.length && this.children.filter((e) => {
                        return e.reel === t
                    }).forEach((t) => {
                        n._updatePosition(t, e), n._shouldRemove(t, !0) && n._removeEffect(t)
                    })
                }
            }, {
                key: '_shouldTrigger',
                value(t) {
                    let e = t.tileData
                            var n = t.label
                            var r = t.tileIndex
                    return !(!this.enabled || e.id !== this._config.tileId || n === rt.a.labels.EASE_END || n === rt.a.labels.EASE_START || r >= or.a.reels.tiles.visible)
                }
            }, {
                key: '_updatePosition',
                value(t, e) {
                    t.y -= e
                }
            }, {
                key: '_shouldRemove',
                value(t, e) {
                    return !t.isRemoving && (!e || t.y > this._reelMaster.getReelBounds(t.reel).height)
                }
            }]) && xs(n.prototype, i), o && xs(n, o), e
        }(o.Container))

        function Ps(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const Rs = (function () {
            function t(e, n) {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.x = e != null ? e : 0, this.y = n != null ? n : 0
            }
            let e, n, r
            return e = t, r = [{
                key: 'fromPositions',
                value (e, n) {
                    var r = e.x
                                var i = e.y
                    return new t(n.x - r, n.y - i)
                }
            }], (n = [{
                key: 'length',
                get () {
                    return Math.hypot(this.x, this.y)
                }
            }, {
                key: 'direction',
                get () {
                    var t = 180 * Math.atan2(this.y, this.x) / Math.PI
                    return t < 0 && (t = 360 + t), t
                }
            }]) && Ps(e.prototype, n), r && Ps(e, r), t
        }())
        let As = n('./src/core/features/covers/SpineCover.js')

        function Is(t) {
            return (Is = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Cs(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function ks(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ns(t, e, n) {
            return e = Ms(e),
            (function (t, e) {
                if (e && (Is(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Ms(t).constructor)
                : e.apply(t, n)))
        }

        function Ms(t) {
            return (Ms = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function js(t, e) {
            return (js = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Ds = (function (t) {
            function e() {
                return Cs(this, e), Ns(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && js(t, e)
            }(e, t)), n = e, (r = [{
                key: 'activate',
                value(t, e) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                            var r = n.curvePoints
                            var i = void 0 === r ? [] : r
                    return this._applyTrajectory(t, e), this._modifyPath(i), this._playAnim()
                }
            }, {
                key: '_applyTrajectory',
                value(t, e) {
                    let n = Rs.fromPositions(t, e)
                    this.anim.x = t.x, this.anim.y = t.y, this.anim.angle = n.direction, this.anim.width = n.length
                }
            }, {
                key: '_modifyPath',
                value(t) {
                    for (let e = 0; e < t.length; e++) {
                        let n = t[e]
                        this.anim.skeleton.findBone(''.concat(this._config.boneName).concat(e + 1)).y += n.y
                    }
                }
            }, {
                key: '_playAnim',
                value() {
                    return this.play(this._config.trailLabel)
                }
            }]) && ks(n.prototype, r), i && ks(n, i), e
        }(As.a))

        function Ls(t) {
            return (Ls = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const Fs = ['staggerDelay']
        const Bs = ['shouldCurve']

        function Us(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function Gs(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Xs(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Gs(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Gs(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Hs(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Vs(t, e, n) {
            return e = Ws(e),
            (function (t, e) {
                if (e && (Ls(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Ws(t).constructor)
                : e.apply(t, n)))
        }

        function Ws(t) {
            return (Ws = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Ys(t, e) {
            return (Ys = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function zs(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function qs(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? zs(new Object(n), !0).forEach((e) => {
                            Ks(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : zs(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Ks(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Zs = {
            shouldCurve: !0,
            shapeMatrices: [
                [
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [1, 0, 0, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                [
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [1, 0, 0, 1],
                    [0, 0, 1, 0],
                    [0, 1, 0, 0]
                ]
            ],
            yGridSize: 40,
            staggerDelay: 0.3,
            trail: {
                boneName: 'trailControl',
                trailLabel: 'show'
            }
        }
        const $s = qs(qs({}, Hn.a), {}, {
            TRAIL_START: 'tc_trail_start',
            TRAIL_END: 'tc_trail_end',
            SINGLE_START: 'tc_single_start',
            SINGLE_END: 'tc_single_end'
        })
        const Js = (function (t) {
            function e(t) {
                let n; let r = t.reelMaster
                            var i = t.animation
                            var o = t.trailSource
                            var a = void 0 === o ? Ds : o
                            var s = t.config
                            var u = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Vs(this, e)).mask = u, n._reelMaster = r, n._animation = i, n._trailSource = a, n._config = new Object(k.c)(Zs, s), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Ys(t, e)
            }(e, t)), n = e, r = [{
                key: 'onCreated',
                value (t, e, n, r) {}
            }, {
                key: 'onRemoved',
                value (t, e, n, r) {}
            }, {
                key: 'fromTo',
                value: (a = Xs(regeneratorRuntime.mark(function t(n, r) {
                    var i; var o = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return i = o.length > 2 && void 0 !== o[2] ? o[2] : {}, this.emit(e.events.TRAIL_START, {
                                            fromPos: n,
                                            toPos: r
                                        }), t.next = 4, this._fromAllToAll(n, r, i);
                                    case 4:
                                        this.emit(e.events.TRAIL_END, {
                                            fromPos: n,
                                            toPos: r
                                        });
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t, e) {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_initTrail',
                value (t) {
                    var e = new this._trailSource({
                        animation: this._animation,
                        config: this._config.trail
                    })
                            return e.name = 'trail', this.addChild(e), e
                }
            }, {
                key: '_fromAllToAll',
                value (t, e, n) {
                    var r = this;
                                var i = n.staggerDelay;
                                var o = void 0 === i ? this._config.staggerDelay : i;
                                var a = Us(n, Fs);
                                var s = [].concat(t);
                                var u = [].concat(e);
                                var c = st(0, Math.max(s.length, u.length))
                            return Promise.all(c.map(function () {
                        var t = Xs(regeneratorRuntime.mark(function t(e) {
                                    var n, i;
                                    return regeneratorRuntime.wrap((function(t) {
                                        for (;;) switch (t.prev = t.next) {
                                            case 0:
                                                if (n = s[Object(k.f)(e, s.length)], i = u[Object(k.f)(e, u.length)], !o || 0 === e) {
                                                    t.next = 5;
                                                    break
                                                }
                                                return t.next = 5, Object(k.d)(e * o);
                                            case 5:
                                                return t.abrupt("return", r._fromTo(n, i, a));
                                            case 6:
                                            case "end":
                                                return t.stop()
                                        }
                                    }), t)
                                }))
                                return function (e) {
                            return t.apply(this, arguments)
                        }
                    }()))
                }
            }, {
                key: '_fromTo',
                value: (o = Xs(regeneratorRuntime.mark(function t(n, r, i) {
                    var o, a, s, u, c, l, h, f, d, p
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return o = i.shouldCurve, a = void 0 === o ? this._config.shouldCurve : o, s = Us(i, Bs), u = qs({
                                            shouldCurve: a
                                        }, s), c = this._initTrail(u), l = this._calculateCoordinates(n, r, u), h = l.fromPos, f = l.toPos, d = qs(qs({}, n), h), p = qs(qs({}, r), f), this.onCreated(c, d, p, u), this.emit(e.events.SINGLE_START, {
                                            fromData: d,
                                            toData: p
                                        }), t.next = 10, c.activate(h, f, {
                                            curvePoints: a && this._calculateCurvePoints(s)
                                        });
                                    case 10:
                                        this.emit(e.events.SINGLE_END, {
                                            fromData: d,
                                            toData: p
                                        }), this.onRemoved(c, d, p, u), c.destroy();
                                    case 13:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t, e, n) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_calculateCoordinates',
                value (t, e, n) {
                    return {
                        fromPos: this._parsePosition(t, n),
                        toPos: this._parsePosition(e, n)
                    }
                }
            }, {
                key: '_parsePosition',
                value (t, e) {
                    var n = t
                            if (!new Object(so.a)(t.reel) && !new Object(so.a)(t.index) && (n = this._reelMaster.getTileCoords({
                        reel: t.reel,
                        index: t.index
                    }), t.center)) {
                        var r = this._reelMaster.tileGuide.width / 2;
                                    var i = r;
                                    var o = r
                                t.height && (i = r * t.height), t.width && (o = r * t.width), n.x += o, n.y += i
                    }
                    return n
                }
            }, {
                key: '_calculateCurvePoints',
                value (t) {
                    for (var e = [], n = this._getShapeMatrix(t), r = Number.parseInt(-n.length / 2), i = 0; i < n.length; i++) {
                        for (let o = 0; o < n[i].length; o++) { n[i][o] && e.push({
                                    xOffset: o,
                                    y: r * this._config.yGridSize * -1
                                });
}
                        r++
                    }
                    return e.sort(function(t, e) {
                                return t.xOffset - e.xOffset
                            })
                }
            }, {
                key: '_getShapeMatrix',
                value (t) {
                    return new Object(k.m)(this._config.shapeMatrices)
                }
            }], i = [{
                key: 'events',
                get () {
                    return $s
                }
            }], r && Hs(n.prototype, r), i && Hs(n, i), e
        }(o.Container))
        const Qs = n('./node_modules/ramda/es/mergeDeepRight.js')

        function tu(t) {
            return (tu = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const eu = ['animLabel']

        function nu(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function ru(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function iu(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function ou(t, e, n) {
            return e = su(e),
            (function (t, e) {
                if (e && (tu(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], su(t).constructor)
                : e.apply(t, n)))
        }

        function au(t, e, n) {
            return (au = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = su(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function su(t) {
            return (su = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function uu(t, e) {
            return (uu = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function cu(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function lu(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? cu(new Object(n), !0).forEach((e) => {
                            hu(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : cu(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function hu(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const fu = lu(lu({}, r.a.animLabels), {}, {
            NUM_HIDE: 'numHide',
            COUNT: 'count',
            COUNT_BIG: 'countBig'
        })
        const du = lu({}, r.a.events)
        const pu = (function (t) {
            function e(t) {
                let n; const r = t.reelMaster
                var i = t.animation
                var o = t.config
                var a = t.mask
                var s = t.data
                var u = t.stopTickChildren
                var c = t.rtMode
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = ou(this, e, [{
                    name: 'MegaWaysCounter',
                    animation: i,
                    config: o,
                    mask: a,
                    data: s,
                    stopTickChildren: u,
                    rtMode: c
                }])).num = null, n._reelMaster = r, n._numBounds = n._getNumBounds(), n._createNum(), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && uu(t, e)
            }(e, t)), n = e, r = [{
                key: 'observeReels',
                value(t, e) {
                    let n = this
                                var r = this._config.activationEvent || nt.a.events.ANIMATION_SPIN_ENDING
                    this._reelMaster.onceReels(r, (r) => {
                        var i = r.reel
                                return n.update(t[i.index], e)
                    }, !0)
                }
            }, {
                key: 'show',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                                var r = [au(su(e.prototype), 'show', this).call(this, n)]
                    return this._config.counter.isInitiallyVisible && r.push(this.update(t, n)), Promise.all(r)
                }
            }, {
                key: 'update',
                value: (o = regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; let o; let a; let s = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = s.length > 1 && void 0 !== s[1] ? s[1] : {}, this.emit(du.UPDATE_START), r = n.playAnim, i = void 0 === r || r, o = n.bangupOptions, a = [this._updateNum(e, o)], i && a.push(this._playUpdateAnim(e, n)), t.next = 7, Promise.all(a);
                                    case 7:
                                        this.emit(du.UPDATE_END);
                                    case 8:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                }), a = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = o.apply(t, e)

                        function a(t) {
                            ru(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            ru(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function (t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'reset',
                value() {
                    this.num.currentCount = 0
                }
            }, {
                key: '_createNum',
                value() {
                    let t = this._anim.numContainer.getLocalBounds().height
                                var e = this._config.counter
                    this.num = new y({
                        config: lu({
                            fontSize: t
                        }, e)
                    }), this.num.alpha = e.isInitiallyVisible ? 1 : 0, this._anim.numContainer.removeChildren(), this._anim.numContainer.addChild(this.num)
                }
            }, {
                key: '_updateNum',
                value(t) {
                    let e = this
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                                var r = this._config
                                var i = r.ignoreRatio
                                var o = r.overscale
                                var a = r.counter
                                var s = a.bangup
                    return a.fitInBounds && (s = lu(lu({}, s), {}, {
                        onUpdate () {
                            return e._fitNumInBounds(i, o)
                        }
                    })), this.num.alpha = t === 0 ? a.isZeroVisible ? 1 : 0 : 1, this.num.update(t, new Object(Qs.a)(s, n))
                }
            }, {
                key: '_playUpdateAnim',
                value(t, e) {
                    let n = this
                                var r = this._config.counter.thresholds.find(function(e) {
                                    var r = e.range;
                                    return n._isInRange(r[0], r[1], t)
                                }) || {}
                                var i = r.animLabel
                                var o = void 0 === i ? fu.COUNT : i
                                var a = nu(r, eu)
                    return this.play(o, new Object(Qs.a)(a, e))
                }
            }, {
                key: '_isInRange',
                value(t, e, n) {
                    return n >= t && n <= e
                }
            }, {
                key: '_fitNumInBounds',
                value(t, e) {
                    this.num.scale.set(1, 1), new Object(k.e)(this.num, this._numBounds, t, e)
                }
            }, {
                key: '_getNumBounds',
                value() {
                    return this._anim.numContainer.getBounds()
                }
            }], i = [{
                key: 'events',
                get() {
                    return du
                }
            }], r && iu(n.prototype, r), i && iu(n, i), e
        }(r.a))

        function mu(t) {
            return (mu = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function yu(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function vu(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function _u(t, e, n) {
            return e = gu(e),
            (function (t, e) {
                if (e && (mu(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], gu(t).constructor)
                : e.apply(t, n)))
        }

        function gu(t) {
            return (gu = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function bu(t, e) {
            return (bu = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Eu = (function (t) {
            function e() {
                return yu(this, e), _u(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && bu(t, e)
            }(e, t)), n = e, (r = [{
                key: '_createPoints',
                value(t) {
                    let e = this.markers
                            var n = this._config.endToEnd
                            var r = this._tileWidth
                            var i = this._tileHeight
                            var a = []
                    if (n && a.push(new o.Point(e[0].x, e[0].y + t[0] * i)), t.forEach((t, n) => {
                        var i = new Object(k.g)(n, t).reel;
                                    var s = e[i].x + r / 2;
                                    var u = e[i].y
                                a.push(new o.Point(s, u))
                    }), n) {
                        let s = or.a.reels
                                var u = s.count
                                var c = s.tiles.visible
                        a.push(new o.Point(e[c * u - c].x + r, e[c * u - c].y + t[t.length - 1] * i))
                    }
                    return a
                }
            }]) && vu(n.prototype, r), i && vu(n, i), e
        }(Nr))

        function xu(t) {
            return (xu = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Tu(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Su(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Tu(new Object(n), !0).forEach((e) => {
                            wu(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Tu(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function wu(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function Ou(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Pu(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ru(t, e, n) {
            return e = Iu(e),
            (function (t, e) {
                if (e && (xu(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Iu(t).constructor)
                : e.apply(t, n)))
        }

        function Au(t, e, n) {
            return (Au = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Iu(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Iu(t) {
            return (Iu = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Cu(t, e) {
            return (Cu = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const ku = (function (t) {
            function e() {
                return Ou(this, e), Ru(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Cu(t, e)
            }(e, t)), n = e, (r = [{
                key: '_getMatchingData',
                value(t) {
                    return Au(Iu(e.prototype), '_getMatchingData', this).call(this, t).map((t) => {
                        return Su(Su({}, t), new Object(k.o)(t.reel))
                    })
                }
            }]) && Pu(n.prototype, r), i && Pu(n, i), e
        }(pa))

        function Nu(t) {
            return (Nu = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Mu(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function ju(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Mu(new Object(n), !0).forEach((e) => {
                            Du(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Mu(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Du(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function Lu(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Fu(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Bu(t, e, n) {
            return e = Uu(e),
            (function (t, e) {
                if (e && (Nu(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Uu(t).constructor)
                : e.apply(t, n)))
        }

        function Uu(t) {
            return (Uu = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Gu(t, e) {
            return (Gu = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Xu = {
            CHANGE_SCENE: 'change_scene',
            CHANGE_SCENE_END: 'change_scene_end'
        }
        const Hu = (function (t) {
            function e(t) {
                let n; const r = t.scenes
                var i = t.name
                var o = t.config
                var a = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Bu(this, e)).name = 'SceneEffects'.concat(i), n.mask = a, n.activeType = void 0, n._effects = {}, n._scenes = r, n._config = o, n.change(n._config.types[0]), n
            }
            let n, r, i, o, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Gu(t, e)
            }(e, t)), n = e, r = [{
                key: 'activeEffect',
                get() {
                    let t = this
                    return this.children.find((e) => {
                        return e.name === t.activeType
                    })
                }
            }, {
                key: 'change',
                value: (o = regeneratorRuntime.mark(function t(n) {
                    let r; let i; let o; let s; let u; let c; let l; let h; let f = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (r = f.length > 1 && void 0 !== f[1] ? f[1] : {}, this._config.types.includes(n)) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return", console.warn("trying to show non-existent effect ".concat(n, " ").concat(this.name)));
                                    case 3:
                                        if (n !== this.activeType) {
                                            t.next = 5;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 5:
                                        return i = Object(Qs.a)(this._config, r), o = i.transition, s = o.fadeIn, u = o.fadeOut, c = i.stopTickChildren, or.a.static && (s.duration = 0, u.duration = 0, c = !0), l = this.activeEffect, h = this._createEffect(n, c), this.emit(e.events.CHANGE_SCENE, {
                                            effect: this.name,
                                            type: n
                                        }), this.activeType = n, t.next = 13, Promise.all([l && a.b.to(l, ju(ju({}, u), {}, {
                                            alpha: 0
                                        })) || Promise.resolve(), a.b.to(h, ju(ju({}, s), {}, {
                                            alpha: 1
                                        }))]);
                                    case 13:
                                        l && (l.stopTick(!0), this.removeChild(l)), this.emit(e.events.CHANGE_SCENE_END, {
                                            effect: this.name,
                                            type: n
                                        });
                                    case 15:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                }), s = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = o.apply(t, e)

                        function a(t) {
                            Lu(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            Lu(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_createEffect',
                value(t, e) {
                    let n
                    return this._effects[t] ? n = this._effects[t] : ((n = new this._scenes[t]()).name = t, this._effects[t] = n), this.addChild(n), e ? n.stopTick(e) : n.startTick(!0), n.alpha = 0, n
                }
            }], i = [{
                key: 'events',
                get() {
                    return Xu
                }
            }, {
                key: 'types',
                get() {
                    let t = {}
                    return this._config.types.forEach((e) => {
                        return t[e.toUpperCase()] = e
                    }), t
                }
            }], r && Fu(n.prototype, r), i && Fu(n, i), e
        }(o.Container))
        n('./node_modules/@games/pixi-animate/lib/index.js')

        function Vu(t) {
            return (Vu = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Wu(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Yu(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Wu(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Wu(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function zu(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function qu(t, e, n) {
            return e = $u(e),
            (function (t, e) {
                if (e && (Vu(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return Ku(t)
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], $u(t).constructor)
                : e.apply(t, n)))
        }

        function Ku(t) {
            if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
            return t
        }

        function Zu(t, e, n) {
            return (Zu = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = $u(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function $u(t) {
            return ($u = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Ju(t, e) {
            return (Ju = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Qu(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function tc(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Qu(new Object(n), !0).forEach((e) => {
                            ec(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Qu(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function ec(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const nc = {
            INIT: 'init',
            SHOW: 'show',
            HIDE: 'hide'
        }
        const rc = tc(tc({}, r.a.events), {}, {
            STALLED: 'stalled',
            PAUSED: 'pause',
            RESUMED: 'playing',
            WAITING: 'waiting',
            ERROR: 'error'
        })
        const ic = (function (t) {
            function e(t) {
                let n; let r = t.animation
                            var i = t.source
                            var o = t.config
                            var a = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = qu(this, e, [{
                    animation: r,
                    config: o,
                    mask: a
                }]))._endPromise = null, n._inLoop = !1, n._videoSkipped = !1, n._videoSprite = n._createVideoSprite(i), n._videoSource = n._videoSprite.texture.baseTexture.resource.source, n._onVideoEventBound = n._onVideoEvent.bind(Ku(n)), n._addVideoSprite(n._videoSprite), n
            }
            let n, r, i, a, s, u
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Ju(t, e)
            }(e, t)), n = e, r = [{
                key: 'source',
                get () {
                    return this._videoSource
                }
            }, {
                key: 'loopVideo',
                set (t) {
                    "boolean" == typeof t && (this._videoSource.loop = t)
                }
            }, {
                key: 'play',
                value (t) {
                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                            if ((n.force || !this._isPlaying) && this._isValid(t)) {
                        var r = n.repeat
                                return (r === -1 || r > 0) && (this._inLoop = !0), Promise.all([Zu($u(e.prototype), 'play', this).call(this, t, n), t === e.animLabels.SHOW ? this.playVideo(n) : Promise.resolve()])
                    }
                }
            }, {
                key: 'hide',
                value () {
                    var t
                            this.clearSourceListeners()
                            for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i]
                            return (t = Zu($u(e.prototype), 'hide', this)).call.apply(t, [this].concat(r))
                }
            }, {
                key: 'playVideo',
                value: (u = Yu(regeneratorRuntime.mark(function t(e) {
                    var n
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return this.addSourceListeners(), this._setVideoOptions(e), n = this._videoSource.play(), t.prev = 3, t.next = 6, n;
                                    case 6:
                                        t.next = 15;
                                        break;
                                    case 8:
                                        return t.prev = 8, t.t0 = t.catch(3), this.emit(rc.ERROR, {
                                            type: rc.ERROR
                                        }), this.clearSourceListeners(), this._anim.videoContainer.removeChildren(), console.warn("VideoCover failed to play.", t.t0), t.abrupt("return");
                                    case 15:
                                        return t.abrupt("return", this.finish());
                                    case 16:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this, [
                        [3, 8]
                    ])
                })), function (t) {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'stop',
                value: (s = Yu(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, Zu($u(e.prototype), "stop", this).call(this);
                                    case 2:
                                        this._videoSource.pause();
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'finish',
                value: (a = Yu(regeneratorRuntime.mark(function t() {
                    var n = this
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (this._inLoop) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.next = 3, Zu($u(e.prototype), "finish", this).call(this);
                                    case 3:
                                        if (!this._videoSource.ended) {
                                            t.next = 5;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 5:
                                        if (!this._endPromise) {
                                            t.next = 7;
                                            break
                                        }
                                        return t.abrupt("return", this._endPromise);
                                    case 7:
                                        return this._endPromise = new Promise((function(t) {
                                            n._videoSource.addEventListener("ended", t, {
                                                once: !0
                                            })
                                        })), t.next = 10, this._endPromise;
                                    case 10:
                                        this._reset();
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'getCurrentAnimation',
                value () {
                    return ''
                }
            }, {
                key: 'skip',
                value () {
                    this._videoSkipped || this._videoSource.paused || (this._videoSource.currentTime = this._videoSource.duration)
                }
            }, {
                key: 'addSourceListeners',
                value () {
                    var t = this._videoSource
                            t.addEventListener('playing', this._onVideoEventBound), t.addEventListener('pause', this._onVideoEventBound), t.addEventListener('waiting', this._onVideoEventBound), t.addEventListener('stalled', this._onVideoEventBound), t.addEventListener('error', this._onVideoEventBound)
                }
            }, {
                key: 'clearSourceListeners',
                value () {
                    var t = this._videoSource
                            t.removeEventListener('playing', this._onVideoEventBound), t.removeEventListener('pause', this._onVideoEventBound), t.removeEventListener('waiting', this._onVideoEventBound), t.removeEventListener('stalled', this._onVideoEventBound), t.removeEventListener('error', this._onVideoEventBound)
                }
            }, {
                key: '_setVideoOptions',
                value (t) {
                    var e = this;
                                var n = t.reset;
                    (void 0 === n || n) && (t.currentTime = 0), Object.keys(t).forEach(function(n) {
                                void 0 !== e._videoSource[n] && (e._videoSource[n] = t[n])
                            })
                }
            }, {
                key: '_createVideoSprite',
                value (t) {
                    var e = null
                            try {
                        e = new o.Sprite(t)
                    } catch (t) {
                        console.error('[VideoCover]('.concat(this.name, ') Failed to create video sprite')), console.error(t)
                    }
                    return e
                }
            }, {
                key: '_addVideoSprite',
                value (t) {
                    var e = this._anim.videoContainer
                            if (e) {
                        var n = e.getLocalBounds();
                                    var r = n.width;
                                    var i = n.height
                                t.width = r, t.height = i, this._anim.videoContainer.removeChildren(), this._anim.videoContainer.addChild(t)
                    } else { console.error("[VideoCover](".concat(this.name, ") Missing 'videoContainer' in animation!"))
}
                }
            }, {
                key: '_reset',
                value () {
                    this._videoSkipped = !1, this._endPromise = null, this._inLoop = !1
                }
            }, {
                key: '_onVideoEvent',
                value (t) {
                    this.emit(t.type, t)
                }
            }], i = [{
                key: 'animLabels',
                get () {
                    return nc
                }
            }, {
                key: 'events',
                get () {
                    return rc
                }
            }], r && zu(n.prototype, r), i && zu(n, i), e
        }(r.a))
        const oc = n('./node_modules/ramda/es/without.js')

        function ac(t) {
            return (ac = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function sc(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || cc(t, e) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function uc(t) {
            return (function (t) {
                if (Array.isArray(t)) return lc(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || cc(t) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function cc(t, e) {
            if (t) {
                if (typeof t == 'string') return lc(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                return n === 'Object' && t.constructor && (n = t.constructor.name), n === 'Map' || n === 'Set' ? Array.from(t) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? lc(t, e) : void 0
            }
        }

        function lc(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function hc(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function fc(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        hc(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        hc(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function dc(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function pc(t, e, n) {
            return e = yc(e),
            (function (t, e) {
                if (e && (ac(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], yc(t).constructor)
                : e.apply(t, n)))
        }

        function mc(t, e, n) {
            return (mc = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = yc(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function yc(t) {
            return (yc = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function vc(t, e) {
            return (vc = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function _c(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function gc(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? _c(new Object(n), !0).forEach((e) => {
                            bc(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : _c(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function bc(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Ec = gc(gc({}, r.a.events), {}, {
            HIDE: 'hide',
            BUTTON_CLICKED: 'button_clicked',
            SLIDE_SCREEN: 'slide_screen'
        })
        const xc = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = t.animation
                var o = t.config
                var a = t.mask
                var s = t.data
                var u = t.stopTickChildren
                var c = t.onLoadStart
                var l = t.onLoadEnd
                var h = t.settings
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = pc(this, e, [{
                    name: r,
                    animation: i,
                    config: o,
                    mask: a,
                    data: s,
                    stopTickChildren: u
                }])).isLoading = !1, n.settings = h, n._tween = null, n._container = null, n._deactivating = !1, n._hasLoaded = !1, n._isInitialPageLoaded = !1, n._onLoadStart = c, n._onLoadEnd = l, n._parsers = n._getParsers(), n._createdScreens = [], n._selectedStake = null, n._initScreens(), n
            }
            let n, r, i, c, l, h, f
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && vc(t, e)
            }(e, t)), n = e, r = [{
                key: 'currentScreenIndex',
                get() {
                    return this._current
                }
            }, {
                key: 'screens',
                get() {
                    return this._config.screens + this.optionalScreenIndices.length
                }
            }, {
                key: 'optionalScreenIndices',
                get() {
                    let t = this._config.optional
                    return (void 0 === t ? [] : t).filter((t) => {
                        var e = t.condition
                                return or.a[e]
                    }).map((t) => {
                        return t.index - 1
                    })
                }
            }, {
                key: 'show',
                value(t) {
                    this._loadInitialPage(), this._setSymbolWins(), this.slideTo(this._config.initialScreen || 0, 0), mc(yc(e.prototype), 'show', this).call(this), t && (this.anim.promises.gotoAndStop('hide'), this._isShown = !0, this._isShowing = !1), this._deactivating = !1, this.visible = !0, Lt.a.set(Lt.a.TYPES.PAYTABLE, !0), Lt.a.set(Lt.a.TYPES.IS_WHOLE_GAME_STAGE_USED, !0), Lt.a.set(Lt.a.TYPES.GAME_ENABLED, !1)
                }
            }, {
                key: 'next',
                value() {
                    return this.slideTo(this._current + 1)
                }
            }, {
                key: 'previous',
                value() {
                    return this.slideTo(this._current - 1)
                }
            }, {
                key: 'slideTo',
                value: (f = fc(regeneratorRuntime.mark(function t(n, r) {
                    let i, o, s, u, c, l, h, f, d, p
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (0 === (n = Math.max(n, 0))) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.next = 4, this._loadPages().catch((function(t) {
                                            n = 0, console.warn("Paytable page failed to change!"), console.warn(t)
                                        }));
                                    case 4:
                                        if (!(null !== this._tween && this._tween.progress() < 1)) {
                                            t.next = 6;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 6:
                                        if (i = this._config, o = i.slideDuration, s = i.ease, u = i.arrangement, c = this._container.children.length, l = void 0 !== r ? r : o, h = n % c, f = this._container.children[h], d = "horizontal" === u ? -f.x : 0, p = "vertical" === u ? -f.y : 0, h !== this._current && l > 0 && this.emit(e.events.SLIDE_SCREEN, {
                                                from: this._current,
                                                to: h
                                            }), this._updateTitle(h, 0 === l), this._current = h, !(l > 0)) {
                                            t.next = 23;
                                            break
                                        }
                                        return this._tween = a.b.to(this._container, {
                                            duration: l,
                                            x: d,
                                            y: p,
                                            ease: s
                                        }), t.next = 20, this._tween.then();
                                    case 20:
                                        this._tween = null, t.next = 24;
                                        break;
                                    case 23:
                                        this._container.position.set(d, p);
                                    case 24:
                                        I.a.emit(I.a.events.PAYTABLE_SCREEN_CHANGE, {
                                            value: n
                                        });
                                    case 25:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return f.apply(this, arguments)
                })
            }, {
                key: 'hide',
                value: (h = fc(regeneratorRuntime.mark(function t(n) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (!this._deactivating) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        if (this._deactivating = !0, Lt.a.set(Lt.a.TYPES.START_SCREEN, !1), Lt.a.set(Lt.a.TYPES.PAYTABLE, !1), Lt.a.set(Lt.a.TYPES.IS_WHOLE_GAME_STAGE_USED, !1), Lt.a.set(Lt.a.TYPES.GAME_ENABLED, !0), this.emit(e.events.HIDE), n) {
                                            t.next = 11;
                                            break
                                        }
                                        return t.next = 11, mc(yc(e.prototype), "hide", this).call(this);
                                    case 11:
                                        this._deactivating && (this.visible = !1);
                                    case 12:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return h.apply(this, arguments)
                })
            }, {
                key: 'initDrag',
                value() {
                    this._drag = new Xn(this._container.mask, {
                        onUpdate: this._dragUpdate.bind(this),
                        onComplete: this._dragEnd.bind(this)
                    }), this._drag.enable()
                }
            }, {
                key: 'setStake',
                value(t) {
                    this._selectedStake = t
                }
            }, {
                key: 'slideToPays',
                value: (l = fc(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, this._loadPages();
                                    case 2:
                                        return t.abrupt("return", this.slideTo(this.paysScreenIndex, e));
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'paysScreenIndex',
                get() {
                    return this._config.paysScreenIndex || this._container.children.findIndex((t) => {
                        return t.children.find(function(t) {
                                    return t.name && t.name.startsWith("paysTile")
                                })
                    })
                }
            }, {
                key: '_loadPages',
                value: (c = fc(regeneratorRuntime.mark(function t() {
                    let e, n, r
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (!this._hasLoaded) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        if (!this.isLoading) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.abrupt("return", Promise.reject());
                                    case 4:
                                        return this.isLoading = !0, this._onLoadStart(), n = !1, t.next = 9, uo.b.loadFeature("paytable", {
                                            nonrecoverable: !1
                                        }).then((function() {
                                            return n = !0
                                        })).catch((function() {
                                            return console.warn("Paytable assets failed to load!")
                                        }));
                                    case 9:
                                        if (this.isLoading = !1, this._onLoadEnd(), n) {
                                            t.next = 13;
                                            break
                                        }
                                        return t.abrupt("return", Promise.reject());
                                    case 13:
                                        r = this._createRemainingScreens(), (e = this._container).addChild.apply(e, uc(r)), this._setSymbolWins(), this._config.drawLines && this._drawLines(), this._hasLoaded = !0;
                                    case 18:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: '_loadInitialPage',
                value() {
                    if (!this._isInitialPageLoaded) {
                        this._isInitialPageLoaded = !0
                        var t = this._createScreen(this._config.initialScreen, this._config)
                        this._container.removeChildren(), this._container.addChild(t)
                    }
                }
            }, {
                key: '_dragUpdate',
                value(t) {
                    let e = t.delta
                                var n = this._container.children.length
                                var r = this._config.maxDrag
                                var i = this._container.children[0]
                                var o = this._container.children[n - 1]
                                var a = this._container.width / n
                                var s = this._container.height / n
                                var u = {
                        x: -o.x - a * r,
                        y: -o.y - s * r
                    };
                    var c = {
                        x: i.x + a * r,
                        y: o.y + s * r
                    };
                    'horizontal' === this._config.arrangement ? this._container.x = Math.max(Math.min(this._container.x + e.x, c.x), u.x) : this._config.arrangement === 'vertical' && (this._container.y = Math.max(Math.min(this._container.y + e.y, c.y), u.y))
                }
            }, {
                key: '_dragEnd',
                value(t) {
                    let e = t.direction
                                var n = 'horizontal' === this._config.arrangement ? 'x' : 'y';
                    var r = e[n]
                                var i = -this._container[n] - r * this._config.transitionLeverage
                                var o = this._container.children.reduce(function(t, e) {
                                    return Math.abs(e[n] - i) < Math.abs(t[n] - i) ? e : t
                                }, this._container.children[0])
                                var a = this._hasLoaded ? this._container.children.indexOf(o) : -r
                    this.slideTo(a)
                }
            }, {
                key: '_updateTitle',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                    if (this.anim.title && t !== this._current) {
                        let n = this._anim.title['title'.concat(this._current + 1)]
                                    var r = this._anim.title['title'.concat(t + 1)]
                        n && (e ? n.promises.gotoAndStop('init') : n.promises.gotoAndPlay('hide')), r && (e ? r.promises.gotoAndStop('hide') : r.promises.gotoAndPlay('show'))
                    }
                }
            }, {
                key: '_createRemainingScreens',
                value() {
                    let t = this._config
                                var e = t.arrangement
                                var n = t.bounds
                                var r = this._getScreensToLoad()
                    return this._createScreens({
                        screens: r,
                        arrangement: e,
                        bounds: n
                    })
                }
            }, {
                key: '_createScreens',
                value(t) {
                    let e = this
                                var n = t.screens
                                var r = t.arrangement
                                var i = t.bounds
                    return n.map((t) => {
                        return e._createScreen(t, {
                            arrangement: r,
                            bounds: i
                        })
                    })
                }
            }, {
                key: '_createScreen',
                value(t, e) {
                    let n = e.arrangement
                                var r = e.bounds
                                var i = 'PaytableScreen'.concat(t + 1)
                                var o = 'paytableScreen'.concat(t + 1)
                                var a = new vr.a[i][o]()
                    return a.name = o, a.x = n === 'horizontal' ? r.width * t : 0, a.y = n === 'vertical' ? r.height * t : 0, this._createdScreens.push(t), a
                }
            }, {
                key: '_getScreensToLoad',
                value() {
                    let t = this._config.screens
                                var e = new Object(k.k)(t).concat(this.optionalScreenIndices)
                    return new Object(oc.a)(this._createdScreens, e)
                }
            }, {
                key: '_drawLines',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._container.children
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.settings
                                var n = e.lines
                                var r = e.cols
                                var i = e.rows
                                var a = t.reduce(function(t, e) {
                                    return e.linesContainer ? t.concat(e.linesContainer.children) : t
                                }, [])
                                var s = new Object(u.f)(new vr.a.Paytable.paytableLineActive());
                    var c = new Object(u.f)(new vr.a.Paytable.paytableLineInactive());
                    var l = n.map((t) => {
                        return new Object(k.k)(i, function(e) {
                                        return Object(k.k)(r, (function(n) {
                                            return t[n] === e ? 1 : 0
                                        }))
                                    })
                    })
                    a.forEach((t, e) => {
                        if (l[e]) {
                            t.lineMatrix = l[e]
                                    var n = l[e];
                                        var a = t.width / r;
                                        var u = t.height / i;
                                        var h = n.reduce(function(e, n, r) {
                                            var i = n.map((function(e, n) {
                                                var i = 1 === e ? s : c,
                                                    l = new o.Sprite(i);
                                                return l.y = u * r + 1, l.x = a * n + 1, t.lineMatrix[r][n] = e, l
                                            }));
                                            return e.concat.apply(e, uc(i))
                                        }, [])
                                    t.removeChildren(), t.addChild.apply(t, uc(h)), t.cacheAsBitmap = !0
                        }
                    })
                }
            }, {
                key: '_setSymbolWins',
                value() {
                    let t = this
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._container.children
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.settings
                                var r = n.tiles
                                var i = this._getPayingTexts(r)
                                var o = e.reduce(function(t, e) {
                                    var n = e.children.filter((function(t) {
                                        return t.name && t.name.startsWith("paysTile")
                                    }));
                                    return t.concat(n)
                                }, [])
                                var a = o.map(function(e) {
                                    var n = i[e.name];
                                    return t._getFontSize(n, e)
                                });
                    var s = Math.min.apply(Math, uc(a))
                    o.forEach((e) => {
                        var n = i[e.name]
                                t._setFieldPayoutText(n, e, s)
                    })
                }
            }, {
                key: '_getFontSize',
                value(t, e) {
                    e.originalStyle || (e.originalStyle = e.style.clone()), e.originalPosition || (e.originalPosition = e.position.clone())
                    for (var n = e.originalStyle.clone(), r = e.name.split('paysTile')[1].replace(/(left|right)/i, ''), i = Object.values(this.settings.tiles.find((t) => {
                            return t.id == r
                        }).pays).filter((t) => {
                            return t > 0
                        }).length, a = o.TextMetrics.measureText(t, n); a.lines.length > i + 1;) a.style.fontSize--, a = o.TextMetrics.measureText(t, a.style)
                    return a.style.fontSize
                }
            }, {
                key: '_setFieldPayoutText',
                value(t, e, n) {
                    let r = e.originalStyle.clone()
                                var i = o.TextMetrics.measureText(t, r)
                    i.style.fontSize = n, e.style = i.style, e.text = t || '{{MISSING_DATA}}', e.position = e.originalPosition.clone(), e.x += e.style.wordWrapWidth / 2 - e.width / 2
                }
            }, {
                key: '_getPayingTexts',
                value(t) {
                    let e = this
                    return t.reduce((t, n) => {
                        var r = n.id;
                                    var i = n.pays
                                return t['paysTile'.concat(r)] = e._parsers[e._config.type](i), t
                    }, {})
                }
            }, {
                key: '_parseClusterWin',
                value(t) {
                    let e = this
                    return Object.entries(t).reduceRight((t, n, r, i) => {
                        var o = sc(n, 2);
                                    var a = o[0];
                                    var u = o[1]
                                if (u === 0) return t
                                var c = Number.parseInt(a);
                                    var l = or.a.reels.count * or.a.reels.tiles.visible === c;
                                    var h = sc(i[r + 1] || i[r], 1)[0];
                                    var f = r === i.length - 1;
                                    var d = !l && f || parseInt(h) - c > 1 ? e._applyTemplate(c) : c;
                                    var p = e._config.paytableDynamicPayouts && e._selectedStake ? s.a.format(e._selectedStake * u) : Number.parseFloat(u)
                                return t + ''.concat(d, ' = ').concat(p, '\n')
                    }, '')
                }
            }, {
                key: '_parseWin',
                value(t) {
                    let e = this
                    return t.reduceRight((t, n, r) => {
                        var i = e._config.paytableDynamicPayouts && e._selectedStake ? s.a.format(e._selectedStake * n) : Number.parseFloat(n)
                                return t + (Number.parseFloat(n) > 0 ? ''.concat(e._applyTemplate(r + 1), ' = ').concat(i, '\n') : '')
                    }, '')
                }
            }, {
                key: '_getParsers',
                value() {
                    return {
                        lines: this._parseWin.bind(this),
                        cluster: this._parseClusterWin.bind(this)
                    }
                }
            }, {
                key: '_applyTemplate',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._config.type
                    return this._config.templates[e].replace('{{val}}', t)
                }
            }, {
                key: '_initScreens',
                value() {
                    let t = this._anim
                                var e = t.screens
                                var n = t.title
                    n && n.children.forEach((t) => {
                        return t.promises.gotoAndPlay('init')
                    }), this._container = e, this._config.bounds = this._container.getBounds(), this._container.mask.name = 'paytableMask'
                }
            }], i = [{
                key: 'events',
                get() {
                    return Ec
                }
            }], r && dc(n.prototype, r), i && dc(n, i), e
        }(r.a))

        function Tc(t) {
            return (Tc = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Sc(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function wc(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Sc(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Sc(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Oc(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Pc(t, e, n) {
            return e = Ac(e),
            (function (t, e) {
                if (e && (Tc(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Ac(t).constructor)
                : e.apply(t, n)))
        }

        function Rc(t, e, n) {
            return (Rc = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Ac(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Ac(t) {
            return (Ac = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Ic(t, e) {
            return (Ic = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Cc = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = t.animation
                var o = t.config
                var a = t.mask
                var s = t.data
                var u = t.stopTickChildren
                var c = t.lang
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Pc(this, e, [{
                    name: r,
                    animation: i,
                    config: new Object(is.b)(o.default, o[c]),
                    mask: a,
                    data: s,
                    stopTickChildren: u
                }]))._shown = [], n._previous = null, n._current = null, or.a.static && (n.setChance(100), n._config.weights = []), n
            }
            let n, r, i, o, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Ic(t, e)
            }(e, t)), n = e, (r = [{
                key: 'config',
                get() {
                    return this._config
                }
            }, {
                key: 'current',
                get() {
                    return this._current
                }
            }, {
                key: 'display',
                value: (s = wc(regeneratorRuntime.mark(function t(e) {
                    let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    if (n = r.length > 1 && void 0 !== r[1] ? r[1] : this._config.showTime, !this._isShown) {
                                        t.next = 3;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 3:
                                    return this._setActive(e), t.next = 6, this.show();
                                case 6:
                                    return t.next = 8, Object(is.c)(n);
                                case 8:
                                    if (e === this.current) {
                                        t.next = 10;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 10:
                                    if (!this._config.waitHideAnimation) {
                                        t.next = 15;
                                        break
                                    }
                                    return t.next = 13, this.hide();
                                case 13:
                                    t.next = 16;
                                    break;
                                case 15:
                                    this.hide();
                                case 16:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'hide',
                value: (a = wc(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    if (this._isShown || this._isShowing) {
                                        t.next = 2;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 2:
                                    return this._previous = this._current, this._current = null, t.next = 6, Rc(Ac(e.prototype), "hide", this).call(this);
                                case 6:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'displayRandom',
                value: (o = wc(regeneratorRuntime.mark(function t(e) {
                    let n, r
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    if (!this._isShown) {
                                        t.next = 2;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 2:
                                    return n = this._generatePool(), r = Object(is.k)(n), this._updateShown(r), t.next = 7, this.display(r, e);
                                case 7:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'setChance',
                value(t) {
                    (!Number.isInteger(t) || t < 0 || t > 100) && (t = this._config.showChance), this._config.showChance = t
                }
            }, {
                key: 'getChance',
                value() {
                    return !this._isShowing && !this._isShown && new Object(is.a)(this._config.showChance)
                }
            }, {
                key: '_updateShown',
                value(t) {
                    this._shown.push(t), this._shown.length === this._config.count && (this._shown = [])
                }
            }, {
                key: '_setActive',
                value(t) {
                    let e = this
                    this._current = t, this.anim.container.children.forEach((n) => {
                        n.visible = n.name === ''.concat(e._config.prefix).concat(t)
                    })
                }
            }, {
                key: '_generatePool',
                value() {
                    let t = this
                    if (this._config.count === 1) return [1]
                    var e = st(1, this._config.count + 1).filter((e) => {
                        return !t._shown.includes(e) && e !== t._previous
                    }).map((e) => {
                        var n = t._config.weights[e] || 1
                            return new Object(Oe.a)(new Object(Pe.a)(e), n)
                    })
                    return new Object(pe.a)(e)
                }
            }]) && Oc(n.prototype, r), i && Oc(n, i), e
        }(r.a))

        function kc(t) {
            return (kc = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Nc(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Mc(t, e, n) {
            return e = Dc(e),
            (function (t, e) {
                if (e && (kc(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Dc(t).constructor)
                : e.apply(t, n)))
        }

        function jc(t, e, n) {
            return (jc = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Dc(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Dc(t) {
            return (Dc = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Lc(t, e) {
            return (Lc = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Fc(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Bc(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Fc(new Object(n), !0).forEach((e) => {
                            Uc(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Fc(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Uc(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Gc = Bc(Bc({}, r.a.events), {}, {
            LOAD_COMPLETE: 'load_complete',
            BUTTON_CLICKED: 'button_clicked'
        })
        const Xc = (function (t) {
            function e(t) {
                const n = t.name
                var r = void 0 === n ? 'LoadingScreen' : n
                var i = t.animation
                var o = t.config
                var a = t.mask
                var s = t.data
                var u = t.stopTickChildren
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), Mc(this, e, [{
                    name: r,
                    animation: i,
                    config: o,
                    mask: a,
                    data: s,
                    stopTickChildren: u
                }])
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Lc(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return Gc
                }
            }], (r = [{
                key: '_init',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var n = t.stopTickChildren
                    jc(Dc(e.prototype), '_init', this).call(this, {
                        stopTickChildren: n
                    }), this.addChild(this._anim)
                }
            }, {
                key: 'onComplete',
                value() {
                    return this.emit(e.events.LOAD_COMPLETE), or.a.autoStart ? Promise.resolve() : this.show()
                }
            }]) && Nc(n.prototype, r), i && Nc(n, i), e
        }(r.a))

        function Hc(t) {
            return (Hc = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Vc(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Wc(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Yc(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Wc(new Object(n), !0).forEach((e) => {
                            zc(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Wc(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function zc(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function qc(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Kc(t, e, n) {
            return e = Zc(e),
            (function (t, e) {
                if (e && (Hc(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Zc(t).constructor)
                : e.apply(t, n)))
        }

        function Zc(t) {
            return (Zc = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function $c(t, e) {
            return ($c = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Jc = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = t.animation
                var o = t.config
                var a = t.mask
                var s = t.data
                var u = t.stopTickChildren
                var c = t.counterSource
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Kc(this, e, [{
                    name: r,
                    animation: i,
                    config: o,
                    mask: a,
                    data: s,
                    stopTickChildren: u
                }]))._counterMc = n._anim.counter, n._counter = n._createCounter(c), n._counter.prepareText(), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && $c(t, e)
            }(e, t)), n = e, (r = [{
                key: 'activate',
                value(t) {
                    let e = this
                            var n = t.value
                            var r = t.stake
                            var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    return this._addCounter(), Promise.all([this.show(), this._counter.update(n, Yc(Yc({}, new Object(k.c)({
                        duration: this._calcBangupDuration({
                            value: n,
                            stake: r
                        })
                    }, i)), {}, {
                        onUpdate (t) {
                            return e._onSumUpdate(t, e._config.counter)
                        }
                    }))])
                }
            }, {
                key: 'deactivate',
                value: (o = regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, this.hide();
                                case 2:
                                    this._counter.reset(), this._counterMc.numContainer.inner.removeChild(this._counter);
                                case 4:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                }), a = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = o.apply(t, e)

                        function a(t) {
                            Vc(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            Vc(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value() {
                    this._counter.skip()
                }
            }, {
                key: '_calcBangupDuration',
                value(t) {
                    let e = t.value
                            var n = t.stake
                    return Math.abs(e) / (n * this._config.counter.bangup.speed)
                }
            }, {
                key: '_createCounter',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : y
                    return new t({
                        config: Yc({
                            fontSize: this._counterMc.numContainer.inner.getLocalBounds().height
                        }, this._config.counter)
                    })
                }
            }, {
                key: '_addCounter',
                value() {
                    this._counterMc.numContainer.inner.removeChildren(), this._counterMc.numContainer.inner.addChild(this._counter)
                }
            }, {
                key: '_onSumUpdate',
                value(t, e) {
                    let n = e.fitBounds
                            var r = e.ignoreRatio
                            var i = e.overscale
                    Object(k.e)(this._counter, {
                        width: n.width || or.a.renderer.width,
                        height: n.height || or.a.renderer.height
                    }, r, i)
                }
            }]) && qc(n.prototype, r), i && qc(n, i), e
        }(r.a))

        function Qc(t) {
            return (Qc = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function tl(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function el(t, e, n) {
            return e = nl(e),
            (function (t, e) {
                if (e && (Qc(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], nl(t).constructor)
                : e.apply(t, n)))
        }

        function nl(t) {
            return (nl = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function rl(t, e) {
            return (rl = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const il = (function (t) {
            function e(t) {
                let n; const r = t.animation
                var i = t.config
                var o = t.mask
                var a = t.data
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = el(this, e, [{
                    animation: r,
                    config: i,
                    mask: o,
                    data: a
                }]))._tile = null, n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && rl(t, e)
            }(e, t)), n = e, (r = [{
                key: 'setTile',
                value(t) {
                    let e = t.tileId
                            var n = t.type
                            var r = void 0 === n ? 'normal' : n
                    this._tile || this._initTile(), this._tile.to({
                        id: e
                    }, r)
                }
            }, {
                key: '_initTile',
                value() {
                    let t = this._anim.tileContainer
                    if (!t) return console.error('Missing tileContainer inside Cascade Tile!')
                    this._tile = this._createInnerTile(), t.removeChildren(), t.addChild(this._tile)
                }
            }, {
                key: '_createInnerTile',
                value() {
                    return new wt.a()
                }
            }]) && tl(n.prototype, r), i && tl(n, i), e
        }(r.a))

        function ol(t) {
            return (ol = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const al = ['name', 'reelMaster', 'source', 'config', 'mask']
        const sl = ['onSingleDrop', 'dropLabel']

        function ul(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function cl(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        ul(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        ul(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function ll(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function hl(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function fl(t, e, n) {
            return e = pl(e),
            (function (t, e) {
                if (e && (ol(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], pl(t).constructor)
                : e.apply(t, n)))
        }

        function dl(t, e, n) {
            return (dl = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = pl(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function pl(t) {
            return (pl = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ml(t, e) {
            return (ml = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function yl(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function vl(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? yl(new Object(n), !0).forEach((e) => {
                            _l(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : yl(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function _l(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const gl = vl(vl({}, ni.events), {}, {
            DESTROY_START: 'c_destroy_start',
            DESTROY_END: 'c_destroy_end',
            MOVE_START: 'c_move_start',
            SINGLE_MOVE_START: 'c_single_move_start',
            SINGLE_MOVE_ENDING: 'c_single_move_ending',
            SINGLE_MOVE_END: 'c_single_move_end',
            SINGLE_MOVE_UPDATE: 'c_single_move_update',
            MOVE_END: 'c_move_end',
            DROP_START: 'c_drop_start',
            DROP_END: 'c_drop_end',
            END: 'c_feature_end'
        })
        const bl = (function (t) {
            function e(t) {
                let n; let r = t.name
                            var i = t.reelMaster
                            var o = t.source
                            var a = t.config
                            var s = t.mask
                            var u = ll(t, al)
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = fl(this, e, [vl({
                    name: r,
                    reelMaster: i,
                    source: vl({
                        cover: il
                    }, o),
                    config: a,
                    mask: s
                }, u)])).isActive = !1, n._emptyScreen = [], n._timelines = [], n._inDestroy = !1, n._inMove = !1, n._inDrop = !1, n._isSkipped = !1, n._onSingleMove = function () {}, n
            }
            let n, r, i, o, s, u, c, l, h
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ml(t, e)
            }(e, t)), n = e, r = [{
                key: 'screenData',
                get () {
                    return this._emptyScreen
                },
                set (t) {
                    this._emptyScreen = this._emptyScreenPositions(t)
                }
            }, {
                key: 'activate',
                value: (h = cl(regeneratorRuntime.mark(function t(n) {
                    var r; var i; var o = this;
                                var a = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return r = a.length > 1 && void 0 !== a[1] ? a[1] : {}, i = n.map((function(t) {
                                            if (t.tileId) return t;
                                            var e = o._reelMaster.getResultData(t.reel)[t.index].id;
                                            return vl(vl({}, t), {}, {
                                                tileId: e
                                            })
                                        })), t.abrupt("return", dl(pl(e.prototype), "activate", this).call(this, i, r));
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return h.apply(this, arguments)
                })
            }, {
                key: 'destroyTiles',
                value: (l = cl(regeneratorRuntime.mark(function t(n) {
                    var r; var i; var o; var a; var s; var u; var c; var l = this;
                                var h = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (r = h.length > 1 && void 0 !== h[1] ? h[1] : {}, this.isActive = !0, this._inDestroy = !0, i = this._config.destroy, o = i.delays, a = o.beforeSetStart, s = o.betweenBlocks, u = o.afterEnd, !a) {
                                            t.next = 8;
                                            break
                                        }
                                        return t.next = 8, Object(k.d)(a);
                                    case 8:
                                        if (this.emit(e.events.DESTROY_START), !s) {
                                            t.next = 15;
                                            break
                                        }
                                        return c = [].concat(n).map(function() {
                                            var t = cl(regeneratorRuntime.mark((function t(e, n) {
                                                return regeneratorRuntime.wrap((function(t) {
                                                    for (;;) switch (t.prev = t.next) {
                                                        case 0:
                                                            return t.next = 2, Object(k.d)(s * n);
                                                        case 2:
                                                            return t.next = 4, l.play("destroy", e, r);
                                                        case 4:
                                                            l.remove(e, r);
                                                        case 5:
                                                        case "end":
                                                            return t.stop()
                                                    }
                                                }), t)
                                            })));
                                            return function(e, n) {
                                                return t.apply(this, arguments)
                                            }
                                        }()), t.next = 13, Promise.all(c);
                                    case 13:
                                        t.next = 18;
                                        break;
                                    case 15:
                                        return t.next = 17, this.play("destroy", n, r);
                                    case 17:
                                        this.remove(n, r);
                                    case 18:
                                        if (this.emit(e.events.DESTROY_END), !u) {
                                            t.next = 22;
                                            break
                                        }
                                        return t.next = 22, Object(k.d)(u);
                                    case 22:
                                        this._inDestroy = !1;
                                    case 23:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'move',
                value: (c = cl(regeneratorRuntime.mark(function t(n) {
                    var r; var i; var o; var a; var s; var u; var c; var l; var h; var f = this;
                                var d = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return r = d.length > 1 && void 0 !== d[1] ? d[1] : {}, i = vl(vl({}, this._config.move), r), o = i.onSingleMove, a = void 0 === o ? function() {} : o, s = i.moveLabel, u = void 0 === s ? "init" : s, this._inMove = !0, this._onSingleMove = a, c = this.parsePositions(Object(Ro.a)(n)), l = i.delays.afterEnd, t.next = 9, this.activate(c, {
                                            animLabel: u
                                        });
                                    case 9:
                                        return h = this._groupByReelIndex(c), t.next = 12, Promise.all(h.map((function(t, e) {
                                            return f._moveGroup(t, e, i)
                                        })));
                                    case 12:
                                        if (this.emit(e.events.MOVE_END), this._timelines = [], this._isSkipped = !1, !l) {
                                            t.next = 18;
                                            break
                                        }
                                        return t.next = 18, Object(k.d)(l);
                                    case 18:
                                        this._inMove = !1, this.emit(e.events.END);
                                    case 20:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'drop',
                value: (u = cl(regeneratorRuntime.mark(function t(n) {
                    var r; var i; var o; var a; var s; var u = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return r = u.length > 1 && void 0 !== u[1] ? u[1] : {}, this._inDrop = !0, i = this._positionsFromBufferData(n), o = r.onSingleDrop, a = r.dropLabel, s = ll(r, sl), this.emit(e.events.DROP_START), t.next = 7, this.move(i, vl(vl({}, this._config.drop), {}, {
                                            onSingleMove: o,
                                            moveLabel: a
                                        }, s));
                                    case 7:
                                        this.emit(e.events.DROP_END), this._inDrop = !1, this._emptyScreen = [], this._reset();
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'onCreated',
                value (t, n, r) {
                    dl(pl(e.prototype), 'onCreated', this).call(this, t, n, r)
                            var i = n.reel;
                                var o = n.index
                            t.setTile(n), void 0 !== n.x && (t.position.x = n.x), void 0 !== n.y && (t.position.y = n.y), this._reelMaster.replaceTile(o, 0, i)
                }
            }, {
                key: 'onDestroyed',
                value (t, n) {
                    dl(pl(e.prototype), 'onDestroyed', this).call(this, t, n)
                            var r = this._config.destroy.replaceTile
                            this._inDestroy && !r || this._reelMaster.replaceTile(t.index, t.data.tileId, t.reel, !0)
                }
            }, {
                key: 'onMoveEnd',
                value (t, e) {}
            }, {
                key: 'onMoveEnding',
                value (t, e) {}
            }, {
                key: 'parsePositions',
                value (t) {
                    return this._sort(t)
                }
            }, {
                key: 'skip',
                value () {
                    var t = this
                            this._isSkipped || this._config.skipTimeScale <= 0 || (this._isSkipped = !0, this._timelines.forEach(function(e) {
                                return e.timeScale(t._config.skipTimeScale)
                            }))
                }
            }, {
                key: '_moveGroup',
                value: (s = cl(regeneratorRuntime.mark(function t(e, n, r) {
                    var i; var o = this
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return i = e.sort((function(t, e) {
                                            return e.index - t.index
                                        })), t.next = 3, Promise.all(i.map((function(t, e) {
                                            return o._moveTo(t, e, n, r)
                                        })));
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
                            }, t)
                })), function (t, e, n) {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_moveTo',
                value: (o = cl(regeneratorRuntime.mark(function t(n, r, i, o) {
                    var a, s, u, c, l, h, f, d, p, m
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return a = o.removeAtEnd, s = void 0 === a || a, u = this._getCoverOnPos(n), c = this._inDrop ? "drop" : "move", l = n.to, h = n.tileId, f = this._parsePositionData(n), d = f.start, p = f.end, u.position.set(d.x, d.y), m = this._getMoveTimeline({
                                            position: n,
                                            tileIndex: r,
                                            groupIndex: i,
                                            options: o,
                                            cover: u,
                                            end: p,
                                            id: h
                                        }), this._isSkipped && this._config.skipTimeScale > 0 && m.timeScale(this._config.skipTimeScale), this._timelines.push(m), t.next = 11, m;
                                    case 11:
                                        return u.reel = l.reel, u.index = l.index, this.emit(e.events.SINGLE_MOVE_END, {
                                            position: n,
                                            tileIndex: r,
                                            id: h,
                                            type: c
                                        }), t.next = 16, this.onMoveEnd(u, o);
                                    case 16:
                                        s && this._destroyCover(u, o);
                                    case 17:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t, e, n, r) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_getMoveTimeline',
                value (t) {
                    var n = this;
                                var r = t.cover;
                                var i = t.position;
                                var o = t.tileIndex;
                                var s = t.groupIndex;
                                var u = t.options;
                                var c = t.end;
                                var l = t.id;
                                var h = i.to;
                                var f = u.speed;
                                var d = u.ease;
                                var p = u.easeEnd;
                                var m = void 0 === p ? {
                                    offset: 0,
                                    speed: 0,
                                    easings: []
                                } : p;
                                var y = u.delays;
                                var v = y.beforeSetStart;
                                var _ = y.betweenBlockSets;
                                var g = y.betweenBlocks;
                                var b = this._inDrop ? "drop" : "move";
                                var E = (c.y - r.position.y) / f;
                                var x = _ * s + v;
                                var T = a.b.timeline({
                            onUpdate: function () {
                                return n._onTweenUpdate(r, i, l, b)
                            },
                            onStart: function () {
                                n.emit(e.events.SINGLE_MOVE_START, {
                                    cover: r,
                                    tileIndex: o,
                                    position: i,
                                    id: l,
                                    type: b
                                }), n._onSingleMove(i, h, c, E, d)
                            },
                            delay: x
                        }).to(r.position, {
                            x: c.x,
                            y: c.y,
                            duration: E,
                            ease: d,
                            delay: g * o,
                            onComplete: function () {
                                n.emit(e.events.SINGLE_MOVE_ENDING, {
                                    cover: r,
                                    tileIndex: o,
                                    position: i,
                                    id: l,
                                    type: b
                                }), n.onMoveEnding(r, u)
                            }
                        })
                            return m.offset && m.offset !== 0 && this._setEaseEndOffsets(T, r, m), T
                }
            }, {
                key: '_setEaseEndOffsets',
                value (t, e, n) {
                    var r = n.offset;
                                var i = n.speed;
                                var o = n.easings
                            if (i === 0 || o.length !== 2) return console.error('Invalid ease end cascade configuration offset: '.concat(r, ', speed: ').concat(i, ', easings: ').concat(o))
                            var a = Math.abs(r) / i / o.length
                            t.to(e.position, {
                        y: '+='.concat(r),
                        duration: a,
                        ease: o[0]
                    }).to(e.position, {
                        y: '-='.concat(r),
                        duration: a,
                        ease: o[1]
                    })
                }
            }, {
                key: '_onTweenUpdate',
                value (t, n, r, i) {
                    this.emit(e.events.SINGLE_MOVE_UPDATE, {
                        cover: t,
                        position: n,
                        tileId: r,
                        type: i
                    })
                }
            }, {
                key: '_positionsFromBufferData',
                value (t) {
                    var e = this;
                                var n = t.map((function(t) {
                                    return t[1]
                                }));
                                var r = this._calcDropOffset()
                            return this._emptyScreen.map(function(t) {
                                var i = t.reel,
                                    o = t.index,
                                    a = e._reelMaster.getTilePosition({
                                        reel: i,
                                        index: o
                                    }),
                                    s = a.x,
                                    u = a.y;
                                return {
                                    x: s,
                                    y: u - r,
                                    reel: i,
                                    index: o,
                                    to: {
                                        x: s,
                                        y: u,
                                        reel: i,
                                        index: o
                                    },
                                    tileId: n[i][o]
                                }
                            })
                }
            }, {
                key: '_parsePositionData',
                value (t) {
                    var e = t.to
                            return {
                        start: void 0 !== t.x && void 0 !== t.y ? t : this._reelMaster.getTilePosition(t),
                        end: void 0 !== e.x && void 0 !== e.y ? e : this._reelMaster.getTilePosition(e)
                    }
                }
            }, {
                key: '_emptyScreenPositions',
                value (t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                                for (var r = 0; r < t[n].length; r++) null === t[n][r] && e.push({
                                    reel: n,
                                    index: r
                                });
}
                    return e
                }
            }, {
                key: '_calcDropOffset',
                value () {
                    var t = this;
                                var e = this._config.drop.addedDropOffset;
                                var n = void 0 === e ? 0 : e
                            return this._emptyScreen.reduce(function(e, n) {
                                var r = t._getTileGuide(n).height * (n.index + 1);
                                return Math.max(r, e)
                            }, 0) + n
                }
            }, {
                key: '_getTileGuide',
                value (t) {
                    return this._reelMaster.tileGuide
                }
            }, {
                key: '_groupByReelIndex',
                value (t) {
                    var e = this._reelMaster.reels;
                                var n = []
                            return e.forEach(function(e) {
                                var r = t.filter((function(t) {
                                    return t.reel === e.index
                                }));
                                r.length > 0 && n.push(r)
                            }), n
                }
            }, {
                key: '_sort',
                value (t) {
                    return t.sort(function(t, e) {
                                return t.reel === e.reel ? t.index - e.index : t.reel - e.reel
                            })
                }
            }], i = [{
                key: 'events',
                get () {
                    return gl
                }
            }], r && hl(n.prototype, r), i && hl(n, i), e
        }(ni))
        const El = n('./node_modules/ramda/es/internal/_includesWith.js')
        const xl = new Object(La.a)((t, e, n) => {
            for (var r = [], i = 0, o = e.length; i < o;) new Object(El.a)(t, e[i], n) || new Object(El.a)(t, e[i], r) || r.push(e[i]), i += 1
            return r
        })

        function Tl(t) {
            return (Tl = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Sl(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function wl(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Sl(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Sl(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Ol(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Pl(t, e, n) {
            return e = Al(e),
            (function (t, e) {
                if (e && (Tl(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Al(t).constructor)
                : e.apply(t, n)))
        }

        function Rl(t, e, n) {
            return (Rl = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Al(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Al(t) {
            return (Al = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Il(t, e) {
            return (Il = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Cl(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function kl(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Cl(new Object(n), !0).forEach((e) => {
                            Nl(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Cl(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Nl(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Ml = kl(kl({}, ni.events), {}, {
            LOCK_START: 'lock_start',
            UNLOCK_START: 'unlock_start'
        })
        const jl = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = t.reelMaster
                var o = t.source
                var a = t.config
                var s = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Pl(this, e, [{
                    name: r,
                    reelMaster: i,
                    source: o,
                    config: a,
                    mask: s
                }]))._prevData = Jo()([]), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Il(t, e)
            }(e, t)), n = e, r = [{
                key: 'activate',
                value: (a = wl(regeneratorRuntime.mark(function t(n) {
                    let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (r = i.length > 1 && void 0 !== i[1] ? i[1] : {}, 0 !== n.length) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        return this.emit(e.events.LOCK_START), t.next = 6, Rl(Al(e.prototype), "activate", this).call(this, n, r);
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'deactivate',
                value: (o = wl(regeneratorRuntime.mark(function t(n) {
                    let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = i.length > 1 && void 0 !== i[1] ? i[1] : {}, this.emit(e.events.UNLOCK_START), t.next = 4, Rl(Al(e.prototype), "deactivate", this).call(this, n, r);
                                    case 4:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'parse',
                value(t) {
                    return {
                        added: this._getDifference(t.filter((t) => {
                            return t.spins > 0
                        }), this._prevData.filter((t) => {
                            return t.spins > 0
                        })),
                        updated: this._getIntersection(t.filter((t) => {
                            return t.spins > 0
                        }), this._prevData.filter((t) => {
                            return t.spins > 0
                        })),
                        removed: this._getIntersection(t.filter((t) => {
                            return t.spins === 0
                        }), this._prevData)
                    }
                }
            }, {
                key: 'set',
                value(t) {
                    this._prevData = Jo()(t)
                }
            }, {
                key: 'reset',
                value() {
                    this._prevData = Jo()([]), this.remove()
                }
            }, {
                key: 'hasTiles',
                value() {
                    return this.children.length > 0
                }
            }, {
                key: 'hasCacheData',
                value() {
                    return this._prevData.length > 0
                }
            }, {
                key: 'onCreated',
                value(t, e) {
                    t.tile = e.tile
                }
            }, {
                key: 'getTiles',
                value() {
                    return this.children
                }
            }, {
                key: '_getIntersection',
                value(t, e) {
                    return t.filter((t) => {
                        return e.find(function(e) {
                                    return t.reel === e.reel && t.index === e.index && t.tile === e.tile
                                })
                    })
                }
            }, {
                key: '_getDifference',
                value(t, e) {
                    return xl((t, e) => {
                        return t.reel === e.reel && t.index === e.index && t.tile === e.tile
                    }, t, e)
                }
            }], i = [{
                key: 'events',
                get() {
                    return Ml
                }
            }], r && Ol(n.prototype, r), i && Ol(n, i), e
        }(ni))

        function Dl(t) {
            return (Dl = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Ll(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Fl(t, e, n) {
            return e = Bl(e),
            (function (t, e) {
                if (e && (Dl(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Bl(t).constructor)
                : e.apply(t, n)))
        }

        function Bl(t) {
            return (Bl = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Ul(t, e) {
            return (Ul = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Gl = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = t.animation
                var o = t.config
                var a = t.container
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Fl(this, e, [{
                    name: r,
                    animation: i,
                    config: o
                }]))._container = a, n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Ul(t, e)
            }(e, t)), n = e, (r = [{
                key: 'activate',
                value () {
                    var t = or.a.renderer
                                var e = t.width
                                var n = t.height
                                var r = this._container.getBounds()
                                var i = this._container.worldTransform.a
                                var o = this._createBackground(r, i)
                    this._anim.throbber.bg.removeChildren(), this._anim.throbber.bg.addChild(o), this._anim.scale.set(1 / i), this._anim.x = e / 2, this._anim.y = n / 2, this.play('loop')
                }
            }, {
                key: 'deactivate',
                value () {
                    this.removeChild(this._anim), this._anim.promises.stop()
                }
            }, {
                key: '_createBackground',
                value (t, e) {
                    var n = this._config
                                var r = n.color
                                var i = n.alpha
                                var a = t.width / e
                                var s = t.height / e
                                var u = new o.Graphics
                                var c = a / 2
                                var l = s / 2
                    return u.beginFill(r, i), u.drawRect(-c, -l, a, s), u.endFill(), u
                }
            }]) && Ll(n.prototype, r), i && Ll(n, i), e
        }(r.a))
        let Xl = new Object(ot.a)((t, e) => {
            return Array.prototype.slice.call(e, 0).sort((e, n) => {
                for (var r = 0, i = 0; r === 0 && i < t.length;) r = t[i](e, n), i += 1
                return r
            })
        })
        let Hl = new Object(La.a)((t, e, n) => {
            const r = t(e)
            var i = t(n)
            return r < i ? -1 : r > i ? 1 : 0
        })
        let Vl = n('./node_modules/ramda/es/path.js')
        let Wl = n('./node_modules/@games/gsap/PixiPlugin.js')
        let Yl = ['scale', 'offsetX', 'offsetY', 'duration', 'ease']
        let zl = ['duration', 'ease']

        function ql(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Kl(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? ql(new Object(n), !0).forEach((e) => {
                            Zl(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : ql(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Zl(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function $l(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function Jl(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Ql(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Jl(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Jl(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function th(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        a.b.registerPlugin(Wl.a)
        const eh = (function () {
            function t(e, n) {
                const r = n.width
                var i = n.height
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.target = e, this.configs = Xl([Hl(new Object(Vl.a)(['threshold', 'width'])), Hl(new Object(Vl.a)(['threshold', 'ratio']))], or.a.camera), this.stage = document.querySelector('#stage'), this._origin = {
                    x: this.target.x,
                    y: this.target.y,
                    width: r,
                    height: i
                }, this.isActive = !1, this.scale = 1, this.offsetX = 0, this.offsetY = 0
            }
            let e, n, r, i, o
            return e = t, (n = [{
                key: 'origin',
                get() {
                    return this._origin
                },
                set(t) {
                    let e = t.x
                            var n = void 0 === e ? this._origin.x : e
                            var r = t.y
                            var i = void 0 === r ? this._origin.y : r
                            var o = t.width
                            var a = void 0 === o ? this._origin.width : o
                            var s = t.height
                            var u = void 0 === s ? this._origin.height : s
                    this.isActive ? (this._origin.x = n, this._origin.y = i, this._origin.width = a, this._origin.height = u) : console.error('The camera has not been activated yet.')
                }
            }, {
                key: 'start',
                value() {
                    this.isActive = !0, I.a.on(I.a.events.RESIZE, this._onResize.bind(this)), this._onResize()
                }
            }, {
                key: 'change',
                value: (o = Ql(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i; let o; let a; let s; let u; let c; let l; let h; let f; let d = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    if (e = d.length > 0 && void 0 !== d[0] ? d[0] : {}, this.isActive) {
                                        t.next = 3;
                                        break
                                    }
                                    return t.abrupt("return", console.error("The camera has not been activated yet."));
                                case 3:
                                    return n = e.scale, r = void 0 === n ? this.scale : n, i = e.offsetX, o = void 0 === i ? this.offsetX : i, a = e.offsetY, s = void 0 === a ? this.offsetY : a, u = e.duration, c = void 0 === u ? 0 : u, l = e.ease, h = void 0 === l ? "none" : l, f = $l(e, Yl), this.scale = r, this.offsetX = o, this.offsetY = s, t.next = 9, this._applyConfig(this.activeConfig, Kl({
                                        duration: c,
                                        ease: h
                                    }, f));
                                case 9:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_onResize',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                            var e = t.width
                            var n = void 0 === e ? this.stage.width : e
                            var r = t.height
                            var i = void 0 === r ? this.stage.height : r
                            var o = this._getConfig(n, i)
                    o && o !== this.activeConfig && (this._applyConfig(o), this.activeConfig = o)
                }
            }, {
                key: '_applyConfig',
                value: (i = Ql(regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; let o; let s; let u; let c; let l; let h; let f; let d = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return n = d.length > 1 && void 0 !== d[1] ? d[1] : {}, r = n.duration, i = void 0 === r ? 0 : r, o = n.ease, s = void 0 === o ? "none" : o, u = $l(n, zl), a.b.killTweensOf(this.target), a.b.killTweensOf(this.target.scale), i = or.a.static ? 0 : null == i ? e.duration : i, c = this.origin.width * e.scale * this.scale, l = (this.origin.width - c) / 2, h = this.origin.height * e.scale * this.scale, f = (this.origin.height - h) / 2, t.abrupt("return", a.b.to(this.target, Kl({
                                        duration: i,
                                        pixi: {
                                            positionX: l + this.origin.x + e.offsetX + this.offsetX,
                                            positionY: f + this.origin.y + e.offsetY + this.offsetY,
                                            scaleX: e.scale * this.scale,
                                            scaleY: e.scale * this.scale
                                        },
                                        ease: s
                                    }, u)));
                                case 9:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return i.apply(this, arguments)
                })
            }, {
                key: '_getConfig',
                value(t, e) {
                    let n = t / e
                    return this.configs.find((e) => {
                        return t <= e.threshold.width && n <= e.threshold.ratio
                    })
                }
            }]) && th(e.prototype, n), r && th(e, r), t
        }())

        function nh(t) {
            return (nh = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function rh(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function ih(t, e, n) {
            return e = ah(e),
            (function (t, e) {
                if (e && (nh(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], ah(t).constructor)
                : e.apply(t, n)))
        }

        function oh(t, e, n) {
            return (oh = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = ah(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function ah(t) {
            return (ah = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function sh(t, e) {
            return (sh = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function uh(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function ch(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? uh(new Object(n), !0).forEach((e) => {
                            lh(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : uh(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function lh(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const hh = ch(ch({}, y.events), {}, {
            BANGUP_SKIP: 'bangup_skip'
        })
        const fh = (function (t) {
            function e(t) {
                let n
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = ih(this, e, [t]))._startValue = 0, n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && sh(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return hh
                }
            }], (r = [{
                key: 'startValue',
                get() {
                    return this._startValue
                }
            }, {
                key: 'endValue',
                get() {
                    let t, e
                    return ((t = this._updateTween) === null || void 0 === t || (e = t.vars) === null || void 0 === e ? void 0 : e.value) || this._count
                }
            }, {
                key: 'update',
                value(t, n) {
                    return this._startValue = (n == null ? void 0 : n.from) || this._count, oh(ah(e.prototype), 'update', this).call(this, t, n)
                }
            }, {
                key: 'skip',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.endValue
                                var n = arguments.length > 1 ? arguments[1] : void 0
                    if (this._shouldSkip()) {
                        let r = t > this.endValue ? this.endValue : t
                        this.emit(e.events.BANGUP_SKIP, {
                            targetValue: r
                        }), this._updateProgress(r, n)
                    }
                }
            }, {
                key: '_shouldSkip',
                value() {
                    let t
                    return ((t = this._updateTween) === null || void 0 === t ? void 0 : t.progress()) !== 1 || this._count !== this.endValue
                }
            }, {
                key: '_updateProgress',
                value(t, e) {
                    let n = a.b.utils.normalize(this.startValue, this.endValue, t)
                                var r = new Object(k.l)(this._updateTween.vars.ease, n, e == null ? void 0 : e.precision)
                    this._updateTween.progress(r)
                }
            }]) && rh(n.prototype, r), i && rh(n, i), e
        }(y))

        function dh(t) {
            return (dh = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ph(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function mh(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        ph(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        ph(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function yh(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function vh(t, e, n) {
            return e = gh(e),
            (function (t, e) {
                if (e && (dh(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], gh(t).constructor)
                : e.apply(t, n)))
        }

        function _h(t, e, n) {
            return (_h = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = gh(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function gh(t) {
            return (gh = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function bh(t, e) {
            return (bh = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Eh(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function xh(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Th = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Eh(new Object(n), !0).forEach((e) => {
                            xh(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Eh(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, qi.events))
        let Sh = (function (t) {
            function e(t) {
                let n; const r = t.reelMaster
                let i = t.tiles
                let o = t.winFrames
                let a = t.labels
                let s = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = vh(this, e, [{
                    reelMaster: r,
                    tiles: i,
                    config: s
                }]))._winFrames = o, n._clusterLabels = a, n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && bh(t, e)
            }(e, t)), n = e, r = [{
                key: 'show',
                value: (a = mh(regeneratorRuntime.mark(function t() {
                    let n; let r; const i = this
                    var o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return n = o.length > 0 && void 0 !== o[0] ? o[0] : [], r = o.length > 1 && void 0 !== o[1] ? o[1] : {}, t.abrupt('return', _h(gh(e.prototype), 'show', this).call(this, n, new Object(k.c)({
                                    onTilesShow: function (t) {
                                        return i.onTilesShow(t, r)
                                    }
                                }, r)))
                                    case 3:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'hide',
                value: (o = mh(regeneratorRuntime.mark(function t() {
                    let n; let r; const i = this
                    var o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (n = o.length > 0 && void 0 !== o[0] ? o[0] : [], r = o.length > 1 && void 0 !== o[1] ? o[1] : {}, n.length) {
                                    t.next = 5
                                            break
                                }
                                return this.emit(e.events.HIDE_ALL_START), t.abrupt('return', Promise.all([this.tiles.deactivate(), this._clusterLabels.hide(), this._winFrames && this._winFrames.hide()]).then(function() {
                                            return i.emit(e.events.HIDE_ALL_END)
                                        }))
                                    case 5:
                                return t.abrupt('return', _h(gh(e.prototype), 'hide', this).call(this, n, new Object(k.c)({
                                    onTilesHide: function (t) {
                                        return i.onTilesHide(t, r)
                                    }
                                }, r)))
                                    case 6:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'remove',
                value() {
                    let t = this
                    var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    return n.length
                        ? _h(gh(e.prototype), 'remove', this).call(this, n, new Object(k.c)({
                                onTilesRemove (e) {
                                    return t.onTilesRemove(e, r)
                                }
                            }, r))
                        : (this.emit(e.events.REMOVE_ALL_START), Promise.all([this.tiles.remove(), this._clusterLabels.remove(), this._winFrames && this._winFrames.remove()]).then(() => {
                                return t.emit(e.events.REMOVE_ALL_END)
                            }))
                }
            }, {
                key: 'onTilesShow',
                value(t) {
                    let e = t.winData
                    var n = t.positions
                    var r = t.index
                    var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    this._clusterLabels.show(r, e, n, i), this._winFrames && this._winFrames.show(r, e, n, i)
                }
            }, {
                key: 'onTilesHide',
                value(t) {
                    t.winData, t.positions
                    let e = t.index
                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    this._clusterLabels.hide(e, n), this._winFrames && this._winFrames.hide(e, n)
                }
            }, {
                key: 'onTilesRemove',
                value(t) {
                    t.winData, t.positions
                    let e = t.index
                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    this._clusterLabels.remove(e, n), this._winFrames && this._winFrames.remove(e, n)
                }
            }], i = [{
                key: 'events',
                get() {
                    return Th
                }
            }], r && yh(n.prototype, r), i && yh(n, i), e
        }(qi))

        function wh(t) {
            return (wh = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const Oh = ['id']

        function Ph(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Rh(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Ph(new Object(n), !0).forEach((e) => {
                            Ah(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Ph(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Ah(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function Ih(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function Ch(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function kh(t, e, n) {
            return e = Mh(e),
            (function (t, e) {
                if (e && (wh(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Mh(t).constructor)
                : e.apply(t, n)))
        }

        function Nh(t, e, n) {
            return (Nh = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Mh(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Mh(t) {
            return (Mh = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function jh(t, e) {
            return (jh = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Dh = (function (t) {
            function e(t) {
                let n; const r = t.id
                var i = Ih(t, Oh)
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = kh(this, e, [i])).id = r, n.counter = null, n._sumBounds = n._anim.numContainer.getLocalBounds(), n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && jh(t, e)
            }(e, t)), n = e, (r = [{
                key: 'show',
                value(t) {
                    let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    if (t) return this.counter || (this.counter = this._createCounter(), this._anim.numContainer.removeChildren(), this._anim.numContainer.addChild(this.counter)), this.counter.reset(), Promise.all([Nh(Mh(e.prototype), 'show', this).call(this, n), this.update(t, n)])
                }
            }, {
                key: 'update',
                value(t) {
                    let e = this
                            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                            var r = new Object(k.c)(this._config.counter.bangup, n)
                            var i = Rh(Rh({}, r), {}, {
                        onUpdate: function () {
                            return e._onSumUpdate()
                        }
                    })
                    return this.counter.update(t, i)
                }
            }, {
                key: '_createCounter',
                value() {
                    return new y({
                        config: Rh(Rh({}, this._config.counter), {}, {
                            fontSize: this._sumBounds.height
                        })
                    })
                }
            }, {
                key: '_onSumUpdate',
                value() {
                    new Object(k.e)(this.counter, {
                        width: this._sumBounds.width,
                        height: this._sumBounds.height
                    }, this._config.counter.ignoreRatio, this._config.counter.overscale)
                }
            }]) && Ch(n.prototype, r), i && Ch(n, i), e
        }(r.a))

        function Lh(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const Fh = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.anchorPoint = void 0, this.reverse = !1, this.points = []
            }
            let e, n, r
            return e = t, (n = [{
                key: 'getHull',
                value(t, e, n) {
                    let r; let i; let o = this
                            var a = []
                    if (this._addPointsToGTest(t, e, n), this.reverse = this.points.every((t) => {
                        return t.x < 0 && t.y < 0
                    }), r = this._sortPoints(), (i = r.length) < 3) { return r.unshift(this.anchorPoint), r
}
                    a.push(r.shift(), r.shift())
                    for (var s, u = function () {
                        let t, e, n
                        if (a.push(r.shift()), t = a[a.length - 3], e = a[a.length - 2], n = a[a.length - 1], o._checkPoints(t, e, n) && a.splice(a.length - 2, 1), r.length == 0) {
                            if (i == a.length) {
                                let s = o.anchorPoint
                                return (a = a.filter((t) => {
                                    return !!t
                                })).some((t) => {
                                    return t.x == s.x && t.y == s.y
                                }) || a.unshift(o.anchorPoint), {
                                    v: a.map((t) => {
                                        return [t.x, t.y]
                                    })
                                }
                            }
                            i = (r = a).length, (a = []).push(r.shift(), r.shift())
                        }
                    }; ;) {
                        if (s = u()) return s.v
                    }
                }
            }, {
                key: 'addPoint',
                value(t, e) {
                    void 0 === this.anchorPoint || this.anchorPoint.y > e || this.anchorPoint.y === e && this.anchorPoint.x > t ? (void 0 !== this.anchorPoint && this.points.push(new o.Point(this.anchorPoint.x, this.anchorPoint.y)), this.anchorPoint = new o.Point(t, e)) : this.points.push(new o.Point(t, e))
                }
            }, {
                key: '_addPointsToGTest',
                value(t, e, n) {
                    let r = this
                    t.forEach((t) => {
                        r.addPoint(t.x, t.y), r.addPoint(t.x + e, t.y), r.addPoint(t.x, t.y + n), r.addPoint(t.x + e, t.y + n)
                    })
                }
            }, {
                key: '_sortPoints',
                value() {
                    let t = this
                    return this.points.sort((e, n) => {
                        var r = t._findPolarAngle(t.anchorPoint, e);
                                var i = t._findPolarAngle(t.anchorPoint, n)
                            return r < i ? -1 : r > i ? 1 : 0
                    })
                }
            }, {
                key: '_checkPoints',
                value(t, e, n) {
                    let r = this._findPolarAngle(t, e)
                            var i = this._findPolarAngle(t, n)
                    return r > i ? !(r - i > 180) : !(r < i) || i - r > 180
                }
            }, {
                key: '_findPolarAngle',
                value(t, e) {
                    let n, r
                    if (!t || !e) return 0
                    if (n = e.x - t.x, r = e.y - t.y, n == 0 && r == 0) return 0
                    var i = 57.295779513082 * Math.atan2(r, n)
                    return this.reverse ? i <= 0 && (i += 360) : i >= 0 && (i += 360), i
                }
            }]) && Lh(e.prototype, n), r && Lh(e, r), t
        }())

        function Bh(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const Uh = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.data = []
            }
            let e, n, r
            return e = t, (n = [{
                key: 'push',
                value(t) {
                    this.data.push(t), this.length++, this._up(this.length - 1)
                }
            }, {
                key: 'pop',
                value() {
                    if (this.length !== 0) {
                        let t = this.data[0]
                                var e = this.data.pop()
                        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t
                    }
                }
            }, {
                key: 'peek',
                value() {
                    return this.data[0]
                }
            }, {
                key: '_up',
                value(t) {
                    for (var e = this.data[t]; t > 0;) {
                        let n = t - 1 >> 1
                                var r = this.data[n]
                        if (this.compare(e, r) >= 0) break
                        this.data[t] = r, t = n
                    }
                    this.data[t] = e
                }
            }, {
                key: '_down',
                value(t) {
                    for (var e = this.length >> 1, n = this.data[t]; t < e;) {
                        let r = 1 + (t << 1)
                                var i = this.data[r]
                                var o = r + 1
                        if (o < this.length && this.compare(this.data[o], i) < 0 && (r = o, i = this.data[o]), this.compare(i, n) >= 0) break
                        this.data[t] = i, t = r
                    }
                    this.data[t] = n
                }
            }, {
                key: 'compare',
                value(t, e) {
                    return e.max - t.max
                }
            }]) && Bh(e.prototype, n), r && Bh(e, r), t
        }())

        function Gh(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const Xh = (function () {
            function t() {
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t))
            }
            let e, n, r
            return e = t, (n = [{
                key: 'getCentroid',
                value(t, e, n) {
                    let r, i, o, a
                    e = e || 1
                    for (let s = 0; s < t.length; s++) {
                        let u = t[s];
                        (!s || u[0] < r) && (r = u[0]), (!s || u[1] < i) && (i = u[1]), (!s || u[0] > o) && (o = u[0]), (!s || u[1] > a) && (a = u[1])
                    }
                    let c = o - r
                            var l = a - i
                            var h = Math.min(c, l)
                            var f = h / 2
                            var d = new Uh()
                    if (h === 0) return [r, i]
                    for (let p = r; p < o; p += h) {
                        for (let m = i; m < a; m += h) d.push(this.getCell(p + f, m + f, f, t))
}
                    let y = this.getCentroidCell(t)
                            var v = this.getCell(r + c / 2, i + l / 2, 0, t)
                    v.d > y.d && (y = v)
                    for (var _ = d.length; d.length;) {
                        let g = d.pop()
                        g.d > y.d && (y = g, n && console.log('found best %d after %d probes', Math.round(1e4 * g.d) / 1e4, _)), g.max - y.d <= e || (f = g.h / 2, d.push(this.getCell(g.x - f, g.y - f, f, t)), d.push(this.getCell(g.x + f, g.y - f, f, t)), d.push(this.getCell(g.x - f, g.y + f, f, t)), d.push(this.getCell(g.x + f, g.y + f, f, t)), _ += 4)
                    }
                    return n && (console.log(`num probes: ${  _}`), console.log(`best distance: ${  y.d}`)), y
                }
            }, {
                key: 'compareMax',
                value(t, e) {
                    return e.max - t.max
                }
            }, {
                key: 'pointToPolygonDist',
                value(t, e, n) {
                    for (var r = !1, i = 1 / 0, o = 0; o < n.length; o++) {
                        for (let a = n[o], s = 0, u = a.length, c = u - 1; s < u; c = s++) {
                            var l = a[s];
                                    var h = a[c]
                                l[1] > e != h[1] > e && t < (h[0] - l[0]) * (e - l[1]) / (h[1] - l[1]) + l[0] && (r = !r), i = Math.min(i, this.getSegDistSq(t, e, l, h))
                        }
                    }
                    return (r ? 1 : -1) * Math.sqrt(i)
                }
            }, {
                key: 'getCentroidCell',
                value(t) {
                    for (var e = 0, n = 0, r = 0, i = t, o = 0, a = i.length, s = a - 1; o < a; s = o++) {
                        let u = i[o]
                                var c = i[s]
                                var l = u[0] * c[1] - c[0] * u[1]
                        n += (u[0] + c[0]) * l, r += (u[1] + c[1]) * l, e += 3 * l
                    }
                    return e === 0 ? this.getCell(i[0][0], i[0][1], 0, t) : this.getCell(n / e, r / e, 0, t)
                }
            }, {
                key: 'getSegDistSq',
                value(t, e, n, r) {
                    let i = n[0]
                            var o = n[1]
                            var a = r[0] - i
                            var s = r[1] - o
                    if (a !== 0 || s !== 0) {
                        let u = ((t - i) * a + (e - o) * s) / (a * a + s * s)
                        u > 1 ? (i = r[0], o = r[1]) : u > 0 && (i += a * u, o += s * u)
                    }
                    return (a = t - i) * a + (s = e - o) * s
                }
            }, {
                key: 'getCell',
                value(t, e, n, r) {
                    return {
                        x: t,
                        y: e,
                        h: n,
                        d: this.pointToPolygonDist(t, e, r),
                        max: this.pointToPolygonDist(t, e, r) + n * Math.SQRT2
                    }
                }
            }]) && Gh(e.prototype, n), r && Gh(e, r), t
        }())

        function Hh(t) {
            return (Hh = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Vh(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Wh(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Vh(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Vh(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Yh(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function zh(t, e, n) {
            return e = qh(e),
            (function (t, e) {
                if (e && (Hh(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], qh(t).constructor)
                : e.apply(t, n)))
        }

        function qh(t) {
            return (qh = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Kh(t, e) {
            return (Kh = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Zh = {
            CLUSTER_LABEL_SHOW: 'cluster_label_show',
            CLUSTER_LABEL_HIDE: 'cluster_label_hide'
        }
        const $h = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = void 0 === r ? 'ClusterLabels' : r
                var o = t.reelMaster
                var a = t.source
                var s = void 0 === a ? {} : a
                var u = t.config
                var c = void 0 === u ? {} : u
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = zh(this, e)).name = i, n._sourceData = s, n._reelMaster = o, n._config = c, n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Kh(t, e)
            }(e, t)), n = e, r = [{
                key: 'show',
                value(t, n, r) {
                    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
                                var o = this._createWinLabel(t, n, new Object(k.c)(this._sourceData, i))
                    return this._setPosition(r, o), this.addChild(o), this.emit(e.events.CLUSTER_LABEL_SHOW), o.show(n.amount, i)
                }
            }, {
                key: 'hide',
                value(t) {
                    let e = this
                                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                                var r = this.getLabelById(t)
                                var i = r ? [].concat(r) : this.children
                    return Promise.all(i.map((t) => {
                        return e._hideLabel(t, n)
                    }))
                }
            }, {
                key: 'remove',
                value: (a = Wh(regeneratorRuntime.mark(function t(e) {
                    let n; let r = this
                                var i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        n = i.length > 1 && void 0 !== i[1] ? i[1] : {}, e ? this._destroyLabel(e, n) : this.children.map((function(t) {
                                            return t.id
                                        })).map((function(t) {
                                            return r._destroyLabel(t, n)
                                        }));
                                    case 2:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'getLabelById',
                value(t) {
                    return this.children.find((e) => {
                        return e.id === t
                    })
                }
            }, {
                key: 'onLabelHidden',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    this._destroyLabel(t.id, e)
                }
            }, {
                key: '_hideLabel',
                value: (o = Wh(regeneratorRuntime.mark(function t(n) {
                    let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = i.length > 1 && void 0 !== i[1] ? i[1] : {}, this.emit(e.events.CLUSTER_LABEL_HIDE), t.next = 4, n.hide(r);
                                    case 4:
                                        this.onLabelHidden(n, r);
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_createWinLabel',
                value(t, e, n) {
                    let r = n.labelConstructor
                    return new (void 0 === r ? Dh : r)({
                        id: t,
                        animation: n.animation,
                        config: n.config
                    })
                }
            }, {
                key: '_setPosition',
                value(t, e) {
                    let n = this._getLabelPosition(t)
                    e.position.set(n.x, n.y)
                }
            }, {
                key: '_getLabelPosition',
                value(t) {
                    let e = this
                                var n = this._reelMaster.tileGuide
                                var r = n.width
                                var i = n.height
                                var o = t.map(function(t) {
                                    return e._reelMaster.getTilePosition(t)
                                });
                    var a = this._getClusterVisualCenter(o, r, i, this._config.polygonPrecision)
                    return {
                        x: a.x,
                        y: a.y
                    }
                }
            }, {
                key: '_getClusterVisualCenter',
                value(t, e, n, r) {
                    let i = new Fh();
                        var o = new Xh();
                        var a = i.getHull(t, e, n)
                    return o.getCentroid(a, r)
                }
            }, {
                key: '_destroyLabel',
                value(t) {
                    let e = this.getLabelById(t)
                    null == e || e.destroy({
                        children: !0
                    })
                }
            }], i = [{
                key: 'events',
                get() {
                    return Zh
                }
            }], r && Yh(n.prototype, r), i && Yh(n, i), e
        }(o.Container))

        function Jh(t) {
            return (Jh = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Qh(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function tf(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Qh(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Qh(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function ef(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function nf(t, e, n) {
            return e = rf(e),
            (function (t, e) {
                if (e && (Jh(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], rf(t).constructor)
                : e.apply(t, n)))
        }

        function rf(t) {
            return (rf = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function of(t, e) {
            return (of = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const af = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = void 0 === r ? 'WinFrames' : r
                var o = t.reelMaster
                var a = t.source
                var s = t.config
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = nf(this, e)).name = i, n._reelMaster = o, n._frameFillTexture = a.frameFillTexture, n._frameEdgeTexture = a.frameEdgeTexture, n._config = s, n
            }
            let n, r, i, s, u
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && of (t, e)
            }(e, t)), n = e, (r = [{
                key: 'show',
                value(t, e, n) {
                    let r = this
                            var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
                            var a = new Object(k.c)(this._config, i)
                            var s = new Object(Ro.a)(n)
                            var u = new o.Container()
                    return u.alpha = 0, u.id = t, s.forEach((t) => {
                        var n = r._getPoints(s, t, a)
                            n.length && (r._drawFrame(e, u, n, a), a.edges.enabled && r._drawEdges(e, u, n, a))
                    }), this._showFrame(u, i), this.addChild(u), u
                }
            }, {
                key: 'hide',
                value: (u = tf(regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; let o = this
                            var a = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return n = a.length > 1 && void 0 !== a[1] ? a[1] : {}, r = this.getFrameById(e), i = r ? [].concat(r) : this.children, t.abrupt("return", Promise.all(i.map((function(t) {
                                        return o._hideFrame(t, n)
                                    }))));
                                case 4:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'remove',
                value: (s = tf(regeneratorRuntime.mark(function t(e) {
                    let n; let r = this
                            var i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    n = i.length > 1 && void 0 !== i[1] ? i[1] : {}, e ? this._destroyFrame(e, n) : this.children.map((function(t) {
                                        return t.id
                                    })).map((function(t) {
                                        return r._destroyFrame(t, n)
                                    }));
                                case 2:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'getFrameById',
                value(t) {
                    return this.children.find((e) => {
                        return e.id === t
                    })
                }
            }, {
                key: '_getPoints',
                value(t, e, n) {
                    let r = this._reelMaster.tileGuide
                            var i = r.width
                            var o = r.height
                            var a = this._reelMaster.getTilePosition(e)
                            var s = []
                    return this._hasTopNeighbor(t, e) && s.push({
                        x: a.x + i / 2,
                        y: a.y,
                        rotation: -90,
                        edge: n.edges.enabled && this._hasRightNeighbor(t, e)
                            ? {
                                    x: a.x + i,
                                    y: a.y
                                }
                            : void 0
                    }), this._hasBottomNeighbor(t, e) && s.push({
                        x: a.x + i / 2,
                        y: a.y + o,
                        rotation: 90,
                        edge: n.edges.enabled && this._hasLeftNeighbor(t, e)
                            ? {
                                    x: a.x,
                                    y: a.y + o
                                }
                            : void 0
                    }), this._hasRightNeighbor(t, e) && s.push({
                        x: a.x + i,
                        y: a.y + o / 2,
                        rotation: 0,
                        edge: n.edges.enabled && this._hasBottomNeighbor(t, e)
                            ? {
                                    x: a.x + i,
                                    y: a.y + o
                                }
                            : void 0
                    }), this._hasLeftNeighbor(t, e) && s.push({
                        x: a.x,
                        y: a.y + o / 2,
                        rotation: 180,
                        edge: n.edges.enabled && this._hasTopNeighbor(t, e)
                            ? {
                                    x: a.x,
                                    y: a.y
                                }
                            : void 0
                    }), s
                }
            }, {
                key: '_drawFrame',
                value(t, e, n) {
                    for (var r = [], i = 0; i < n.length; i++) {
                        let o = this._createSprite(this._frameFillTexture)
                                var a = n[i]
                                var s = a.x
                                var u = a.y
                                var c = a.rotation
                                var l = c * (Math.PI / 180)
                                var h = this._reelMaster.tileGuide
                                var f = h.width
                                var d = h.height
                                var p = c === 0 || c === 180
                        o.height = p ? d : f, o.x = s, o.y = u, o.rotation = l, o.anchor.set(0.5), r.push(o)
                    }
                    e.addChild.apply(e, r)
                }
            }, {
                key: '_drawEdges',
                value(t, e, n) {
                    for (var r = [], i = 0; i < n.length; i++) {
                        let o = n[i]
                                var a = o.rotation
                                var s = o.edge
                        if (s) {
                            let u = a * (Math.PI / 180)
                                    var c = this._createSprite(this._lineEdgeTexture)
                            c.x = s.x, c.y = s.y, c.rotation = u, c.anchor.set(0.5), r.push(c)
                        }
                    }
                    r.length && e.addChild.apply(e, r)
                }
            }, {
                key: '_createSprite',
                value(t) {
                    return new o.Sprite(t)
                }
            }, {
                key: '_showFrame',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    return a.b.to(t, new Object(k.c)({
                        alpha: 1,
                        duration: this._config.fadeDuration || 0
                    }, e))
                }
            }, {
                key: '_hideFrame',
                value(t) {
                    let e = this
                            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    return a.b.to(t, new Object(k.c)({
                        alpha: 0,
                        duration: this._config.fadeDuration || 0
                    }, n)).then(() => {
                        return e._destroyFrame(t.id, n)
                    })
                }
            }, {
                key: '_hasTopNeighbor',
                value(t, e) {
                    return !t.find((t) => {
                        return t.reel === e.reel && t.index === e.index - 1
                    })
                }
            }, {
                key: '_hasLeftNeighbor',
                value(t, e) {
                    return !t.find((t) => {
                        return t.reel === e.reel - 1 && t.index === e.index
                    })
                }
            }, {
                key: '_hasRightNeighbor',
                value(t, e) {
                    return !t.find((t) => {
                        return t.reel === e.reel + 1 && t.index === e.index
                    })
                }
            }, {
                key: '_hasBottomNeighbor',
                value(t, e) {
                    return !t.find((t) => {
                        return t.reel === e.reel && t.index === e.index + 1
                    })
                }
            }, {
                key: '_destroyFrame',
                value(t) {
                    let e = this.getFrameById(t)
                    null == e || e.destroy({
                        children: !0
                    })
                }
            }]) && ef(n.prototype, r), i && ef(n, i), e
        }(o.Container))

        function sf(t) {
            return (sf = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function uf(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function cf(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        uf(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        uf(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function lf(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function hf(t, e, n) {
            return e = ff(e),
            (function (t, e) {
                if (e && (sf(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], ff(t).constructor)
                : e.apply(t, n)))
        }

        function ff(t) {
            return (ff = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function df(t, e) {
            return (df = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const pf = {
            INIT: 'init',
            WIN: 'win',
            NO_WIN: 'noWin',
            NO_WIN_HIDE: 'noWinHide',
            SELECT: 'select',
            DESELECT: 'deselect'
        }
        const mf = (function (t) {
            function e(t) {
                let n; const r = t.index
                var i = t.anim
                var o = t.config
                var a = t.sourceData
                var s = void 0 === a ? {} : a
                var u = t.sectorRange
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = hf(this, e)).index = r, n.anim = i, n.range = u, n.isWinning = !1, n._config = o, n._sourceData = s, n
            }
            let n, r, i, o, a, s, u, c, l
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && df(t, e)
            }(e, t)), n = e, r = [{
                key: 'width',
                get() {
                    return this.range.max - this.range.min
                }
            }, {
                key: 'select',
                value: (l = cf(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap((t) => {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t)
                })), function () {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'deselect',
                value: (c = cf(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap((t) => {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'win',
                value: (u = cf(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap((t) => {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t)
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'noWin',
                value: (s = cf(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap((t) => {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'noWinHide',
                value: (a = cf(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap((t) => {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'update',
                value: (o = cf(regeneratorRuntime.mark(function t() {
                    let e = arguments
                    return regeneratorRuntime.wrap((t) => {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        !(e.length > 0 && void 0 !== e[0]) || e[0];
                                    case 1:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'isInRange',
                value(t) {
                    return this.range.max >= t && this.range.min <= t
                }
            }, {
                key: 'reset',
                value() {}
            }, {
                key: 'onUpdateHit',
                value(t) {}
            }, {
                key: 'onBeforeUpdateHit',
                value(t) {}
            }, {
                key: 'onAfterUpdateHit',
                value(t) {}
            }], i = [{
                key: 'states',
                get() {
                    return pf
                }
            }], r && lf(n.prototype, r), i && lf(n, i), e
        }(s.b))

        function yf(t) {
            return (yf = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const vf = ['anim', 'value']

        function _f(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function gf(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        _f(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        _f(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function bf(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function Ef(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function xf(t, e, n) {
            return e = Tf(e),
            (function (t, e) {
                if (e && (yf(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Tf(t).constructor)
                : e.apply(t, n)))
        }

        function Tf(t) {
            return (Tf = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Sf(t, e) {
            return (Sf = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function wf(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Of(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? wf(new Object(n), !0).forEach((e) => {
                            Pf(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : wf(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Pf(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Rf = Of(Of({}, mf.states), {}, {
            UPDATE_START: 'updateStart',
            UPDATE_END: 'updateEnd'
        })
        const Af = (function (t) {
            function e(t) {
                let n; const r = t.anim
                var i = t.value
                var o = bf(t, vf)
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = xf(this, e, [o])).anim = r, n.num = null, n.init({
                    value: i
                }), n
            }
            let n, r, i, o, a, s, u, c, l, h
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Sf(t, e)
            }(e, t)), n = e, r = [{
                key: 'currentValue',
                get() {
                    let t
                    return (t = this.num) === null || void 0 === t ? void 0 : t.currentCount
                }
            }, {
                key: 'reset',
                value() {
                    this.play(e.states.INIT)
                }
            }, {
                key: 'play',
                value(t) {
                    return this.anim.promises.gotoAndPlay(t)
                }
            }, {
                key: 'select',
                value: (h = gf(regeneratorRuntime.mark(function t() {
                    let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = r.length > 0 && void 0 !== r[0] ? r[0] : e.states.SELECT, t.next = 3, this.play(n);
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return h.apply(this, arguments)
                })
            }, {
                key: 'deselect',
                value: (l = gf(regeneratorRuntime.mark(function t() {
                    let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = r.length > 0 && void 0 !== r[0] ? r[0] : e.states.DESELECT, t.next = 3, this.play(n);
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'win',
                value: (c = gf(regeneratorRuntime.mark(function t() {
                    let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = r.length > 0 && void 0 !== r[0] ? r[0] : e.states.WIN, t.next = 3, this.play(n);
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'noWin',
                value: (u = gf(regeneratorRuntime.mark(function t() {
                    let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = r.length > 0 && void 0 !== r[0] ? r[0] : e.states.NO_WIN, t.next = 3, this.play(n);
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'updateStart',
                value: (s = gf(regeneratorRuntime.mark(function t() {
                    let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = r.length > 0 && void 0 !== r[0] ? r[0] : e.states.UPDATE_START, t.next = 3, this.play(n);
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'updateEnd',
                value: (a = gf(regeneratorRuntime.mark(function t() {
                    let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = r.length > 0 && void 0 !== r[0] ? r[0] : e.states.UPDATE_END, t.next = 3, this.play(n);
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'update',
                value: (o = gf(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s; let u; let c; let l = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (r = l.length > 0 && void 0 !== l[0] ? l[0] : {}, i = r.data, o = r.instant, a = r.updateStartLabel, s = void 0 === a ? e.states.UPDATE_START : a, u = r.updateEndLabel, c = void 0 === u ? e.states.UPDATE_END : u, this.onBeforeUpdateHit(r), t.t0 = !o, !t.t0) {
                                            t.next = 7;
                                            break
                                        }
                                        return t.next = 7, this.updateStart(s);
                                    case 7:
                                        return this.onUpdateHit(r), t.next = 10, null === (n = this.num) || void 0 === n ? void 0 : n.update(i, r);
                                    case 10:
                                        if (t.t1 = !o, !t.t1) {
                                            t.next = 14;
                                            break
                                        }
                                        return t.next = 14, this.updateEnd(c);
                                    case 14:
                                        this.onAfterUpdateHit(r);
                                    case 15:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'init',
                value(t) {
                    let e = t.value
                    this.anim.promises.gotoAndPlay('init'), this._createCounter({
                        value: e
                    })
                }
            }, {
                key: '_createCounter',
                value(t) {
                    let e = t.value
                    if (this.anim.numContainer && !this.anim.numContainer.inner && console.warn('Inner container is missing this will cause issues with font size on mobile devices!'), this.anim.numContainer) {
                        let n = this._sourceData
                                    var r = n.counter
                                    var i = void 0 === r ? y : r
                                    var o = n.counterConfig
                                    var a = void 0 === o ? this._config.counter : o
                                    var s = this.anim.numContainer.inner || this.anim.numContainer
                                    var u = new i({
                            config: Of({
                                fontSize: s.getLocalBounds().height
                            }, a)
                        })
                        s.removeChildren(), s.addChild(u), u.update(e), this.num = u
                    }
                }
            }], i = [{
                key: 'states',
                get() {
                    return Rf
                }
            }], r && Ef(n.prototype, r), i && Ef(n, i), e
        }(mf))

        function If(t) {
            return (If = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const Cf = ['sectors', 'instant']
        const kf = ['resetNonWinning']
        const Nf = ['sector']

        function Mf(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function jf(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Df(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        jf(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        jf(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Lf(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ff(t, e, n) {
            return e = Uf(e),
            (function (t, e) {
                if (e && (If(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Uf(t).constructor)
                : e.apply(t, n)))
        }

        function Bf(t, e, n) {
            return (Bf = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Uf(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Uf(t) {
            return (Uf = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Gf(t, e) {
            return (Gf = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Xf(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Hf(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Xf(new Object(n), !0).forEach((e) => {
                            Vf(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Xf(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Vf(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Wf = Hf(Hf({}, r.a.events), {}, {
            SPIN_BEGINNING_START: 'spin_beginning_start',
            SPIN_BEGINNING_END: 'spin_beginning_end',
            SPIN_LOOP_START: 'spin_loop_start',
            SPIN_LOOP_END: 'spin_loop_end',
            SPIN_FINISH_START: 'spin_finish_start',
            SPIN_FINISH_END: 'spin_finish_end',
            WIN_START: 'win_start',
            WIN_END: 'win_end',
            SECTOR_CHANGE: 'sector_change',
            SECTORS_UPDATE_START: 'sectors_update_start',
            SECTORS_UPDATE_END: 'sectors_update_end'
        })
        const Yf = {
            INIT: 'init',
            WIN: 'win',
            SPIN: 'spin'
        }
        const zf = (function (t) {
            function e(t) {
                let n
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Ff(this, e, [t]))._spinTarget = n._anim.wheel, n._sourceData = t.source, n._currentWinValue = 0, n._currentSectorId = 0, n._spin = {
                    angle: 0
                }, n._idleSpinner = null, n._spinner = a.b.timeline({
                    onUpdate() {
                        return n._onSpinUpdate()
                    }
                }), n._sectors = [], n
            }
            let n, r, i, o, s, u, c, l, h, f, d, p, m, y, v
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Gf(t, e)
            }(e, t)), n = e, r = [{
                key: 'maxDegrees',
                get() {
                    return 360
                }
            }, {
                key: 'winningSector',
                get() {
                    return this._sectors[this._currentSectorId]
                }
            }, {
                key: 'nonWinningSectors',
                get() {
                    return this._sectors.filter((t) => {
                        return !t.isWinning
                    })
                }
            }, {
                key: 'show',
                value: (v = Df(regeneratorRuntime.mark(function t() {
                    let n; let r = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = r.length > 0 && void 0 !== r[0] ? r[0] : {}, this._reset(), this.prepareSectors(n), t.next = 5, Bf(Uf(e.prototype), "show", this).call(this, n);
                                    case 5:
                                        this._config.spin.idle.startAfterShow && this.startIdle();
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return v.apply(this, arguments)
                })
            }, {
                key: 'hide',
                value: (y = Df(regeneratorRuntime.mark(function t(n) {
                    let r
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return null === (r = this._idleSpinner) || void 0 === r || r.kill(), t.abrupt("return", Bf(Uf(e.prototype), "hide", this).call(this, n));
                                    case 2:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return y.apply(this, arguments)
                })
            }, {
                key: 'updateSectors',
                value: (m = Df(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s = this
                                var u = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = u.length > 0 && void 0 !== u[0] ? u[0] : {}, r = n.sectors, i = void 0 === r ? [] : r, o = n.instant, a = Mf(n, Cf), this.emit(e.events.SECTORS_UPDATE_START, Hf({
                                            sectors: i,
                                            instant: o
                                        }, a)), t.next = 4, Promise.all(this._sectors.map((function(t, e) {
                                            return s._onUpdateSector(Hf({
                                                sector: t,
                                                data: i[e],
                                                instant: o
                                            }, a))
                                        })));
                                    case 4:
                                        this.emit(e.events.SECTORS_UPDATE_END, Hf({
                                            sectors: i,
                                            instant: o
                                        }, a));
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return m.apply(this, arguments)
                })
            }, {
                key: 'startIdle',
                value() {
                    let t = this
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var n = e.resetNonWinning
                                var r = void 0 !== n && n
                                var i = Mf(e, kf)
                    r && this._resetNonWinningSectors(i)
                    var o = this._config.spin
                    this._idleSpinner = a.b.timeline({
                        onUpdate () {
                            return t._onSpinUpdate()
                        },
                        repeat: -1
                    }), this._idleSpinner.to(this._spin, Hf({
                        angle: `+=${  this.maxDegrees}`,
                        duration: this._calcDuration(this.maxDegrees, o.idle.speed)
                    }, o.idle.tweenOptions))
                }
            }, {
                key: 'spin',
                value: (p = Df(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, this.start(e);
                                    case 2:
                                        return t.next = 4, this.loop(e);
                                    case 4:
                                        return t.next = 6, this.end(e);
                                    case 6:
                                        return t.next = 8, this.win(e);
                                    case 8:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return p.apply(this, arguments)
                })
            }, {
                key: 'win',
                value: (d = Df(regeneratorRuntime.mark(function t(n) {
                    let r, i, o, a
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = n.onBeforeWin, i = void 0 === r ? function() {} : r, o = n.onAfterWin, a = void 0 === o ? function() {} : o, this.emit(e.events.WIN_START, {
                                            winValue: this.winningSector.currentValue
                                        }), i(n), t.next = 5, Promise.all([this._handleWinningSector(n), this._handleNonWinningSectors(n)]);
                                    case 5:
                                        a(n), this.emit(e.events.WIN_END, {
                                            winValue: this.winningSector.currentValue
                                        }), this._spin.angle %= this.maxDegrees, this._sectors.forEach((function(t) {
                                            return t.isWinning = !1
                                        }));
                                    case 9:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return d.apply(this, arguments)
                })
            }, {
                key: 'start',
                value: (f = Df(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s; let u; let c; let l; let h; let f; let d; let p; let m; let y; let v; let _; let g; let b = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = b.length > 0 && void 0 !== b[0] ? b[0] : {}, i = Object(Qs.a)(this._config, r), o = i.spin.start, a = r.onBeforeStart, s = void 0 === a ? function() {} : a, u = r.onAfterStart, c = void 0 === u ? function() {} : u, l = r.spinLabel, h = void 0 === l ? e.animLabels.SPIN : l, f = o.distance, d = o.speed, p = o.duration, m = void 0 === p ? this._calcDuration(f, d) : p, y = o.angle, v = void 0 === y ? "+=" + f : y, _ = o.tweenOptions, g = Hf({
                                            duration: m,
                                            angle: v
                                        }, r), null === (n = this._idleSpinner) || void 0 === n || n.kill(), s(g), this.emit(e.events.SPIN_BEGINNING_START, g), this.play(h), t.next = 12, this._spinner.to(this._spin, Hf({
                                            duration: m,
                                            angle: v
                                        }, _));
                                    case 12:
                                        c(g), this.emit(e.events.SPIN_BEGINNING_END, g);
                                    case 14:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return f.apply(this, arguments)
                })
            }, {
                key: 'loop',
                value: (h = Df(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s; let u; let c; let l; let h; let f; let d; let p; let m; let y; let v; let _; let g; let b; let E; let x; let T; let S = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = S.length > 0 && void 0 !== S[0] ? S[0] : {}, r = Object(Qs.a)(this._config, n), i = n.onBeforeLoop, o = void 0 === i ? function() {} : i, a = n.onAfterLoop, s = void 0 === a ? function() {} : a, u = r.spin.loop, c = u.spinCount, h = (l = void 0 === c ? {} : c).min, f = void 0 === h ? 1 : h, d = l.max, p = void 0 === d ? 1 : d, m = u.speed, y = u.distance, v = void 0 === y ? Object(k.i)(f, p) * this.maxDegrees : y, _ = u.duration, g = void 0 === _ ? this._calcDuration(v, m) : _, b = u.angle, E = void 0 === b ? "+=" + v : b, x = u.tweenOptions, T = Hf({
                                            distance: v,
                                            duration: g,
                                            angle: E
                                        }, n), o(T), this.emit(e.events.SPIN_LOOP_START, T), t.next = 10, this._spinner.to(this._spin, Hf({
                                            duration: g,
                                            angle: E
                                        }, x));
                                    case 10:
                                        s(T), this.emit(e.events.SPIN_LOOP_END, T);
                                    case 12:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return h.apply(this, arguments)
                })
            }, {
                key: 'end',
                value: (l = Df(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s; let u; let c; let l; let h; let f; let d; let p; let m; let y; let v; let _; let g; let b; let E; let x; let T; let S; let w = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = w.length > 0 && void 0 !== w[0] ? w[0] : {}, r = Object(Qs.a)(this._config, n), i = r.spin.end, o = r.targetSector, a = r.onBeforeEnd, s = void 0 === a ? function() {} : a, u = r.onAfterEnd, c = void 0 === u ? function() {} : u, l = i.speed, h = i.spinCount, d = (f = void 0 === h ? {} : h).min, p = void 0 === d ? 1 : d, m = f.max, y = void 0 === m ? 1 : m, v = i.distance, _ = void 0 === v ? this._calcDistance(o) + Object(k.i)(p, y) * this.maxDegrees : v, g = i.duration, b = void 0 === g ? this._calcDuration(_, l) : g, E = i.angle, x = void 0 === E ? "+=" + _ : E, T = i.tweenOptions, S = Hf({
                                            distance: _,
                                            duration: b,
                                            angle: x,
                                            targetSector: o
                                        }, n), s(S), this.emit(e.events.SPIN_FINISH_START, S), this._spinner.kill(), t.next = 11, this._spinner.to(this._spin, Hf({
                                            duration: b,
                                            angle: x
                                        }, T));
                                    case 11:
                                        this._sectors[this._currentSectorId].isWinning = !0, c(S), this.emit(e.events.SPIN_FINISH_END, Hf({
                                            winValue: this._sectors[this._currentSectorId].currentValue
                                        }, S));
                                    case 14:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'prepareSectors',
                value(t) {
                    let e = this._parseSectorsData(t)
                    this._sectors = this._createSectors(e), this._currentSectorId = this._calcSpinningSectorId()
                }
            }, {
                key: '_handleNonWinningSectors',
                value: (c = Df(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = i.length > 0 && void 0 !== i[0] ? i[0] : {}, n = e.noWinLabel, r = void 0 === n ? this._sourceData.sector.states.NO_WIN : n, t.next = 3, Promise.all(this.nonWinningSectors.map((function(t) {
                                            return t.noWin(r)
                                        })));
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: '_resetNonWinningSectors',
                value: (u = Df(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = i.length > 0 && void 0 !== i[0] ? i[0] : {}, n = e.noWinHideLabel, r = void 0 === n ? this._sourceData.sector.states.NO_WIN_HIDE : n, t.next = 3, Promise.all(this.nonWinningSectors.map((function(t) {
                                            return t.noWinHide(r)
                                        })));
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: '_handleWinningSector',
                value: (s = Df(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s; let u; let c; let l = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = l.length > 0 && void 0 !== l[0] ? l[0] : {}, r = n.sectorWinLabel, i = void 0 === r ? this._sourceData.sector.states.WIN : r, o = n.winLabel, a = void 0 === o ? e.animLabels.WIN : o, s = n.shouldPlayWin, u = void 0 === s ? this.winningSector.currentValue > this._currentWinValue : s, (c = []).push(this.winningSector.win(i)), u && c.push(this.play(a)), this._currentWinValue = this.winningSector.currentValue, t.next = 8, Promise.all(c);
                                    case 8:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_changeSector',
                value: (o = Df(regeneratorRuntime.mark(function t(n) {
                    let r, i, o
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = this._sectors[this._currentSectorId], i = this._sectors[n], this.emit(e.events.SECTOR_CHANGE, {
                                            current: r,
                                            next: i
                                        }), o = Promise.all([r.deselect(this._sourceData.sector.states.DESELECT), i.select(this._sourceData.sector.states.SELECT)]), this._currentSectorId = n, t.next = 7, o;
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_createSectors',
                value(t) {
                    let e = this
                    return t.map((t) => {
                        return e._createSector(t)
                    })
                }
            }, {
                key: '_onUpdateSector',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var e = t.sector
                                var n = Mf(t, Nf)
                    return e.update(Hf({}, n))
                }
            }, {
                key: '_parseSectorsData',
                value(t) {
                    throw new Error('this method should be overridden with custom logic for parsing data for each sector')
                }
            }, {
                key: '_createSector',
                value(t) {
                    throw new Error('this method should be overridden with custom logic for creating individual sector instance')
                }
            }, {
                key: '_calcDuration',
                value(t, e) {
                    return t / e
                }
            }, {
                key: '_onSpinUpdate',
                value() {
                    this._spinTarget.angle = this._spin.angle % this.maxDegrees
                    var t = this._calcSpinningSectorId()
                    this._currentSectorId !== t && this._changeSector(t)
                }
            }, {
                key: '_calcSpinningSectorId',
                value() {
                    let t = Math.floor((this._spin.angle + this._config.targetPointerOffset) % this.maxDegrees)
                                var e = this._sectors.find((e) => {
                        return e.isInRange(t)
                    })
                    return (e == null ? void 0 : e.index) || 0
                }
            }, {
                key: '_calcDistance',
                value(t) {
                    let e = this._config.spin.end.sectorDeviation
                                var n = this._sectors[t]
                                var r = n.width / 2
                                var i = 0
                    null != e && e.enabled && (i = new Object(k.i)(-r + e.offset, r - e.offset))
                    var o = +(this._config.targetPointerOffset + this._spin.angle) % this.maxDegrees
                                var a = n.range.max - r - o
                    return a < 0 ? a + this.maxDegrees + i : a + i
                }
            }, {
                key: '_reset',
                value() {
                    this._currentWinValue = 0, this._spinTarget.angle = 0, this._spin = {
                        angle: 0
                    }, this._sectors.forEach((t) => {
                        return t.reset()
                    }), this._currentSectorId = this._calcSpinningSectorId()
                }
            }], i = [{
                key: 'events',
                get() {
                    return Wf
                }
            }, {
                key: 'animLabels',
                get() {
                    return Yf
                }
            }], r && Lf(n.prototype, r), i && Lf(n, i), e
        }(r.a))

        function qf(t) {
            return (qf = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const Kf = ['source']

        function Zf(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function $f(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Jf(t, e, n) {
            return e = td(e),
            (function (t, e) {
                if (e && (qf(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], td(t).constructor)
                : e.apply(t, n)))
        }

        function Qf(t, e, n) {
            return (Qf = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = td(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function td(t) {
            return (td = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function ed(t, e) {
            return (ed = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function nd(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function rd(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? nd(new Object(n), !0).forEach((e) => {
                            id(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : nd(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function id(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const od = rd(rd({}, zf.events), {}, {
            SECTOR_CHANGE: 'sector_change'
        })
        const ad = (function (t) {
            function e(t) {
                const n = t.source
                var r = void 0 === n ? {} : n
                var i = Zf(t, Kf)
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), Jf(this, e, [rd({
                    source: rd({
                        sector: Af
                    }, r)
                }, i)])
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ed(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return od
                }
            }], (r = [{
                key: 'prepareSectors',
                value(t) {
                    if (!this._sectors.length) {
                        let n = this._anim.wheel.sectors
                        this._sectorsMCs = new Object(k.k)(n.children.length, (t) => {
                            return n['sector'.concat(t)]
                        }), Qf(td(e.prototype), 'prepareSectors', this).call(this, t)
                    }
                    this.updateSectors(rd({
                        instant: !0
                    }, t))
                }
            }, {
                key: '_parseSectorsData',
                value() {
                    let t = this
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var n = e.sectors
                                var r = void 0 === n ? [] : n
                                var i = e.sectorWidths
                                var o = void 0 === i ? [] : i
                                var a = this.maxDegrees
                    return this._sectorsMCs.map((e, n) => {
                        var i = o[n] || t.maxDegrees / t._sectorsMCs.length;
                                    var s = {
                                max: a,
                                min: a - i
                            };
                        return a -= i, {
                            value: r[n],
                            sectorRange: s,
                            index: n,
                            width: i
                        }
                    })
                }
            }, {
                key: '_createSector',
                value(t) {
                    let e = t.index
                                var n = t.sectorRange
                                var r = t.value
                                var i = this._sectorsMCs[e]
                                var o = this._sourceData || {}
                                var a = o.sector
                                var s = o.sectorConfig
                                var u = void 0 === s ? this._config.sector : s
                                var c = o.sectorSource
                    return new a({
                        index: e,
                        anim: i,
                        config: u,
                        value: r,
                        sourceData: void 0 === c ? {} : c,
                        sectorRange: n
                    })
                }
            }]) && $f(n.prototype, r), i && $f(n, i), e
        }(zf))

        function sd(t) {
            return (sd = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ud(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return cd(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return cd(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function cd(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function ld(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function hd(t, e, n) {
            return e = dd(e),
            (function (t, e) {
                if (e && (sd(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], dd(t).constructor)
                : e.apply(t, n)))
        }

        function fd(t, e, n) {
            return (fd = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = dd(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function dd(t) {
            return (dd = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function pd(t, e) {
            return (pd = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function md(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function yd(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? md(new Object(n), !0).forEach((e) => {
                            vd(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : md(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function vd(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const _d = yd({}, r.a.events)
        const gd = (function (t) {
            function e(t) {
                let n; const r = t.animation
                var i = t.config
                var o = t.mask
                var a = t.counterCtor
                var s = void 0 === a ? y : a
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = hd(this, e, [{
                    animation: r,
                    config: i,
                    mask: o
                }])).counters = {}, n._counterCtor = s, n._countersBounds = {}, n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && pd(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return _d
                }
            }], (r = [{
                key: 'show',
                value() {
                    let t = this
                                var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                                var i = this._config.counters
                                var o = void 0 === i ? [] : i
                    return Object.keys(n).forEach((e) => {
                        if (o[e]) {
                            var r = t._getContainer(o[e].containerName);
                                        var i = t._getCounterBounds(r, e);
                                        var a = t._createCounter(yd(yd({}, o[e].counter), {}, {
                                    fontSize: i.height
                                }))
                                    t.counters[e] = a, t._updateCounter(a, n[e]), t._fitCounter(a, i), t._addCounter(a, r)
                        } else { console.error("No counter data found for key ".concat(e))
}
                    }), fd(dd(e.prototype), 'show', this).call(this, r)
                }
            }, {
                key: 'update',
                value() {
                    for (let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = 0, n = Object.entries(t); e < n.length; e++) {
                        let r = ud(n[e], 2)
                                    var i = r[0]
                                    var o = r[1]
                        if (this.counters[i]) {
                            let a = this.counters[i]
                                        var s = this._countersBounds[i]
                            this._updateCounter(a, o), this._fitCounter(a, s)
                        } else { console.error('No counter data found for key '.concat(i))
                        }
                    }
                }
            }, {
                key: '_createCounter',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    return new this._counterCtor({
                        config: t
                    })
                }
            }, {
                key: '_addCounter',
                value(t, e) {
                    e.removeChildren(), e.addChild(t)
                }
            }, {
                key: '_updateCounter',
                value(t, e) {
                    t.currentCount = e
                }
            }, {
                key: '_fitCounter',
                value(t, e) {
                    let n = this._config.fit
                                var r = void 0 === n ? {} : n
                                var i = r.width
                                var o = void 0 === i ? e.width : i
                                var a = r.height
                                var s = void 0 === a ? e.height : a
                                var u = r.ignoreRatio
                                var c = void 0 !== u && u
                                var l = r.overscale
                                var h = void 0 !== l && l
                    Object(k.e)(t, {
                        width: o,
                        height: s
                    }, c, h)
                }
            }, {
                key: '_getContainer',
                value(t) {
                    let e = this
                                var n = t.split('.');
                    var r = null
                    return n.forEach((t) => {
                        if (!(r = r ? r[t] : e._anim[t])) throw new Error('No container found with name '.concat(t))
                    }), r
                }
            }, {
                key: '_getCounterBounds',
                value(t, e) {
                    return this._countersBounds[e] || (this._countersBounds[e] = t.getLocalBounds()), this._countersBounds[e]
                }
            }]) && ld(n.prototype, r), i && ld(n, i), e
        }(r.a))

        function bd(t) {
            return (bd = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Ed(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function xd(t, e, n) {
            return e = Sd(e),
            (function (t, e) {
                if (e && (bd(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Sd(t).constructor)
                : e.apply(t, n)))
        }

        function Td(t, e, n) {
            return (Td = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Sd(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Sd(t) {
            return (Sd = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function wd(t, e) {
            return (wd = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Od = {
            WIN_ACTIVE: 'win_active',
            LOSE_ACTIVE: 'no_win_active',
            WIN_FINAL: 'win_final',
            LOSE_FINAL: 'lose_final'
        }
        const Pd = (function (t) {
            function e(t) {
                let n; let r = t.animation
                            var i = t.config
                            var o = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = xd(this, e, [{
                    animation: r,
                    config: i,
                    mask: o
                }]))._isWinning = !1, n
            }
            let n, r, i
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && wd(t, e)
            }(e, t)), n = e, (r = [{
                key: 'animLabels',
                get () {
                    return Od
                }
            }, {
                key: 'update',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                var e = t ? Od.WIN_ACTIVE : Od.LOSE_ACTIVE
                            this._isWinning = t, this._anim.gamble.gotoAndStop(e)
                }
            }, {
                key: 'win',
                value () {
                    var t = this._isWinning ? Od.WIN_FINAL : Od.LOSE_FINAL
                            return this._anim.gamble.promises.gotoAndPlay(t)
                }
            }, {
                key: 'reset',
                value () {
                    this._anim.gamble.gotoAndStop('init')
                }
            }, {
                key: '_init',
                value () {
                    this._anim.gamble.gotoAndStop('init'), Td(Sd(e.prototype), '_init', this).call(this)
                }
            }]) && Ed(n.prototype, r), i && Ed(n, i), e
        }(gd))
        const Rd = new Object(La.a)((t, e, n) => {
            if (t > e) throw new Error('min must not be greater than max in clamp(min, max, value)')
            return n < t ? t : n > e ? e : n
        })

        function Ad(t) {
            return (Ad = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Id(t) {
            return (function (t) {
                if (Array.isArray(t)) return Cd(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return Cd(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Cd(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function Cd(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function kd(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Nd(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        kd(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        kd(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Md(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function jd(t, e, n) {
            return e = Fd(e),
            (function (t, e) {
                if (e && (Ad(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return Dd(t)
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Fd(t).constructor)
                : e.apply(t, n)))
        }

        function Dd(t) {
            if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
            return t
        }

        function Ld(t, e, n) {
            return (Ld = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Fd(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Fd(t) {
            return (Fd = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Bd(t, e) {
            return (Bd = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Ud(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Gd(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Ud(new Object(n), !0).forEach((e) => {
                            Xd(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Ud(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Xd(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Hd = 38
        const Vd = 40
        const Wd = Gd(Gd({}, xc.events), {}, {
            TITLE_UPDATE: 'title_update'
        })
        const Yd = (function (t) {
            function e(t) {
                let n
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = jd(this, e, [t])).isMinimal = Boolean(n._config.isMinimal), n._isSplashShown = !1, n._sliderClicked = !1, n._sliderShown = !1, n._sliderDrag = null, n._onScroll = n._onScroll.bind(Dd(n)), n._onKeyDown = n._onKeyDown.bind(Dd(n)), n._smoothMoveTimeline = null, n._splashScreenMc = null
                var r = n._config.screens.length + n.optionalScreenIndices.length
                            var i = n._config.bounds.height
                return n._topY = 0 + (n._config.offsets.top || 0), n._bottomY = -(r - 1) * i + (n._config.offsets.bottom || 0), n._mobileScrollStartY = 0, n._initTitles(), n
            }
            let n, r, i, s, u, c
            return (function (t, e) {
                if ('function' != typeof e && e !== null) throw new TypeError('Super expression must either be null or a function');
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Bd(t, e)
            }(e, t)), n = e, r = [{
                key: 'paysScreenIndex',
                get () {
                    return this._config.paysScreen || Ld(Fd(e.prototype), 'paysScreenIndex', this)
                }
            }, {
                key: 'setup',
                value (t) {
                    this._hasLoaded = t, this._isInitialPageLoaded = !0, this._isSplashShown = !0
                }
            }, {
                key: 'show',
                value (t) {
                    Ld(Fd(e.prototype), 'show', this).call(this, t), this._toggleListeners()
                }
            }, {
                key: 'hide',
                value: (c = Nd(regeneratorRuntime.mark(function t(n) {
                    return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (!this._deactivating) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        return this._toggleListeners(!1), t.next = 5, Ld(Fd(e.prototype), "hide", this).call(this, n);
                                    case 5:
                                        this._isSplashShown = !0, this._container.removeChild(this._splashScreenMc), this._container.position.set(0, 0), this._moveSlider(), this._changeMasks();
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'slideTo',
                value: (u = Nd(regeneratorRuntime.mark(function t(e) {
                    var n; var r; var i; var o; var s; var u; var c; var l; var h; var f; var d; var p = arguments
                            return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if (n = p.length > 1 && void 0 !== p[1] ? p[1] : 0, r = p.length > 2 && void 0 !== p[2] && p[2], this._isSplashShown) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 4:
                                        if ((i = e % this._container.children.length) !== this._current && this.emit(xc.events.SLIDE_SCREEN, {
                                                from: this._current,
                                                to: i
                                            }), this._updateTitle(i, !1), this._current = i, 0 !== e) {
                                            t.next = 10;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 10:
                                        if (e = Math.max(e, 0), !this._hasMissingScreens()) {
                                            t.next = 15;
                                            break
                                        }
                                        return t.next = 14, this._loadPages().catch((function() {
                                            e = 0, console.warn("Paytable page failed to change!")
                                        }));
                                    case 14:
                                        this._hasMissingScreens() && this._attachMissingScreens();
                                    case 15:
                                        if (!r) {
                                            t.next = 30;
                                            break
                                        }
                                        if (o = this._config, s = o.slideDuration, u = o.ease, c = o.arrangement, l = void 0 !== n ? n : s, h = this._container.children[i], f = "horizontal" === c ? -h.x + (this._config.offsets.left || 0) : 0, d = "vertical" === c ? -h.y + (this._config.offsets.top || 0) : 0, !(l > 0)) {
                                            t.next = 28;
                                            break
                                        }
                                        return this._tween = a.a.to(this._container, {
                                            duration: l,
                                            x: f,
                                            y: d,
                                            ease: u
                                        }), t.next = 25, this._tween.then();
                                    case 25:
                                        this._tween = null, t.next = 29;
                                        break;
                                    case 28:
                                        this._container.position.set(f, d);
                                    case 29:
                                        this._moveSlider();
                                    case 30:
                                        I.a.emit(I.a.events.PAYTABLE_SCREEN_CHANGE, {
                                            value: e
                                        });
                                    case 31:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'initSlider',
                value () {
                    var t = this;
                                var e = this.anim.slider
                            if (e && !this._sliderShown) {
                        this._sliderShown = !0
                                var n = this.anim.slider;
                                    var r = n.sliderBody;
                                    var i = n.sliderHead
                                r.interactive = !0, i.interactive = !0, i.buttonMode = !0, e.promises.gotoAndStop('show'), i.promises.gotoAndPlay('over'), r.on('click', function(e) {
                                    var n = e.data;
                                    return t._onSliderClick(n)
                                }), i.on('pointermove', function(e) {
                                    var n = e.data;
                                    return t._onMouseMove(n)
                                }), i.on('pointermoveoutside', function(e) {
                                    var n = e.data;
                                    return t._onMouseMove(n)
                                }), i.on('pointerover', function() {
                                    return i.promises.gotoAndPlay("hit")
                                }), i.on('pointerout', function() {
                                    return i.promises.gotoAndPlay("over")
                                }), i.on('pointerdown', function() {
                                    return t._sliderClicked = !0
                                }), i.on('pointerup', function() {
                                    return t._sliderClicked = !1
                                }), i.on('pointerupoutside', function() {
                                    return t._sliderClicked = !1
                                })
                    }
                }
            }, {
                key: '_updateTitle',
                value (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                            if (this.anim.title && t !== this._current) {
                        this.emit(Wd.TITLE_UPDATE, {
                            index: t
                        })
                                var n = this._anim.title.children[this._current];
                                    var r = this._anim.title.children[t]
                                n && (e ? n.promises.gotoAndStop('init') : n.promises.gotoAndPlay('hide')), r && (e ? r.promises.gotoAndStop('hide') : r.promises.gotoAndPlay('show')), this._current = t
                    }
                }
            }, {
                key: '_getScreensToLoad',
                value () {
                    var t = Id(this._config.screens)
                            return this.optionalScreenIndices.map(function(e) {
                                return t.splice(e, 0, e + 1)
                            }), new Object(oc.a)(this._createdScreens, t.concat(this.optionalScreenIndices))
                }
            }, {
                key: '_hasMissingScreens',
                value () {
                    return this._createdScreens.length !== this._config.screens.length + this.optionalScreenIndices.length
                }
            }, {
                key: '_attachMissingScreens',
                value () {
                    var t
                            if (!this.isLoading) {
                        var e = this._createRemainingScreens()
                                e.length && (this._setSymbolWins(e, this.settings), this._config.drawLines && this._drawLines(e, this.settings), (t = this._container).addChild.apply(t, Id(e)))
                    }
                }
            }, {
                key: '_createScreen',
                value (t, n) {
                    var r = n.arrangement;
                                var i = n.bounds;
                                var o = Ld(Fd(e.prototype), '_createScreen', this).call(this, t, {
                            arrangement: r,
                            bounds: i
                        })
                            return o.x = 'horizontal' === r ? i.width * (this._createdScreens.length - 1) : 0, o.y = 'vertical' === r ? i.height * (this._createdScreens.length - 1) : 0, o
                }
            }, {
                key: '_scrollTable',
                value (t) {
                    if (this._isSplashShown) {
                        this._killSmoothMove()
                                var e = Rd(this._bottomY, this._topY, this._container.y + t.y)
                                this._container.y = e, this._moveSlider(), this.slideTo(this._getNextIndex())
                    }
                }
            }, {
                key: '_moveSlider',
                value () {
                    if (this.anim.slider) {
                        var t = this.anim.slider;
                                    var e = t.sliderHead;
                                    var n = t.sliderBody;
                                    var r = Math.abs(this._bottomY + this._topY);
                                    var i = e.height / 2;
                                    var o = n.bodyHitArea.height - e.height / 2;
                                    var a = Math.abs(this._container.y / r);
                                    var s = n.bodyHitArea.height * a;
                                    var u = Rd(i, o, s)
                                e.y = u
                    }
                }
            }, {
                key: '_toggleListeners',
                value () {
                    var t = this;
                                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                            this._sliderShown && (e
? (window.addEventListener('touchstart', function(e) {
                                return t._touchstartStart(e)
                            }, !0), window.addEventListener('touchmove', function(e) {
                                return t._onMobileScroll(e)
                            }, !0), window.addEventListener('wheel', this._onScroll), window.addEventListener('keydown', this._onKeyDown))
: (window.removeEventListener('touchstart', this._touchstartStart, !0), window.removeEventListener('touchmove', this._onMobileScroll, !0), window.removeEventListener('wheel', this._onScroll), window.removeEventListener('keydown', this._onKeyDown)))
                }
            }, {
                key: '_onScroll',
                value (t) {
                    this._scrollTable({
                        y: -t.deltaY
                    })
                }
            }, {
                key: '_onMobileScroll',
                value (t) {
                    var e = t.touches[0].clientY;
                                var n = (this._mobileScrollStartY - e) * this._config.mobileScrollSpeed
                            this._mobileScrollStartY = e, this._scrollTable({
                        y: -n
                    })
                }
            }, {
                key: '_touchstartStart',
                value (t) {
                    this._mobileScrollStartY = t.touches[0].clientY
                }
            }, {
                key: '_onKeyDown',
                value (t) {
                    if ([Hd, Vd].includes(t.keyCode)) {
                        var e = this._config.arrowKeysDeltas;
                                    var n = e.up;
                                    var r = e.down
                                this._scrollTable({
                            y: t.keyCode === Hd ? n : r
                        })
                    }
                }
            }, {
                key: '_dragUpdate',
                value (t) {
                    var e = t.delta
                            this._scrollTable(e)
                }
            }, {
                key: '_dragEnd',
                value (t) {
                    t.direction
                }
            }, {
                key: '_initScreens',
                value () {
                    var t = this._anim;
                                var e = t.screens;
                                var n = t.title
                            n && n.children.forEach(function(t) {
                                return t.promises.gotoAndPlay("init")
                            }), this._container = e, this._config.bounds = this._container.getBounds(), this._config.bounds = Gd(Gd({}, this._config.bounds), {}, {
                        height: this._config.bounds.height - (this._config.offsets.height || 0),
                        width: this._config.bounds.width - (this._config.offsets.width || 0)
                    }), this._container.mask.name = 'paytableMask', this._container.removeChildren()
                }
            }, {
                key: '_initTitles',
                value () {
                    var t = this
                            if (this.anim.title) {
                        var e = this._config.optional;
                        (void 0 === e ? [] : e).map(function(t) {
                                    return t.index
                                }).filter(function(e) {
                                    return !t.optionalScreenIndices.includes(e - 1)
                                }).forEach(function(e) {
                                    return t.anim.title.removeChild(t.anim.title["title".concat(e)])
                                })
                    }
                }
            }, {
                key: '_onMouseMove',
                value (t) {
                    this._sliderClicked && (this._container.y = this._topY, this._scrollTable({
                        y: this._calcSliderPosition(t)
                    }))
                }
            }, {
                key: '_onSliderClick',
                value (t) {
                    this._smoothMove(this._calcSliderPosition(t))
                }
            }, {
                key: '_calcSliderPosition',
                value (t) {
                    return -this.anim.slider.toLocal(new o.Point(0, t.global.y)).y / this.anim.slider.sliderBody.bodyHitArea.height * Math.abs(this._bottomY + this._topY)
                }
            }, {
                key: '_smoothMove',
                value (t) {
                    var e = this;
                                var n = this._config.smoothSlide;
                                var r = n.ease;
                                var i = n.speed;
                                var o = Math.abs(this._container.y - t) / i
                            this._smoothMoveTimeline = a.a.to(this._container, {
                        y: t,
                        duration: o,
                        ease: r,
                        onUpdate: function () {
                            e._moveSlider(), e._updateTitle(e._getNextIndex())
                        }
                    })
                }
            }, {
                key: '_killSmoothMove',
                value () {
                    this._smoothMoveTimeline && (this._smoothMoveTimeline.kill(), this._smoothMoveTimeline = null)
                }
            }, {
                key: '_getNextIndex',
                value () {
                    var t = this;
                                var e = this._container.children.reduce(function(e, n) {
                                    var r = Math.abs(n.y + t._container.y);
                                    return Math.abs(e.y + t._container.y) < r ? e : n
                                }, this._container.children[0])
                            return this._hasLoaded ? this._container.children.indexOf(e) : 1
                }
            }, {
                key: '_loadInitialPage',
                value () {
                    if (!this._isInitialPageLoaded) {
                        this._isInitialPageLoaded = !0
                                var t = this._config;
                                    var e = t.splashNameSpace;
                                    var n = void 0 === e ? "PaytableScreen1" : e;
                                    var r = t.splashName;
                                    var i = void 0 === r ? 'paytableScreen1' : r
                                this._splashScreenMc = new uo.a[n][i](), this._splashScreenMc.name = i, this._container.removeChildren(), this._container.addChild(this._splashScreenMc)
                    }
                }
            }, {
                key: '_changeMasks',
                value () {
                    var t = this._container.mask;
                                var e = this._anim.maskVertical
                            t.alpha = 0, e.alpha = 1, this._container.mask = e
                }
            }, {
                key: 'slideToPays',
                value: (s = Nd(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, this._loadPages();
                                    case 2:
                                        return this._hasMissingScreens() && this._attachMissingScreens(), t.abrupt("return", this.slideTo(this.paysScreenIndex, e, !0));
                                    case 4:
                                    case "end":
                                        return t.stop()
                                }
                            }, t, this)
                })), function (t) {
                    return s.apply(this, arguments)
                })
            }], i = [{
                key: 'events',
                get () {
                    return Wd
                }
            }], r && Md(n.prototype, r), i && Md(n, i), e
        }(xc))
        const zd = {
            FreeSpinsStatus: A,
            FreeSpinsStartScreen: W,
            FreeSpinsBonusScreen: et,
            LoadingScreen: Xc,
            ReelMaster: nt.a,
            SpinningReelMaster: rt.a,
            FallingReelMaster: Se,
            SpinningMegaWaysReelMaster: Ln,
            SceneEffects: Hu,
            Cascade: bl,
            Cover: r.a,
            Choices: ir,
            Drag: Xn,
            WinBar: yr,
            WinLinesImage: Nr,
            WinLinesColor: Ur,
            WinTiles: fi,
            WinTile: bi,
            MegaWaysWinTile: Ri,
            Wins: Li,
            WaysWins: qi,
            WinWaysBar: ao,
            ReelCovers: ni,
            ExtraWin: Po,
            SkipStepExtraWin: Go,
            Rumble: Zo,
            HeaderBanners: Cc,
            StatefulControl: ta,
            PopupTiles: pa,
            Jackpots: Oa,
            Anticipation: ms,
            SpineCover: As.a,
            VideoCover: ic,
            Paytable: xc,
            PassingEffects: Os,
            CenterWinBar: Jc,
            LockedTiles: jl,
            Throbber: Gl,
            Camera: eh,
            TrailController: Js,
            MegaWaysCounter: pu,
            ParticlesContainer: co.a,
            SkipStepCounter: fh,
            ClusterWins: Sh,
            ClusterLabels: $h,
            ClusterWinFrames: af,
            ClusterWinLabel: Dh,
            RoyalWheel: ad,
            SpinningTilesPopupTiles: ku,
            SpinningTilesWinLines: Eu,
            CounterCover: gd,
            GambleStatus: Pd,
            ScrollablePaytable: Yd
        }

        function qd(t) {
            return (qd = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Kd(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Zd(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function $d(t, e, n) {
            return e = Jd(e),
            (function (t, e) {
                if (e && (qd(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Jd(t).constructor)
                : e.apply(t, n)))
        }

        function Jd(t) {
            return (Jd = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Qd(t, e) {
            return (Qd = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function tp(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function ep(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const np = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? tp(new Object(n), !0).forEach((e) => {
                            ep(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : tp(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, ms.events))
        let rp = (function (t) {
            function e() {
                return Kd(this, e), $d(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Qd(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return np
                }
            }], (r = [{
                key: '_startAnticipation',
                value(t) {
                    let n = this
                                var r = this._config.reels.filter((e) => {
                        return e === t && !n._activeReels.includes(t)
                    })
                    this._activeReels = r
                    var i = r.map((t) => {
                        return {
                            reel: t
                        }
                    })
                    this.emit(e.events.START, {
                        reelIndex: t
                    }), this.activate(i)
                }
            }, {
                key: '_getReelTileTotals',
                value(t) {
                    let e = this._config.tileIds || [].concat(this._config.tileId)
                                var n = [0]
                    return this._reelMaster.reels.forEach((r) => {
                        var i = t[r.index];
                                    var o = Ma(parseInt)(i);
                                    var a = e.filter(function(t) {
                                        return o[t]
                                    }).length
                                n.push(n[r.index] + a)
                    }), n.slice(0, -1)
                }
            }]) && Zd(n.prototype, r), i && Zd(n, i), e
        }(ms))
        let ip = n('./src/core/config/index.js')

        function op(t) {
            return (op = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ap(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function sp(t) {
            return (function (t) {
                if (Array.isArray(t)) return up(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return up(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return up(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function up(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function cp(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function lp(t, e, n) {
            return e = hp(e),
            (function (t, e) {
                if (e && (op(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], hp(t).constructor)
                : e.apply(t, n)))
        }

        function hp(t) {
            return (hp = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function fp(t, e) {
            return (fp = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const dp = (function (t) {
            function e(t) {
                let n; const r = t.name
                var i = t.reelMaster
                var o = t.source
                var a = t.config
                var s = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = lp(this, e, [{
                    name: r,
                    reelMaster: i,
                    source: o,
                    config: a,
                    mask: s
                }]))._activeReels = [], n._buffers = [], n.inclusiveIds = [], n.firstNoPopupReel = 0, n
            }
            let n, i, o, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && fp(t, e)
            }(e, t)), n = e, i = [{
                key: 'reset',
                value () {
                    this._activeReels = [], this.inclusiveIds = [], this.firstNoPopupReel = 0
                }
            }, {
                key: 'prepare',
                value (t) {
                    var e; let n = this._config
                                var r = n.reels
                                var i = n.tileId
                                var o = n.tileIds
                                var a = void 0 === o ? [] : o
                                var s = (e = []).concat.apply(e, [i].concat(sp(a)))
                    this.firstNoPopupReel = r.find((e) => {
                        return !t[e][1].find(function(t) {
                                    return s.includes(t)
                                })
                    })
                }
            }, {
                key: '_handleTileEnter',
                value: (a = regeneratorRuntime.mark(function t(n, r, i, o) {
                    let a
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (this._shouldTrigger({
                                                tileData: n,
                                                label: i,
                                                tileIndex: o,
                                                reelIndex: r
                                            })) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        return this._activeReels.push(r), a = this._createEffect({
                                            reel: r,
                                            index: 0,
                                            id: n.id
                                        }), this.emit(e.events.SHOW_START, {
                                            reelIndex: r,
                                            label: i,
                                            effect: a
                                        }), t.next = 7, a.show(this._config.onShow);
                                    case 7:
                                        this.removeChild(a), this.emit(e.events.SHOW_END, {
                                            reelIndex: r,
                                            label: i,
                                            effect: a
                                        });
                                    case 9:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                }), s = function () {
                    let t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = a.apply(t, e)

                        function o(t) {
                            ap(i, n, r, o, s, 'next', t)
                        }

                        function s(t) {
                            ap(i, n, r, o, s, 'throw', t)
                        }
                        o(void 0)
                    })
                }, function (t, e, n, r) {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_createEffect',
                value (t) {
                    var e = t.reel
                                var n = t.index
                                var i = this._sourceData
                                var o = i.cover
                                var a = void 0 === o ? r.a : o
                                var s = i.animation
                                var u = i.config
                                var c = i.mask
                                var l = this._reelMaster.getTilePosition({
                        reel: e,
                        index: n
                    })
                                var h = new a({
                        name: ''.concat(this.name, 'Cover').concat(n, 'x').concat(e),
                        animation: s,
                        config: u,
                        mask: c,
                        data: t
                    })
                    return h.reel = e, h.index = n, h.isRemoving = !1, h.position.set(l.x, l.y), this.addChild(h), h
                }
            }, {
                key: '_shouldTrigger',
                value (t) {
                    var e = t.tileData
                                var n = t.label
                                var r = t.tileIndex
                                var i = t.reelIndex
                                var o = this._config.reels
                                var a = !!((void 0 === o ? [] : o).length && i > this.firstNoPopupReel)
                                var s = this.inclusiveIds.length && this.inclusiveIds || this._config.tileIds || [].concat(this._config.tileId)
                    return !(a || e.replaced === 0 || this._activeReels.includes(i) || !this.enabled || !s.includes(e.id) || n === rt.a.labels.EASE_END || n === rt.a.labels.EASE_START || r >= ip.a.reels.tiles.visible)
                }
            }], o = [{
                key: 'events',
                get () {
                    return Hn.a
                }
            }], i && cp(n.prototype, i), o && cp(n, o), e
        }(Os))
        let pp = n('./src/utils/index.js')

        function mp(t) {
            return (mp = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function yp(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function vp(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        yp(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        yp(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function _p(t) {
            return (function (t) {
                if (Array.isArray(t)) return gp(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return gp(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return gp(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function gp(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function bp(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ep(t, e, n) {
            return e = Tp(e),
            (function (t, e) {
                if (e && (mp(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Tp(t).constructor)
                : e.apply(t, n)))
        }

        function xp(t, e, n) {
            return (xp = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Tp(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Tp(t) {
            return (Tp = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Sp(t, e) {
            return (Sp = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function wp(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Op(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Pp = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? wp(new Object(n), !0).forEach((e) => {
                            Op(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : wp(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, pa.events))
        let Rp = (function (t) {
            function e(t) {
                let n; const r = t.name
                let i = t.reelMaster
                let a = t.source
                let s = t.config
                let u = t.mask
                let c = t.anticipations
                let l = t.particlesContainer
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Ep(this, e, [{
                    name: r,
                    reelMaster: i,
                    source: a,
                    config: s,
                    mask: u
                }])).inactiveContainer = new o.Container(), n.firstNoPopupReel = 0, n._skippedTilePositions = [], n._isActive = !0, n._anticipations = c || [], n._particles = l, n
            }
            let n, r, i, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Sp(t, e)
            }(e, t)), n = e, r = [{
                key: 'allTiles',
                get() {
                    return [].concat(_p(this.children), _p(this.inactiveContainer.children))
                }
            }, {
                key: 'isAttached',
                get() {
                    return this.getCovers().some((t) => {
                        return t.attached
                    })
                }
            }, {
                key: 'prepare',
                value(t) {
                    let e; const n = this._config
                    var r = n.reels
                    var i = void 0 === r ? [] : r
                    var o = n.tileId
                    var a = n.tileIds
                    var s = void 0 === a ? [] : a
                    var u = (e = []).concat.apply(e, [o].concat(_p(s)))
                    this.firstNoPopupReel = i.find((e) => {
                        return !t[e][1].find((t) => {
                            return u.includes(t)
                        })
                    })
                }
            }, {
                key: 'includesId',
                value(t) {
                    let e = this._config
                    var n = e.tileId
                    var r = e.tileIds
                    var i = [].concat(n || r)
                    return i == null ? void 0 : i.includes(t)
                }
            }, {
                key: 'burstParticles',
                value: (a = vp(regeneratorRuntime.mark(function t() {
                    let e; const n = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                if (this._config.particles) {
                                    t.next = 2
                                            break
                                }
                                return t.abrupt('return');
                            case 2:
                                return this.allTiles.forEach(function(t) {
                                            return n._addParticles(t)
                                        }), this.emit(Pp.PARTICLE_EMIT), e = this._particles.children.map(function () {
                                    var t = vp(regeneratorRuntime.mark(function t(e) {
                                                var r;
                                                return regeneratorRuntime.wrap((function(t) {
                                                    for (;;) switch (t.prev = t.next) {
                                                        case 0:
                                                            return r = n._config.particles[e.name] || n._config.particles.defaultParticles, t.next = 3, e.activate({
                                                                duration: r.duration
                                                            });
                                                        case 3:
                                                            e.destroy({
                                                                children: !0
                                                            });
                                                        case 4:
                                                        case "end":
                                                            return t.stop()
                                                    }
                                                }), t)
                                            }))
                                            return function (e) {
                                        return t.apply(this, arguments)
                                    }
                                }()), t.next = 7, Promise.all(e)
                                    case 7:
                                this._particles.removeChildren()
                                    case 8:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'onDestroyed',
                value(t, n) {
                    let r = this._config.replaceOnDestroy;
                    (void 0 === r || r) && xp(Tp(e.prototype), 'onDestroyed', this).call(this, t, n)
                }
            }, {
                key: 'setSkippedPositions',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                    this._skippedTilePositions = t
                }
            }, {
                key: 'whenAllActive',
                value() {
                    return this._skippedTilePositions = [], xp(Tp(e.prototype), 'whenAllActive', this).call(this)
                }
            }, {
                key: 'activate',
                value(t) {
                    let n = this
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    this._isActive = !0
                    let i = [].concat(t).filter((t) => {
                        return !n._skippedTilePositions.some((e) => {
                            return e.reel === t.reel && e.index === t.index
                        })
                    })
                    return xp(Tp(e.prototype), 'activate', this).call(this, i, r)
                }
            }, {
                key: 'moveToInactive',
                value() {
                    let t; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.children
                    this._isActive = !1, e.length && (t = this.inactiveContainer).addChild.apply(t, _p(e))
                }
            }, {
                key: 'moveToActive',
                value(t) {
                    this._isActive = !0
                    let e = this.inactiveContainer.children
                    if (e.length && this.addChild.apply(this, _p(e)), t) {
                        let n; const r = this.getCovers(t)
                        var i = this.allTiles.filter((t) => {
                            return !r.some((e) => {
                                return t.reel === e.reel && t.index === e.index
                            })
                        })
                        i.length && (n = this.inactiveContainer).addChild.apply(n, _p(i))
                    }
                }
            }, {
                key: 'getCovers',
                value(t) {
                    let e = this
                    return t
                        ? [].concat(t).map((t) => {
                                const n = t.reel;
                                var r = t.index
                                return e._getCoverOnPos({
                                    reel: n,
                                    index: r
                                })
                            }).filter(Boolean)
                        : _p(this.allTiles)
                }
            }, {
                key: 'onShowStart',
                value(t, n, r, i) {
                    let o = r.reel
                    var a = r.index
                    var s = r.tileId
                    var u = this._config
                    var c = u.replaceOnShow
                    var l = void 0 === c || c
                    var h = u.reorderByIndex
                    var f = void 0 !== h && h
                    l && this._reelMaster.replaceTile(a, 0, o), f && this._reorderTiles(), i.silent || this.emit(e.events.TILE_ADD, {
                        reel: o,
                        index: a,
                        tileId: s,
                        total: this.children.length,
                        animLabel: n
                    }), !this.inactiveContainer.children.length && this._isActive || this.inactiveContainer.addChild(t)
                }
            }, {
                key: 'onReelEvent',
                value(t) {
                    let e = this._getMatchingData(t.reel)
                    var n = this._anticipations.some((t) => {
                        return t.isActive
                    })
                    var r = this._config.reels
                    var i = void 0 === r ? [] : r
                    if (!e.length || n) return Promise.resolve()
                    let o = i.length && t.reel.index > this.firstNoPopupReel ? 'init' : t.animLabel
                    return this.activate(e, {
                        animLabel: o,
                        attachToReels: t.attachToReels
                    })
                }
            }, {
                key: 'onShowEnd',
                value(t, n, r, i) {
                    new Object(k.c)(this._config, i).shouldLoop && xp(Tp(e.prototype), 'onShowEnd', this).call(this, t, n, r, i)
                }
            }, {
                key: '_reorderTiles',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getCovers()
                    var e = new Object(pp.e)(t, this._config.shouldAscend)
                    this.addChild.apply(this, _p(e))
                }
            }, {
                key: '_getCoverOnPos',
                value(t) {
                    let e = t.reel
                    var n = t.index
                    return this.allTiles.find((t) => {
                        return t.reel === e && t.index === n
                    })
                }
            }, {
                key: '_reset',
                value() {
                    this.allTiles.length || (this.isActive = !1, this.visible = !1, this._rtCache = {}, this._observeActivations = [])
                }
            }], i = [{
                key: 'events',
                get() {
                    return Pp
                }
            }], r && bp(n.prototype, r), i && bp(n, i), e
        }(pa))

        function Ap(t) {
            return (Ap = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Ip(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Cp(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Ip(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Ip(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function kp(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Np(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Mp(t, e, n) {
            return e = Dp(e),
            (function (t, e) {
                if (e && (Ap(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Dp(t).constructor)
                : e.apply(t, n)))
        }

        function jp(t, e, n) {
            return (jp = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Dp(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Dp(t) {
            return (Dp = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Lp(t, e) {
            return (Lp = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Fp(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Bp(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Fp(new Object(n), !0).forEach((e) => {
                            Up(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Fp(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Up(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Gp = Bp(Bp({}, Oa.events), {}, {
            DEACTIVATE_POPUPS: 'deactivate_popups'
        })
        const Xp = (function (t) {
            function e() {
                return kp(this, e), Mp(this, e, arguments)
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Lp(t, e)
            }(e, t)), n = e, r = [{
                key: 'activate',
                value: (a = Cp(regeneratorRuntime.mark(function t() {
                    let e; let n; let r = this
                                var i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (e = i.length > 0 && void 0 !== i[0] ? i[0] : [], !(n = e.filter((function(t) {
                                                return !t.screen
                                            }))).length) {
                                            t.next = 12;
                                            break
                                        }
                                        return t.next = 5, Object(k.d)(this._config.delays.spawn.beforeShow);
                                    case 5:
                                        return this._features.wins.deactivate(), this._features.rumble.start({
                                            duration: this._config.rumble.duration
                                        }), this.emit(Gp.DEACTIVATE_POPUPS), t.next = 10, this._spawnTiles(n);
                                    case 10:
                                        t.next = 14;
                                        break;
                                    case 12:
                                        return t.next = 14, Object(k.d)(or.a.jackpots.delayBeforeWin);
                                    case 14:
                                        return this._features.jackpotPopupTiles.burstParticles(), t.next = 17, Promise.all([this._features.fade.show(), this._features.jackpotPopupTiles.play("win")]);
                                    case 17:
                                        e.length === this._config.winTilesThreshold && this._playSiren(), Object(k.d)(or.a.jackpots.delayBeforeDestroy).then((function() {
                                            r._features.fade.hide()
                                        }));
                                    case 19:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_addTileToReel',
                value: (o = Cp(regeneratorRuntime.mark(function t(n) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return t.abrupt("return", jp(Dp(e.prototype), "_addTileToReel", this).call(this, Bp(Bp({}, n), {}, {
                                            tileId: or.a.jackpotPopupTiles.tileId
                                        })));
                                    case 1:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return o.apply(this, arguments)
                })
            }], i = [{
                key: 'events',
                get() {
                    return Gp
                }
            }], r && Np(n.prototype, r), i && Np(n, i), e
        }(Oa))

        function Hp(t) {
            return (Hp = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Vp(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Wp(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Vp(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Vp(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Yp(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function zp(t, e, n) {
            return e = Kp(e),
            (function (t, e) {
                if (e && (Hp(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Kp(t).constructor)
                : e.apply(t, n)))
        }

        function qp(t, e, n) {
            return (qp = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Kp(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Kp(t) {
            return (Kp = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Zp(t, e) {
            return (Zp = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function $p(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Jp(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? $p(new Object(n), !0).forEach((e) => {
                            Qp(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : $p(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Qp(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const tm = Jp(Jp({}, qi.events), {}, {
            SHOW_ALL_WAYS: 'show_all_ways',
            LOOP_START: 'loop_start'
        })
        const em = (function (t) {
            function e(t) {
                let n
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = zp(this, e, [t]))._isLooping = !0, n
            }
            let n, r, i, o, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Zp(t, e)
            }(e, t)), n = e, r = [{
                key: 'getWaysPositions',
                value(t) {
                    let e = this
                    return t.reduce((t, n) => {
                        var r = e._generatePositions(n).positions
                                return t.concat(r)
                    }, [])
                }
            }, {
                key: 'showAllWays',
                value: (s = Wp(regeneratorRuntime.mark(function t(e, n) {
                    let r; let i = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return r = e.reduce((function(t, e) {
                                            var n = i._generatePositions(e).skipped;
                                            return t.concat(n)
                                        }), []), this.emit(tm.SHOW_ALL_WAYS, {
                                            skipped: r
                                        }), t.next = 4, this.show(e, n);
                                    case 4:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'hideAllWays',
                value() {
                    return this.deactivate()
                }
            }, {
                key: 'startLoop',
                value(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    if (!this._isLooping) { return this.emit(tm.LOOP_START), this._isLooping = !0, this._loop(t, Jp(Jp({}, e), {}, {
                        firstIteration: !0
                    }))
                    }
                }
            }, {
                key: '_showSingle',
                value: (a = Wp(regeneratorRuntime.mark(function t(n, r) {
                    let i; let o; let a; let s; let u; let c; let l; let h = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (i = h.length > 2 && void 0 !== h[2] ? h[2] : {}, o = Object(me.a)(i, this._config), a = o.delays.betweenShows, s = this._generatePositions(n), u = s.positions, c = s.skipped, !((l = a * r) > 0)) {
                                            t.next = 7;
                                            break
                                        }
                                        return t.next = 7, Object(k.d)(l);
                                    case 7:
                                        return i.silent || this.emit(e.events.SHOW_SINGLE, {
                                            winData: n,
                                            positions: u,
                                            skipped: c,
                                            index: r
                                        }), i.onTilesShow && i.onTilesShow({
                                            winData: n,
                                            positions: u,
                                            skipped: c,
                                            index: r
                                        }), t.abrupt("return", this.tiles.activate(u, i));
                                    case 10:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_loop',
                value: (o = Wp(regeneratorRuntime.mark(function t(e, n) {
                    let r; let i = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (this._isLooping) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        return r = e.map((function(t) {
                                            return i._showSingle(t, 0, Jp(Jp({}, n), {}, {
                                                multipleWays: e.length > 1
                                            }))
                                        })), t.next = 5, Promise.all(r);
                                    case 5:
                                        this.remove(), this._loop(e, Jp(Jp({}, n), {}, {
                                            firstIteration: !1
                                        }));
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t, e) {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'deactivate',
                value() {
                    return this._isLooping = !1, qp(Kp(e.prototype), 'deactivate', this).call(this)
                }
            }], i = [{
                key: 'events',
                get() {
                    return tm
                }
            }], r && Yp(n.prototype, r), i && Yp(n, i), e
        }(qi))

        function nm(t) {
            return (nm = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function rm(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function im(t, e, n) {
            return e = am(e),
            (function (t, e) {
                if (e && (nm(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], am(t).constructor)
                : e.apply(t, n)))
        }

        function om(t, e, n) {
            return (om = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = am(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function am(t) {
            return (am = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function sm(t, e) {
            return (sm = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const um = (function (t) {
            function e(t) {
                let n
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = im(this, e, [t]))._anim.bg.promises.gotoAndPlay('reel'.concat(or.a.reels.count - 1)), n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && sm(t, e)
            }(e, t)), n = e, (r = [{
                key: 'show',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                    om(am(e.prototype), 'show', this).call(this, t)
                    var n = t.reelIndex
                                var r = void 0 === n ? or.a.reels.count - 1 : n
                    return this._anim.bg.promises.gotoAndPlay('reel'.concat(r))
                }
            }]) && rm(n.prototype, r), i && rm(n, i), e
        }(r.a))
        let cm = ['type', 'animLabel', 'shouldLoop']

        function lm(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function hm(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function fm(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        hm(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        hm(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function dm(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const pm = (function () {
            function t(e) {
                let n = e.idles
                var r = e.scenes
                var i = e.particles
                var o = e.config
                var a = e.transitions
                var s = e.reactiveScenes
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.currentIdleType = 'normal', this._idles = n, this._transitions = a, this._scenes = r, this._particles = i, this._config = o, this._reactiveScenes = s
            }
            let e, n, r, i
            return e = t, (n = [{
                key: 'sceneType',
                get () {
                    return Lt.a.get(Lt.a.TYPES.IN_FREE_SPINS) ? 'special' : 'normal'
                }
            }, {
                key: 'startIdles',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.currentIdleType
                    this._idles && (this.currentIdleType = t, this._exec(this._idles[t], (t) => {
                        return t.activate()
                    }))
                }
            }, {
                key: 'stopIdles',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.currentIdleType
                                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                    this._idles && this._exec(this._idles[t], (t) => {
                        return t.deactivate(e)
                    })
                }
            }, {
                key: 'changeReactiveScene',
                value () {
                    var t = this
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var n = e.type
                                var r = void 0 === n ? this.sceneType : n
                                var i = e.shouldLoop
                                var o = void 0 === i || i
                                var a = Object.keys(this._reactiveScenes).filter((t) => {
                        return t !== r
                    })
                        return a.forEach((e) => {
                        var n = t._reactiveScenes[e];
                                    var i = t._reactiveScenes[r]
                                n.filter(function(t) {
                                    return !i.some((function(e) {
                                        return e === t
                                    }))
                                }).forEach(function(t) {
                                    return t.hide()
                                })
                    }), Promise.all(this._reactiveScenes[r].map(function () {
                        var t = fm(regeneratorRuntime.mark(function t(e) {
                            return regeneratorRuntime.wrap(function(t) {
                                        for (;;) switch (t.prev = t.next) {
                                            case 0:
                                                return t.next = 2, e.show();
                                            case 2:
                                                o && e.play("loop", {
                                                    repeat: -1
                                                });
                                            case 3:
                                            case "end":
                                                return t.stop()
                                        }
                                    }, t)
                        }))
                        return function (e) {
                            return t.apply(this, arguments)
                        }
                    }()))
                }
            }, {
                key: 'playReaction',
                value () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var e = t.type
                                var n = void 0 === e ? this.sceneType : e
                                var r = t.animLabel
                                var i = void 0 === r ? 'reaction' : r
                                var o = (t.shouldLoop, lm(t, cm))
                    return Promise.all(this._reactiveScenes[n].map(function () {
                        var t = fm(regeneratorRuntime.mark(function t(e) {
                            return regeneratorRuntime.wrap(function(t) {
                                        for (;;) switch (t.prev = t.next) {
                                            case 0:
                                                return t.next = 2, e.play(i, o);
                                            case 2:
                                                e.play("loop", {
                                                    repeat: -1
                                                });
                                            case 3:
                                            case "end":
                                                return t.stop()
                                        }
                                    }, t)
                        }))
                        return function (e) {
                            return t.apply(this, arguments)
                        }
                    }()))
                }
            }, {
                key: 'changeScene',
                value (t, e) {
                    Object.values(this._scenes).forEach((n) => {
                        return n.change(t, e)
                    })
                }
            }, {
                key: 'changeParticles',
                value: (i = fm(regeneratorRuntime.mark(function t() {
                    let e; let n; let r = this
                                var i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (e = i.length > 0 && void 0 !== i[0] ? i[0] : "normal", n = i.length > 1 ? i[1] : void 0, this._particles) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 4:
                                        this.deactivateParticles(n), this._config.particles[e].forEach((function(t) {
                                            return r._particles[t].activate()
                                        }));
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return i.apply(this, arguments)
                })
            }, {
                key: 'deactivateParticles',
                value (t) {
                    this._particles && Object.values(this._particles).forEach((e) => {
                        return e.deactivate(t)
                    })
                }
            }, {
                key: '_exec',
                value (t, e) {
                    t.length && t.forEach((t) => {
                        return e(t)
                    })
                }
            }]) && dm(e.prototype, n), r && dm(e, r), t
        }())
        let mm = n('./src/features/ParticlesContainer.js')

        function ym(t) {
            return (ym = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function vm(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function _m(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        vm(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        vm(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function gm(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function bm(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Em(t, e, n) {
            return e = Tm(e),
            (function (t, e) {
                if (e && (ym(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Tm(t).constructor)
                : e.apply(t, n)))
        }

        function xm(t, e, n) {
            return (xm = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Tm(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Tm(t) {
            return (Tm = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Sm(t, e) {
            return (Sm = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const wm = (function (t) {
            function e() {
                let t
                gm(this, e)
                for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i]
                return (t = Em(this, e, [].concat(r)))._type = null, t._counterMc.numContainer.skew.set(t._config.skew.x, t._config.skew.y), t
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Sm(t, e)
            }(e, t)), n = e, (r = [{
                key: 'activate',
                value: (a = _m(regeneratorRuntime.mark(function t() {
                    let e; let n; let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (e = i.length > 0 && void 0 !== i[0] ? i[0] : {}, n = e.mode, void 0 !== (r = e.spins)) {
                                            t.next = 4;
                                            break
                                        }
                                        throw new Error("Spins count not provided!");
                                    case 4:
                                        return this._counter.reset(), this._count = r, this._isInLastSpin = !1, this._addCounter(), this._counter.update(this._count), this._changeType(n), this._updateTitle(), t.next = 13, this.show();
                                    case 13:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'update',
                value: (o = _m(regeneratorRuntime.mark(function t() {
                    let n; let r; let i = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = i.length > 0 && void 0 !== i[0] ? i[0] : {}, r = n.mode, this._changeType(r), t.next = 5, xm(Tm(e.prototype), "update", this).call(this, n);
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_changeType',
                value (t) {
                    var e = this
                    this._type = t, ['textContainer', 'plate'].forEach((n) => {
                        e._anim[n].promises.gotoAndStop(t)
                    })
                }
            }, {
                key: '_updateTitle',
                value () {
                    var t = this.anim.textContainer
                                var e = this.animLabels
                                var n = e.LAST_SPIN
                                var r = e.RETURN_SPINS
                                var i = e.SPIN
                                var o = e.SPINS
                                var a = e.INIT
                    this._count ? (this._isInLastSpin && this.play(r), this._count === 1 ? t[''.concat(this._type, 'ТextContainer')].promises.gotoAndPlay(i) : [o, a].includes(t[''.concat(this._type, 'ТextContainer')].currentLabel) || t[''.concat(this._type, 'ТextContainer')].promises.gotoAndPlay(o), this._isInLastSpin = !1) : (this._isInLastSpin = !0, this.play(n))
                }
            }]) && bm(n.prototype, r), i && bm(n, i), e
        }(A))
        let Om = n('./src/core/utils/AsyncAction.js')

        function Pm(t) {
            return (Pm = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const Rm = ['skinName']

        function Am(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function Im(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Cm(t, e) {
            if (e && (Pm(e) === 'object' || typeof e == 'function')) return e
            if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
            return (function (t) {
                if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                return t
            }(t))
        }

        function km(t) {
            return (km = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Nm(t, e) {
            return (Nm = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Mm = (function (t) {
            function e(t) {
                let n; const r = t.skinName
                var i = Am(t, Rm)
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = (function (t, e, n) {
                    return e = km(e), Cm(t, (function () {
                        if ('undefined' == typeof Reflect || !Reflect.construct) return !1
                            if (Reflect.construct.sham) return !1
                            if ('function' == typeof Proxy) return !0
                            try {
                            return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
                        } catch (t) {
                            return !1
                        }
                    }())
? Reflect.construct(e, n || [], km(t).constructor)
                        : e.apply(t, n))
                }(this, e, [i]))).asyncAction = void 0, n._repeat = 0, n._loopCount = 0, r ? (n._anim.skeleton.setSkinByName(r), n) : Cm(n)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Nm(t, e)
            }(e, t)), n = e, (r = [{
                key: 'play',
                value(t) {
                    let e; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    if (!this._hasAnimation(this._anim, t)) return console.warn('['.concat(this.name, '] Missing animation: ').concat(t)), Promise.resolve()
                    var r = n.repeat
                            var i = void 0 === r ? 0 : r
                    return this._loopCount = 0, this._repeat = i, (e = this.asyncAction) === null || void 0 === e || e.complete(), this.asyncAction = new Om.a(), this._anim.parent || this.addChild(this._anim), this._anim.state.setAnimation(0, t, !!this._repeat), this._anim.state.addListener({
                        complete: this._onPlayEnd.bind(this)
                    }), this.asyncAction.wait()
                }
            }, {
                key: 'stop',
                value() {
                    this._loopCount = 0, this._repeat = 0, this._onPlayEnd(this._anim.state.tracks[0])
                }
            }, {
                key: 'finish',
                value() {
                    return this._repeat !== 0 && this._anim.state.addListener({
                        complete: this._onPlayEnd.bind(this)
                    }), this._loopCount = 0, this._repeat = 0, this.asyncAction.wait()
                }
            }, {
                key: 'skip',
                value() {
                    this._repeat = 0, this._loopCount = 0, this.asyncAction.complete()
                    var t = this.anim.state.tracks[0]
                    t && (t.animationStart = t.animationEnd)
                }
            }, {
                key: '_onPlayEnd',
                value(t) {
                    this._repeat >= 0 ? (this._loopCount++, this._loopCount !== this._repeat && this._repeat !== 0 || (t.loop = !1, this._removeAnimListeners('complete'), this.asyncAction.complete())) : (this._removeAnimListeners('complete'), this.asyncAction.complete())
                }
            }]) && Im(n.prototype, r), i && Im(n, i), e
        }(As.a))

        function jm(t) {
            return (jm = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Dm(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Lm(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Fm(t, e, n) {
            return e = Bm(e),
            (function (t, e) {
                if (e && (jm(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Bm(t).constructor)
                : e.apply(t, n)))
        }

        function Bm(t) {
            return (Bm = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Um(t, e) {
            return (Um = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Gm = (function (t) {
            function e() {
                return Dm(this, e), Fm(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Um(t, e)
            }(e, t)), n = e, (r = [{
                key: 'lockedReels',
                get() {
                    return this.allTiles.filter((t) => {
                        return t.isLocked
                    }).map((t) => {
                        return t.reel
                    })
                }
            }, {
                key: 'setLockTiles',
                value() {
                    let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                    this.allTiles.forEach((e) => {
                        e.isLocked = t
                    })
                }
            }]) && Lm(n.prototype, r), i && Lm(n, i), e
        }(Rp))

        function Xm(t) {
            return (Xm = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Hm(t) {
            return (function (t) {
                if (Array.isArray(t)) return Vm(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return Vm(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Vm(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function Vm(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function Wm(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ym(t, e, n) {
            return e = zm(e),
            (function (t, e) {
                if (e && (Xm(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], zm(t).constructor)
                : e.apply(t, n)))
        }

        function zm(t) {
            return (zm = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function qm(t, e) {
            return (qm = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Km(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Zm(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Km(new Object(n), !0).forEach((e) => {
                            $m(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Km(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function $m(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Jm = {
            ANTICIPATION_WIN: 'anticipationWin',
            IDLE: 'idle',
            POPUP: 'popup',
            HIDE: 'hideNormal'
        }
        const Qm = Zm(Zm({}, Gm.events), {}, {
            WIN: 'win'
        })
        const ty = (function (t) {
            function e(t) {
                let n
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Ym(this, e, [t])).skipTiles = [], n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && qm(t, e)
            }(e, t)), n = e, i = [{
                key: 'animLabels',
                get() {
                    return Jm
                }
            }], (r = [{
                key: 'events',
                get() {
                    return Qm
                }
            }, {
                key: 'win',
                value(t) {
                    return this.emit(e.events.WIN), t != null && t.length
                        ? this.play('wildWin', t, {
                                repeat: -1
                            })
                        : this.play('anticipationWin', null)
                }
            }, {
                key: 'onShowEnd',
                value(t) {
                    let n = e.animLabels.IDLE
                    return t.play(n, {
                        repeat: -1
                    })
                }
            }, {
                key: '_createCover',
                value(t, e) {
                    let n = e.cover
                    return new (void 0 === n ? Mm : n)({
                        animation: e.animation,
                        skinName: this._config.skinPrefix && ''.concat(this._config.skinPrefix).concat(t.tileId)
                    })
                }
            }, {
                key: '_getMatchingData',
                value(t) {
                    let e = this
                                var n = this._config.tileIds || [].concat(this._config.tileId)
                    return this._reelMaster.getResultData(t.index).reduce((r, i, o) => {
                        return !e.skipTiles.some(function(e) {
                                    return Object(pp.c)(e, {
                                        reel: t.index,
                                        index: o
                                    })
                                }) && n.includes(i.id)
? [].concat(Hm(r), [Zm({
                                    reel: t.index,
                                    index: o,
                                    tileId: i.id
                                }, i)])
: r
                    }, [])
                }
            }]) && Wm(n.prototype, r), i && Wm(n, i), e
        }(Gm))

        function ey(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function ny(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        ey(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        ey(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function ry(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }
        const iy = (function () {
            function t(e) {
                const n = e.animation
                var r = e.tileId
                !(function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, t)), this.anim = n, this.id = -1, this.isSkipped = !1, this._activatedPays = [], this.updateTile(r)
            }
            let e, n, r, i, o, a, s
            return e = t, (n = [{
                key: 'show',
                value: (s = ny(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, this.anim.promises.gotoAndPlay("show");
                                case 2:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'win',
                value: (a = ny(regeneratorRuntime.mark(function t(e) {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return this.isSelected = !0, this._activatedPays.push("X".concat(e)), this.anim.paysContainer["X".concat(e)].promises.gotoAndPlay("win"), this._getInactivePays().forEach((function(t) {
                                        return t.promises.gotoAndStop("deselect")
                                    })), t.next = 6, this.anim.promises.gotoAndPlay("win");
                                case 6:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function (t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'winLoop',
                value() {
                    this.isSkipped || this.anim.promises.gotoAndPlay('winLoop', {
                        repeat: -1
                    })
                }
            }, {
                key: 'reset',
                value: (o = ny(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return this._deactivatePays(), t.next = 3, this.anim.promises.gotoAndPlay("active");
                                case 3:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: 'deactivate',
                value: (i = ny(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    return this._deactivatePays(), t.next = 3, this.anim.promises.gotoAndPlay("deactivate");
                                case 3:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                })), function () {
                    return i.apply(this, arguments)
                })
            }, {
                key: 'updateTile',
                value(t) {
                    let e = 'tile'.concat(t)
                    this.id = t, this.anim.tileContainer.promises.gotoAndStop(e), this.anim.tileContainerAdd.promises.gotoAndStop(e)
                }
            }, {
                key: '_deactivatePays',
                value() {
                    let t = this
                    this._activatedPays.length && (this._activatedPays.forEach((e) => {
                        return t.anim.paysContainer[e].promises.gotoAndPlay('winDeactivate')
                    }), this._getInactivePays().forEach((t) => {
                        return t.promises.gotoAndStop('init')
                    }), this._activatedPays = [])
                }
            }, {
                key: '_getInactivePays',
                value() {
                    return this.anim.paysContainer.children.filter((t) => {
                        return 'win' !== t.currentLabel
                    })
                }
            }]) && ry(e.prototype, n), r && ry(e, r), t
        }())

        function oy(t) {
            return (oy = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ay(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function sy(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? ay(new Object(n), !0).forEach((e) => {
                            uy(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : ay(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function uy(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }

        function cy(t) {
            return (function (t) {
                if (Array.isArray(t)) return ly(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return ly(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ly(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function ly(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function hy(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function fy(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        hy(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        hy(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function dy(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function py(t, e, n) {
            return e = my(e),
            (function (t, e) {
                if (e && (oy(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], my(t).constructor)
                : e.apply(t, n)))
        }

        function my(t) {
            return (my = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function yy(t, e) {
            return (yy = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const vy = {
            NORMAL: 'normal',
            FREE_SPINS: 'freeSpins',
            WIN_SPINS: 'winSpins',
            WILD_SPINS: 'wildSpins'
        }
        const _y = {
            11: vy.FREE_SPINS,
            13: vy.FREE_SPINS,
            14: vy.WIN_SPINS,
            15: vy.WILD_SPINS
        }
        const gy = (function (t) {
            function e(t) {
                let n; const r = t.animation
                var i = t.settings
                var o = t.config
                var a = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = py(this, e, [{
                    animation: r,
                    config: o,
                    mask: a
                }]))._tileCounts = {}, n._isSkipped = !1, n._isReset = !1, n._tiles = n._createTiles(), n.changeScene(), n._createPayoutTexts(i), n._initTiles(), n._idle(), n
            }
            let n, r, i, a, s
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && yy(t, e)
            }(e, t)), n = e, (r = [{
                key: 'sceneType',
                get() {
                    return vy
                }
            }, {
                key: 'selectTiles',
                value: (s = fy(regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i; let o = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (n = this._getLoosingTiles(e), this._isReset = !1, this._isSkipped && (this._isSkipped = !1, this._tiles.forEach((function(t) {
                                                return t.isSkipped = !1
                                            }))), !e.length) {
                                            t.next = 11;
                                            break
                                        }
                                        r = regeneratorRuntime.mark((function t() {
                                            var n, r, a;
                                            return regeneratorRuntime.wrap((function(t) {
                                                for (;;) switch (t.prev = t.next) {
                                                    case 0:
                                                        n = e[i], r = n.tile, (a = o._tiles.find((function(t) {
                                                            return t.id === r
                                                        }))).win(n.length).then((function() {
                                                            o._isReset || a.winLoop()
                                                        }));
                                                    case 4:
                                                    case "end":
                                                        return t.stop()
                                                }
                                            }), t)
                                        })), i = 0;
                                    case 6:
                                        if (!(i < e.length)) {
                                            t.next = 11;
                                            break
                                        }
                                        return t.delegateYield(r(), "t0", 8);
                                    case 8:
                                        i++, t.next = 6;
                                        break;
                                    case 11:
                                        n.forEach((function(t) {
                                            return t.deactivate()
                                        }));
                                    case 12:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: 'skip',
                value() {
                    this._isSkipped = !0, this._tiles.forEach((t) => {
                        return t.isSkipped = !0
                    })
                }
            }, {
                key: 'changeScene',
                value(t) {
                    let e = ''
                    e = t ? _y[t] : vy.NORMAL, this.anim.slotPaytableBg.promises.gotoAndStop(e)
                }
            }, {
                key: 'reset',
                value(t) {
                    let e = this._config.wildTileId
                    this._isReset = !0, this._tileCounts = {}, this._tiles.forEach((n) => {
                        var r = n.id === e;
                                    var i = "active" === n.anim.currentLabel;
                                    var o = 'deactivate' === n.anim.currentLabel
                                r ? t && !i ? n.reset() : t || o || n.deactivate() : i || n.reset()
                    })
                }
            }, {
                key: '_getLoosingTiles',
                value(t) {
                    return t.length
                        ? this._tiles.reduce((e, n) => {
                                return t.filter(function(t) {
                                    return t.tile === n.id
                                }).length
? e
: [].concat(cy(e), [n])
                            }, [])
                        : this._tiles
                }
            }, {
                key: '_updateFsPayouts',
                value(t) {
                    let e = this._fsPayouts.find((e) => {
                        return e.id === t
                    }).pays
                    this._createPayoutText(e, this._config.normalFsTileId, !0)
                }
            }, {
                key: '_idle',
                value: (a = fy(regeneratorRuntime.mark(function t() {
                    let e, n, r, i, o
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return e = this._config.idle.delay, n = e.min, r = e.max, i = Object(k.i)(n, r), o = this._getIdleLabel(), t.next = 5, Object(k.d)(i);
                                    case 5:
                                        return t.next = 7, this.anim.promises.gotoAndPlay(o);
                                    case 7:
                                        return t.abrupt("return", this._idle());
                                    case 8:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_getIdleLabel',
                value() {
                    let t = new Object(k.i)(0, 1)
                    return this._config.idle.labels[t]
                }
            }, {
                key: '_createTiles',
                value() {
                    let t = this
                    return this.anim.children.filter((t) => {
                        return t.name.includes('tile')
                    }).map((e) => {
                        var n = Number.parseInt(e.name.split('tile')[1]);
                                    var r = 'tile'.concat(n)
                                return new iy({
                            animation: t.anim[r],
                            tileId: n
                        })
                    })
                }
            }, {
                key: '_createPayoutTexts',
                value(t) {
                    let e = this
                    this._tiles.forEach((n) => {
                        var r = t.find(function(t) {
                                    return t.id === n.id
                                });
                        if (!r) return console.warn('Settings for tile with id: '.concat(n.id, ' was not found !'))
                                e._createPayoutText(r.pays, n)
                    })
                }
            }, {
                key: '_createPayoutText',
                value(t, e) {
                    let n = this
                                var r = t.filter((t) => {
                        return t > 0
                    }).reverse()
                    e.anim.paysContainer.children.reverse().forEach((t, e) => {
                        var i = r[e]
                                if (i) {
                            var a = i === Number.parseInt(i, 10);
                                        var s = "x".concat(i < 10 && a ? "@" : null).concat(i);
                                        var u = new o.BitmapText(s, sy(sy({}, n._config.textSettings), {}, {
                                    fontSize: t.paysContainer.inner.height
                                }))
                                    t.paysContainer.removeChildren(), t.paysContainer.addChild(u)
                        }
                    })
                }
            }, {
                key: '_initTiles',
                value() {
                    let t = this
                    this._tiles.forEach((e) => {
                        e.id === t._config.wildTileId ? e.deactivate() : e.reset()
                    })
                }
            }]) && dy(n.prototype, r), i && dy(n, i), e
        }(r.a))

        function by(t) {
            return (by = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const Ey = ['mode']

        function xy(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Ty(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        xy(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        xy(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Sy(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function wy(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Oy(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Py(t, e, n) {
            return e = Ay(e),
            (function (t, e) {
                if (e && (by(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Ay(t).constructor)
                : e.apply(t, n)))
        }

        function Ry(t, e, n) {
            return (Ry = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Ay(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Ay(t) {
            return (Ay = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Iy(t, e) {
            return (Iy = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Cy(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function ky(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Cy(new Object(n), !0).forEach((e) => {
                            Ny(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Cy(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Ny(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const My = ky(ky({}, r.a.events), {}, {
            BUTTON_CLICKED: 'button_clicked',
            COUNT_END: 'count_end'
        })
        const jy = (function (t) {
            function e() {
                return wy(this, e), Py(this, e, arguments)
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Iy(t, e)
            }(e, t)), n = e, r = [{
                key: 'show',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                                var n = t.mode
                                var r = Sy(t, Ey)
                                var i = new Object(pp.a)(this._config.spineAnim, this.anim.spineContainer, !0)
                    return i.anim.skeleton.setSkinByName(n), this.anim.splashTxt.promises.gotoAndPlay(n), Ry(Ay(e.prototype), 'show', this).call(this, r)
                }
            }, {
                key: 'showStart',
                value: (a = Ty(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return I.a.emit(I.a.events.FEATURE_CONTROLS_SHOW, {
                                            options: this._getButtonOptions()
                                        }), t.next = 3, C.a.when("FREE_SPINS_START");
                                    case 3:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: 'start',
                value: (o = Ty(regeneratorRuntime.mark(function t() {
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        I.a.emit(I.a.events.FEATURE_CONTROLS_HIDE), this.emit(e.events.BUTTON_CLICKED);
                                    case 2:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_getButtonOptions',
                value() {
                    return {
                        align: 'center',
                        buttons: [{
                            name: 'FREE_SPINS_START',
                            label: s.c.texts.FREE_SPINS_START,
                            type: 'primary',
                            size: 'large',
                            spacebar: !0
                        }]
                    }
                }
            }], i = [{
                key: 'events',
                get() {
                    return My
                }
            }], r && Oy(n.prototype, r), i && Oy(n, i), e
        }(r.a))

        function Dy(t) {
            return (Dy = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Ly(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Fy(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function By(t, e, n) {
            return e = Uy(e),
            (function (t, e) {
                if (e && (Dy(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Uy(t).constructor)
                : e.apply(t, n)))
        }

        function Uy(t) {
            return (Uy = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Gy(t, e) {
            return (Gy = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const Xy = (function (t) {
            function e(t) {
                let n; const r = t.animation
                var i = t.config
                var o = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = By(this, e, [{
                    animation: r,
                    config: i,
                    mask: o
                }]))._isActive = !1, n._animations = n._anim.children, n._shouldLoop = n._animations.length > 0, n._prevIdle = null, n.addChild(n._anim), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Gy(t, e)
            }(e, t)), n = e, (r = [{
                key: 'isActive',
                get() {
                    return this._isActive
                }
            }, {
                key: 'activate',
                value() {
                    this._playConstantLoops(), this._playIdles()
                }
            }, {
                key: 'deactivate',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                    this._shouldLoop = !1, this._isActive = !1, t && this._animations.forEach((t) => {
                        return t.promises.gotoAndStop('init')
                    })
                }
            }, {
                key: '_playIdles',
                value: (o = regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a = this
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    if (this._shouldLoop = !0, this._isActive = !0, n = this._animations.filter((function(t) {
                                            return !a._config.constantLoops.some((function(e) {
                                                return e === t.name
                                            }))
                                        })), r = Object(k.i)(this._config.delay.min, this._config.delay.max), i = Object(k.b)(this._config.mainLabelChance) ? 0 : Object(k.i)(0, n.length - 1), (o = n[i]).labels.find((function(t) {
                                            return "show" === t.label
                                        }))) {
                                        t.next = 9;
                                        break
                                    }
                                    return t.abrupt("return", console.warn("Trying to play show label, on anim ".concat(o, " , which doesn't have it.")));
                                case 9:
                                    return this.emit(e.events.ACTIVATE_START, {
                                        idleNumber: i + 1
                                    }), t.next = 12, o.promises.gotoAndPlay("show");
                                case 12:
                                    if (this.emit(e.events.ACTIVATE_END, {
                                            idleNumber: i + 1
                                        }), this._prevIdle = o, !(r > 0)) {
                                        t.next = 17;
                                        break
                                    }
                                    return t.next = 17, Object(k.d)(r);
                                case 17:
                                    return t.abrupt("return", this._shouldLoop && this._playIdles());
                                case 18:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                }), a = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = o.apply(t, e)

                        function a(t) {
                            Ly(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            Ly(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_playConstantLoops',
                value() {
                    let t = this
                    this._config.constantLoops.forEach((e) => {
                        t._animations.find(function(t) {
                                return t.name === e
                            }).promises.gotoAndPlay('show', {
                            repeat: -1
                        })
                    })
                }
            }]) && Fy(n.prototype, r), i && Fy(n, i), e
        }(r.a))

        function Hy(t) {
            return (Hy = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function Vy(t) {
            return (function (t) {
                if (Array.isArray(t)) return Wy(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return Wy(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Wy(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function Wy(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function Yy(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function zy(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        Yy(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        Yy(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function qy(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ky(t, e, n) {
            return e = $y(e),
            (function (t, e) {
                if (e && (Hy(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], $y(t).constructor)
                : e.apply(t, n)))
        }

        function Zy(t, e, n) {
            return (Zy = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = $y(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function $y(t) {
            return ($y = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Jy(t, e) {
            return (Jy = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Qy(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function tv(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Qy(new Object(n), !0).forEach((e) => {
                            ev(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Qy(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function ev(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const nv = tv(tv({}, ni.events), {}, {
            WILD_SPAWN: 'wild_spawn'
        })
        const rv = (function (t) {
            function e(t) {
                let n; const r = t.reelMaster
                var i = t.source
                var o = t.config
                var a = t.mask
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Ky(this, e, [{
                    reelMaster: r,
                    config: o,
                    mask: a
                }]))._wildAnim = i.animation, n._expWildAnim = i.animation2, n._counter = 0, n
            }
            let n, r, i, o
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Jy(t, e)
            }(e, t)), n = e, r = [{
                key: 'activate',
                value: (o = zy(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s; let u = this
                                var c = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        return n = c.length > 0 && void 0 !== c[0] ? c[0] : {}, this.isActive = !0, r = n.animLabel, i = void 0 === r ? "wildSpawn" : r, this.emit(e.events.SHOW_START, {
                                            label: i
                                        }), this.visible = !0, o = this._generateReelsData(), a = Object(k.n)(Vy(o), !0), s = a.map(function() {
                                            var t = zy(regeneratorRuntime.mark((function t(n, r) {
                                                var o;
                                                return regeneratorRuntime.wrap((function(t) {
                                                    for (;;) switch (t.prev = t.next) {
                                                        case 0:
                                                            return o = u._config.delayThreshold * r, t.next = 3, Object(k.d)(o);
                                                        case 3:
                                                            return u.emit(e.events.WILD_SPAWN), t.next = 6, Zy($y(e.prototype), "activate", u).call(u, n, {
                                                                animLabel: i,
                                                                force: !0
                                                            });
                                                        case 6:
                                                        case "end":
                                                            return t.stop()
                                                    }
                                                }), t)
                                            })));
                                            return function(e, n) {
                                                return t.apply(this, arguments)
                                            }
                                        }()), t.next = 10, Promise.all(s);
                                    case 10:
                                        return t.abrupt("return", t.sent);
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return o.apply(this, arguments)
                })
            }, {
                key: '_createCover',
                value(t, e) {
                    let n = e.cover
                                var r = void 0 === n ? Mm : n
                                var i = this._counter < this._config.wildRatioThreshold ? this._wildAnim : this._expWildAnim
                    return this._counter > this._config.wildRatioThreshold && (this._counter = 0), this._counter++, new r({
                        animation: i
                    })
                }
            }, {
                key: '_generateReelsData',
                value() {
                    for (var t = this._config, e = t.reels, n = t.reelThreshold, r = t.tileThreshold, i = [], o = 0; o < n; o++) {
                        for (let a = 0; a < r; a++) i.push(this._generatePosition(e[o], a))
}
                    return i
                }
            }, {
                key: '_generatePosition',
                value(t, e) {
                    return {
                        reel: t,
                        index: e
                    }
                }
            }], i = [{
                key: 'events',
                get() {
                    return nv
                }
            }], r && qy(n.prototype, r), i && qy(n, i), e
        }(ni))

        function iv(t) {
            return (iv = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function ov(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function av(t) {
            return (function (t) {
                if (Array.isArray(t)) return sv(t)
            }(t)) || (function (t) {
                if (typeof Symbol != 'undefined' && t[Symbol.iterator] != null || t['@@iterator'] != null) return Array.from(t)
            }(t)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return sv(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sv(t, e)
            }(t)) || (function () {
                throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function sv(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function uv(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function cv(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function lv(t, e, n) {
            return e = fv(e),
            (function (t, e) {
                if (e && (iv(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], fv(t).constructor)
                : e.apply(t, n)))
        }

        function hv(t, e, n) {
            return (hv = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = fv(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function fv(t) {
            return (fv = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function dv(t, e) {
            return (dv = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function pv(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function mv(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const yv = (function (t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? pv(new Object(n), !0).forEach((e) => {
                            mv(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : pv(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }({}, xc.events))
        let vv = (function (t) {
            function e() {
                let t, n
                uv(this, e)
                for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o]
                return (n = lv(this, e, [].concat(i)))._particlesContainer = n._anim.particlesContainer, n._particles = new Object(pp.b)({
                    configs: n._config.particles,
                    animateTarget: 'SceneParticles',
                    guide: (new uo.a.SceneParticles.emitterGuide2()).guide
                }), n._particlesContainer.removeChildren(), (t = n._particlesContainer).addChild.apply(t, av(n._particles)), n._attachListener(), n
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && dv(t, e)
            }(e, t)), n = e, r = [{
                key: '_attachListener',
                value() {
                    let t = this
                    this.on(e.events.SLIDE_SCREEN, (e) => {
                        let n = e.to
                        return t._onSlideScreen(n)
                    })
                }
            }, {
                key: '_onSlideScreen',
                value(t) {
                    t === this._config.targetParticlesPage
                        ? this._particles.forEach((t) => {
                                return t.activate()
                            })
                        : this._particles.forEach((t) => {
                                return t.deactivate()
                            })
                }
            }, {
                key: '_createScreen',
                value() {
                    for (var t, n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i]
                    let o = (t = hv(fv(e.prototype), '_createScreen', this)).call.apply(t, [this].concat(r))
                    return o.name === 'paytableScreen1' && (this._addSpineAnim(o), this._particles.forEach((t) => {
                        return t.activate()
                    })), o
                }
            }, {
                key: '_addSpineAnim',
                value(t) {
                    let e = this
                    var n = this._config.spine.tileSpine
                    this._tileCovers = this._config.spine.spineContainers.map((e) => {
                        return new Object(pp.a)(n, t['spineContainer'.concat(e)])
                    }) || [], this._tileCovers.forEach((t) => {
                        return e._spineLoop(t)
                    }), this._tileCovers.forEach((t, n) => {
                        return t.anim.skeleton.setSkinByName('tile'.concat(e._config.spine.initialSkinIndex + n))
                    })
                }
            }, {
                key: '_spineLoop',
                value: (o = regeneratorRuntime.mark(function t(e) {
                    let n
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                            case 0:
                                return n = this._config.spine.loopStates, e.currentAnim = n, t.next = 4, e.play(n)
                                    case 4:
                                return t.abrupt('return', this._spineLoop(e))
                                    case 5:
                            case 'end':
                                return t.stop()
                        }
                        }
                    }, t, this)
                }), a = function () {
                    const t = this
                    let e = arguments
                    return new Promise((n, r) => {
                        const i = o.apply(t, e)

                        function a(t) {
                            ov(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            ov(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function (t) {
                    return a.apply(this, arguments)
                })
            }], i = [{
                key: 'events',
                get() {
                    return yv
                }
            }], r && cv(n.prototype, r), i && cv(n, i), e
        }(xc))

        function _v(t) {
            return (_v = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function gv(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function bv(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Ev(t, e, n) {
            return e = Tv(e),
            (function (t, e) {
                if (e && (_v(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Tv(t).constructor)
                : e.apply(t, n)))
        }

        function xv(t, e, n) {
            return (xv = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Tv(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Tv(t) {
            return (Tv = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Sv(t, e) {
            return (Sv = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function wv(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Ov(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? wv(new Object(n), !0).forEach((e) => {
                            Pv(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : wv(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Pv(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Rv = Ov(Ov({}, y.events), {}, {
            BANGUP_INCREMENT: 'bangup_increment',
            BANGUP_START: 'bangup_start'
        })
        const Av = (function (t) {
            function e() {
                return gv(this, e), Ev(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Sv(t, e)
            }(e, t)), n = e, i = [{
                key: 'events',
                get() {
                    return Rv
                }
            }], (r = [{
                key: 'update',
                value(t, n) {
                    return n != null && n.duration && this.emit(e.events.BANGUP_START), xv(Tv(e.prototype), 'update', this).call(this, t, n)
                }
            }, {
                key: 'speedUpBangup',
                value(t, e) {
                    let n = (this._updateTween.duration() - this._updateTween.time()) * t
                    a.a.from(this._updateTween, {
                        duration: n,
                        timeScale: e
                    })
                }
            }, {
                key: 'updateConfig',
                value(t) {
                    this._config = new Object(k.c)(this._config, t), this._template = t.template || '{{val}}', this._updateNum(this._count)
                }
            }, {
                key: 'reset',
                value() {
                    xv(Tv(e.prototype), 'reset', this).call(this), this.scale.set(1)
                }
            }, {
                key: '_updateNum',
                value(t) {
                    if (this._count < t && this.emit(e.events.BANGUP_INCREMENT, {
                        value: t
                    }), xv(Tv(e.prototype), '_updateNum', this).call(this, t), this._fitBounds) {
                        let n = this._config.fitSettings || {}
                                    var r = n.ignoreRatio
                                    var i = void 0 !== r && r
                                    var o = n.overscale
                                    var a = void 0 !== o && o
                        Object(k.e)(this, this._fitBounds, i, a)
                    }
                }
            }, {
                key: '_format',
                value(t) {
                    let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2
                                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this._config.useCustomFormat
                    if (r) {
                        let i = Number.parseFloat(t)
                        return i.toFixed(n)
                    }
                    return xv(Tv(e.prototype), '_format', this).call(this, t, n)
                }
            }]) && bv(n.prototype, r), i && bv(n, i), e
        }(y))

        function Iv(t) {
            return (Iv = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }
        const Cv = ['thresholds', 'animation', 'bgAnim', 'config', 'mask', 'counterConstructor', 'bgContainer']

        function kv(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function Nv(t) {
            return function () {
                const e = this
                const n = arguments
                return new Promise((r, i) => {
                    const o = t.apply(e, n)

                    function a(t) {
                        kv(o, r, i, a, s, 'next', t)
                    }

                    function s(t) {
                        kv(o, r, i, a, s, 'throw', t)
                    }
                    a(void 0)
                })
            }
        }

        function Mv(t, e) {
            if (t == null) return {}
            let n; let r; const i = (function (t, e) {
                if (t == null) return {}
                let n; let r; const i = {}
                var o = Object.keys(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || (i[n] = t[n])
                return i
            }(t, e))
            if (Object.getOwnPropertySymbols) {
                const o = Object.getOwnPropertySymbols(t)
                for (r = 0; r < o.length; r++) n = o[r], e.includes(n) || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
            }
            return i
        }

        function jv(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Dv(t, e, n) {
            return e = Fv(e),
            (function (t, e) {
                if (e && (Iv(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Fv(t).constructor)
                : e.apply(t, n)))
        }

        function Lv(t, e, n) {
            return (Lv = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Fv(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Fv(t) {
            return (Fv = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Bv(t, e) {
            return (Bv = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function Uv(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function Gv(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? Uv(new Object(n), !0).forEach((e) => {
                            Xv(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : Uv(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function Xv(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const Hv = Gv({}, Po.events)
        const Vv = Gv({}, Po.types)
        const Wv = (function (t) {
            function e(t) {
                let n; const r = t.thresholds
                var i = t.animation
                var o = t.bgAnim
                var a = t.config
                var s = t.mask
                var u = t.counterConstructor
                var c = t.bgContainer
                var l = Mv(t, Cv)
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = Dv(this, e, [Gv({
                    thresholds: r,
                    animation: i,
                    config: a,
                    mask: s,
                    counterConstructor: u
                }, l)])).bgContainer = c, n._bgAnim = o, n._background = null, n._particles = null, n._spineAnims = {}, n
            }
            let n, i, o, a, s, u, c, l
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Bv(t, e)
            }(e, t)), n = e, i = [{
                key: 'allParticles',
                get() {
                    return new Object(pe.a)(Object.values(this._particles))
                }
            }, {
                key: 'showBackground',
                value() {
                    let t; let e; let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.type
                    this.roundHasCelebrations && ((t = this._background) !== null && void 0 !== t && t.isShown || (e = this._background) !== null && void 0 !== e && e.isShowing || (this.type || (this.type = n), this._config.backgrounds.includes(n) && (this._initBg(), this._background.show())))
                }
            }, {
                key: 'showLabel',
                value() {
                    let t
                    if (this.roundHasCelebrations) {
                        Lt.a.set(Lt.a.TYPES.IS_WHOLE_GAME_STAGE_USED, !0), Lt.a.set(Lt.a.TYPES.RESULT_READY, !0), this._showSpine()
                        for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i]
                        return (t = Lv(Fv(e.prototype), 'showLabel', this)).call.apply(t, [this].concat(r))
                    }
                }
            }, {
                key: 'showEwLabel',
                value: (l = Nv(regeneratorRuntime.mark(function t(e) {
                    let n; let r; let i = this
                                var o = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (n = !(o.length > 1 && void 0 !== o[1]) || o[1], r = o.length > 2 && void 0 !== o[2] ? o[2] : "showBottom", this.roundHasCelebrations) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 4:
                                        return this.type = e, t.next = 7, Object(k.d)(this._config.labelShowDelay[e]);
                                    case 7:
                                        this.showBackground(), this.showLabel(e, "show"), e !== Vv.NORMAL_WIN && this.playSum({
                                            anim: r
                                        }).then((function() {
                                            return i.pulseSum()
                                        })), n && this.speedUpBangup(e);
                                    case 11:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function (t) {
                    return l.apply(this, arguments)
                })
            }, {
                key: 'hide',
                value: (c = Nv(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a; let s; let u = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (r = u.length > 0 && void 0 !== u[0] ? u[0] : {}, i = r.sumAnim, o = void 0 === i ? "hide" : i, a = r.labelsAnim, s = void 0 === a ? "hide" : a, this.roundHasCelebrations) {
                                            t.next = 3;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 3:
                                        return t.next = 5, Promise.all([null === (n = this._background) || void 0 === n ? void 0 : n.hide(), Lv(Fv(e.prototype), "hide", this).call(this, {
                                            sumAnim: o,
                                            labelsAnim: s
                                        }), this._hideSpine()]);
                                    case 5:
                                        Lt.a.set(Lt.a.TYPES.IS_WHOLE_GAME_STAGE_USED, !1), Lt.a.set(Lt.a.TYPES.RESULT_READY, !1);
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return c.apply(this, arguments)
                })
            }, {
                key: 'speedUpBangup',
                value(t) {
                    if (this.roundHasCelebrations) {
                        let e = this._config.speedUp
                                    var n = e.durationMultiplier
                                    var r = e.timeScale
                        this.counter.speedUpBangup(n[t], r)
                    }
                }
            }, {
                key: 'addParticles',
                value(t) {
                    this._particles = t
                }
            }, {
                key: 'activateParticles',
                value() {
                    this.roundHasCelebrations && this.allParticles.forEach((t) => {
                        return t.activate()
                    })
                }
            }, {
                key: 'deactivateParticles',
                value() {
                    this.roundHasCelebrations && this.allParticles.forEach((t) => {
                        return t.deactivate()
                    })
                }
            }, {
                key: 'bangup',
                value: (u = Nv(regeneratorRuntime.mark(function t() {
                    let n; let r; let i; let o; let a = arguments
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        for (this.isSkipped = !1, r = a.length, i = new Array(r), o = 0; o < r; o++) i[o] = a[o];
                                        return t.next = 4, (n = Lv(Fv(e.prototype), "bangup", this)).call.apply(n, [this].concat(i));
                                    case 4:
                                        this.stopPulse();
                                    case 5:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return u.apply(this, arguments)
                })
            }, {
                key: 'reset',
                value() {
                    Lv(Fv(e.prototype), 'reset', this).call(this), this.sumInner.scale.set(1, 1), this.sumInner.initialScale = this._config.pulseSum.initialScale
                }
            }, {
                key: '_showSpine',
                value: (s = Nv(regeneratorRuntime.mark(function t() {
                    let e, n
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (null !== (e = this.winLabels[this.type]) && void 0 !== e && e.spineContainer) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        return this._spineAnims[this.type] || (this._spineAnims[this.type] = this._createSpine()), (n = this._spineAnims[this.type]).anim.skeleton.setSkinByName("wildSpins"), t.next = 7, n.show();
                                    case 7:
                                        n.play("loop", {
                                            repeat: -1
                                        });
                                    case 8:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return s.apply(this, arguments)
                })
            }, {
                key: '_hideSpine',
                value: (a = Nv(regeneratorRuntime.mark(function t() {
                    let e, n
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                    case 0:
                                        if (this._spineAnims[this.type]) {
                                            t.next = 2;
                                            break
                                        }
                                        return t.abrupt("return");
                                    case 2:
                                        e = this._config.spineContainerName || "spineContainer", null == (n = this.winLabels[this.type][e]) || n.removeChildren(), delete this._spineAnims[this.type];
                                    case 6:
                                    case "end":
                                        return t.stop()
                                }
}
                    }, t, this)
                })), function () {
                    return a.apply(this, arguments)
                })
            }, {
                key: '_createSpine',
                value() {
                    let t = this._config.spineContainerName || 'spineContainer';
                        var e = this.winLabels[this.type][t]
                    return new Object(pp.a)(this._config.spineAnimName, e)
                }
            }, {
                key: '_initBg',
                value() {
                    let t = new r.a({
                        animation: this._bgAnim[''.concat(this.type, 'Bg')]
                    })
                    this.bgContainer.removeChildren(), this.bgContainer.addChild(t), this._background = t
                }
            }, {
                key: '_createCounter',
                value() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                    this.counter || (Lv(Fv(e.prototype), '_createCounter', this).call(this, t), new Object(k.e)(this.counter, {
                        width: this._fitBounds.width,
                        height: this._fitBounds.height
                    }, !1, !0))
                }
            }], o = [{
                key: 'events',
                get() {
                    return Hv
                }
            }, {
                key: 'types',
                get() {
                    return Vv
                }
            }], i && jv(n.prototype, i), o && jv(n, o), e
        }(Po))

        function Yv(t) {
            return (Yv = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function zv(t, e, n, r, i, o, a) {
            try {
                var s = t[o](a)
                var u = s.value
            } catch (t) {
                return void n(t)
            }
            s.done ? e(u) : Promise.resolve(u).then(r, i)
        }

        function qv(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function Kv(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function Zv(t, e, n) {
            return e = Jv(e),
            (function (t, e) {
                if (e && (Yv(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], Jv(t).constructor)
                : e.apply(t, n)))
        }

        function $v(t, e, n) {
            return ($v = typeof Reflect != 'undefined' && Reflect.get
                ? Reflect.get
                : function (t, e, n) {
                    const r = (function (t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Jv(t)) !== null;);
                        return t
                    }(t, e))
                    if (r) {
                        const i = Object.getOwnPropertyDescriptor(r, e)
                        return i.get ? i.get.call(n) : i.value
                    }
                })(t, e, n || t)
        }

        function Jv(t) {
            return (Jv = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function Qv(t, e) {
            return (Qv = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const t_ = (function (t) {
            function e() {
                return qv(this, e), Zv(this, e, arguments)
            }
            let n, r, i, o, a
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Qv(t, e)
            }(e, t)), n = e, (r = [{
                key: '_createAnim',
                value(t) {
                    $v(Jv(e.prototype), '_createAnim', this).call(this, t)
                }
            }, {
                key: '_init',
                value() {
                    for (var t, n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
                    (t = $v(Jv(e.prototype), '_init', this)).call.apply(t, [this].concat(r)), this._initSpines(this._anim.paytable1), this._startLoops(), this.show()
                }
            }, {
                key: '_initSpines',
                value(t) {
                    let e = this
                            var n = this._config.tileSpine
                    this._tileCovers = this._config.spineContainers.map((e) => {
                        return new Object(pp.a)(n, t['spineContainer'.concat(e)])
                    }) || [], this._tileCovers.forEach((t, n) => {
                        return t.anim.skeleton.setSkinByName('tile'.concat(e._config.initialSkinIndex + n))
                    })
                }
            }, {
                key: '_startLoops',
                value() {
                    let t = this
                    this._tileCovers.forEach((e) => {
                        return t._spineLoop(e)
                    })
                }
            }, {
                key: '_spineLoop',
                value: (o = regeneratorRuntime.mark(function t(e) {
                    let n
                    return regeneratorRuntime.wrap(function (t) {
                        for (;;) { switch (t.prev = t.next) {
                                case 0:
                                    if (this._config) {
                                        t.next = 2;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 2:
                                    return n = this._config.loopStates, e.currentAnim = n, t.next = 6, e.play(n);
                                case 6:
                                    return t.abrupt("return", this._spineLoop(e));
                                case 7:
                                case "end":
                                    return t.stop()
                            }
}
                    }, t, this)
                }), a = function () {
                    const t = this
                    var e = arguments
                    return new Promise((n, r) => {
                        let i = o.apply(t, e)

                        function a(t) {
                            zv(i, n, r, a, s, 'next', t)
                        }

                        function s(t) {
                            zv(i, n, r, a, s, 'throw', t)
                        }
                        a(void 0)
                    })
                }, function (t) {
                    return a.apply(this, arguments)
                })
            }]) && Kv(n.prototype, r), i && Kv(n, i), e
        }(Xc))

        function e_(t) {
            return (e_ = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function n_(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function r_(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function i_(t, e, n) {
            return e = o_(e),
            (function (t, e) {
                if (e && (e_(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], o_(t).constructor)
                : e.apply(t, n)))
        }

        function o_(t) {
            return (o_ = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function a_(t, e) {
            return (a_ = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function s_(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function u_(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? s_(new Object(n), !0).forEach((e) => {
                            c_(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : s_(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function c_(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const l_ = u_(u_({}, ty.animLabels), {}, {
            IDLE_LOCK: 'idleLock'
        })
        const h_ = (function (t) {
            function e() {
                return n_(this, e), i_(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && a_(t, e)
            }(e, t)), n = e, i = [{
                key: 'animLabels',
                get() {
                    return l_
                }
            }], (r = [{
                key: 'onReelEvent',
                value(t) {
                    let e = this._getMatchingData(t.reel)
                                var n = this._anticipations.some((t) => {
                        return t.isActive
                    })
                    if (!e.length || n) return Promise.resolve()
                    var r = t.animLabel
                    return this.activate(e, {
                        animLabel: r,
                        attachToReels: t.attachToReels,
                        isWildSpins: t.isWildSpins
                    })
                }
            }, {
                key: 'onShowEnd',
                value(t, n, r, i) {
                    let o = i.isWildSpins ? e.animLabels.IDLE_LOCK : e.animLabels.IDLE
                    return t.play(o, {
                        repeat: -1
                    })
                }
            }]) && r_(n.prototype, r), i && r_(n, i), e
        }(ty))

        function f_(t) {
            return (f_ = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function d_(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function p_(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function m_(t, e, n) {
            return e = y_(e),
            (function (t, e) {
                if (e && (f_(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], y_(t).constructor)
                : e.apply(t, n)))
        }

        function y_(t) {
            return (y_ = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function v_(t, e) {
            return (v_ = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const __ = (function (t) {
            function e() {
                return d_(this, e), m_(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && v_(t, e)
            }(e, t)), n = e, (r = [{
                key: 'onReelEvent',
                value(t) {
                    let e = this._getMatchingData(t.reel)
                            var n = this._anticipations.some((t) => {
                        return t.isActive
                    })
                    if (!e.length || n) return Promise.resolve()
                    var r = this._config.winOnMaxTiles && this.allTiles.length + e.length >= this._config.maxTiles
                            var i = t.reel.index > this.firstNoPopupReel ? 'init' : r ? 'anticipationWin' : t.animLabel
                    return r && (i = 'anticipationWin', this.play(i)), this.activate(e, {
                        animLabel: i,
                        attachToReels: t.attachToReels,
                        winOnMaxTiles: r
                    })
                }
            }, {
                key: 'onShowEnd',
                value(t, e, n, r) {
                    let i = new Object(k.c)(this._config, r)
                            var o = ty.animLabels.IDLE
                    return i.shouldLoop && t.play(o, {
                        repeat: -1
                    })
                }
            }]) && p_(n.prototype, r), i && p_(n, i), e
        }(ty))

        function g_(t) {
            return (g_ = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function b_(t, e) {
            if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
        }

        function E_(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function x_(t, e, n) {
            return e = T_(e),
            (function (t, e) {
                if (e && (g_(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return (function (t) {
                    if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
                    return t
                }(t))
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], T_(t).constructor)
                : e.apply(t, n)))
        }

        function T_(t) {
            return (T_ = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function S_(t, e) {
            return (S_ = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const w_ = (function (t) {
            function e() {
                return b_(this, e), x_(this, e, arguments)
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && S_(t, e)
            }(e, t)), n = e, (r = [{
                key: 'activate',
                value() {
                    return !1
                }
            }]) && E_(n.prototype, r), i && E_(n, i), e
        }(ms))

        function O_(t) {
            return (O_ = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (t) {
                    return typeof t
                }
                : function (t) {
                    return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t
                })(t)
        }

        function P_(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        function R_(t, e, n) {
            return e = A_(e),
            (function (t, e) {
                if (e && (O_(e) === 'object' || typeof e == 'function')) return e
                if (void 0 !== e) throw new TypeError('Derived constructors may only return object or undefined')
                return I_(t)
            }(t, (function () {
                if (typeof Reflect == 'undefined' || !Reflect.construct) return !1
                if (Reflect.construct.sham) return !1
                if (typeof Proxy == 'function') return !0
                try {
                    return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], () => {}))
                } catch (t) {
                    return !1
                }
            }())
                ? Reflect.construct(e, n || [], A_(t).constructor)
                : e.apply(t, n)))
        }

        function A_(t) {
            return (A_ = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
        }

        function I_(t) {
            if (void 0 === t) throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')
            return t
        }

        function C_(t, e) {
            return (C_ = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }
        const k_ = (function (t) {
            function e(t) {
                let n; const r = t.gameContainer
                var i = t.config
                var o = t.renderer
                var a = t.slotWays
                var s = t.winBar
                return (function (t, e) {
                    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function')
                }(this, e)), (n = R_(this, e))._gameContainer = r, n._config = i, n._renderer = o, n._slotWays = a, n._winBar = s, I.a.on(I.a.events.RESIZE, n._onResize.bind(I_(n))), n
            }
            let n, r, i
            return (function (t, e) {
                if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function')
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && C_(t, e)
            }(e, t)), n = e, (r = [{
                key: 'orientationTypes',
                get() {
                    return {
                        LANDSCAPE: 'landscape',
                        PORTRAIT: 'portrait'
                    }
                }
            }, {
                key: 'orientation',
                get() {
                    return this.ratio >= this._config.landscapeThreshold ? this.orientationTypes.LANDSCAPE : this.orientationTypes.PORTRAIT
                }
            }, {
                key: 'ratio',
                get() {
                    return this._renderer._activeStageProps.width / this._renderer._activeStageProps.height
                }
            }, {
                key: '_onResize',
                value() {
                    let t = this.orientation === this.orientationTypes.LANDSCAPE
                    this._slotWays.renderable = !t && this._winBar.value
                }
            }]) && P_(n.prototype, r), i && P_(n, i), e
        }(s.b))

        function N_(t, e) {
            const n = Object.keys(t)
            if (Object.getOwnPropertySymbols) {
                let r = Object.getOwnPropertySymbols(t)
                e && (r = r.filter((e) => {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                })), n.push.apply(n, r)
            }
            return n
        }

        function M_(t) {
            for (let e = 1; e < arguments.length; e++) {
                var n = arguments[e] != null ? arguments[e] : {}
                e % 2
                    ? N_(new Object(n), !0).forEach((e) => {
                            j_(t, e, n[e])
                        })
                    : Object.getOwnPropertyDescriptors
                        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
                        : N_(new Object(n)).forEach((e) => {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            })
            }
            return t
        }

        function j_(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        e.a = M_(M_({}, zd), {}, {
            SceneController: pm,
            Anticipation: rp,
            PassingEffects: dp,
            PopupTiles: Rp,
            Jackpots: Xp,
            WaysWins: em,
            ParticlesContainer: mm.a,
            Fade: um,
            VaryingFreeSpinsStatus: wm,
            SpinePopupCover: Mm,
            SpinePopupTiles: ty,
            SlotPaytable: gy,
            BonusSplashScreen: jy,
            SceneIdle: Xy,
            FreeSpinsSpawn: rv,
            Paytable: vv,
            Counter: Av,
            ExtraWin: Wv,
            LoadingScreen: t_,
            FatWildLocked: Gm,
            LockPopupTiles: h_,
            FreeSpinsPopupTiles: __,
            MiniAnticipation: w_,
            ViewportTracker: k_
        })
    },
    './src/states.js': function (t, e, n) {
        'use strict'
        n.d(e, 'a', () => {
            return r
        })
        var r = {
            INIT: 'init',
            INTRO: 'intro',
            READY: 'ready',
            PLAY_START: 'play_start',
            PLAY_DATA: 'play_data',
            PLAY_STOP: 'play_stop',
            PLAY_END: 'play_end',
            WILD_EXPAND: 'wild_expand',
            WIN_LINES: 'win_lines',
            WIN_LINES_EW: 'win_lines_ew',
            WIN_LINES_SUM: 'win_lines_sum',
            WIN_LINES_NO_WIN: 'win_lines_no_win',
            FREE_SPINS_START: 'free_spins_start',
            FREE_SPINS_BONUS: 'free_spins_bonus',
            TOTAL_WIN: 'total_win',
            JACKPOT_WIN: 'jackpot_win',
            FINISH: 'finish'
        }
    },
    './src/texts/index.js': function (t, e, n) {
        'use strict'
        let r; const i = {
            'bg': {
                CANNOT_PRELOAD_ASSETS: 'Активите не успяха да се презаредят:',
                NO_CONNECTION: 'Няма връзка със сървъра',
                REMOVE_LOCKED_TILES: 'Промяната на залога сега ще махне всички заключени плочки.',
                TITLE_SERVER_ERROR: 'Грешка в Сървъра',
                CHOICE_GAMBLE: 'Заложи',
                CHOICE_COLLECT: 'Вземи',
                CHOICE_EXCHANGE: 'Обмени',
                CHOICE_SPIN: 'Завърти',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Продължи',
                FREE_SPINS_START: 'Старт'
            },
            'cs': {
                CANNOT_PRELOAD_ASSETS: 'Položky nelze nahrát:',
                NO_CONNECTION: 'Chybí připojení na server',
                REMOVE_LOCKED_TILES: 'Změna vkladu odstraní všechna uzamčená pole.',
                TITLE_SERVER_ERROR: 'Chyba serveru',
                CHOICE_GAMBLE: 'Vsadit',
                CHOICE_COLLECT: 'Sebrat',
                CHOICE_EXCHANGE: 'Vyměňte',
                CHOICE_SPIN: 'Roztočit',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Pokračovat',
                FREE_SPINS_START: 'Spustit'
            },
            'da': {
                CANNOT_PRELOAD_ASSETS: 'Kan ikke forindlæse aktiver:',
                NO_CONNECTION: 'Ingen forbindelse til server',
                REMOVE_LOCKED_TILES: 'Ændrer du din indsats nu, fjerner det alle låste felter.',
                TITLE_SERVER_ERROR: 'Serverfejl',
                CHOICE_GAMBLE: 'Gamble',
                CHOICE_COLLECT: 'Indsaml',
                CHOICE_EXCHANGE: 'Veksel',
                CHOICE_SPIN: 'Spin',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Fortsæt',
                FREE_SPINS_START: 'Start'
            },
            'de': {
                CANNOT_PRELOAD_ASSETS: 'Objekte können nicht im Voraus geladen werden:',
                NO_CONNECTION: 'Keine Verbindung zum Server',
                REMOVE_LOCKED_TILES: 'Durch eine Änderung der Wette zum jetzigen Zeitpunkt werden alle gesperrten Kacheln entfernt.',
                TITLE_SERVER_ERROR: 'Serverfehler',
                CHOICE_GAMBLE: 'Spielen',
                CHOICE_COLLECT: 'Sammeln',
                CHOICE_EXCHANGE: 'Austausch',
                CHOICE_SPIN: 'Drehen',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Weiter',
                FREE_SPINS_START: 'Start'
            },
            'en': {
                CANNOT_PRELOAD_ASSETS: 'Cannot preload assets:',
                NO_CONNECTION: 'No connection to server',
                REMOVE_LOCKED_TILES: 'Changing your stake now will remove all the locked tiles.',
                TITLE_SERVER_ERROR: 'Server Error',
                CHOICE_GAMBLE: 'Gamble',
                CHOICE_COLLECT: 'Collect',
                CHOICE_EXCHANGE: 'Exchange',
                CHOICE_SPIN: 'Spin',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continue',
                FREE_SPINS_START: 'Start'
            },
            'en-US': {
                CANNOT_PRELOAD_ASSETS: 'Cannot preload assets:',
                NO_CONNECTION: 'No connection to server',
                REMOVE_LOCKED_TILES: 'Changing your stake now will remove all the locked tiles.',
                TITLE_SERVER_ERROR: 'Server Error',
                CHOICE_GAMBLE: 'Gamble',
                CHOICE_COLLECT: 'Collect',
                CHOICE_EXCHANGE: 'Exchange',
                CHOICE_SPIN: 'Spin',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continue',
                FREE_SPINS_START: 'Start'
            },
            'en-SC': {
                CANNOT_PRELOAD_ASSETS: 'Cannot preload assets:',
                NO_CONNECTION: 'No connection to server',
                REMOVE_LOCKED_TILES: 'Changing your play amount now will remove all the locked tiles.',
                TITLE_SERVER_ERROR: 'Server Error',
                CHOICE_GAMBLE: 'Take a Chance',
                CHOICE_COLLECT: 'Collect',
                CHOICE_EXCHANGE: 'Exchange',
                CHOICE_SPIN: 'Spin',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continue',
                FREE_SPINS_START: 'Start'
            },
            'el': {
                CANNOT_PRELOAD_ASSETS: 'Δεν είναι δυνατή η προφόρτωση των αποκτημάτων:',
                NO_CONNECTION: 'Δεν υπάρχει σύνδεση στον διακομιστή',
                REMOVE_LOCKED_TILES: 'Η αλλαγή του ποσού πονταρίσματός σας τώρα θα καταργήσει όλα τα κλειδωμένα πλακίδια.',
                TITLE_SERVER_ERROR: 'Σφάλμα διακομιστή',
                CHOICE_GAMBLE: 'Ρισκαρετε',
                CHOICE_COLLECT: 'ΕΙΣΠΡΑΞΤΕ',
                CHOICE_EXCHANGE: 'Ανταλλαξτε',
                CHOICE_SPIN: 'Περιστρ.',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'ΣΥΝΕΧΕΙΑ',
                FREE_SPINS_START: 'ΕΝΑΡΞΗ'
            },
            'es': {
                CANNOT_PRELOAD_ASSETS: 'No se pueden precargar los valores:',
                NO_CONNECTION: 'No hay conexión al servidor',
                REMOVE_LOCKED_TILES: 'Si cambia la apuesta ahora se quitarán todas las posiciones bloqueadas.',
                TITLE_SERVER_ERROR: 'Error del servidor',
                CHOICE_GAMBLE: 'Apostar',
                CHOICE_COLLECT: 'Recaudar',
                CHOICE_EXCHANGE: 'Intercambia',
                CHOICE_SPIN: 'Girar',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continuar',
                FREE_SPINS_START: 'Empezar'
            },
            'es-PE': {
                CANNOT_PRELOAD_ASSETS: 'No se pueden cargar los activos:',
                NO_CONNECTION: 'Se perdió la conexión con el servidor.',
                REMOVE_LOCKED_TILES: 'Si cambia su apuesta se eliminarán todas las celdas bloqueadas.',
                TITLE_SERVER_ERROR: 'Error en el servidor',
                CHOICE_GAMBLE: 'Apostar',
                CHOICE_COLLECT: 'Recaudar',
                CHOICE_EXCHANGE: 'Intercambia',
                CHOICE_SPIN: 'Girar',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continuar',
                FREE_SPINS_START: 'Iniciar'
            },
            'et': {
                CANNOT_PRELOAD_ASSETS: 'Ei saa mänguressursse eellaadida:',
                NO_CONNECTION: 'Puudub ühendus serveriga',
                REMOVE_LOCKED_TILES: 'Panuse muutmine eemaldab kõik lukustatud plaadid.',
                TITLE_SERVER_ERROR: 'Serveri viga',
                CHOICE_GAMBLE: 'Õnnemäng',
                CHOICE_COLLECT: 'Kogu',
                CHOICE_EXCHANGE: 'Vaheta',
                CHOICE_SPIN: 'Keeruta',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Jätka',
                FREE_SPINS_START: 'Alusta'
            },
            'fi': {
                CANNOT_PRELOAD_ASSETS: 'Varoja ei voi ladata etukäteen:',
                NO_CONNECTION: 'Ei palvelinyhteyttä',
                REMOVE_LOCKED_TILES: 'Jos muutat panosta nyt, poistetaan kaikki lukitut palkit.',
                TITLE_SERVER_ERROR: 'Palvelinvirhe',
                CHOICE_GAMBLE: 'Onnenpeli',
                CHOICE_COLLECT: 'Lunasta',
                CHOICE_EXCHANGE: 'Vaihda',
                CHOICE_SPIN: 'Pelaa',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Jatka',
                FREE_SPINS_START: 'Käynnistä'
            },
            'fr': {
                CANNOT_PRELOAD_ASSETS: 'Impossible de précharger les ressources :',
                NO_CONNECTION: 'Aucune connexion au serveur',
                REMOVE_LOCKED_TILES: 'Si vous modifiez votre mise, les cases verrouillées seront débloquées.',
                TITLE_SERVER_ERROR: 'Erreur du serveur',
                CHOICE_GAMBLE: 'Parier',
                CHOICE_COLLECT: 'Collecter',
                CHOICE_EXCHANGE: 'Échanger',
                CHOICE_SPIN: 'Lancer',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continuer',
                FREE_SPINS_START: 'Démarrer'
            },
            'fr-CA': {
                CANNOT_PRELOAD_ASSETS: 'Impossible de précharger les ressources :',
                NO_CONNECTION: 'Aucune connexion au serveur',
                REMOVE_LOCKED_TILES: 'Si vous modifiez votre mise, les cases verrouillées seront débloquées.',
                TITLE_SERVER_ERROR: 'Erreur du serveur',
                CHOICE_GAMBLE: 'Parier',
                CHOICE_COLLECT: 'Collecter',
                CHOICE_EXCHANGE: 'Échangez',
                CHOICE_SPIN: 'Lancer',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continuer',
                FREE_SPINS_START: 'Démarrer'
            },
            'hi': {
                CANNOT_PRELOAD_ASSETS: 'ऐसेट्स प्रीलोड नहीं किए जा सकते हैं:',
                NO_CONNECTION: 'सर्वर से कनेक् शन नहीं है',
                REMOVE_LOCKED_TILES: 'अब अपने दांव की राशि बदलने से सभी लॉक् ड टाइल् स हटा दिए जाएंगे।',
                TITLE_SERVER_ERROR: 'सर्वर एरर',
                CHOICE_GAMBLE: 'गैम् बल',
                CHOICE_COLLECT: 'कलेक् ट करें',
                CHOICE_EXCHANGE: 'एक्स्चेंज करें',
                CHOICE_SPIN: 'स्पिन',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'जारी रखें',
                FREE_SPINS_START: 'शुरू करें'
            },
            'hy': {
                CANNOT_PRELOAD_ASSETS: 'Հետևյալ օբյեկտները չհաջողվեց թարմացնել՝',
                NO_CONNECTION: 'Սերվերի հետ կապ չկա',
                REMOVE_LOCKED_TILES: 'Խաղադրույքը փոխելու դեպքում բոլոր անշարժացած սալիկները կհեռացվեն:',
                TITLE_SERVER_ERROR: 'Սերվերի սխալ',
                CHOICE_GAMBLE: 'Խաղալ',
                CHOICE_COLLECT: 'Վերցնել',
                CHOICE_EXCHANGE: 'Փոխանակե՛լ',
                CHOICE_SPIN: 'Պտտել',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Շարունակեք',
                FREE_SPINS_START: 'Սկսել'
            },
            'hu': {
                CANNOT_PRELOAD_ASSETS: 'Az eszközök előtöltése sikertelen:',
                NO_CONNECTION: 'Nincs kapcsolat a szerverrel.',
                REMOVE_LOCKED_TILES: 'A téted megváltoztatásával törlöd az összes zárolt csempét.',
                TITLE_SERVER_ERROR: 'Szerverhiba',
                CHOICE_GAMBLE: 'Kockáztat',
                CHOICE_COLLECT: 'Begyűjt',
                CHOICE_EXCHANGE: 'Átváltás',
                CHOICE_SPIN: 'Pörgetés',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Folytatás',
                FREE_SPINS_START: 'Start'
            },
            'hr': {
                CANNOT_PRELOAD_ASSETS: 'Nemoguće učitati elemente:',
                NO_CONNECTION: 'Nema veze s poslužiteljem',
                REMOVE_LOCKED_TILES: 'Promjena uloga u ovom trenutku uklonit će sve zaključane pločice.',
                TITLE_SERVER_ERROR: 'Greška poslužitelja',
                CHOICE_GAMBLE: 'Kockaj',
                CHOICE_COLLECT: 'Uzmi Dobitak',
                CHOICE_EXCHANGE: 'Zamijeni',
                CHOICE_SPIN: 'Okretanje',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Nastavak',
                FREE_SPINS_START: 'Start'
            },
            'id': {
                CANNOT_PRELOAD_ASSETS: 'Tidak dapat memuat aset lebih dulu:',
                NO_CONNECTION: 'Tidak tersambung ke server',
                REMOVE_LOCKED_TILES: 'Mengubah taruhanmu sekarang akan menghapus semua ubin yang terkunci.',
                TITLE_SERVER_ERROR: 'Server Bermasalah',
                CHOICE_GAMBLE: 'Taruhan',
                CHOICE_COLLECT: 'Kumpulkan',
                CHOICE_EXCHANGE: 'Tukarkan',
                CHOICE_SPIN: 'Putar',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Lanjutkan',
                FREE_SPINS_START: 'Mulai'
            },
            'it': {
                CANNOT_PRELOAD_ASSETS: 'Impossibile caricare asset:',
                NO_CONNECTION: 'Connessione al server assente',
                REMOVE_LOCKED_TILES: 'Se cambi la puntata in questo momento, tutte le posizioni bloccate saranno rimosse.',
                TITLE_SERVER_ERROR: 'Errore del server',
                CHOICE_GAMBLE: 'Scommetti',
                CHOICE_COLLECT: 'Riscuoti',
                CHOICE_EXCHANGE: 'Scambia',
                CHOICE_SPIN: 'Gira',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continua',
                FREE_SPINS_START: 'Inizia'
            },
            'ja': {
                CANNOT_PRELOAD_ASSETS: '次のアセットをプリロードできません:',
                NO_CONNECTION: 'サーバーに接続されていません',
                REMOVE_LOCKED_TILES: '賭け金を変更すると、ロックされているすべてのタイルが削除されます。',
                TITLE_SERVER_ERROR: 'サーバーエラー',
                CHOICE_GAMBLE: '賭け',
                CHOICE_COLLECT: '回収',
                CHOICE_EXCHANGE: '交換',
                CHOICE_SPIN: '回す',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: '続行',
                FREE_SPINS_START: 'スタート'
            },
            'ka': {
                CANNOT_PRELOAD_ASSETS: 'აქტივების წინასწარ ჩატვირთვა შეუძლებელია:',
                NO_CONNECTION: 'სერვერთან კავშირი არ არის',
                REMOVE_LOCKED_TILES: 'თქვენი ფსონის ახლა შეცვლა წაშლის ყველა ჩაკეტილ მოზაიკას.',
                TITLE_SERVER_ERROR: 'მოხდა სერვერის შეცდომა',
                CHOICE_GAMBLE: 'გარისკვა',
                CHOICE_COLLECT: 'შეგროვება',
                CHOICE_EXCHANGE: 'გადაცვალე',
                CHOICE_SPIN: 'Spin',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'გაგრძელება',
                FREE_SPINS_START: 'დაწყება'
            },
            'ko': {
                CANNOT_PRELOAD_ASSETS: '애셋을미리로드할수없음:',
                NO_CONNECTION: '서버에 연결되지 않음',
                REMOVE_LOCKED_TILES: '지금 판돈을 변경하면 모든 잠긴 타일이 제거됩니다.',
                TITLE_SERVER_ERROR: '서버 오류',
                CHOICE_GAMBLE: '겜블',
                CHOICE_COLLECT: '받기',
                CHOICE_EXCHANGE: '교환',
                CHOICE_SPIN: '스핀',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: '계속하기',
                FREE_SPINS_START: '시작'
            },
            'lt': {
                CANNOT_PRELOAD_ASSETS: 'Nepavyko iš anksto įkelti išteklių:',
                NO_CONNECTION: 'Nėra ryšio su serveriu',
                REMOVE_LOCKED_TILES: 'Jei dabar pakeisite savo statymo dydį, visos užfiksuotos plytelės bus pašalintos.',
                TITLE_SERVER_ERROR: 'Serverio klaida',
                CHOICE_GAMBLE: 'Lažintis',
                CHOICE_COLLECT: 'Gauti',
                CHOICE_EXCHANGE: 'Keiskite',
                CHOICE_SPIN: 'Sukti',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Tęsti',
                FREE_SPINS_START: 'Pradėti'
            },
            'lv': {
                CANNOT_PRELOAD_ASSETS: 'Nevar ielādēt resursus:',
                NO_CONNECTION: 'Nav savienojuma ar serveri',
                REMOVE_LOCKED_TILES: 'Ja tagad mainīsi likmi, tiks noņemti visi bloķētie spēles kauliņi.',
                TITLE_SERVER_ERROR: 'Servera kļūda',
                CHOICE_GAMBLE: 'Riskēt',
                CHOICE_COLLECT: 'Saņemt',
                CHOICE_EXCHANGE: 'Apmainiet',
                CHOICE_SPIN: 'Griezt',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Turpināt',
                FREE_SPINS_START: 'Sākt'
            },
            'mk': {
                CANNOT_PRELOAD_ASSETS: 'Не може да се вчитаат средства однапред:',
                NO_CONNECTION: 'Нема врска со серверот',
                REMOVE_LOCKED_TILES: 'Промената на влогот сега ќе ги отстрани сите заклучени плочки.',
                TITLE_SERVER_ERROR: 'Грешка со серверот',
                CHOICE_GAMBLE: 'Коцкај',
                CHOICE_COLLECT: 'Собери',
                CHOICE_EXCHANGE: 'Размени',
                CHOICE_SPIN: 'Врти',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Продолжи',
                FREE_SPINS_START: 'Старт'
            },
            'ms': {
                CANNOT_PRELOAD_ASSETS: 'Tidak dapat pramuat aset:',
                NO_CONNECTION: 'Tiada sambungan ke pelayan',
                REMOVE_LOCKED_TILES: 'Menukarkan pertaruhan anda sekarang akan mengeluarkan semua jubin dikunci.',
                TITLE_SERVER_ERROR: 'Ralat Pelayan',
                CHOICE_GAMBLE: 'Taruh',
                CHOICE_COLLECT: 'Kumpul',
                CHOICE_EXCHANGE: 'Tukar',
                CHOICE_SPIN: 'Putar',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Teruskan',
                FREE_SPINS_START: 'Mula'
            },
            'nl': {
                CANNOT_PRELOAD_ASSETS: 'Kan vooraf geen activa laden:',
                NO_CONNECTION: 'Geen verbinding met de server',
                REMOVE_LOCKED_TILES: 'Door nu uw inzet te veranderen verwijdert u alle vergrendelde tegels.',
                TITLE_SERVER_ERROR: 'Serverfout',
                CHOICE_GAMBLE: 'Gokken',
                CHOICE_COLLECT: 'Innen',
                CHOICE_EXCHANGE: 'Wissel In',
                CHOICE_SPIN: 'Draaien',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Doorgaan',
                FREE_SPINS_START: 'Start'
            },
            'no': {
                CANNOT_PRELOAD_ASSETS: 'Kan ikke forhåndsinnlaste ressurser:',
                NO_CONNECTION: 'Ingen tilkobling til serveren',
                REMOVE_LOCKED_TILES: 'Endrer du innsatsen din nå oppheves alle de låste feltene.',
                TITLE_SERVER_ERROR: 'Serverfeil',
                CHOICE_GAMBLE: 'Gamble',
                CHOICE_COLLECT: 'Samle Inn',
                CHOICE_EXCHANGE: 'Veksle',
                CHOICE_SPIN: 'Spinn',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Fortsette',
                FREE_SPINS_START: 'Start'
            },
            'pl': {
                CANNOT_PRELOAD_ASSETS: 'Nie można wczytać zasobów:',
                NO_CONNECTION: 'Brak połączenia z serwerem',
                REMOVE_LOCKED_TILES: 'Zmiana stawki usunie zablokowane pola.',
                TITLE_SERVER_ERROR: 'Błąd serwera',
                CHOICE_GAMBLE: 'Postaw',
                CHOICE_COLLECT: 'Zbierz',
                CHOICE_EXCHANGE: 'Wymień',
                CHOICE_SPIN: 'Obrót',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Kontynuuj',
                FREE_SPINS_START: 'Start'
            },
            'pt': {
                CANNOT_PRELOAD_ASSETS: 'Impossível fazer o pré-carregamento de ativos.',
                NO_CONNECTION: 'Sem ligação ao servidor',
                REMOVE_LOCKED_TILES: 'Mudar a sua aposta agora removerá todos os blocos trancados.',
                TITLE_SERVER_ERROR: 'Erro de Servidor',
                CHOICE_GAMBLE: 'Arriscar',
                CHOICE_COLLECT: 'Recolher',
                CHOICE_EXCHANGE: 'Trocar',
                CHOICE_SPIN: 'Rodar',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continuar',
                FREE_SPINS_START: 'Iniciar'
            },
            'pt-BR': {
                CANNOT_PRELOAD_ASSETS: 'Impossível fazer o pré-carregamento de ativos.',
                NO_CONNECTION: 'Sem ligação ao servidor',
                REMOVE_LOCKED_TILES: 'Mudar a sua aposta agora removerá todos os blocos trancados.',
                TITLE_SERVER_ERROR: 'Erro de Servidor',
                CHOICE_GAMBLE: 'Apostar',
                CHOICE_COLLECT: 'Coletar',
                CHOICE_EXCHANGE: 'Trocar',
                CHOICE_SPIN: 'Rodar',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continuar',
                FREE_SPINS_START: 'Iniciar'
            },
            'ro': {
                CANNOT_PRELOAD_ASSETS: 'Nu se pot preîncărca resursele:',
                NO_CONNECTION: 'Fără conexiune la server',
                REMOVE_LOCKED_TILES: 'Dacă schimbați miza acum, vor fi eliminate toate plăcile blocate.',
                TITLE_SERVER_ERROR: 'Eroare de server',
                CHOICE_GAMBLE: 'Pariați',
                CHOICE_COLLECT: 'Colectați',
                CHOICE_EXCHANGE: 'Schimbați',
                CHOICE_SPIN: 'Rotiți',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Continuare',
                FREE_SPINS_START: 'Start'
            },
            'ru': {
                CANNOT_PRELOAD_ASSETS: 'Нельзя заранее загрузить активы:',
                NO_CONNECTION: 'Отсутствует соединение с сервером',
                REMOVE_LOCKED_TILES: 'Изменение вашей ставки не удалит все запертые плитки.',
                TITLE_SERVER_ERROR: 'Ошибка сервера',
                CHOICE_GAMBLE: 'Рискнуть',
                CHOICE_COLLECT: 'Забрать',
                CHOICE_EXCHANGE: 'Обменять',
                CHOICE_SPIN: 'Спин',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Продолжить',
                FREE_SPINS_START: 'Начать'
            },
            'sv': {
                CANNOT_PRELOAD_ASSETS: 'Lyckades inte ladda resurser',
                NO_CONNECTION: 'Ingen serveranslutning',
                REMOVE_LOCKED_TILES: 'Om du ändrar din insats nu avlägsnas alla låsta rutor.',
                TITLE_SERVER_ERROR: 'Serverfel',
                CHOICE_GAMBLE: 'Satsa',
                CHOICE_COLLECT: 'Samla',
                CHOICE_EXCHANGE: 'Byt',
                CHOICE_SPIN: 'Snurra',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Fortsätt',
                FREE_SPINS_START: 'Starta'
            },
            'sk': {
                CANNOT_PRELOAD_ASSETS: 'Nemožno načítať položky na pozadí:',
                NO_CONNECTION: 'Žiadne pripojenie k serveru.',
                REMOVE_LOCKED_TILES: 'Ak teraz zmeníte stávku, odstránia sa všetky zamknuté dlaždice.',
                TITLE_SERVER_ERROR: 'Chyba servera',
                CHOICE_GAMBLE: 'Riskovať',
                CHOICE_COLLECT: 'Zobrať',
                CHOICE_EXCHANGE: 'Vymeniť',
                CHOICE_SPIN: 'Točiť',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Pokračovať',
                FREE_SPINS_START: 'Štart'
            },
            'sl': {
                CANNOT_PRELOAD_ASSETS: 'Predhodno nalaganje sredstev ni mogoče:',
                NO_CONNECTION: 'Ni povezave s strežnikom.',
                REMOVE_LOCKED_TILES: 'Če boste spremenili svoj vložek zdaj, boste odstranili vse zaklenjene ploščice.',
                TITLE_SERVER_ERROR: 'Napaka strežnika',
                CHOICE_GAMBLE: 'Hazard',
                CHOICE_COLLECT: 'Unovči',
                CHOICE_EXCHANGE: 'Zamenjaj',
                CHOICE_SPIN: 'Zavrti',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Nadaljuj',
                FREE_SPINS_START: 'Start'
            },
            'sr': {
                CANNOT_PRELOAD_ASSETS: 'Nije moguće unapred učitati sredstva:',
                NO_CONNECTION: 'Ne postoji veza sa serverom',
                REMOVE_LOCKED_TILES: 'Ako sad promenite ulog, biće uklonjene sve zaključane pločice.',
                TITLE_SERVER_ERROR: 'Greška servera',
                CHOICE_GAMBLE: 'Kockaj Se',
                CHOICE_COLLECT: 'Uzmi',
                CHOICE_EXCHANGE: 'Razmeni',
                CHOICE_SPIN: 'Zavrti',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Nastavi',
                FREE_SPINS_START: 'Start'
            },
            'tr': {
                CANNOT_PRELOAD_ASSETS: 'Önyükleme başarısız:',
                NO_CONNECTION: 'Sunucuya bağlı değilsiniz',
                REMOVE_LOCKED_TILES: 'Bahis tutarınızı şimdi değiştirirseniz kilitli tüm kareler kaldırılır.',
                TITLE_SERVER_ERROR: 'Sunucu Hatası',
                CHOICE_GAMBLE: 'BAHSE GİR',
                CHOICE_COLLECT: 'Topla',
                CHOICE_EXCHANGE: 'Takas Et',
                CHOICE_SPIN: 'Döndür',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Devam',
                FREE_SPINS_START: 'Başla'
            },
            'th': {
                CANNOT_PRELOAD_ASSETS: 'ไม่สามารถโหลดทรัพย์สินก่อนล่วงหน้าได้:',
                NO_CONNECTION: 'ไม่มีการเชื่อมต่อไปยังเซิร์ฟเวอร์',
                REMOVE_LOCKED_TILES: 'หากเปลี่ยนเงินเดิมพันในตอนนี้ จะเป็นการลบสิ่งที่ล็อคเอาไว้ทั้งหมด',
                TITLE_SERVER_ERROR: 'เซิร์ฟเวอร์ขัดข้อง',
                CHOICE_GAMBLE: 'วางเดิมพัน',
                CHOICE_COLLECT: 'รับ',
                CHOICE_EXCHANGE: 'แลกเปลี่ยน',
                CHOICE_SPIN: 'หมุน',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'ต่อไป',
                FREE_SPINS_START: 'เริ่ม'
            },
            'vi': {
                CANNOT_PRELOAD_ASSETS: 'Không thể tải trước tài sản:',
                NO_CONNECTION: 'Chưa kết nối với máy chủ',
                REMOVE_LOCKED_TILES: 'Đổi tiền cược của bạn lúc này sẽ xóa mọi viên gạch bị khóa.',
                TITLE_SERVER_ERROR: 'Lỗi máy chủ',
                CHOICE_GAMBLE: 'Thử Vận May',
                CHOICE_COLLECT: 'Thu Thập',
                CHOICE_EXCHANGE: 'Trao Đổi',
                CHOICE_SPIN: 'Quay',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: 'Tiếp tục',
                FREE_SPINS_START: 'Bắt đầu'
            },
            'zh': {
                CANNOT_PRELOAD_ASSETS: '无法预加载资源',
                NO_CONNECTION: '无法连接服务器',
                REMOVE_LOCKED_TILES: '现在更改赌注可以解锁所有的牌。',
                TITLE_SERVER_ERROR: '温馨提示',
                CHOICE_GAMBLE: '赌注',
                CHOICE_COLLECT: '领取',
                CHOICE_EXCHANGE: '转换',
                CHOICE_SPIN: '旋转',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: '继续',
                FREE_SPINS_START: '开始'
            },
            'zh-TW': {
                CANNOT_PRELOAD_ASSETS: '無法預載資料：',
                NO_CONNECTION: '未連接伺服器',
                REMOVE_LOCKED_TILES: '變更注金將會除除所有上鎖的區塊。',
                TITLE_SERVER_ERROR: '伺服器錯誤',
                CHOICE_GAMBLE: '賭注',
                CHOICE_COLLECT: '領取',
                CHOICE_EXCHANGE: '兌換',
                CHOICE_SPIN: '旋轉',
                CHOICE_ACCEPT: 'Accept',
                CHOICE_DECLINE: 'Decline',
                WIN_EXCHANGE_SPLASH_BUTTON: '繼續',
                FREE_SPINS_START: '開始'
            }
        }
        const o = n('./src/core/utils/misc.js')

        function a(t, e, n) {
            return e in t
                ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    })
                : t[e] = n, t
        }
        const s = (a(a(a(a(a(a(a(a(a(a(r = {
            'bg': {},
            'cs': {},
            'da': {},
            'de': {},
            'en': {},
            'en-SC': {},
            'en-US': {}
        }, 'en-SC', {}), 'el', {}), 'es', {}), 'es-PE', {}), 'et', {}), 'fi', {}), 'fr', {}), 'fr-CA', {}), 'hi', {}), 'hy', {}), a(a(a(a(a(a(a(a(a(a(r, 'hu', {}), 'hr', {}), 'id', {}), 'it', {}), 'ja', {}), 'ka', {}), 'ko', {}), 'lt', {}), 'lv', {}), 'mk', {}), a(a(a(a(a(a(a(a(a(a(r, 'ms', {}), 'nl', {}), 'no', {}), 'pl', {}), 'pt', {}), 'pt-BR', {}), 'ro', {}), 'ru', {}), 'sv', {}), 'sk', {}), a(a(a(a(a(a(a(r, 'sl', {}), 'sr', {}), 'tr', {}), 'th', {}), 'vi', {}), 'zh', {}), 'zh-TW', {}))
        const u = new Object(o.b)(i, s)
        e.a = u
    },
    './src/utils/index.js': function (t, e, n) {
        'use strict'
        n.d(e, 'd', () => {
            return u
        }), n.d(e, 'e', () => {
            return c
        }), n.d(e, 'a', () => {
            return l
        }), n.d(e, 'c', () => {
            return h
        }), n.d(e, 'b', () => {
            return f
        })
        const r = n('./src/core/features/covers/SpineCover.js')
        const i = n('./src/core/loader/index.js')
        const o = n('./src/features/ParticlesContainer.js')

        function a(t, e) {
            return (function (t) {
                if (Array.isArray(t)) return t
            }(t)) || (function (t, e) {
                let n = t == null ? null : typeof Symbol != 'undefined' && t[Symbol.iterator] || t['@@iterator']
                if (n == null) return
                let r; let i; const o = []
                let a = !0
                let s = !1
                try {
                    for (n = n.call(t); !(a = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); a = !0);
                } catch (t) {
                    s = !0, i = t
                } finally {
                    try {
                        a || n.return == null || n.return()
                    } finally {
                        if (s) throw i
                    }
                }
                return o
            }(t, e)) || (function (t, e) {
                if (!t) return
                if (typeof t == 'string') return s(t, e)
                let n = Object.prototype.toString.call(t).slice(8, -1)
                n === 'Object' && t.constructor && (n = t.constructor.name)
                if (n === 'Map' || n === 'Set') return Array.from(t)
                if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return s(t, e)
            }(t, e)) || (function () {
                throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.')
            }())
        }

        function s(t, e) {
            (e == null || e > t.length) && (e = t.length)
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
            return r
        }

        function u(t) {
            if (typeof t == 'string') {
                const e = t.charAt(0)
                const n = e.toLowerCase()
                return t.replace(e, n)
            }
            throw new Error('Argument must be a string')
        }

        function c(t) {
            const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
            return t.sort((t, n) => {
                const r = e ? t : n
                let i = e ? n : t
                return r.reel !== i.reel ? r.reel - i.reel : r.index - i.index
            })
        }

        function l(t, e) {
            const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
            const o = i.g[t]
            if (!o) return console.error('Spine anim with name: '.concat(t, ' not found'))
            const a = new r.a({
                animation: o
            })
            return n && a.play('loop', {
                repeat: -1
            }), e.removeChildren(), e.addChild(a), a
        }

        function h(t, e) {
            return t.index === e.index && t.reel === e.reel
        }

        function f(t) {
            const e = t.configs
            const n = t.animateTarget
            const r = t.guide
            const s = t.reelMaster
            return Object.entries(e).map((t) => {
                const e = a(t, 2)
                let u = e[0]
                let c = e[1]
                let l = c.guideName && c.guideName.slice(-1)
                let h = i.a[n][u] || i.a[c.animateTarget][u]
                let f = r || (new i.a[n][c.guideName]()).guide || (new i.a[n][c.guideName]())[`guide${l}`]
                return new o.a({
                    source: h,
                    guide: f,
                    config: c,
                    name: u,
                    reelMaster: s
                })
            })
        }
    },
    '0': function (t, e) {}
}))